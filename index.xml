<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 개발자 이동욱</title>
    <link>/</link>
    <description>Recent content in Home on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 05 May 2021 17:30:39 +0900</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>오픈 소스 분석 방법</title>
      <link>/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Wed, 05 May 2021 17:30:39 +0900</pubDate>
      
      <guid>/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95/</guid>
      <description>오픈 소스 분석 방법  머리속 한켠에는 오픈 소스 활동을 다시 하고 싶다는 생각을 가지고 있지만, 바쁘다는 핑계로 미뤄왔다. 우연히 어떤 블로그에서 오픈 소스 분석 방법 이라는 글을 읽고나서, 오픈 소스 개발을 하고 싶다는 생각이 들었다. 또한 오픈 소스 활동은 시간이 날때 하는 것이 아니라, 평소에 시간을 쪼개가면서, 짜투리 시간을 만들어야 가능하다는 것을 느끼게 되었다. 다음은 오픈 소스 분석하는데 좋은 팁이다.
공식 문서를 통해 파악하기    코드를 분석하기 전에, 먼저 해당 솔루션에 대한 지식을 먼저 익혀야 한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 05 May 2021 16:00:30 +0900</pubDate>
      
      <guid>/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)   나의 핵심 역량 및 성취 그리고 주요 프로젝트 및 성과에 대해서 생각을 해보았다.
  작은 오픈소스 프로그램을 분석해서 실력을 쌓아 나간 사례 라는 글을 읽어 보게 되었다.
  Feelings (느낌, 주관)   평소에 정리를 하지 않아서 막상 생각나는 것들이 없었다. 따라서 이러한 점을 고려하면서 나의 핵심 역량 및 어떤 성취를 하였는지 그리고, 내가 맡은 주요 프로젝트에서 어떤 성과를 내었는지를 항상 생각하고, 정리를 해야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 04 May 2021 14:00:30 +0900</pubDate>
      
      <guid>/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 한 블로그 글을 읽었다.Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기  네트워크 기초에 대해서 다시 공부하게 되었다.  Feelings (느낌, 주관)  코드의 문제점을 재현해보고 직접 눈으로 확인하면서 해결하는 모습이 인상 깊었다. nGrinder로 부하를 주고, Pinpoint로 모니터링을 하고 힙 덤프를 통해서 실제로 JVM에서 FULL GC가 몇 번 일어나는지 측정까지 하고 있었다.  Learning (배운점)  허브, 브릿지, 스위치에 대해서 알게 되었고, 각각 어느 계층에서 동작하는지를 파악하게 되었다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 03 May 2021 16:00:30 +0900</pubDate>
      
      <guid>/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 클린 아키텍처 파이썬이라는 책을 읽었다.  Feelings (느낌, 주관)  시스템 디자인에서 중요한 컨셉중에 관심사의 분리와 제어의 역전이 중요하다는 것을 알게 되었다. 추상화를 할 때, 웹 프레임워크는 웹을 통해서 프로그램을 이용할 수 있게 해주는 것이며 분리가 잘 되어 있다면, CLI를 통해서 비즈니스 로직의 변경없이 프로그램을 사용할 수 있어야한다. 데이터베이스 역시, 관계형 데이터베이스 뿐만 아니라, NoSQL도 빠르게 바꿔서 사용할 수 있도록 해야한다.  Learning (배운점) Bad (개선할 점) Affimation (자기 선언) 회고 작성법  Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 02 May 2021 22:00:36 +0900</pubDate>
      
      <guid>/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  숫자 야구를 구현하는 간단한 과제를 하였다. 오픈 소스 분석 방법이라는 블로그 글을 읽었다. 회사에서 성능 개선 이슈를 맡아서 진행을 하였다. 회사에서 진행하고 있는 솔루션에서 개선해야할 점들을 발표 자료로 만들어서, 발표를 해보았다. 파이썬으로 클린 아키텍처를 만드는 방법에 대해서, 배울 수 있었다. 장기적으로 보았을 때, 체력과 건강이 중요하기 때문에, 복싱 도장에 등록을 하였다.  Feelings (느낌, 주관)  아직 함수나, 클래스를 나누는 연습이 많이 부족한 것을 느낄 수 있었다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 30 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 복싱 도장에 등록을 했다. 오늘은 하루종일 API 문서만 작성했다. 요즘에는 내가 배운 것들을 어떻게 공유하지라는 상상을 하곤 한다.  Feelings (느낌, 주관)  맨날 앉아만 있어서 그런지, 몸이 무겁고 작은일에도 짜증이 나고 만사가 귀찮기도 했는데 운동을 배우면서, 건강해지고 코딩도 잘 할 수 있으면 좋겠다. 공부할 시간도 없다는 핑계로 여태까지 미뤄왔는데 지금이라도 해야겠다 문제를 해결하기 위해서, 줌을 하듯이 확대 축소를 할 수 있어야한다. 때로는 아키텍처만 파악하고 나서, 필요한 부분을 돋보기로 보듯이 확대해서 문제를 해결해나가자.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 29 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  클린코드를 플라스크에서 작성하는 법에 대한 책을 읽고 공부하였다. 모바일 개발 외주를 주기 위해서, API 문서를 정리하였다. 제대로 작성하는 법에 대해서 주말에 공부하도록 해야겠다.  Feelings (느낌, 주관)   우연히, 우아한 테크 코스 영상을 보았는데, 이를 보면서 블로그에 정리하고 실제로 녹화를 해보면서 발표 연습을 하자라는 마음을 먹었던게 기억이 났다.
  해야할 일을 일일 회고에는 많이 기록을 해두었는데, 막상 기억이 나지 않을 때가 있으므로, 따로 투두 리스트를 정리해야겠다.</description>
    </item>
    
    <item>
      <title>마크다운으로 슬라이드 쇼 만드는 방법 (draft)</title>
      <link>/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft/</link>
      <pubDate>Wed, 28 Apr 2021 11:00:39 +0900</pubDate>
      
      <guid>/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft/</guid>
      <description>기존에 슬라이드 쇼를 만드는데, 콘텐츠에 집중하기 보다는 부가적인 요소에 집중할 때가 많았다.
  개발 발표 자료는 사실, 슬라이드 디자인이 크게 영향을 미치지 않는 경우가 많다.
  따라서 프레젠테이션을 만들때 드는 비용을 많이 줄여줄 수 있다고 생각을 한다.
  그리고 웹에서 동작하기 때문에, 커스터 마이징을 할 수 있고 더 실험적인 동작을 할 수 있을 것 같다. (예제 코드를 실행해보기)
  아래에 비슷한 툴들이 많이 있다. 따라서 이를 통해서 슬라이드를 만들어보면 좋을 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 28 Apr 2021 09:30:30 +0900</pubDate>
      
      <guid>/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)   네이버에서 NDTI라는 맞춤 채용 제안을 확인할 수 있었다. 재미있고 좋은 아이디어인 것 같다.
  지도 서비스를 구축하는데 도움이 되는 라이브러리 및 도구를 발견하였다. 토이 프로젝트를 하는데 많은 도움이 될 것 같다. OPEN STREET MAP으로 나만의 지도시스템 만들기
  TDD를 하는 이유 중에, 테스트를 하면서 미리 설계를 같이 하고 이를 검증해볼 수 있다는 점도 있지만 무엇보다 좋은 점은 구현을 먼저하면 테스트 코드를 귀찮아서 작성하지 않는다는 점이다.</description>
    </item>
    
    <item>
      <title>리눅스 네트워크 도구 (테스트, 추적, 모니터링 명령어)</title>
      <link>/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4/</link>
      <pubDate>Wed, 28 Apr 2021 00:12:39 +0900</pubDate>
      
      <guid>/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4/</guid>
      <description>hping3  hping3 -S www.daum.net -p 80   TCP/UDP, ICMP 및 다양한 종류의 패킷을 전송할 수 있다.
  좀 더 빠른 주기로 패킷을 보내고 싶다면 --fast 옵션을 줄 수 있다.
  iptables   이 명령어는 특정 IP 주소의 요청을 막을 수 있는 명령이다.  # localhost의 UDP 요청을 차단하는 규칙을 추가하였다. iptables -I OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP # iptables 설정을 확인해본다.</description>
    </item>
    
    <item>
      <title>가상 파일 시스템(VFS)이란? (draft)</title>
      <link>/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Wed, 28 Apr 2021 00:09:24 +0900</pubDate>
      
      <guid>/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>가상 파일 시스템(Virtual File System)    리눅스가 하는 일을 생각해보면 크게 하드웨어 자원 관리 및 소프트웨어의 자원을 관리한다고 생각을 해볼 수 있다.
  리눅스는 이러한 자원을 파일로써 관리하게 되며 모든 것이 가상 파일 시스템을 통해서 접근하게 된다.
  예를 들어서, NGINX 같은 웹 서버 프로그램이 시스템 자원을 요청할 때, 시스템 콜을 호출하게 되며 (open, read, write) 이러한 자원은 가상 파일 시스템(VFS)를 통해서 자원에 접근하게 된다.
  </description>
    </item>
    
    <item>
      <title>MSS 그리고 MTU (draft)</title>
      <link>/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft/</link>
      <pubDate>Tue, 27 Apr 2021 23:44:39 +0900</pubDate>
      
      <guid>/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft/</guid>
      <description>MSS (Maximun Segment Size)   MSS는 TCP 상에서 전송할 수 있는 사용자의 데이터(payload) 크기를 말한다. MSS는 TCP 헤더를 제외한 데이터의 크기이다. MSS는 TCP(L4) 계층에서 데이터의 크기를 말한다. 위의 사진을 보면, TCP 헤더를 제외한 데이터 부분을 MSS라고 말한다.  MTU (Maximun Transmission Unit)   MTU는 네트워크에서 전송 될 수 있는 최대 패킷의 크기를 말한다. MTU는 IP(L3) 계층에서 패킷이라고도 불리운다. MTU에서 IP 헤더와 TCP 헤더를 제외하면 그것이 바로 MSS가 된다. MTU를 패킷이라고 부른다.</description>
    </item>
    
    <item>
      <title>데이트 타임 및 표준 규격에 대해서 (draft)</title>
      <link>/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft/</link>
      <pubDate>Tue, 27 Apr 2021 18:00:39 +0900</pubDate>
      
      <guid>/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft/</guid>
      <description>참고 문헌   ISO 8061 - WIKI RFC 2822 RFC 3339  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 27 Apr 2021 13:30:30 +0900</pubDate>
      
      <guid>/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)    출근길에, 소프트웨어 엔지니어를 평가하는 4가지 항목이라는 영상을 보았다. 기존에 느리게 동작하던 코드를 개선하였다. 오픈 소스 분석 방법 이라는 블로그 글을 읽었다. 강연: 호갱노노 이렇게 만듭니다 이라는 글을 읽었다. 오늘 사내 메신저에서 이해하지도 못했는데, 대충 이해했다고 생각하여 넘어갔지만, 실제로는 다른 이야기였다.  Feelings (느낌, 주관)  성능 개선을 할 때, 코드를 이해하지 못해서 이 부분이 필요한 부분인지를 미쳐 파악하지 못했던 것 같다. 따라서, 사실 필요없는 부분 이었음에도 불구하고, 필요하다고 생각하여 어려웠던 것이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 26 Apr 2021 23:30:30 +0900</pubDate>
      
      <guid>/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  과제를 끝냈다.  Feelings (느낌, 주관)  나의 부족한 점을 한 번 더 느낄 수 있었다. 객체지향적인 코딩 실력이 부족한 것을 느낄 수 있었고, 자바 실력을 더 키워야겠다는 생각을 했다. 회사에서 일을 할 때, 미리 계획을 세우고 코딩을 하면서 내가 놓친 부분이 있지 않는지 생각을 하면서 코딩을 해야겠다. 기존 회사 소스코드 의존성 때문에 테스트 코드를 작성하기 힘들다는 핑계를 대면서 테스트 코드를 작성하는 것을 미루었는데, 지금부터라도 테스트 코드를 작성하려고 노력하면서 좋은 설계를 할 수 있도록 해야겠다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 25 Apr 2021 22:00:36 +0900</pubDate>
      
      <guid>/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  출근 시간에 개발 유튜브 영상을 시청하였다. 코드를 작성할 때, 더 빨리 자주 실패하라는 문구를 잊어버린 느낌이었다. 정신이 없다는 핑계로, 동료가 물어보는 질문에 생각하지 않고 답변을 해버려서 잘못된 정보를 전달하였다. 파라미터에 여러가지 인자를 많이 전달하지 말라는 유튜브 영상을 보았다.  Feelings (느낌, 주관)  개발 유튜브 영상중에 하나가 코딩을 할 때, 어떻게에 집중해서 코딩을 하지 말고 무엇을에 집중해서 코딩을 하라는 것이었다. 내가 작성한 코드를 뒤돌아보았을 때 어떻게 코딩을 할지 집중해서 코딩된 것이 많았던 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 23 Apr 2021 23:00:30 +0900</pubDate>
      
      <guid>/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  클린 파이썬이라는 책을 읽었다. 배포날이 다가오니까, 야근을 하였다.  Feelings (느낌, 주관)  확실히 베스트 프랙티스를 보니까, 그동안 작성되었던 코드들의 개선사항이 눈에 보였다. 아직은 회사 생활을 할만하다고 느끼지만, 구조를 개선하려는 노력이 없어서 아쉽고, 코드가 망가지는 것을 볼 때마다 가슴이 아프다.  Bad (개선할 점)  어떻게 하면, 코드를 깔끔하게 개선할 수 있고, 구조를 더 좋게 만들 수 있을지를 고민해봐야겠다. 다른 회사에서는 이러한 상황에 처해있을 때, 어떻게 변화를 하는지 알아봐야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 22 Apr 2021 22:00:30 +0900</pubDate>
      
      <guid>/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)    오늘 출근을 할 때, 프로그래밍 왕초식 시리즈중에 하나인 왕파라미터를 사용하지 말자라는 영상을 보았다. 오늘은 회사에서 코딩을 할 때, 비교적 일이 잘 풀린 편인 것 같다.  Feelings (느낌, 주관)  회사에서 코드를 작성할 때, 위와 같은 왕파라미터를 사용하는 경우를 많이 보았고 이 경우에, 파이썬에서 지원하는 네임드 튜플을 사용하면 좋겠다는 생각이 들었다. 이제 마지막 이슈만을 남겨 놓고 있다. 이 이슈를 잘 처리하여 문제 없이 이관을 할 수 있으면 좋겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 21 Apr 2021 23:01:30 +0900</pubDate>
      
      <guid>/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 정신이 없어서 생각하지 않고 동료에게 잘못된 정보를 전달하였다.  Feelings (느낌, 주관)  아무리 바뻐도, 확인을 완전히 하고 전달을 해야겠다. 구현을 할 때 일정을 고려해서 코딩하는 것과 정석대로 구현하는 것의 균형을 잡기 어렵다는 느낌을 받았다. 최대한 기존 소스 코드에 영향을 주지 않는 방향으로 구현을 해야하는 것인지 아니면, 과감하게 구현해야할때는 언제인지가 궁금했다.  Bad (개선할 점)  아무리 바쁘더라도, 제대로 확인을 하고 정보를 전달하고 헷갈린다면 확인해보고 알려준다고 말을 하자.</description>
    </item>
    
    <item>
      <title>TCP 통신과정 추적해보기 (draft)</title>
      <link>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</link>
      <pubDate>Tue, 20 Apr 2021 23:51:39 +0900</pubDate>
      
      <guid>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</guid>
      <description>추적 과정  추적하기 전에 클라이언트와 서버 코드를 컴파일 한다.
client.c
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define MAXLINE 1024 int main(int argc, char **argv) { struct sockaddr_in serveraddr; int server_sockfd; int client_len; char buf[MAXLINE]; if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(&amp;quot;error : &amp;quot;); return 1; } serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;); serveraddr.sin_port = htons(4000); client_len = sizeof(serveraddr); if(connect(server_sockfd, (struct sockaddr*)&amp;amp;serveraddr, client_len) == -1) { perror(&amp;quot;connect error : &amp;quot;); return 1; } memset(buf, 0x00, MAXLINE); read(0, buf, MAXLINE); if(write(server_sockfd, buf, MAXLINE) &amp;lt;= 0) { perror(&amp;quot;write error : &amp;quot;); return 1; } memset(buf, 0x00, MAXLINE); if(read(server_sockfd, buf, MAXLINE) &amp;lt;= 0) { perror(&amp;quot;read error: &amp;quot;); return 1; } close(server_sockfd); printf(&amp;quot;server:%s\n&amp;quot;, buf); return 0; } server.</description>
    </item>
    
    <item>
      <title>TCP 통신에 대해서 알아보자...</title>
      <link>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</link>
      <pubDate>Tue, 20 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</guid>
      <description>TCP (Transmission Control Protocol)    TCP는 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다.
  TCP는 IP 네트워크를 통해서 통신하는 호스트에서 실행되는 애플리케이션 간에 신뢰할 수 있고, 순서가 정해져있으며, 오류를 체크하고 전송할 수 있다.
  월드 와이드 웹, 이메일, 원격 관리, 파일 전송과 같은 주요 인터넷 애플리케이션은 전송 계층의 일부인 TCP에 의존한다.
  SSL/TLS 또한 TCP 위에서 동작한다.
  TCP는 인터넷 프로토콜 (IP)과 작동하여 컴퓨터가 서로 데이터 패킷을 보내는 방법을 정의한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 20 Apr 2021 17:01:30 +0900</pubDate>
      
      <guid>/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  더 빨리 자주 실패하자라는 원칙을 잊어버린 느낌이었다. 최근에 시청하였던 왕 파라미터 금지라는 소프트웨어 원칙을 파이썬에서 네임드 튜플을 이용하여 지킬 수 있을 것 같다.  Feelings (느낌, 주관)  토이 프로젝트를 할 때 자꾸 생각만 하고 코딩을 하지 않는 것 같다. 따라서 의도적으로라도 코딩을 계속하려는 노력을 해야겠다.  Bad (개선할 점)  매일 코딩을 해야한다. 완벽한 구조는 계속 만들어가는 것이다.  Affimation (자기 선언)  지금 당장 완벽한 코딩을 하려고 하지 말고, 계속 발전시켜나가자!</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 19 Apr 2021 12:01:30 +0900</pubDate>
      
      <guid>/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)    출근 시간에 위의 영상을 시청하였다.
Feelings (느낌, 주관)  한번도 무엇과 어떻게에 대해서 생각을 하면서 코딩한 적이 없는데, 신선한 충격이었고, 가독성을 높히기 위해서 노력해야겠다.  Findings (배운 점)  무엇을 할지와 어떻게 할지는 다르다는 것을 알게 되었고, 가독성을 위해서 무엇을 할지에 대해서 생각을 하면서 코딩을 해야한다.  Bad (개선할 점)  항상 의식적으로 무엇을 하려고 하는지 생각을 하면서 코딩해야겠다.  Affimation (자기 선언)  가독성 있는 코딩을 하기 위해서 노력해야겠다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 18 Apr 2021 20:02:36 +0900</pubDate>
      
      <guid>/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  기대했던 결과가 나오지 않아서 조금 실망하기는 했다. 졸업 작품으로 했던 프로젝트를 다시 만들어가고 있다. 네트워크에 대한 기반 지식이 부족한 것을 알게 되었서, 관련된 공부를 하면서 기본기를 쌓고 있다. 자바스크립트 프로토타입에 대해서 세미나 준비 및 세미나를 하였다.  Findings (배운 점)  그래도 내가 어떤 점이 부족하고, 채워가야하는지 시야가 넓어져서 좋은 것 같다. 평소에 발표 연습을 많이 하고, 녹화하면서 안좋은 습관들을 고치도록 해야겠다. 다시 한번 복습하며서, 부족한 점을 채워나가고 있다.</description>
    </item>
    
    <item>
      <title>SHADOW DOM 이란 (draft)</title>
      <link>/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Thu, 15 Apr 2021 22:07:39 +0900</pubDate>
      
      <guid>/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>참고 문헌   Using shadow DOM  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 15 Apr 2021 18:23:30 +0900</pubDate>
      
      <guid>/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 자바스크립트 세미나 발표를 했다.  Feelings (느낌, 주관)  많이 부족한 세미나 발표였음에도 불구하고 열심히 들어주셔서 고마웠다. 세미나를 하기 전에는 많은 걱정을 하였지만, 막상 하고 나니까 속이 후련하고 다음에 한 번 더 하고 싶은 마음이 생겼다. 사람들의 호응이 많을 때, 발표자로서 힘이 나는 것 같다.  Findings (배운 점)  확실히 문서를 기반으로 발표를 하는 것 보다는 프레젠테이션으로 발표를 하는게 더 효과가 좋은 것 같았다.</description>
    </item>
    
    <item>
      <title>디바운스란? (draft)</title>
      <link>/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft/</link>
      <pubDate>Wed, 14 Apr 2021 18:54:39 +0900</pubDate>
      
      <guid>/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft/</guid>
      <description>디바운스란? 참고 문헌  </description>
    </item>
    
    <item>
      <title>DNS란? (draft)</title>
      <link>/post/2021/04/13/dns%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:15:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/dns%EB%9E%80-draft/</guid>
      <description>DNS(Domain Name System)  내가 활용중인 DNS IP 주소 확인하기   위의 명령어를 통해서, 내가 사용하고 있는 DNS 서버의 IP 주소를 알아낼 수 있다.   위에 명령어를 통해서 나온 주소를 구글에 검색하면, 어떤 DNS 서버를 사용하는지 대략적으로 알 수 있다.  DNS 동작과정 추적하기   위와 같은 과정을 통해서, DNS 서버에 요청하고, 도메인 주소를 통해서 IP 정보를 받아오는 것을 확인할 수 있다.  sudo systemd-resolve --flush-caches  DNS 캐시 정보를 지우고 싶다면 위의 명령어를 입력하면 된다.</description>
    </item>
    
    <item>
      <title>ARP란? (draft)</title>
      <link>/post/2021/04/13/arp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/arp%EB%9E%80-draft/</guid>
      <description>ARP(Address Resolution Protocol)   L2(데이터 링크 계층) 통신 프로토콜이다. IP 네트워크 주소를 데이터 링크 프로토콜에서 사용하는 하드웨어 주소(Mac ADDRESS)에 맵핑하기 위해서 사용하는 프로토콜이다.  arp -n 위의 명령어를 통해서, ARP 테이블을 확인할 수 있다.
ARP 패킷 추적하기   위의 명령어를 통해서, 패킷 추적을 시작한다. 그리고 MAC 주소를 확인하기 위해서 PING 명령어를 자신의 IP 주소로 보내며, 네트워크 패킷이 호출되는 것을 확인한다.   ffff:ffff:ffff는 목적지 주소를 나타내며, 브로드 캐스트의 의미이다.</description>
    </item>
    
    <item>
      <title>ICMP란 (draft)</title>
      <link>/post/2021/04/13/icmp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:52:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/icmp%EB%9E%80-draft/</guid>
      <description>ICMP(Internet Control Message Protocol)    L3(네트워크 계층) 통신 프로토콜로서, 라우터를 포함한 네트워크 장치가 다른 IP 주소와 통신을 할 때 성공 또는 실패를 나타내는 오류 메시지 및 운영정보를 보내는데 사용된다.
  흔히 사용하는 PING 명령어가 ICMP 프로토콜을 사용하고 있다.
  네트워크 패킷 추적하기 sudo apt-get install tshark  위의 명령어를 입력하여 tshark를 설치한다, 네트워크 패킷 분석을 할 수 있는 툴이다.   위의 명령어를 입력해서, ICMP 패킷을 분석을 시작한다.</description>
    </item>
    
    <item>
      <title>MAC 주소란 (draft)</title>
      <link>/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:21:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</guid>
      <description>MAC 주소란?  MAC 주소 알아내는 법   위의 명령어를 이용하면 사용하고 있는 하드웨어의 MAC 주소 및 네트워크 카드 ID, 제조사를 알아낼 수 있다.  참고 문헌  </description>
    </item>
    
    <item>
      <title>라우팅이란 (draft)</title>
      <link>/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:48 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>라우팅이란?   네트워크 패킷이 목적지를 찾아가기 위한, 최적의 경로이다.  요청한 서버까지 라우터를 추적하는 방법   구글 서버까지 굉장히 많은 라우터를 거쳐간다는 것을 확인할 수 있다. 네이버 서버에 요청하였을 때는 보안상의 이유로 라우터가 가려진 것을 확인할 수 있다. 모든 라우터의 주소를 확인할 수 있는 것은 아니다.  참고 문헌  </description>
    </item>
    
    <item>
      <title>웹 클라이언트(브라우저) 부터 웹서버까지의 구조 (draft)</title>
      <link>/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</guid>
      <description> 브라우저에서 주소를 입력하면 HTTP 통신이 일어나게 되고, DNS 서버에서, 도메인 주소를 IP 주소로 변환하는 요청을 하게 된다. IP 주소를 알아내면, 라우터를 통해서 TCP / IP 통신을 하게 된다. 웹 서버에 도착했을 때는 최종적으로 HTTP 통신이 이루어지게 된다.  참고 문헌   리얼 리눅스  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 13 Apr 2021 21:23:30 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  네트워크에 대해서 공부를 하였다. 자바 스크립트 세미나 자료를 작성하였다.  Feelings (느낌, 주관)  네트워크에 대한 지식이 부족함을 알게 되었고, 부족한 점을 채우기 위해서 노력해야겠다는 생각이 들었다. 생각보다 대략적으로 알고 있는 내용이 많았고, 제대로 알고 넘어가야하는 점이 많다는 것을 알게 되었다. 생각보다 발표준비를 할 시간이 많이 남지 않았다는 것을 알게 되었다.  Findings (배운 점)  네트워크 지식이 나중에 문제를 해결할 때 많은 도움을 줄 것이라고 생각한다.</description>
    </item>
    
    <item>
      <title>문서화를 코드로 관리하는 법 (draft)</title>
      <link>/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft/</link>
      <pubDate>Tue, 13 Apr 2021 15:47:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft/</guid>
      <description>이전에 프로젝트를 진행할 때는 문서화에 대한 고민이 정말로 많았다. 왜냐하면 요구사항은 나날이 변경되는데, 요구사항에 맞춰서 문서화를 변경하는 일은 손이 많이가고 귀찮은 일이었기 때문이다. 또한 변경사항이 변경할 때마다, 어느 부분을 어떤 이유로 수정하였는지 추적하기도 힘이 들었다.
따라서 추후에 프로젝트를 다시 시작할 때 무조건 문서화를 코드에 가깝게 두려고 노력을 했다. 또한 깃으로 상태 관리를 할 수 있었으면 좋겠다는 생각을 하기도 하였다. 그러던 중에, plantuml 이라는 도구를 알게 되었다. 이 도구는 아키텍처를 도식화할 때 사용할 수 있는 툴로써 다양한 다이어그램을 그릴 수 있다.</description>
    </item>
    
    <item>
      <title>윈도우 함수에서 WHERE 절을 사용하지 못하는 이유(draft)</title>
      <link>/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft/</link>
      <pubDate>Tue, 13 Apr 2021 15:20:24 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft/</guid>
      <description>참고 문헌  Why Window Functions Are Not Allowed in WHERE Clauses  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 12 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 친구랑 같이 밥을 먹었다.  Feelings (느낌, 주관)  예상은 했지만, 그래도 기대를 해서 그런지 기분이 조금 꿀꿀한 하루였다. 친구랑 밥먹으면서 얘기를 하니까 기분이 조금은 풀렸다. 오늘 일이 쉽게 풀려서 기분이 좋았다. 목표한 기간내에 마감을 할 수 있을 것 같다.  Findings (배운 점)  나의 부족한 점을 알 수 있는 소중한 기회였다. 진행하고 있는 프로젝트를 열심히 해보고, 꾸준히 해야겠다. 매주 일요일마다. 조금씩 하는 것을 계획하고 있다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 11 Apr 2021 12:00:36 +0900</pubDate>
      
      <guid>/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)   우아한 형제들에서 일하고 있는 박재성 개발자의 10년차 이상의 개발자는 어떤 준비를 하면 좋을까라는 영상을 시청하였다.
  회사에서 이슈를 처리하다가, 각각의 이슈의 경우에는 해결이 되었지만, 그 이슈들이 조합되어서 나타났을 때의 상황을 고려하지 못했던 것 같다.
  이전에 레디스에서 Sorted Set이 어떻게 구현되어있는지 궁금해서 직접 찾아보고, SKIP LIST 자료구조를 이용해서 구현을 했다는 것을 알게 되었다.
  Feelings (느낌, 주관)   나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 다른 사람들을 이끌고 설계할 수 있는 리더십 역량이 필요할텐데 시니어 때가 되서 부랴부랴 준비하려면 늦을 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 10 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  이제 다시 마음을 다잡고 공부를 이어가야겠다. 사내 세미나 준비를 하였다.  Feelings (느낌, 주관)  이번 주말에 재충전을 하였고, 다시 앞으로 나갈 힘을 얻은 것 같다.  Findings (배운 점)  많은 것을 배울 수 있었으며, 나에게 현재 어떤점이 부족한지를 파악할 수 있었다. 사내 세미나 준비를 하면서, 나의 발표 실력을 키울 수 있는 기회로 삼아야겠다. 영어 공부를 하여서, 인생에서 내가 선택할 수 있는 선택지를 늘려야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 08 Apr 2021 09:03:36 +0900</pubDate>
      
      <guid>/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  정신없는 하루를 보냈다.  Feelings (느낌, 주관)  이번 주말에 재정비를 하고, 다시 앞으로 나가야할 것 같다.  Findings (배운 점)  평소에 준비를 하지 않으면 기회를 잡을 수 없다.  Bad (개선할 점)  상황에 닥쳐서 하지 말고, 미리미리 준비하자.  Affimation (자기 선언)  나는 기술 블로그에 내가 배운 것들을 차곡차곡 준비할 것이다. 어떤 기술을 익힐 때, 내부 원리에 대해서 이해하려고 노력할 것이다.</description>
    </item>
    
    <item>
      <title>주키퍼란 무엇인가? (draft)</title>
      <link>/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</link>
      <pubDate>Thu, 08 Apr 2021 08:53:24 +0900</pubDate>
      
      <guid>/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</guid>
      <description>참고 문헌  What is ZooKeeper  </description>
    </item>
    
    <item>
      <title>카프카란 무엇인가? (draft)</title>
      <link>/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</link>
      <pubDate>Thu, 08 Apr 2021 08:19:24 +0900</pubDate>
      
      <guid>/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</guid>
      <description>참고 문헌  KafkaConsumer Client Internals  </description>
    </item>
    
    <item>
      <title>TWO-PHASE-LOCK(2PL)이란 (draft)</title>
      <link>/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Wed, 07 Apr 2021 18:05:24 +0900</pubDate>
      
      <guid>/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>TWO PHASE LOCK    2PC(TWO PHASE COMMIT)과 헷갈리는 개념이 있다. 그것은 바로 2PL(TWO PHASE LOCK)이다.
  2단계 잠금 프로토콜은 트랜잭션 도줌에 락을 걸어서 동일한 데이터에 동시에 접근하려는 트랜잭션을 차단하여 직렬화를 보장하는 DBMS의 동시 제어 방법이다.
  DBMS의 동시성 문제를 해결하는데 도움이 된다.
  이 잠금 프로토콜은 트랜잭션의 실행 단계를 세 단계로 나눈다.
  첫 번째 단계에서는 트랜잭션이 실행되기 시작할 때 필요한 락에 대한 권한을 요청한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 07 Apr 2021 09:01:36 +0900</pubDate>
      
      <guid>/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  전에 레디스에 구현되어 있는 SORTED SET 연산이 어떻게 구현되어 있는지 찾아보다가, SKIP LIST 까지 조사하게 되었다. 대충 돌아가는 구현은 파악하였지만, 실제 구현된 코드를 보고 이해하기는 힘들었고, 내가 이를 실제로 코드로 구현할 생각을 하니까 자신이 없었다. 발표 연습을 위해서 내가 어떤 주제를 가지고 발표를 하려는데, 잘 정리된 발표 자료가 필요했다. 물론 내가 발표할 주제에 맞게 구성을 변경할 수는 있지만, 내용이 탄탄해야했다. 그러던 중에 적합한 사이트를 발견하였다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 06 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 이슈를 처리하는데 느낀게 많았다.  Feelings (느낌, 주관)  나는 이슈 각각의 구현을 끝내고 나서, 고려할 사항이 끝났다고 생각했는데 이슈들이 조합될때의 경우를 고려하지 못한 것 같다.  Findings (배운 점)  이슈는 각각으로 나누어져 있어도 사실, 이슈가 조합되면 내가 예상하지 못하는 버그가 생길 수 있다는 점을 염두해야겠다.  Bad (개선할 점) Affimation (자기 선언) 회고 작성법  Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 05 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  출근길에 박재성님의 10년차 이상의 개발자는 어떤 준비를 하면 좋을까?  영상을 보았다. 오늘 기술 주제를 가지고, 설명을 하는 과정을 녹화하고 녹화된 영상을 보았다.  Feelings (느낌, 주관)  나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 리더십 역량이 필요할 날이 올텐데 미리 준비하면 좋을 것 같다는 생각을 했다. 우선 발표 실력부터 늘리고, 내 생각을 남에게 논리적으로 표현할 수 있어야 겠다는 생각을 했다. 설명을 할 때는 완벽하지는 않아도 설명을 그럭저럭 했다고 생각했는데, 녹화된 영상을 보니까 논리가 하나도 맞지 않고 횡설 수설 하였다.</description>
    </item>
    
    <item>
      <title>GC(Garbage Collector) 종류 및 내부 원리</title>
      <link>/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC/</link>
      <pubDate>Sun, 04 Apr 2021 20:30:23 +0900</pubDate>
      
      <guid>/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC/</guid>
      <description>모든 자바 애플리케이션은 JVM(Java Virtual Machine) 위에서 작동한다. 따라서, JVM이 작동하는데 있어서 메모리 구조와 GC는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 맺고 있다.
GC란 무엇인가?   GC(Garbage Collection)는 자바 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다. C/C++ 같은 언어는 메모리를 할당하고 직접 해제해야했지만, 자바에서는 GC를 이용하여 개발자들이 메모리 관리를 비교적 신경쓰지 않아도 된다.  JVM 메모리 영역   GC의 동작 방법을 이해하려면, 먼저 자바의 메모리 구조를 이해할 필요가 있다.</description>
    </item>
    
    <item>
      <title>그림으로 공부하는 IT 인프라 구조를 읽고나서 느낀점</title>
      <link>/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Sun, 04 Apr 2021 20:20:39 +0900</pubDate>
      
      <guid>/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>데브옵스 팀이 따로 있기 때문에, 실무에서 인프라 지식을 접할 기회가 별로 없었다. 따라서 이 책을 읽게 되었다. 웹 애플리케이션 시스템을 구축하는 기반 지식들을 배울 수 있었다. 특히 웹 데이터 흐름이라는 파트가 많은 도움이 되었는데, 내가 어떤 웹 사이트에 접속을 하였을 때, 내부적으로 어떻게 동작하는지 알 수 있었다. 특히 네트워크에 대한 지식이 많이 부족했는데, 네트워크의 흐름에 대해서 알게 되었다. 다양한 계층에서의 이중화 전략에 대해서 알게 되었다. 현재 나에게도 도움이 많이 되었던 책이지만, 나 말고도 많은 신입 개발자들에게 많은 도움이 될 것 같다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 04 Apr 2021 15:25:36 +0900</pubDate>
      
      <guid>/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  서버 성능 튜닝 및 성능 개선에 관련된 책을 읽었다. 구글 번역기 관련 이슈가 발생하였다. API 문서가 업데이트 되지 않는 문제가 있어서, 이를 수정하는 작업을 하였다. 사내 세미나가 거의 코 앞으로 다가 왔다. 예전에 리눅스 공부 및 정리한 내용을 블로그에 옮겨서 적어보았다.  Feelings (느낌, 주관)  서버 성능 튜닝을 제대로 이해하려면 학부 때 배운 운영체제 지식 및 데이터베이스에 대한 이해가 필수라는 것을 느끼게 되었다. 이론으로만 배운 지식이 어떤 원리로 나타나는지 확인하는 과정이 재미있었다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 03 Apr 2021 22:25:36 +0900</pubDate>
      
      <guid>/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  예전에 리눅스 커널을 보면서 공부했던 내용을 블로그에 정리하고 있다.  Feelings (느낌, 주관)  아쉽게도 공부한 직후에 바로 기록하여 내용이 정리 되어 있지는 않았다. 블로그를 예전 부터 시작하고, 기록 했으면 편했을 것 같다.  Findings (배운 점)  오랜만에 운영체제에 대해서 공부하게 되었고, 지금은 잊어버린 시스템 코드를 분석하는 툴 및 방법을 다시 확인해볼 수 있었다.  Bad (개선할 점)  시스템 개발에 대한 열정을 일어버리지는 말자.</description>
    </item>
    
    <item>
      <title>메모리 액세스 과정</title>
      <link>/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95/</link>
      <pubDate>Sat, 03 Apr 2021 21:21:24 +0900</pubDate>
      
      <guid>/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95/</guid>
      <description>메모리 액세스 과정    프로그램을 실행 할 때, 반드시 모두 물리 메모리에 있어야 할 필요는 없으므로, 일부분만 물리 메모리에 올려 놓고 실행된다.
  따라서 프로그램은 더 이상 물리 메모리에 의해서 더 이상 제약 받지 않으며, 사용자들은 매우 큰 가상 공간을 가정하고 프로그램을 만들 수 있고, 프로그래밍 과정이 간단해진다.
  각 사용자 프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다.
  가상 메모리에서는 페이지들이 실행 과정에서 실제 필요할 때, 메모리에 적재되게 된다.</description>
    </item>
    
    <item>
      <title>좀비 프로세스와 고아 프로세스</title>
      <link>/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</link>
      <pubDate>Sat, 03 Apr 2021 18:57:24 +0900</pubDate>
      
      <guid>/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</guid>
      <description>좀비(zombie) 프로세스란    프로세스가 종료 될 때, 마지막 문장의 실행을 끝내고, exit() 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면서 종료된다.
  이 시점에서, 프로세스는 자신의 부모가 호출한 wait() 시스템 호출을 통해서, 상태 값을 반환할 수 있고, 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제로 반납된다.
  부모 프로세는 wait() 시스템 호출을 사용하여 자식 프로세스가 종료할 때를 기다릴 수 있고, 부모가 자식의 종료 상태를 얻어 낼 수 있도록 하나의 인자를 전달 받는다.</description>
    </item>
    
    <item>
      <title>프로그램 실행시 메모리 구조 및 실제로 확인해보는 방법</title>
      <link>/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Sat, 03 Apr 2021 18:09:24 +0900</pubDate>
      
      <guid>/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>컴퓨터 구조 시간때 배웠듯이 프로그램이 메모리에 올라가면 다음과 같은 구조로 메모리가 할당되고 실행이 된다.
 디스크에 저장되어 있는 프로그램이 메모리에 올라가게 된다. 메모리에는 크게 코드, 스택, 힙 영역이 있다.  이를 리눅스에서 확인해보려면 다음과 같은 명령어를 사용하면 된다.
cat /proc/self/maps  이 명령어가 뜻하는 바는 cat이라는 프로그램을 실행했을 때의 메모리 구조를 의미한다. 여기서 self는 자기 자신을 의미한다.   위에서부터 코드 영역, 힙 영역, 스택이 메모리에 할당되어 있는 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>리눅스는 특별한 프로그램인가?</title>
      <link>/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80/</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80/</guid>
      <description>리눅스는 과연 특별한가?  리눅스 파일이 다른 실행 파일과 다른지 알아보기 위해서 커널을 실제로 빌드 해보고 일반 실행파일과 다른점이 있는지 알아보았다.
다음은 리눅스 커널을 make 명령어를 통해서, 빌드한 모습이다. 빌드를 마치게 되면 vmlinux 라는 실행 파일이 나오게 된다.
이를 file 도구를 통해서 알아보았다. file 도구는 파일이 어떤 타입인지를 알려주는 리눅스 도구이다.
man을 통해서 메뉴얼을 확인해보면 더욱 자세한 사용법을 알 수 있다.
리눅스 실행 파일과 간단한 프로그램을 만들어서 비교한 결과, 거의 같은 파일이라는 것을 확인할 수 있었다.</description>
    </item>
    
    <item>
      <title>운영체제의 역할 및 리눅스를 공부할 때 중요한 핵심 개념</title>
      <link>/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90/</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90/</guid>
      <description>예전에 시스템 프로그래밍을 조금 더 잘 알고 싶어서 리얼 리눅스에서 강의를 들은 적이 있는데, 그 때는 노션에 정리를 하던 시절이라서 블로그에 게시하지 못했다. 따라서 그때 정리한 개념을 블로그에 글로 작성해보고 다시 운영체제에 대해서 복습하였다.
리눅스를 공부할 때 중요한 개념  리눅스를 공부할 때는 다음과 같은 개념이 중요하다고 했다.
  소프트웨어 기본 원리 : 당연한 말이지만, 소프트웨어의 기본 동작 원리를 제대로 아는 것이 중요하다.
  메모리 액세스 원리 : 운영체제에서 메모리를 어떻게 액세스 하고 관리하는지 아는 것이 중요하다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 02 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 자바스크립트 세미나를 들었다. 내가 개발하고 있는 솔루션에서 이제 슬슬 성능 문제가 나오고 있다. 엔지닉스 및 톰캣에 대해서 자세히 공부를 해야겠다는 생각을 했다.  Feelings (느낌, 주관)  자신감 있게 발표하는 것이 중요할 것 같다. 내용 뿐만 아니라 자신감 있는 목소리는 우선 집중이 되기 때문이다. 따라서 비언어적인 요소에도 신경을 많이 쓰자 발표 연습을 할 주제를 정하기가 어려워서 자꾸 발표 연습을 하는 것을 꺼리게 된다. 그리고 발표 자료를 만들어야한다는 마음에 자꾸 발표를 미루게 되는 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 01 Apr 2021 20:10:36 +0900</pubDate>
      
      <guid>/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  이제 곧 있으면 자바스크립트 관련 사내 세미나 발표를 한다.  Feelings (느낌, 주관)  곧 회사 사람들 앞에서 발표를 한다고 생각하니까 떨리고 살짝 무섭기도 하다. 최근 팀에 새로운 분이 들어왔는데, 뭔가 부끄럽지 않은 모습과 배울 점이 있는 사람으로 느껴졌으면 하는 마음이 있다.  Findings (배운 점)  발표 할 수 있는 것을 좋은 기회라고 생각하고, 회고를 작성했던 것 처럼, 말하는 연습을 하는데 좋은 동기로 작용했으면 좋겠다.</description>
    </item>
    
    <item>
      <title>ARIES란 (draft)</title>
      <link>/post/2021/03/31/aries%EB%9E%80-draft/</link>
      <pubDate>Wed, 31 Mar 2021 22:56:24 +0900</pubDate>
      
      <guid>/post/2021/03/31/aries%EB%9E%80-draft/</guid>
      <description>참고 문헌  WIKI - ARIES  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 31 Mar 2021 22:25:36 +0900</pubDate>
      
      <guid>/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  어제는 한 시간정도 일찍 취침을 했다. 오늘 회사에서, 모바일 개발을 위한 API 정리를 하였다. 팀이 변경되어서 자리를 옮기게 되었다.  Feelings (느낌, 주관)  API 문서가 현재와 맞지 않는 것들이 많아서 어지러웠다. 그리고 어떻게 해야지 모바일 개발자들이 더 쉽게 API를 사용할 수 있을까 그리고 쉽게 사용하려면 사실 컨트롤러 부분을 수정해야하는것이 아닌지 고민을 하게 되었다. 새로운 팀에서 새롭게 시작한 기분이 되어서 조금 기분 전환이 되었다.  Findings (배운 점)  API 문서를 제대로 관리하고 되도록이면 소스 코드랑 동떨어지지 않도록 노력해야겠다.</description>
    </item>
    
    <item>
      <title>데이터베이스에 대해서 배울 수 있는 좋은 강의 (CS186Berkeley)</title>
      <link>/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley/</link>
      <pubDate>Wed, 31 Mar 2021 20:40:24 +0900</pubDate>
      
      <guid>/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley/</guid>
      <description>우연히 유튜브에서 데이터베이스에 대해서 체계적이고 좋은 영상이 있는 것을 발견하였다.
  커리큘럼을 보면, 초반에는 디스크, 버퍼, 파일 및 인덱스 B+Tree 부터 시작해서 간단한 SQL 및 간단하 쿼리 튜닝까지 배운다.
  그리고, 트랜잭션 처리 부터 시작해서, 병렬 쿼리 실행 그리고 분산 트랜잭션 처리까지 철저하게 배운다.
  심지어 과제 및 시험문제도 풀어볼 수 있다. CS186
  남는시간에 틈틈히 DBMS에 대해서 공부하면서 부족했던 기본기를 튼튼하게 하면서, 오픈 소스에 기여할 때 도움이 되도록 해야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 30 Mar 2021 22:09:36 +0900</pubDate>
      
      <guid>/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘은 어제 발생했던 이슈의 원인을 찾아보았다.  Feelings (느낌, 주관)  오늘 하루 우울하고 힘이 없었던 것 같다. 오늘 밤에는 조금 쉬기로 하였다. 내일이면 팀이 새롭게 개편되어서 자리를 옮길 것 같다. 팀원들이랑 정들었는데 조금 아쉽다. 새로운 팀이랑 일을 잘 할 수 있을지 조금은 걱정되기도 한다. 이슈가 발생한 정확한 원인을 파악해서 기쁘다.  Findings (배운 점)  오픈 소스 커뮤니티에 가면, 대부분 발생했던 문제들의 해결책이 있고 만약 없더라도 내가 이슈를 만들어서 보고하도록 하자.</description>
    </item>
    
    <item>
      <title>리액트에서 구글 번역기가 번역하면서, DOM 트리를 변경해 렌더링이 되지 않는 현상</title>
      <link>/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81/</link>
      <pubDate>Tue, 30 Mar 2021 13:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81/</guid>
      <description>문제 상황 개발을 진행하다가, PM에서 데이터가 이상하다고, 확인해달라는 요청을 받았다. 확인을 해본 결과, 데이터베이스 및 서버에서 내려오는 데이터는 정상이였다. 하지만 화면에서 업데이트를 시키지 않고, 기존에 데이터가 그대로 남아있어 화면 업데이트가 안되는 상황이였다. 재현을 해봤을 때는 아무런 문제가 없어서 혹시나 하고 구글 번역기를 켜고 재현을 해보았을 때 버그가 발생하였다.
원인 검색을 해보니, 비슷한 현상이 이미 보고가 되어있었고, 원인을 파악하기 위해서 살펴보았다.
구글 번역기를 켰을 때 변경된 텍스트가 업데이트 되지 않는 이유는 다음과 같다.</description>
    </item>
    
    <item>
      <title>클라우드 이벤트 스펙이란?</title>
      <link>/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Mon, 29 Mar 2021 22:55:39 +0900</pubDate>
      
      <guid>/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</guid>
      <description>클라우드 이벤트 스펙이란?    이벤트는 어디에서든지 발생하지만, 이벤트를 생산하는 생산자에 따라서 이벤트를 다르게 정의하는 경향이 있다.
  이벤트를 설명하는 표준이 없기 때문에, 개발자는 이벤트 사용방법을 계속해서 배워야 한다. 또한 SDK, 이벤트 라우터 또는 추적 시스템과 같은 환경에서 이벤트 데이터를 전달하는데 도움이 되는 도구 및 인프라의 잠재력을 제한한다.
  클라우드 이벤트는 서비스, 플랫폼 및 시스템간에 상호 운영성을 제공하기 위해서 이벤트 데이터를 공통 형시으로 설명하기 위한 스펙이다.
    문서를 보면 프로토콜 별로 스펙과 문서를 정의한 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>메시지 큐를 이용한 비동기처리 및 에러 처리</title>
      <link>/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC/</link>
      <pubDate>Mon, 29 Mar 2021 22:19:24 +0900</pubDate>
      
      <guid>/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC/</guid>
      <description>메시지 큐를 이용한 비동기 요청 처리    요청을 처리하는 방법에는 전통적인 동기식 방식도 있지만, 비동기식 방식도 있는데, 동기 방식이 클라이언트가 요청을 보내면 처리한 다음에 응답이 오는 방식이라면 비동기 방식은 요청을 보낸 후 비즈니스 로직이 처리가 완료되지 않은 상태에서 다음 로직을 진행한다.
  서버로 전달된 요청은 나중에 처리되며 나중에 클라이언트로 응답이 전달된다. (응답을 전달하지 않을 때도 있다.)
  동기식 방식과 비동기식 방식의 가장 큰 차이점은 동기식 방식은 응답이 올 때까지 클라이언트가 대기하는 것이고, 비동기식 방식은 요청만 보내놓고 응답이 오는 것과 상관없이 클라이언트 대기 없이 다음 로직을 수행한다.</description>
    </item>
    
    <item>
      <title>멤티어 벤치마크로 아커스 성능 측정하기</title>
      <link>/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 29 Mar 2021 22:04:24 +0900</pubDate>
      
      <guid>/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0/</guid>
      <description>아커스에 내가 작성한 코드를 도입하고 나서, 얼마만큼의 성능 개선이 이루어졌는지 궁금했다. 따라서 오픈 소스 컨트리뷰톤 행사를 참여할 때, 도움을 주셨던 멘토님이 memtier_benchmark 라는 툴을 알려주셨다.
  물론 멘토님께서는 눈에 띄는 변화는 없을 것이라고 하셨다. 하지만, 내가 작성한 코드가 과연 성능 개선이 있을까 궁금해서 이를 측정해보고 싶었다.
  git clone https://github.com/RedisLabs/memtier_benchmark.git  README 문서에 나와있는데로, 의존성 패키지들을 다운로드 받고 이를 빌드 하면된다.   귀찮은 의존성들을 모두 설치해주고, make를 해주면, 드디어 사용할 수 있다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 29 Mar 2021 21:53:36 +0900</pubDate>
      
      <guid>/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 서버 성능 튜닝 및 알아야할 지식에 대한 책을 읽었다.  Feelings (느낌, 주관)  운영 체제 및 기반 지식을 이해하고, 이렇게 구성하면 빨라지겠구나를 이해하고 튜닝을 하는 것은 재미있는 것 같다. 회사에서 일을 할 때, 스트레스 관리를 잘 하는 것이 중요할 것 같다. 최근에 무리해서 공부를 했더니 오늘 조금 지쳐있어서 제대로 일을 하지 못한 것 같다.  Findings (배운 점)  기술적인 역량 및 운영체제, 네트워크, 디스크에 대한 깊은 지식이 있어야 겠다는 생각을 했다.</description>
    </item>
    
    <item>
      <title>슬로우 쿼리란? (draft)</title>
      <link>/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft/</link>
      <pubDate>Mon, 29 Mar 2021 20:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft/</guid>
      <description>슬로우 쿼리란  참고 문헌  MySql - The Slow Query Log  </description>
    </item>
    
    <item>
      <title>성능 엔지니어링 및 절차</title>
      <link>/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8/</link>
      <pubDate>Sun, 28 Mar 2021 23:24:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8/</guid>
      <description>1.성능 엔지니어링이란    성능 엔지니어링은 시스템의 목표 성능 (응답 시간과 동시 접속자 수)를 정의하고 이를 달성하기 위해서 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.
  좁게 생각하면 코드 상의 병목을 잡고 시스템의 설정을 바꿔서 성능을 높이는 튜닝으로 생각할 수 있지만, 성능 목표의 정의부터 최적의 성능을 위한 디자인 및 구현 같은 개발 초기의 설계 부분과 개발 후의 운영 단계 그리고 모니터링까지 전 과정을 포함한다.
  성능 엔지니어링을 해야하는 시기  1.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 28 Mar 2021 18:15:49 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>주간 회고 이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.
Facts (사실, 객관)  토이 프로젝트를 시작했다. 내가 여태까지 정리했던 글을 보면서, 남에게 이를 설명할 수 있는지 녹화를 해보고 이를 시청하였다. 다른 곳에 적어두었지만, 미쳐 블로그에 올리지 않은 내용을 정리해서 블로그에 포스팅을 해보았다. 회의 때 토의했던 내용중에 다르게 해석한 부분이 있었다. 회의 때 토의했던 내용을 착각한 뒤로 팀원에게 메신저로 내가 했던 일을 공유하고 그 다음에 어떤 일을 진행할 것인지 상세하게 말했다.</description>
    </item>
    
    <item>
      <title>리플리케이션이란 (draft)</title>
      <link>/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sun, 28 Mar 2021 17:43:24 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>Gelera 리플리케이션    MariaDB 클러스터에서, 서버는 트랜잭션과 관련된 쓰기를 클러스터의 모든 노드에 브로드캐스트해서 커밋을 할 때, 모든 노드에 트랜잭션을 복사한다.
  클라이언트는 DBMS에 직접 연결하여 대부분의 경우 기본의 MariaDB와 유사한 동작을 경험할 수 있다.
  wsrep(write set replication API)를 이용하여 Galera 리플리케이션과 MariaDB 사이의 인터페이스를 정의한다.
  동기 vs 비동기 리플리케이션   동기식 복제와 비동기식 복제의 기본적인 차이점은 동기식 복제는 클러스터에서 한 노드에서 변경이 발생한 경우에, 클러스터의 다른 노드에서 동기적으로 변경이 발생한다는 점이다.</description>
    </item>
    
    <item>
      <title>쿼리 오프 로딩이란 (draft)</title>
      <link>/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sun, 28 Mar 2021 17:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>참고 문헌 </description>
    </item>
    
    <item>
      <title>네트워크 메시지 암호화 및 방식 (중간자 공격, HMAC, 대칭, 비대칭 키)</title>
      <link>/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4/</link>
      <pubDate>Sun, 28 Mar 2021 16:17:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4/</guid>
      <description>네트워크(전송) 레벨 암호화    가장 기본적이고 필수적인 REST API 보안 방법은 네트워크 전송 프로토콜에서 HTTPS 보안 프로토콜을 사용하는 방법이다.
  HTTPS 프로토콜을 사용한다 하더라도, 메세지 자체를 암호화해서 전송하기 때문에 해킹으로 말미암은 메시지 누출 위협을 해소할 수 있다.
  그러나 HTTPS를 사용하더라도 메시지를 낚아 채거나 변조하는 방법이 있는데 이러한 해킹 방법을 바로 중간자 공격 (Man-In-The-Middle-Attack)이라고 한다.
  정상적인 HTTPS 통신의 경우 다음과 같이 서버에서 제공하는 인증서를 이용하여 API와 서버 상호간에 암호화된 신뢰할 수 있는 새로운 네트워크 연결을 만든다.</description>
    </item>
    
    <item>
      <title>REST API 보안 및 인가 방식</title>
      <link>/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D/</link>
      <pubDate>Sun, 28 Mar 2021 15:17:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D/</guid>
      <description>권한 인가  인증이 끝나면 다음 단계는 권한에 대한 인증, 즉 인가(Authoriation) 과정이 필요하다. 사용자가 인증을 받고 로그인을 했더라도, 해당 API를 호출할 수 있는 권한이 있는가를 확인 해야 한다.
API 인가 방식  권한 인가(Authorization) 방식에는 여러 가지 방식이 있는데, 대표적인 방식 몇 가지만 보면 가장 일반적인 권한 인증 방식으로는 사용자의 역할을 기반으로 하는 RBAC (Role Based Access Control) 이라는 방식이 있다. 이 방식은 정해진 연결에 권한을 연결해놓고, 이 역할을 가진 사용자에게 해당 권한을 부여하는 것이다.</description>
    </item>
    
    <item>
      <title>HTTP란 무엇일까? (draft)</title>
      <link>/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>HTTP    HTTP(Hyper Text Transfer Protocol)의 약자로서, 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.
  HTTP는 요청(REQUEST), 응답(RESPONSE)을 통해서 정보를 주고 받으며, HTTP 메시지 구조는 크게 헤더(HEADER)와 바디(BODY)로 나누어진다.
  CURL 명령어를 통한 요청  요청 헤더 및 응답 헤더
 다음은 curl 명령어를 통해서 구글 서버에 GET 요청을 날려보았다. 요청 헤더 및 응답 헤더를 확인할 수 있다.  응답 바디
 HTML, CSS, JS 파일을 응답한 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>HTTP와 HTTPS의 차이점 (draft)</title>
      <link>/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft/</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft/</guid>
      <description>참고 문헌   RFC - 2818  </description>
    </item>
    
    <item>
      <title>REST API 보안 및 인증 방식</title>
      <link>/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D/</link>
      <pubDate>Sun, 28 Mar 2021 13:17:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D/</guid>
      <description>REST API 보안   보안에 관해서는 백번, 천번을 강조해도 과함이 없다. 근래의 대부분의 서비스 시스템들은 API를 기반으로 통신한다. 앱과 서버 간의 통신 또는 자바 스크립트 웹 클라이언트와 서버 간 대부분의 통신이 이 API들을 이용해서, 이루어지기 때문에 한번 보안이 뚫리면 개인 정보가 탈취되는 것 뿐만 아니라, 더 많은 문제를 일으킬 수 있다.  REST API 보안 관점 및 개요  인증(Authentication)  인증은 누가 서비스를 사용하는지를 확인하는 절차이다. 쉽게 생각하면 웹 사이트에 사용자 아이디와 비밀번호를 넣어서 사용자를 확인하는 과정이 인증이다.</description>
    </item>
    
    <item>
      <title>나만의 지도 시스템을 만드는데 유용한 도구 (draft)</title>
      <link>/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft/</link>
      <pubDate>Sun, 28 Mar 2021 10:45:24 +0900</pubDate>
      
      <guid>/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft/</guid>
      <description>지도 시스템을 만드는데, 추천하는 도구    지도 시스템을 만드는데 추천하는 도구들은 다음과 같다.
  우선 프론트엔드로는, Leaflet, Openlayers, GeoExt, Turf.js 등이 있다.
  벡엔드로는 GEODjango, GeoServer 등이 있다.
  데이터베이스는 PostGIS를 많이 사용한다.
  데이터는 QGIS, Mapshaper 등이 있고, 데이터소스로는 OpenStreetMap을 사용한다.
  참고 문헌   Tools I recommend for building Geospatial Web Applications  </description>
    </item>
    
    <item>
      <title>데이터베이스 스토리지 티어링이란 (draft)</title>
      <link>/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sat, 27 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>스토리지 티어링이란  참고 문헌 </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 27 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  네이버 기술 블로그를 대략적으로 보면서, 시스템 성능 분석 및 디버깅을 통해서 객관적인 자료를 수집하는 것을 보았다.  Feelings (느낌, 주관)  개발을 잘하기 위해서는 호기심을 가지고 실험을 많이 해보고, 이를 확인할 수 있는 디버깅 툴을 많이 알아두고 적재 적소에 사용할 수 있어야겠다. 나도 네트워크 패킷을 분석하면서 문제점을 빠르게 찾고 개선해나갈 수 있는 개발자가 될 것이다.  Findings (배운 점)  리눅스 도구 및 성능 측정 도구를 많이 사용해봐야겠다.</description>
    </item>
    
    <item>
      <title>인코딩과 캐릭터 셋의 차이</title>
      <link>/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Sat, 27 Mar 2021 17:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>최근에 인코딩과 캐릭터 셋의 차이를 아는지에 대한 질문을 받았고, 제대로 답변하지 못한 기억이 난다. 따라서 이 두개의 차이점 및 추가적인 궁금증에 대해서 조사를 해보았다.
유니코드와 UTF-8, UTF-16은 무엇이 다른가   유니코드는 문자 집합으로, 문자 집합만 의미하며, 실제로 저장되는 방식(바이트로 맵핑)에 대해서는 아무런 설명을 하지 않는다.
  UTF-8, UTF-16 은 문자열 또는 바이트 배열에서 바이트로 문자를 맵핑하는 방법을 정의하는 인코딩이다.
  UTF-8, UTF-16, UTF-32는 기본적으로 일부 문자를 인코딩하는데, 사용되는 바이트의 양이 다르다.</description>
    </item>
    
    <item>
      <title>REST 및 베스트 프랙티스</title>
      <link>/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</link>
      <pubDate>Sat, 27 Mar 2021 17:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</guid>
      <description>REST    REST는 웹의 창시자 중의 한 사람인 로이 필딩이 2000년에 발표한 논문에 의해서 처음 소개되었다.
  현대의 아키텍처가 웹의 장점을 잘 활용하지 못하고 있다고 판단했기 때문에 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이바로 Representational Safe Transfer(REST) 이다.
  REST는 근래에 들어 HTTP와 JSON을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 OPEN API는 이 REST 아키텍처를 기반으로 설계 및 구현되고 있다.</description>
    </item>
    
    <item>
      <title>리버스 프록시란 무엇일까? (draft)</title>
      <link>/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>참고 문헌  </description>
    </item>
    
    <item>
      <title>메시지 교환 패턴이란(MESSAGE EXCHNAGE PATTERN)</title>
      <link>/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern/</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern/</guid>
      <description>비동기 메시지 패턴  비동기 메시지 패턴은 앞서 살펴보았듯이 중간에 큐를 두어서 구현하기 때문에, 여러 가지 메시지 전달 패턴을 구현할 수 있다. 몇 가지 대표적인 패턴에 대해서 알아보자.
Fire &amp;amp; Forgot 패턴   메시지 큐를 사용하는 패턴 중에 가장 일반적인 비동기 호출 패턴으로, 클라이언트가 호출한 후 큐에 메시지가 제대로 들어갔을면 메시지의 처리 결과에 관계없이 응답을 기다리지 않고 바로 반환한다.
  큐에 저장된 메시지는 비즈니스 컴포넌트에 의해서 나중에 처리된다.</description>
    </item>
    
    <item>
      <title>아키텍처란 무엇인가?</title>
      <link>/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</link>
      <pubDate>Sat, 27 Mar 2021 14:23:33 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</guid>
      <description>아키텍처란 무엇인가?  아키텍처에 대한 정의는 다음과 같다.
 &amp;ldquo;아키텍처는 비즈니스 요구사항을 만족하는 시스템을 구축하기 위해서 전체 시스템에 대한 구조를 정의한 문서로, 시스템을 구성하는 컴포넌트와 그 컴포넌트 간의 관계, 그리고 컴포넌트가 다루는 정보(데이터)를 정의한다&amp;rdquo;
 아키텍처 설계 프로세스    아키텍처 설계 방법론은 여러 가지가 있으나, 주로 사용되는 프레임워크로는 Zachman, TOGAF, Federal Enterprise Architecture등이 있다.
  그러나 이러한 전통적인 방법론은 학문적이고, 그 깊이가 매우 깊어서 일반적인 개발자들이 실무에 적용하기가 매우 어렵다.</description>
    </item>
    
    <item>
      <title>SOA, 모놀리틱, 그리고 MSA 아키텍처</title>
      <link>/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
      <pubDate>Sat, 27 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid>
      <description>SOA    SOA(Service Oriented Architecture)는 1990년대에 정의되어, 2008년에 유행했던 아키텍처 스타일이다.
  현대의 서버 아키텍처는 SOA 사상에 많은 영향을 받았고 많은 분산 아키텍처가 거의 이 SOA 사상에 기인한다고 해도 될 만큼 중요한 아키텍처이다.
  SOA의 기본 개념    SOA란 기존 애플리케이션들의 기능을 비즈니스적인 의미가 있는 기능 단위로 묶고, 표준화된 호출 인터페이스를 통해 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을 서로 조합(Orchestration)하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍처이다.</description>
    </item>
    
    <item>
      <title>네이버 페이 배송 모듈 아키텍처 및 사용기술 분석</title>
      <link>/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D/</link>
      <pubDate>Sat, 27 Mar 2021 10:31:33 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D/</guid>
      <description>많은 양의 트래픽을 감당하고 어떻게 고가용성의 시스템을 구축하는지 알아보기 위해서 네이버 기술 블로그 및 세미나를 보면서 사용하는 기술을 분석하고 어떤 고민을 하고 있는지 살펴보았다.
네이버 페이가 고민했던 문제점  
위에 있는 기술 세미나 영상을 보면서, 기존에 네이버 페이에서 발생했던 문제점들과 이를 해결하기 위한 기술들을 살펴볼 수 있었다.
네이버 페이에서 유저와 상호 작용하는 서비스  스마트 스토어에 보이는 주문형 페이 배달의 민족에 연동되어 있는 결제형 페이 송금 네이버 통장  배송 모듈은 주문형 페이에 속하고, 주문형 페이에는 이커머스 삼대장인 주문, 배송, 클레임 을 관리하는 부서이다.</description>
    </item>
    
    <item>
      <title>샤딩이란(draft)</title>
      <link>/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft/</guid>
      <description>샤딩  참고 문헌  모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다  </description>
    </item>
    
    <item>
      <title>클러스터링이란?(draft)</title>
      <link>/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft/</guid>
      <description>클러스터링  참고 문헌   Understanding MariaDB Enterprise Cluster
  MariaDB cluster setup
  What is MariaDB Galera Cluster?
  How to deploy a MySQL Cluster from Scratch with Docker
  </description>
    </item>
    
    <item>
      <title>CONCURRENCY(동시성)와 PARALLELISM(병행성) (draft)</title>
      <link>/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft/</link>
      <pubDate>Sat, 27 Mar 2021 01:09:24 +0900</pubDate>
      
      <guid>/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft/</guid>
      <description>CONCURRENCY(동시성)와 PARALLELISM(병행성)  병행성  동시성    CONCURRENCY(동시성) 에서 가장 중요한 것은 동시에 수행되는 기능들의 빠른 반응이다.
  이러한 빠른 반응은, 운영체제의 핵심인 커널에서 프로세스 스케줄러가 선점형(Preemption)으로 동작하느냐가 관건이다.
  CPU 자원은 한정되어 있는데 반해서 작업 진행이 필요한 프로세스들은 여러 개가 생길 수 있다. 이때 CPU 자원을 어떻게 분배하느냐가 스케줄링이 필요한 이유이다.
  컴퓨터에서 사용자가 파일을 다운로드 받을 때 파일을 다운로드 받는 프로세스가 CPU 자원을 할당 받아서 작업을 진행하게 된다.</description>
    </item>
    
    <item>
      <title>트랜잭션과 ACID</title>
      <link>/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid/</link>
      <pubDate>Fri, 26 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid/</guid>
      <description>누군가 트랜잭션에 대해서 물어보았을 때, 분명히 알고 있다고 생각한 것인데도 제대로 답변하지 못했다. 이건 평소에 생각이 정리되지 않아서 그런 것 같다. 따라서 이참에 이에 대해서 정리를 해보도록 했다.
트랜잭션이란  위키 백과에서는 트랜잭션을 다음과 같이 정의하고 있다.
  데이터베이스 트랜잭션은 데이터베이스에 대해서 DBMS 내에서 수행되고 다른 트랜잭션과 무관하게 일관되고 신뢰할 수 있는 방식으로 처리되는 작업 단위를 말한다.
  트랜잭션은 일반적으로 데이터베이스의 모든 변경 사항이 있다.
  데이터베이스 환경의 트랜잭션에는 두 가지의 주요 목적이 있다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 26 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 일을 하기전에, 내가 어떤 일을 할 계획이고 그 일이 마감되었다면 내가 구현한 것을 녹화하여 공유하였다. 내가 경험해보지 못한 생소한 업계에는 어떤 기술을 사용하고, 어떤 고민을 할까라는 생각을 해봤다.  Feelings (느낌, 주관)  그렇게 하니까 동료들이 내가 무엇을 했는지 쉽게 이해할 수 있고, 개발자 뿐만 아니라 PM 및 QA 분들도 작업이 어떻게 진행되고 있는지 쉽게 이해하시는 것 같았다. 내가 어떤 일을 하고 있는지 설명하기가 더 쉬워지고 상대방도 더 빠르게 이해하는 것 같았다.</description>
    </item>
    
    <item>
      <title>CAP 이론이란?</title>
      <link>/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80/</guid>
      <description>CAP 정리    CAP 정리에 의하면 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 것이다.
  위의 그림에서 볼 수 있듯이, Consistency, Availablity를 합치면, CA 또는 Consistency와 Partition tolerance를 조합하면 AP가 된다.
  이 모든 속성을 다 포함한 시스템은 절대로 존재할 수 없다는 것이 CAP 정리이다.
  각 특징의 의미    일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다.</description>
    </item>
    
    <item>
      <title>MVCC(다중 버전 동시성 제어)란 (draft)</title>
      <link>/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft/</guid>
      <description>참고 문헌 </description>
    </item>
    
    <item>
      <title>TWO-PHASE COMMIT 이란?</title>
      <link>/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80/</guid>
      <description>TWO-PHASE 커밋이란?    투 페이즈 커밋은 여러 노드에 거쳐서 원자성 트랜잭션 커밋을 달성하기 위한 알고리즘이다.
  분산 데이터베이스의 트랜잭션 처리를 위해서 사용하는 고전적인 방법이다.
  2PC에서는 일반적으로 단일 노드 트랜잭션에서는 나타나지 않는 새로운 구성 요소인 코디네이터(트랜잭션 관리자)를 사용한다.
  2PC 트랜잭션은 애플리케이션이 정상적으로 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작된다.
  커밋할 준비가 되면 트랜잭션 관리자는 1 단계를 시작한다. 그런 다음에 각 노드에 준비 요청을 보내서 커밋 가능 여부를 묻게 되며, 참가자의 응답에 따라서 커밋을 할지, 롤백을 할지 결정을 한다.</description>
    </item>
    
    <item>
      <title>합의(Consensus) 알고리즘이란(draft)</title>
      <link>/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft/</guid>
      <description>참고 문헌   WIKI - Consensus
  ZOOKEEPER DOCS - CONSENSUS ALGORITHMS
  Demystifying Consensus Algorithms and Their Implementations
  RAFT 합의 알고리즘
  D2 - Raft 분산 합의 알고리즘과 Python에서의 활용
  </description>
    </item>
    
    <item>
      <title>IoC의 여러가지 구현 방식(draft)</title>
      <link>/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</link>
      <pubDate>Thu, 25 Mar 2021 19:03:23 +0900</pubDate>
      
      <guid>/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</guid>
      <description>스프링 문서를 보면서, IoC에 대해서 공부를 하다가, 서비스 로케이터 패턴을 알게 되었다. 서비스 로케이터 패턴을 조사하다가 자연스럽게 다른 IoC 구현 방식도 알게 되었는데 정리를 해보았다.
참고 문헌  IOC 구현 방식  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 25 Mar 2021 18:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  팀 회식을 했다. 회의때 진행한 이야기중에 내가 놓친것들이 있었다.  Feelings (느낌, 주관)  회의때 집중을 해야겠다는 생각을 하게 되었고, 부끄러웠다.  Findings (배운 점)  회의때 내용을 파악하고 이를 기록하자.  Bad (개선할 점)  일을 진행할 때 다시한번 회의때 내가 파악하고 있는것이 맞는지 확인하자.  Affimation (자기 선언)  회의때 집중하고, 내가 놓친부분이 있을 수 있으니 이를 확인하고 일을 시작하자.  회고 작성법  Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.</description>
    </item>
    
    <item>
      <title>빈 펙토리와 애플리케이션 컨텍스트의 차이</title>
      <link>/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Wed, 24 Mar 2021 23:30:23 +0900</pubDate>
      
      <guid>/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>궁금증을 가지게 된 이유    스프링 문서를 보면서 공부하다가 위와 같은 문구를 보게 되었다. ApplicationContext가 BeanFactory의 서브 타입의 인터페이스라는 것이다.
  그렇다면 무슨 차이가 있을까라는 생각을 하게 되었다.
  BEAN FACOTRY  다행스럽게도 위와 같은 문서가 스프링 공식문서에서 제공되고 있었다. 차이점은 아래와 같다.
 BeanFactory API는 Spring IoC 기능을 위한 기초적인 기반을 제공한다. 이것의 구체적인 계약은, 주로 스프링의 다른 부분과 관련된 써드 파티 프레임워크와의 통합에 사용된다. BeanFactory 및 관련 인터페이스 (예: BeanFactoryAware, Initializing Bean, DispisableBean)는 다른 프레임워크 구성 요소의 중요한 통합지점이다.</description>
    </item>
    
    <item>
      <title>IoC 컨테이너란 무엇일까</title>
      <link>/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Wed, 24 Mar 2021 18:13:23 +0900</pubDate>
      
      <guid>/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>스프링 전반적인 기술을 주제로 사내 세미나를 하였다. 따라서 이를 공식 문서를 보면서 복습하면서 다시 정리해보았다.
  스프링 코어 문서 가장 첫 부분에 나와있는 문구이다. 전체적인 기술을 다루지만 특히 스프링 프레임워크의 IoC(Inversion of Control) 컨테이너가 가장 중요하다고 나와있다.
  Spring Framework의 IoC 컨테이너에 대한 처리는 Spring의 AOP(Aspect-Oriented Programmin) 기술을 밀접하게 따르고 있다고 한다.
  스프링 프레임워크는 개념적으로 이해하기 쉽고 자바 엔터프라이즈 프로그래밍에서 AOP 요구사항의 80%를 성공적으로 해결하는 AOP 프레임워크가 있다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 24 Mar 2021 09:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  SOP에 대해서 정리해보았다. 스프링 문서를 보면서, 세미나에서 들었던 내용을 다시 한번 보았다. 빈 펙토리와 애플리케이션 컨텍스트의 차이에 대해서 알게 되었다.  Feelings (느낌, 주관)  SOP에 대해서 정리하면서 CORS에 대해서도 알게 되었는데, 퍼즐이 맞춰지는 기분이였다. 이전에는 CORS 에러가 발생했을 때, 왜 발생했는지 원인을 파악하고 해결 방법만 찾고나서 끝이였다. 하지만 중요한 것은 왜 브라우저에서 CORS 에러를 나게 했을까라는 근본적인 물음을 가지고, 해결하는 것이 중요하다는 생각을 했다.</description>
    </item>
    
    <item>
      <title>CSP(Content Security Policy) 란 무엇일까? (draft)</title>
      <link>/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>참고 문헌   MDN - CSP  </description>
    </item>
    
    <item>
      <title>SOP(Same-origin policy) 란 무엇일까?</title>
      <link>/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>브라우저 보안 정책에 SOP(same-origin-policy) 있다는 것을 알게 되었고, 어떤건지 궁금해서 찾아보았다. 마침 MDN 문서에 잘 나와있어서 이를 참조할 수 있었다.
Same-Origin-Policy(동일 출처 정책)    SOP는 한 Origin에서 로드된 문서 또는 스크립트가 다른 Origin의 리소스와 상호 작용할 수 있는 방법을 제한하는 중요한 보안 메커니즘이다.
  보안을 위협하는 문서를 격리하여, 보안 위협으로부터 보호할 수 있다.
  한마디로 말해서 웹 브라우저에서 동작하는 프로그램은 로딩된 위치에 있는 리소스만 접근 할 수 있다는 정책이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 23 Mar 2021 21:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  내가 정리했던 블로그 글을 정해서, 남이 궁금해서 물어볼 때, 설명을 할 수 있는지 알아보기 위해, 녹화를 해보았다. 웹 애플리케이션 보안이라는 책을 읽었다.  Feelings (느낌, 주관)  분명히 알고 있다고 생각한 것인데도 불구하고 정리가 되지 않아 버벅거리고 힘들었다.  Findings (배운 점)  블로그에 기술적인 내용을 정리하고, 스스로 제대로 이해하고 있는지 문제를 만들어서 직접 풀어보도록 해야겠다. 그리고, 이를 스스로 녹화해보면서 다른 사람이 내 설명을 어떻게 들었는지 테스트 해본다면 좋을 것이다.</description>
    </item>
    
    <item>
      <title>TCP/IP 및 네트워크 계층 및 RFC 791 (draft)</title>
      <link>/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</guid>
      <description>네트워크 통신   네트워크 통신은 관점에 따라 OSI 7 모델과 TCP/IP 모델 두가지로 설명할 수 있다. OSI 7 모델은 1984년에 ISO (국제 표준화 기술)에 의해 표준화되었고, 통신이 이루어지는 과정을 단계별로, 파악할 수 있도록 7 개의 계층인 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구분되어 있으며 네트워크 구현을 연구하고 배우기에 적합한 구조다. 반면에, TCP/IP 모델은 현장에 많이 사용하는 기술 위주로 4계층으로 단순화한 모델로, 실제 사용하는 프로토콜 규약은 이 모델을 따르고 있다.</description>
    </item>
    
    <item>
      <title>최근에 애플리케이션 보안에 관심을 가지게 된 이유</title>
      <link>/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</guid>
      <description>최근에 내가 웹 애플리케이션 보안에 대해서 굉장히 무관심함을 알게 됨과 동시에 데이터베이트 연결이 끊어지는 네트워크 통신과 관련된 장애가 있었다.
장애의 이유를 알지 못하니까 굉장히 답답함과 동시에 문제를 해결할 수 없었다. 따라서 디버깅을 하듯이 네트워크 패킷을 분석해서 원인을 알아 낼 수 있으면 굉장히 좋을 것 같다는 생각을 함과 동시에 내가 주도하면서 진행하는 토이 프로젝트가 보안에 대해서 굉장히 견고한 애플리케이션이 되었으면 하는 마음이 있다. 따라서, 앞으로 웹 애플리케이션 보안에 대해서 공부하고 견고한 시스템을 구축해나갈 생각이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 22 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  아커스 이슈 구현을 하는데, 전체적인 흐름 및 구현 위치는 파악을 하였으나, 자료구조를 정확히 파악하지 못해서, 어디서부터 손대야할지 감이오지 않고, 깊은 이해를 하기 힘들었다. 대학교 동기들과 토이프로젝트를 시작했다. 회사에서 일하면서 소프트웨어 스펙을 정하고 어떤 것을 만들지 구체화 하는 과정이 중요하다는 것을 깨달았기 때문에, 지루하기는 하지만 작성하고 있다.  Feelings (느낌, 주관)  프로젝트를 주관해서 이끌어 가는 일이 힘들것이라고 예상했지만 생각보다 많은 공수가 들었다. 그래도 처음이 가장 힘들것이라고 생각하고 프로세스가 정립되면 쉬워질 것이다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 21 Mar 2021 17:15:39 +0900</pubDate>
      
      <guid>/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>주간 회고 이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.
Facts (사실, 객관)  코딩을 하면서, 사소한 실수가 발견되었고 재배포를 해야하는 상황이 되었다. 내가 아는 것을 다른사람에게 설명하는데 생각보다 말이 잘 나오지 않았고, 더듬더듬 말하고 있었다. 오랜만에 코딩 테스트 문제를 풀어보았다.  Feelings (느낌, 주관)  다른 사람들에게 미안하기도 했고, 시간이 많이 소모되었다. 다른 사람에게 쉽게 설명할 수 없으면 제대로 아는 것이 아니라는 생각이 들었다. 남들이 꺼려하는 일을 먼저 나서서 하려고 하는 자세가 동료들에게 신뢰를 줄 수 있을 것같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 20 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오랜만에 코딩 테스트 문제를 풀어봤다.  Feelings (느낌, 주관)  직장을 구하기 전에는 코딩 테스트가 그저 스트레스였는데, 오랜만에 풀어보니까 매우 재미있었다.  Findings (배운 점)  재귀를 활용해서 푸는 문제가 있었는데 재귀를 이용하니까 너무 시간이 오래 걸렸다. 따라서 메모이제이션을 공부하고 이를 이용해서 풀 수 있는지 생각을 해봐야할 것 같다. 추가로 다이나믹 프로그래밍을 이용해서 문제를 푸는 방법 및 DFS BFS 문제를 공부해야겠다.  Bad (개선할 점)  알고리즘 문제를 평소에 풀어보자.</description>
    </item>
    
    <item>
      <title>SQLAlchemy 세션(draft)</title>
      <link>/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft/</link>
      <pubDate>Fri, 19 Mar 2021 16:40:24 +0900</pubDate>
      
      <guid>/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft/</guid>
      <description>참고 문헌  Transactions and Connection Management  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 19 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)   테스트 코드를 REST DOCS를 이용해서 문서화하는 법에 대해서 배울 수 있었다.
  웹 애플리케이션 보안에 대해서 더 많이 배우기 위해서 다음과 같은 책을 구매했다.웹 애플리케이션 보안
  이번에 GC 및 JVM에 대해서 더 자세히 알고 싶어서 책을 구매 하였다. 자바 성능 튜닝이야기
  서버와 브라우저에 대해서 앞으로 더 깊게 공부를 해야겠다는 마음을 먹었다.
  Feelings (느낌, 주관)  나의 부족한 점을 채우기 위해서 더 열심히 공부를 해야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 18 Mar 2021 22:11:39 +0900</pubDate>
      
      <guid>/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘은 회사에서 배포를 기다리고 문제가 생겼을 때, 대응하기 위해서 대기하는 시간이 많았고, 이때 평소에 궁금했던 것과 현재 프로젝트에 적용하면 좋을 기술들을 찾아보고 정리하였다. 같은 솔루션을 진행하는 선배에게 프로젝트에 트랜잭션 처리를 위해서 조사를 하고 있다고 솔직하게 말하고 공부를 하였다.  Feelings (느낌, 주관)  트랜잭션에 대해서 공부하게 되었는데, SQLAlchemy 에서 트랙잭션을 사용하느 법과 세션마다 고립 레벨을 설정하는 법에 대해서 배우게 되었다. 하지만, 현재 프로젝트에 어떻게 적용하면 좋을지 조금 막막했다.</description>
    </item>
    
    <item>
      <title>SQLAlchemy에서 트랜잭션 사용법</title>
      <link>/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95/</link>
      <pubDate>Thu, 18 Mar 2021 13:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95/</guid>
      <description>회사에서 이슈 진행을 하다가, 트랜잭션를 이용하여 처리해야하는 부분을 발견하였다. 따라서 SQLAlchemy에서는 트랜잭션을 어떻게 사용하는지 정리해보도록 하겟다.
트랜잭션 관리하기  새롭게 생성된 세션은 begin() 상태이다. begin() 상태에서 Session은 아직 어떠한 Connection 및 Transactional과 연관되지 않았다. 그러한 다음에, Session 은 데이터베이스 커넥션 요청을 수신한다. 일반적으로, 이것은 Engine을 이용하여, 특정 SQL 문을 수행해야하는 것을 의미한다. 특정 SQL문의 수행은 Session.query(), Session.execute() 통해 이루어지고 Session.commit(), Session.flush()를 할 때 보류된 변경 사항을 비우고 커밋하면서 발생합니다. 이러한 요청이 수신되면, 새로운 엔진 각각이 세션에서 유지되고 관리하는 트랜잭션 상태와 연결이 된다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 17 Mar 2021 22:37:39 +0900</pubDate>
      
      <guid>/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 자투리 시간이 굉장히 많았음에도 불구하고, 시간을 가치있게 사용하지 못했다. 신규 개발을 거의 하지 않고, 유지보수만 하였더니 API 설계에 대한 감이 완전히 죽었다.  Feelings (느낌, 주관)  평소에는 시간이 없다고 불평하였는데, 예상하지 못하게 시간이 비어있을 경우에는 내가 시간을 제대로 활용하지 못했다. 업무상 많이 다루지 않는 기술을 조금 놔버렸던 것 같다.  Findings (배운 점)  예상하지 못하게 자투리 시간을 활용할 수 있도록 항상 고민을 해야겠다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 16 Mar 2021 12:37:39 +0900</pubDate>
      
      <guid>/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 내가 정말 아는 것이 없구나라는 것을 깨닫게 되었다. 내가 아는 것도 없고 설명도 잘 못한다는 것을 알게 되었다. 코드 리뷰를 통해서, 개인의 역량에 모든 것을 맡기지 않는 방법도 알게 되었다.  Feelings (느낌, 주관)  어렴풋이 들어봤던 것 같은데, 설명하려고 애를 쓰니까 굉장히 힘들었다. 내가 어떤 것을 안다고 생각하는 기준이 다른 사람에 비해서 터무니 없이 낮고, 얕았다. 코드 리뷰를 한다고 해서, 대충짜도 된다고 생각하지 말고, 다른 사람에게 내가 작성한 의도와 왜 이렇게 작성했냐고 물어보았을 때 항상 대답할 수 있게 알고 작성하자.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 15 Mar 2021 07:37:39 +0900</pubDate>
      
      <guid>/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  Javadoc을 영어로 작성할 때에는, 3인칭 단수로 작성한다. 자바독을 많이 읽어보면서 어떻게 작성했는지 알아보는 것이 좋다. 코딩을 하면서, 부주의한 실수를 하였다.  Feelings (느낌, 주관)  어떻게 보면 별것 아니라고 생각을 할지 모르겠지만, 다른 사람들의 시간을 많이 낭비하였다.  Findings (배운 점)  나의 사소한 실수로 인해서, 다른 사람들의 시간을 낭비시키지 말자.  Bad (개선할 점)  코드를 작성하고 나서, 실수를 한 것이 없는지 꼼꼼히 살펴보자.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 14 Mar 2021 20:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>주간 회고 이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.
커뮤니케이션 및 협업 능력  업무를 할 때, 상황 설명 및 커뮤니케이션을 조리있게 하지 못하고 이로 인해서 협업에 여려움을 느끼고 있었다. 어떻게 하면 내가 말을 좀 더 조리있게 잘하고 다른 사람들이 이해할 수 있을까라는 고민을 하던 중에, 다음과 같은 프레임워크를 알게 되었다.
 Situation, task, action, result  쉽게 말하면서 어떤 상황 및 이야기를 할 때, 다음과 같은 순서에 따라서 말을 하는 것이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 13 Mar 2021 23:40:39 +0900</pubDate>
      
      <guid>/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  어제 회사에서 일한 모습을 곰곰히 생각을 해보았다. 운동을 배우면 좋다는 이야기를 들었다.  Feelings (느낌, 주관)  업무중에 사소한 거짓말을 하거나 오해의 소지를 가질 수 있는 말을 하는 것 같다. 도메인 지식을 완전히 이해하지 못하다보니까, 업무를 할당 받아도 목적을 잘 이해하지 못하는 것 같다. 나도 요즘에 체력이 많이 줄어든 것 같은데 운동을 배워야겠다는 생각이 들었다.  Findings (배운 점)  사소한 것이라도 동료들에게 명확하게 말하며, 순간의 실수를 만회하려고 거짓말을 해서는 안된다.</description>
    </item>
    
    <item>
      <title>객체지향 5원칙 (SOLID)</title>
      <link>/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid/</link>
      <pubDate>Sat, 13 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid/</guid>
      <description>회사에서 객체지향 및 SOLID 원칙에 대해서 설명하는 세미나를 진행하였다.
 사내 세미나 과제  객체지향 5원칙 (SOLID) 원칙  SRP (Single Responsiblity Principle) - 단일 책임 원칙  하나의 클래스는 하나의 책임만 가져야 한다. 어떤 변화 (요구 사항등의 변화)에 의해서 클래스를 변경해야하는 이유는 오직 하나여야 한다. 나머지 4원칙의 기초가 되는 원칙으로 SRP만 잘 지키면 다른 책임의 변경으로 인한 연쇄 작용을 방지할 수 있다.  OCP (Open-Closed Principle) - 개방, 폐쇄 원칙   SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫쳐있어야 한다.</description>
    </item>
    
    <item>
      <title>사내 세미나 과제 피드백 CH10 - Future, ComputableFuture</title>
      <link>/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</link>
      <pubDate>Sat, 13 Mar 2021 11:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</guid>
      <description>회사에서 자바 비동기 처리 및 Future, CompletableFuture에 대해서 세미나를 진행하였다.
과제를 진행하면서, 비동기 프로그래밍 및 자바에서 비동기 프로그래밍을 어떻게 사용하는지 생각해 볼 수 있었다.
 사내 세미나 과제  친절하게 피드백을 해주셨기 때문에, 내가 ComputableFuture를 잘못사용하고 있다는 사실을 알게 되었다.
repository.retrieveCategories().parallelStream() .map(category -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category))) .collect(Collectors.toList()) .parallelStream() .map(CompletableFuture::join) // (1) .flatMap(Collection::parallelStream) .collect(Collectors.toList()) .parallelStream() .map(book -&amp;gt; CompletableFuture.runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors)) .collect(Collectors.toList()) .forEach(CompletableFuture::join); // (2) executors.shutdown(); 위의 코드는 내가 처음에 제출한 코드이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 12 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  현상보다는 원인을 분석할 수 있어야 할 것 같다.  Feelings (느낌, 주관)  오늘 성급하게 기존 소스코드에 문제가 있다고 생각 했는데, 사실 그게 아니였고 URS 스펙 문서를 보면서, 도메인 로직을 모르고 있어서 발생한 문제인 것을 알게 되었다. 도메인 지식을 무시하지 말고, 코딩 실력보다 사실 업무를 하는데 있어서는 도메인 로직이 중요하다는 것을 알게 되었다.  Findings (배운 점)  도메인 로직을 코드 상에서 드러낼 수 있도록 하는 것이 중요함과 동시에, 그렇지 못하다면 직접 검증하는 자세가 필요하다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 11 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 다른 사람의 소스 코드를 내 마음대로 수정했다가, 조심해달라는 이야기를 들었다. 기존의 소스 코드가 잘못되어 있더라도, 최소한의 영향을 주는 방향으로 코딩하는 것이 좋을 수도 있다는 생각을 했다.  Feelings (느낌, 주관)  상대방의 입장에서는 기분이 나쁠 수도 있는데, 화내지 않고 말해줘서 고마웠다.  Findings (배운 점)   다른 사람의 소스코드를 고칠 때는, 의견을 물어보고 고치도록하고, 어떠한 부탁을 할 때는 최대한 감정을 들어내지 않고 말하도록 해야겠다.</description>
    </item>
    
    <item>
      <title>스프링 시큐리티 아키텍처 (미완성)</title>
      <link>/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</link>
      <pubDate>Thu, 11 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</guid>
      <description>인증(Authentication)과 인과(Authorization)   어플리케이션 보안은 두가지의 독립적인 문제로 나뉜다. 바로 인증(authentication)과 인가(authorization)이다. 인증은 (who are you?) 이고, 인가는 (what are you allowed to do?) 스프링 시큐리티는 인증과 인과를 분리하도록 설계된 아키텍처를 가지고 있으며, 두 가지 모두에 대한 전략과 확장 할 수 있는 포인트가 존재한다.  인증 (Authentication)  public interface AuthenticationManager { Authentication authenticate(Authentication authentication) throws AuthenticationException; }   인증을 위한, AuthenticationManager 라는 인터페이스를 제공한다.
  AuthenticationManager는 authenticate 라는 메서드를 제공하는데, 다음과 같은 3가지 일을 한다.</description>
    </item>
    
    <item>
      <title>CSRF 란 무엇일까?</title>
      <link>/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Wed, 10 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>CSRF    CSRF(Cross-Site Request Forgery)는 신뢰할 수 있는 사용자를 가장하여 웹 사이트에 원치않는 명령을 보내는 공격입니다.
  예를 들어, 다른 곳으로 이동하기 위해 사용하는 링크 뒤에 있는 URL에 악의적인 매겨변수를 포함시킴으로써 다음을 수행할 수 있다.
  &amp;lt;img src=&amp;quot;https://www.example.com/index.php?action=delete&amp;amp;id=123&amp;quot;&amp;gt;   해당 도메인에 수정 권한이 있는 사용자의 경우 &amp;lt;img&amp;gt; 요소가, 사용자 모르게 동작을 수행한다.
  심지어, 요소가 https://www.example.com에 없는 경우에도 실행된다.
  CSRF를 방지하는 방법은 RestfulAPI 구현 및 시큐어 토큰을 추가하는 등 많은 방법이 있다.</description>
    </item>
    
    <item>
      <title>스프링의 세 가지 특징</title>
      <link>/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</link>
      <pubDate>Wed, 10 Mar 2021 08:00:33 +0900</pubDate>
      
      <guid>/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</guid>
      <description>스프링의 세 가지 특징  회사에서 하는 세미나에서, 자바 세미나가 끝나고 이어서 스프링 세미나를 시작하였다.
세미나를 진행하면서, 강조했던 스프링의 세 가지 특징에 대해서 설명한 부분을 정리해보겠다.
1. IoC / DI, DL   스프링 프레임워크는 DL (Dependency Look-up)과 DI(Dependency Injection)를 통해서 IoC (Inversion of Control)을 구현합니다.
  프로젝트를 진행하면서, 많은 라이브러리를 사용할 것이다. 특정 라이브러리에서 원하는 기능을 사용하려면 new 를 통해서 객체를 생성해야하는데, 이 객체를 생성하기 위해서는 다른 객체를 생성해야하는 등 복잡한 의존 관계가 발생하고 사용자는 파악하기 힘들다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 10 Mar 2021 07:07:39 +0900</pubDate>
      
      <guid>/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  코드숨 강의를 들었다. 회사에서 조금 동료와 트러블이 있었다.  Feelings (느낌, 주관)  강의를 들으면서, 내가 바꿀 부분에 주석으로 표시하고 진행을 하는 것을 보고 나도 배워야겠다는 생각을 했다. 왜냐하면, 내가 어떤 것을 하고 있는지 까먹을 때가 많이 때문이다. 설명도 들어보지 않고, 감정부터 앞세워서 굉장히 당황스럽고 나도 화가 났다. 이럴 때는 어떻게 대응 해야하는지 모르겠다. 그냥 좋은게 좋은거라고 넘어가야할까? 아니면 같이 화를 내는것이 맞을까?  Findings (배운 점)   기능 개선이나, 유지보수를 할 때, 주석으로 변경되어야하는 범위를 먼저 체크하고 나서 실제 기능 개발을 시작한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 09 Mar 2021 15:22:39 +0900</pubDate>
      
      <guid>/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 회사에서 동료가 나에게 한 말 조금 화가났다. 코드숨 시큐리티 강의를 들었다. 회사 세미나에서 스프링에 대한 주제로 세미나를 했다.  Feelings (느낌, 주관)  그 순간에는 뭐라고 한 소리 할까라고 생각을 했지만, 집에와서 다시 생각해보니까 안하길 잘한 것 같다. 그리고 퇴근 하기전에 오해가 풀려서 다행이다.  Findings (배운 점)  내가 되고 싶은 개발자는 같이 일하고 싶은 개발자라는 것을 명심해야겠다. 감정에 휩쓸리지 말자.   중요한 결정을 나중으로 미룰 수 있는 것이 바로 실력이다.</description>
    </item>
    
    <item>
      <title>mariadb 유니크 인덱스</title>
      <link>/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link>
      <pubDate>Tue, 09 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid>
      <description>유니크 인덱스   유니크 키는 유일해야하지만, 널을 허용할 수 있다. 테이블을 생성한 후 CREATE INDEX 명령 또는 ALTER TABLE 명령을 사용하여, 고유 키를 추가할 수 있다.  ALTER TABLE Employees ADD UNIQUE `EmpCode`(`Employee_Code`); CREATE UNIQUE INDEX HomePhone ON Employees(Home_Phone); 참고 문헌  mariadb-unique-index  </description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 08 Mar 2021 15:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)   오늘 회사에서 구현하다가 설계가 잘못되었다는 사실을 발견하고, 이를 고치기 위해서 다시 설계를 하고 여태까지 작업한 내용을 거의 다 버리게 되었다.
  오늘 회사에서 새로운 테이블 설계를 하였다.
  내가 오늘 생각하고 배운 것들을 코드숨에서 의견을 나누어 보았다.
  Feelings (느낌, 주관)   다시 설계를 할 때, 뭔가 시간을 많이 사용하지 못하는 것 같다. 어색하기도 하고 막상 동료랑 같이 이야기를 하다보니까 뽀죡한 수가 떠오르지 않았다.</description>
    </item>
    
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</guid>
      <description>MediaType.APPLICATION_JSON_UTF8  테스트 코드를 작성하다가, MediaType.APPLICATION_JSON_UTF8 부분이 Deprecated 된 것을 확인할 수 있었다.
밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 Deprecated 되었는지 알아보고 API 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.
API 주석을 읽어보니 이유는 다음과 같았다.
 크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 UTF-8 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.</description>
    </item>
    
    <item>
      <title>네이버 신입 공채 체크 포인트 및 준비해야할 것들</title>
      <link>/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4/</link>
      <pubDate>Sun, 07 Mar 2021 22:15:14 +0900</pubDate>
      
      <guid>/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4/</guid>
      <description>네이버에서 신입을 뽑을 때 고려하는 부분을 알 수 있을 것 같아서 읽어보았다. 물론 다른 기업들도 이러한 점을 고려해서 신입을 뽑을 것이다.
 2020신입개발공채체크포인트!  네이버가 강조하는 세가지의 키워드  기본기! 커뮤니케이션! 성장가능성!  기본기   기술 생태계가 빠르기 때문에, 의욕만 앞서 모두 다 경험해보겠다는 태도는 그다지 효율적인 접근 방법이 아니다. 따라서 이럴 수록 기본기에 충실해야만 새로운 기술 흐름에 압도되지 않고, 스스로의 방향성과 페이스로 앞으로 나갈 수 있다.
   새로운 기술을 배웠다거나, 사용할 수 있다고 어필을 하는 것 보다는 기본기가 탄탄하다는 인상을 주는 것이 유리할 것이다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</guid>
      <description>ComputableFuture란   자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.  자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.
 Future를 외부에서 완료시킬 수 없다. 작업을 취소하거나, get()에 타임아웃을 설정할 수 없다. 블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다. 예외처리용 API를 제공하지 않았다.  비동기로 작업 실행하기  비동기로 작업을 실행하는 방법은 두가지가 있다.
 runAsync(): 리턴값이 없는 경우 사용한다. supplyAsync(): 리턴 값이 있는 경우 사용한다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 07 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>주간 회고  한 주간에 있었던 일과 생각을 정리해보았습니다.
JWT 토큰에 대해서 알게 되었다.   코드숨 과제를 하면서 JWT 토큰에 대해서 조사를 해보았다. JWT 토큰에 대해서 들어본적은 기억은 있었지만, 로그인을 할 때 사용한다 정도로만 알고 있었다.   과제를 제출하기 전에, 내가 사용하는 라이브러리에 대해서 최소한의 조사를 하고 PR을 하자는 목표를 가지고 조사를 하게 되었다. RFC 문서까지 읽고 공부를 했으면 더 좋았을 것 같다. 따라서 투두 리스트에 넣어두고 시간이 되는대로 읽고 정리하도록 해야겠다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</guid>
      <description>Callable과 Future   Callable과 Runnable의 차이점은 작업의 결과를 받을 수 있다는 사실이다. Future는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.  다음은 Future에 대해 설명한 API 주석이다.
 Future는 비동기식 계산의 결과를 나타냅니다. 계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다. 결과는 계산이 완료된 경우에만 메서드 get을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다. 또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 06 Mar 2021 15:14:39 +0900</pubDate>
      
      <guid>/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  파이썬 AOP라는 글을 읽어보았다. 1   오늘 회사 세미나 과제를 했다. (자바 동시성 및 ComputableFuture) 인터셉터에 대해서 배우게 되었다.  Feelings (느낌, 주관)  아직 스트림 연산에 대해서 완전히 이해를 하지 못한 것 같다. 객체의 본질적인 역할과 관심사의 분리를 해주는 것이 중요하다.  Findings (배운 점)   어떤한 기능을 도입할 때, 프로젝트에 정말로 필요한 기능인가를 생각해보고 프로젝트에 필요한 부분만 선택하는 능력이 필요하다는 것을 느꼈다.</description>
    </item>
    
    <item>
      <title>파이썬에 AOP 적용하기라는 글을 읽고 느낀점</title>
      <link>/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Sat, 06 Mar 2021 14:50:40 +0900</pubDate>
      
      <guid>/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>배경  내가 현재 맡고 있는 솔루션에는 일일이 데이터베이스를 열어주고 쿼리를 실행하고 데이터베이스를 닫아주는 과정을 거치고 있었다. 매우 비효율적이고 중복된 코드가 많아져 이를 수정하고자 하였다. 따라서, 어떻게 수정할까 고민하는 과정에서 스프링에 있는 AOP 개념이 파이썬에도 있을 것이라고 확신하고 검색을 했다. 그러던 중에, 브랜디 개발 블로그에서 좋은 글을 발견하여 이를 읽고 느낀점을 적어보았다.
본문   다양한 관점에서 고려해보는 모습이 인상 깊었다. 나도 물론 최선의 방법을 생각해보려고 고민을 해보지만, 이렇게까지 다양한 과점을 고려해보지는 않은 것 같다.</description>
    </item>
    
    <item>
      <title>파이썬 itertools 모듈의 group by 함수</title>
      <link>/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98/</link>
      <pubDate>Sat, 06 Mar 2021 13:15:35 +0900</pubDate>
      
      <guid>/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98/</guid>
      <description>배경  회사에서 이슈를 처리 하다가, 키 값을 기준으로 하위 리스트를 처리할 일이 있었다. 자바였으면 groupingBy()를 이용하여 쉽게 처리를 할 수 있다는 생각을 하고 있었던 참에 파이썬도 이와같은 함수를 지원하지 않을까라는 생각이 들어서 검색을 해보니 비슷한 함수가 있었다.
 연속된 키와 그룹을 반환하는 이터레이터를 만든다. 인자중에, 키는 각 요소의 키 값을 계산하는 함수이다. 일반적으로 해당 항목은 동일한 키 함수에 대해서 이미 정렬되어야 한다. 키 함수의 값이 변경될 때마다 중단하거나 새 그룹을 생성하기 때문에 동일한 키 함수를 이용하여 데이터를 정렬해줘야한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 05 Mar 2021 07:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  기계인간님의 DRY 원칙에 대해서 쓴 글을 읽었다. 1   기계인간님의 디미터 법칙에 관한 글을 읽었다. 2  Feelings (느낌, 주관)   DRY 원칙은 모든 곳에 적용할 수 있을 것이다. (코드, 테스트, 문서화) 그리고 내가 DRY 원칙을 잘 지키고 있는지 생각하면 그렇지 못한 것 같다.
   Findings (배운 점)   실용주의 프로그래머에서는 중복을 4가지로 분리한다.
 강요된 중복 : 개발자들은 다른 선택이 없어 보인다.</description>
    </item>
    
    <item>
      <title>테크니컬 라이팅 4대 원칙이라는 글을 읽고 느낀점</title>
      <link>/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Thu, 04 Mar 2021 18:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>테스트 코드 및 메서드 주석에 대한 고민 코드를 작성하면서 테스트 코드에 어떤 테스트라는 것을 어떻게 명확하게 표현할까, 그리고 모듈 및 클래스, 메서드 주석을 달면서 어떻게 작성해야 좋은 문서가 될까? 라는 고민을 하고 작성하였지만 여전히 어렵기만 했다. 그런던 중에서 카카오 기술 블로그에서 도움이 될 만한 글을 발견하였다.
테크닐컬 라이팅의 4대 원칙 명확성  테크니컬 라이팅의 첫 번째 원칙은 명확성이다.   명확성이란 핵심어나 핵심 문장이 모호하게 사용되지 않고, 대상 독자가 기술 문서를 읽을 때, 내용의 모호함이나 혼란 없이 한번에 이해하도록 하는 글이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 04 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 PM 분이 맡은 일을 언제까지 끝낼 수 있는지 공유를 해주면 일정 조율을 하기 편할 것 같다는 말씀을 하셨다. 오늘 이슈를 진행하면서, 전체적인 기능을 보고 코드를 보면서 어떻게 구현할지 생각하지 않고, 코드부터 보면서 어떻게 구현할지 생각을 했다. 오늘 이슈를 진행하면서 메서드 주석 및 클래스 주석을 작성하려고 하였다.  Feelings (느낌, 주관)  여태까지 팀 안에서 개발자들과의 소통만 생각했었는데, PM 분과의 소통 하는 방법에 대해서도 생각을 해봐야겠다.</description>
    </item>
    
    <item>
      <title>DBMS를 분석하는 방법</title>
      <link>/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Wed, 03 Mar 2021 23:32:24 +0900</pubDate>
      
      <guid>/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>KCD 2020    막 오픈소스 컨트리뷰톤을 끝마치고, 오픈소스 개발에 재미를 붙였을 때, KDC 2020이라는 세미나가 열렸다. 오픈소스 데이터베이스 큐브리드에 기여하기라는 제목의 세션을 보았을 때, 오픈소스 DBMS를 개발한다는 부분이 신기했고, 궁금한 점이 있어서 메일을 보내게 되었는데, 친절하게도 아주 장문의 답장을 해주셨다.
메일  내가 보낸 메일을 다시 보니까, 많이 부끄럽다;;
매우 유용한 조언을 해주셨고, 실제로 많은 도움이 되었다. 이를 요약하자면 다음과 같다.
  코드 레벨에서부터 접근하면 분석하기 쉽지 않다.</description>
    </item>
    
    <item>
      <title>우아한 테크 코드 지원 후기 및 회고</title>
      <link>/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 03 Mar 2021 23:15:14 +0900</pubDate>
      
      <guid>/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0/</guid>
      <description>이전에 우아한 테크코스에 지원을 하여 코딩 테스트를 본 적이 있었다. 비록 탈락했지만 다음에 더 잘할 수 있도록 피드백을 주셨다.
코딩 테스트   코딩 테스트의 경우 알고리즘 역량이나 풀이 속도도 중요하지만, 문제를 명확하고 꼼꼼히 이해하는 능력이 가장 중요하다고 하셨다.
  프로그래머에게 속도가 빠름도 중요하지만, 그 보다는 요구사항을 명확히 이해해 버그없는 프로그래밍을 구현하는게 더 중요하다고 하셨다.
  자기소개서   자기소개서는 구체적으로 쓰는 것이 좋다. 어떤 내용을 학습했다는 결과 위주의 내용이 아니라, 어떤 내용을 학습하는데 어떤 어려움이 있었고, 어떻게 극복했다와 같이 구체적인 사례를 들어서 공감을 얻는 것이 중요하다.</description>
    </item>
    
    <item>
      <title>라인 개발자 입사기를 읽고 느낀점</title>
      <link>/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Wed, 03 Mar 2021 21:49:39 +0900</pubDate>
      
      <guid>/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>지원서 작성할 때, 참고할 부분    대외 활동을 했다는 사실 그 자체보다는 그 활동에서 배우고 얼마나 성장했는지를 위주로 적자
  무엇을 했는지가 중요한 것이 아니다, 무엇을 얻었고, 배웠는지를 위주로 작성하자.
  어떤 활동을 하더라도, 자신의 성장을 연결하는 것이 중요하다, 자신의 성장을 감춰두고 혼자만 아는 것 보다는 어떠한 방식으로도 그것을 드러내서 어필하는 것이 중요하다.
  신입 개발자가 아닌 경우  스스로 공부해 왔던 내용과, 더불어 내가 어떤 개발자가 되고 싶은지 목표를 설정 지금 근무하는 곳에서 책임감을 가지고 근무하는 모습이 중요하다.</description>
    </item>
    
    <item>
      <title>데이터베이스 스키마를 관리하는 도구, Flyway</title>
      <link>/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway/</link>
      <pubDate>Wed, 03 Mar 2021 20:09:39 +0900</pubDate>
      
      <guid>/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway/</guid>
      <description>데이터베이스 스키마 관리의 필요성  최근에 회사에서 기존에 AWS에서 서비스하던 서비스를 ALI 클라우드에서 제공해야하는 일이 있었다. 따라서 데이터베이스 스키마와 마스터 데이터를 새로운 클라우드 환경으로 이전을 시켜줘야 했다.
비교적 규모가 큰 서비스는 아니여서, 덤프를 이용해서 간단하게 이전하였고, 데이터베이스 스키마 및 마스터 데이터를 쿼리문 형태로 만들어서 GIT으로 형상관리를 하였다.
이 정도로 모든 일이 마무리 되기는 하였지만, 어딘가 부족한 느낌이 들었다. 왜냐하면 개발을 하면서 DB 스키마가 변경할 일이 있는데 그럴 때마다 쿼리문으로 테이블 스키마를 변경하고, 스키마 파일을 업데이트 해야했기 때문이다.</description>
    </item>
    
    <item>
      <title>파이썬 @classmethod와 @staticmethod 차이</title>
      <link>/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Wed, 03 Mar 2021 08:45:13 +0900</pubDate>
      
      <guid>/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4/</guid>
      <description>파이썬을 코딩을 하다가 @classmethod 데코레이터가 붙어 있는 메서드를 볼 수 있었다. 정확히 어떤 역할을 하는지 몰라서 문서에서 찾아보았다.
@classmethod  메서드를 클래스 메서드로 변환합니다. 클래스 메서드는 인스턴스 메서드가 인스턴스를 받는 것 처럼 클래스를 암시적인 첫 번째 인수로 수신한다.1  클래스 메서드는 다음과 같이 사용한다.
class C: @classmethod def f(cls, arg1, arg2, ...): ...  클래스 메서드는 다음과 같이 호출 될 수 있다.  C.f(), C().f()   앞의 경우에는 클래스에서 호출 된 것이고, 뒤의 경우에는 인스턴스에서 호출 된 것이다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 03 Mar 2021 08:00:39 +0900</pubDate>
      
      <guid>/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  오늘 WSGI에 대해서 정리를 해보았다. 오늘 @staticmethod, @classmethod에 대해서 조사 및 정리를 하였다. 이슈를 진행하던 도중에 @classmethod를 사용하는 코드를 보았고, 무슨 역할을 하는지 몰라서 찾아보았다.  Feelings (느낌, 주관)  그냥 모르고 관성적으로 쓰는 것보다 이게 왜 사용되었는지 알고 생각하면서 사용하니까 훨씬 많이 배우는 느낌이고 자신감이 생긴것 같다. 오늘 이슈를 진행하다가 비슷한 예외가 많이 발생하여, 이러한 예외가 발생하고 있다고 말했는데 실제로는 그러한 예외가 호출되지 않고 다른 예외가 호출되었다.</description>
    </item>
    
    <item>
      <title>WSGI</title>
      <link>/post/2021/03/02/wsgi/</link>
      <pubDate>Tue, 02 Mar 2021 14:39:13 +0900</pubDate>
      
      <guid>/post/2021/03/02/wsgi/</guid>
      <description>플라스크와 WSGI 플라스크 문서를 살펴보다가 다음과 같은 문장을 보았다.
 플라스크는 Jinja 템플릿 엔진과 Werkzeug WSGI 툴킷에 의존하고 있다. 1  Werkzeug가 무엇을 하는 툴인지 몰라서 검색을 해본 결과 다음과 같았다.
 Werkzeug는 포괄적인 WSGI 웹 애플리케이션 라이브러리이다. WSGI 응용 프로그램을 위한 단순한 유틸리티에서 시작하였지만, 현재는 가장 진보한 WSGI 유틸리티 라이브러가 되었다. 플라스크는 Werkzeug를 감싸 WSGI의 세부사항을 처리하는 동시에 강력한 애플리케이션을 위한 더 많은 구조와 패턴을 제공한다. 2  Werkzeug는 다음을 포함하고 있다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 02 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  코드숨 강의를 들엇다. (JWT 토큰에 대해서 알게 되었다.) 오늘 회사에서 일을 할 때, 적극적으로 의사소통을 하려고 노력하였다. 플라스크 관련된 문서를 정리해보았다. 퇴근하는 길에, 라인 개발자 채용 관련 QnA 영상을 보았다.  Feelings (느낌, 주관)  적극적으로 의사소통을 하니, 동료들과 소통이 더 잘되는 느낌이였다. 라인 채용 유튜브 영상을 보니, 컴퓨터공학 기반 지식과 알고리즘 그리고 코딩테스트를 중요하게 여기는 것 같았다.  Findings (배운 점)  소통하려는 의지만 있어도 동료들이 알아차리고 좋게 봐주는 것 같다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</guid>
      <description>Executor Interfaces  Executor, 태스크를 관리하는 인터페이스 입니다. ExecutorService는 Executor의 하위 인터페이스이며 태스트와 Exector의 라이프 사이클을 관리하는 기능을 포함하고 있다. ScheduledExecutorService는 ExecutorService의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.  Executor 인터페이스  Executor 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다. Executor는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.  ExecutorService 인터페이스 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>동시성이란? (Concurrency)  동시성 프로그래밍이란? 동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다. 유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 01 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>TIL 양식 Facts (사실, 객관)  코딩 테스트 공부를 했다.  Feelings (느낌, 주관)  정답을 맞추는 것 뿐만 아니라, 더 좋은 방법은 없는지 생각을 해보는 것이 중요하다는 것을 느꼈다. 더 좋은 방법이 없는지 생각해보는 것은 실제로 코딩을 할 때, 지금보다 나은 방법이 없는지 꾸준히 고민하게 해주는 습관을 기를 수 있게 될 것이다.  Findings (배운 점)  코딩 테스트 문제를 풀 때, 입력 값을 받는 코드를 넣으면 테스트 하기 불편해진다.</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</guid>
      <description>그리디 알고리즘  현재 상황에서 좋아 보이는 것만을 선택하는 알고리즘
 어떤 문제가 있을 때 단순 무식하게 탐욕적으로 푸는 알고리즘이다. 여기서 탐욕적이라는 말은 &amp;lsquo;현재 상황에서 지금 당장 좋은 것을 고르는 방법&amp;rsquo;을 의미한다. &amp;lsquo;사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 유형&amp;rsquo; 이라는 특징이 있다. 그리디 알고리즘 유형의 문제는 매우 다양하기 때문에, 암기한다고 해서 항상 잘 풀수 있는 것은 아니다. 많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다. 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>주간 회고 이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.
출근 방식의 변화  이번주에는 새벽까지 할 일을 하고 아침에 늦게 출근하느 방식에서 벗어나 차라리 일찍 일어나서 일찍 출근하고 일찍 취침하는 방식을 택했다. 무엇보다 마음에 드는 것은 활용할 수 있는 시간이 훨씬 많아진 것이다. 새벽에 출근을 하니까 교통이 막히자 않아서 전에는 버스를 타고 1시간 20분 걸리던 거리가 40분 만에 도착할 수 있었다. 그리고 남는 시간에 개인적인 공부를 하니 시간 확보를 하는데 많은 도움이 되었다.</description>
    </item>
    
    <item>
      <title>개발자 채용 프로세스</title>
      <link>/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</link>
      <pubDate>Sat, 27 Feb 2021 22:56:33 +0900</pubDate>
      
      <guid>/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</guid>
      <description>개발자 채용 프로세스  개발자 채용 프로세스는 다음과 같다.
  서류 검토 코딩 테스트 기술 면접 인성 면접    코딩 테스트는 주로 알고리즘 문제를 출제하므로, 알고리즘을 열심히 공부하고 연습했다면 합격할 수 있다. 하지만 기술 면접에서는 알고리즘 외에도 컴퓨터구조, 운영체제 등 컴퓨터공학 전반에 대한 다양한 지식에 관해서 질문하므로 공부해야할 범위가 상당히 넓다. 또한 아무리 실력이 좋더라도 성실성과 팀원으로서 잘 어울릴 수 있는지 그리고 커뮤니케이션 능력 또한 무시할 수 없다.</description>
    </item>
    
    <item>
      <title>코딩 테스트 출제 경향 및 준비 방향</title>
      <link>/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5/</link>
      <pubDate>Sat, 27 Feb 2021 22:28:35 +0900</pubDate>
      
      <guid>/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5/</guid>
      <description>최신 출제 경향과 준비 방향  정확한 알고리즘을 사용하여 얼마나 빠르게 많은 문제를 풀었는지를 토대로 순위를 매긴다. 기업은 코딩 테스트를 통해서 취업 준비생들에게 뛰어난 프로그래밍 실력을 원하는 것이 아니라, 기초 알고리즘에 기반하는 문제들이 출제된다. 가장 출제 빈도가 높은 문제는 그리디, 구현(implementation), DFS/BFS를 활용한 탐색 문제이다. 또한 상대적으로 높은 사고력을 요구하는 다이나믹 프로그래밍이나, 그래프 이론 문제도 출제된다.  다음은 카카오 기술 블로그에 언급된 코딩 테스트 문제 난이도에 대한 내용이다.
 ACM-ICPC 같은 어려운 알고리즘 설계 능력을 겨루는 문제가 아닌, 업무에서 있을만한 상황을 가정하여 독창적이고 다양한 분야의 문제를 출제했고 난이도 또한 비교적 쉬운 수준으로 조정하였습니다.</description>
    </item>
    
    <item>
      <title>이것이 코딩 테스트다</title>
      <link>/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/</guid>
      <description>내가 코딩 테스트를 준비하는 이유  당장 구직하지 않더라도, 이러한 준비를 미리 해두어야 좋은 기회를 잡을 수 있다. 대기업이나, 누구나 가고 싶은 기업에는 코딩 테스트가 존재한다. 항상 서류에서 통과가 되더라도, 코딩 테스트에서 떨어지곤 했는데 이번에는 떨어지지 않고 면접까지 가는 것이 목표이다. 대기업 면접을 통해서 합격하지 못하더라도 내가 미쳐 생각하지 못했던 부분과, 부족한 부분을 배울 수 있는 기회로 삼고 싶은데 코딩 테스트때문에 면접까지 갈 수가 없기 때문에 배울 기회가 없다. 물론 코딩 테스트를 통해서 테스트 코드를 작성하는 법과 사고력을 키울 수 있을 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>facts (사실, 객관)  오늘 개발 블로그를 만들었다. 오늘 회사에 일찍 일어나서, 출근을 하였다. 테스트 주도 개발 시작하기라는 책을 3장까지 읽었다.  feelings (느낌, 주관)  블로그 서비스를 이용하는 것보다는 많은 시간이 들었다. 아직 많은 기능이 필요하지만, 실제로 그 기능이 필요할 때 까지는 최대한 늦추도록 해야겠다. 일찍자고, 일찍 일어나는 것이 늦게까지 개발을 하다가 늦게 일어나는 것 보다 효율이 좋은 것 같다. 하지만, 회사에 출근을 했을 때, 무엇을 해야할지 계획을 세우지 않아서 조금 헤메였다.</description>
    </item>
    
    <item>
      <title>테스트 코드를 작성하는 순서</title>
      <link>/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C/</guid>
      <description>테스트 코드를 작성하는 순서 테스트 코드를 작성하는 것도 무작성 작성하는 것보다는 순서를 지켜가면서 작성하는 것이 훨씬 좋다.
테스트는 다음과 같은 순서를 따르면서 작성 해야한다.   쉬운 경우에서, 어려운 경우로 진행 예외적인 경우에서, 정상적인 경우로 진행   한번에 완벽한 코드를 만들면 좋겠지만, 모두가 슈퍼 개발자인 것은 아니다. 보통의 개발자는 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다. 당연히 테스트 통과 시간도 길어진다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 26 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  다른 사람들의 PR을 참고해보았다. (https://github.com/CodeSoom/spring-week5-assignment-1/pull/10)  Feelings (느낌, 주관)  다른 사람들의 PR에서 내가 경험해보지 못한 많은 것을 배울 수 있었다.  Findings (배운 점)  예외처리에 어떤 정보를 추가하는 것은, 디버깅하는 사람과 모니터링을 하는 사람들을 위한 서비스 정보라는 것을 알게 되었고, 이러한 사람들을 위해서 적절한 예외와 정보를 알려줘야겠다고 생각을 했다. 예외를 반드시 컨트롤러에서 처리를 하지 않아도 된다는 것을 배울 수 있었다. 어떤 예외는 레이어를 넘나들고, 어떤 예외는 다른 레이어에 공개되지 않도록 조용이 처리해야한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 25 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  오늘도 일찍 출근하였다. 버스로 출퇴근하면서 경제 유튜브를 시청하였다. 어제 퇴근하면서 버클리에서 하는 데이터베이스 강의를 들었다. 기계인간님이 코드숨 과정을 진행할 때, 자신의 PR에 dozer-mapper를 소개하고, 자신이 생각하는 장점을 같이 기입하면 좋을 것 같다고 하셨다. 오늘 목표를 정했다. 1. LMS에서 함수 하나를 정해서 작게라도 테스트 코드를 작성하기 슬랙에 요청만 하고 확인하지 않았다. 최근에 스트레스 관리를 못해서 회사에서 감정 컨트롤을 하지 못해 회사에서 하루종 일 우울한 모습을 보였다. 무언가를 물어볼 때, 말을 조리있게 못한다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 24 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  오늘 이력서를 간단하게 작성을 시도해보았다. 아침에 과제를 바로 하거나, 이력서 관련 분석을 해야겠다. 더 많은 일을 하면서 더 빠르게 하기(http://agile.egloos.com/1762301) 라는 글을 읽었다. 간단한 쿼리문을 작성해보았다.  Feelings (느낌, 주관)  경력 기술서를 간단하게 적고 있는데, 회사에서 했던일이 무엇인지 잘 생각이 나지 않는다. 어떤 일을 할 때, 작은 규모의 일을 하고 그 다음에 같은일을 좀 더 큰 규모로 하면 더 쉽다는 것이다. 조인에 대해서 내가 잘 이해하지 못하고 있는 것 같다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 23 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  오늘도 일찍 출근해서, 아침에 과제를 하였다. 테스트를 먼저 작성하다보니, 미완성인 클래스들을 우선 만들어주어야하는 경우가 있었다. 오늘 퍼블리싱 세미나에 참석했다. 스마트한 시간관리, 인생관리 습관이라는 책을 읽었다.  Feelings (느낌, 주관)  내가 자본주의를 살면서 느낀 것은 하이 리턴을 바랄 려면 하이 리스크를 감당할 줄 알아야하는 것과, 시간은 곧 돈이고 모든 서비스는 어떻게 보면 다른 사람들의 시간을 아껴주는데서 발생한다는 것이다. 따라서 다른 사람들이 어떤 일에 시간이라는 자원을 많이 들이는지 그리고 내가 어떻게 하면 그 시간을 줄여줄 수 있는지에 대해서 고민을 하자.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 22 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  어제 일찍 자고, 일찍 출근하여 개발 공부를 하였다. 오늘 퇴근하는 길에, 라인 개발자 공고를 보았다.  Feelings (느낌, 주관)  출근 시간이 훨씬 빨라진 느낌을 받았다. 하루가 길게 느껴졌고, 코드숨 강의를 여유롭게 들을 수 있었다. 나도 저런곳에서 한번 일해보고 싶은 마음이 있었다. 요즘 배우고 있는 TDD를 코딩 테스트를 풀면 일석이조의 효과를 누릴 수 있겠다는 생각을 했다. 빌 에반스가 성공한 사람들은 놀랍게도 현실적인 관점을 가지고 있다는 말을 했다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 21 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  백기선님의 유튜브 영상을 보았다. (https://www.youtube.com/watch?v=iua0nrfh4_Q&amp;amp;feature=share) 이직관련해서 좋은 영상들을 많이 보았다.  개발자가 이직하는 방법 (전략) (https://www.youtube.com/watch?v=W5Nx4Bq7Y-4&amp;amp;feature=share) 개발자 취업의 비밀 (역시사지)(https://www.youtube.com/watch?v=PWl9dmwnzoo&amp;amp;feature=share)   네이버 FINANCIAL에 지원을 해보았다.(https://recruit.navercorp.com/naver/job/detail/developer?annoId=20005127&amp;amp;classId=&amp;amp;jobId=&amp;amp;entTypeCd=&amp;amp;searchTxt=&amp;amp;searchSysComCd=) 자기 회고를 했던 일과 느낀점을 나열하고 있었다. 코딩을 할 때 세심하게 주의를 기울이지 않는 것 같다.  Feelings (느낌, 주관)  단지 회고를 할 때 내가 했던일, 느낀점, 자기 선언을 나열하는 형식보다는 알아보기 쉽게 하는 능력이 부러웠다. 이력서를 다시 작성하고 보니, 나의 부족한 점이 무엇인지 알 수 있었다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 20 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  오늘 TDD로 과제를 하기 위해서 회사에 나왔다. 오류 메시지가 나왔을 때, 아샬님은 어떤 오류 메시지가 발생하였는지 꼼꼼하게 읽어 보고 개선을 하지만, 나는 그냥 대충 읽어본다는 사실을 발견하였다. 매일 회고를 작성하니까, 주간 회고를 더 상세하고 의미 있게 작성할 수 있었다. 테스트 주도 개발 시작하기라는 책을 2장까지 읽어보았다. 회고를 작성하는 것도 좋지만, 내가 지난 회고를 보고 다시 리마인드 할 수 있게 만드는 것도 생각을 해봐야겠다. TDD를 진행하면서 과제를 하였다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 19 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  오늘 친구랑 같이 졸업 사진을 찍었다. 졸업 사진을 찍으면서 많은 이야기를 할 수 있었다. 개발 관련된 이야기를 하면서 많은 것을 생각해 볼 수 있었다. 개발자 이종립님이 코드에 작성한 주석을 바탕으로 문서화를 할 수 있다는 것을 알려주었다. 성공의 단계에 이르는 빌 에반스의 연습 방법이라는 영상을 보았다. (https://youtube.com/watch?v=anH8Y8vAz2Q&amp;amp;feature=share) 나 혼자 독단적으로 판단해서 과제를 진행하던 것을, 초기화 시켰다.  Feelings (느낌, 주관)  교수님이 추천한 곳으로 취직한 얘들은 별로 좋은 조건에 취업을 하지 못했다는 느낌을 받았다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 18 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)  요즘 출퇴근 하면서 30대 방구석 이야기라는 유튜브 채널을 시청하고 있다. 개발 이야기 및 삶에 대한 좋은 자세를 배울 수 있었다. 이슈를 볼 때 현상에 집중하는 것 보다 빠르게 본질을 파악하는 것이 중요하다. 내가 작성한 코드에 대해서 근거와 논리가 있어야한다는 것을 알게 되었다. 오늘 내가 작성한 코드에 대해서 왜 이렇게 작성하였는지, 질문이 들어왔다. 우연하게 내가 작성한 코드가 올바른 이유를 가지고는 있었지만 의도했다고는 말을 하지 못하겠다.  Feelings (느낌, 주관)  나도 이러한 자세를 가지고 일을 하고 살아가고 싶다는 느낌을 받았다.</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 17 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>Facts (사실, 객관)   좋은 유튜브 채널을 찾았다. (https://www.youtube.com/channel/UCyCFnxi_hBaLvL6pV_zVILQ) 면접을 보면서 공부한 내용을 정리하면 좋을 것 같다는 생각을 했다.
  최근에 네트워크 관련한 문제로 골머리를 앓고 있는데, 네트워크 패킷 분석에 대해서 조금 알아둔다면 이러한 상황에 잘 대처를 할 수 있을 것 같다는 생각을 했다.
  아샬님의 강의를 보다가 느꼈는데, 실제 인터페이스와 서비스, 그리고 인터페이스를 상속받는 클래스와의 의존성을 간단히 확인하고 계셨다. 그 방법은 메서드를 변경해보는 것이다. 그러자 인텔리제이에서 에러를 알아서 표시를 해주었고, 자연스럽게 의존하고 있는 부분이 들어났다.</description>
    </item>
    
  </channel>
</rss>
