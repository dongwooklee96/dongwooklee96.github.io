<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>네트워크 on 개발자 이동욱</title>
    <link>/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/</link>
    <description>Recent content in 네트워크 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Tue, 20 Apr 2021 23:51:39 +0900</lastBuildDate><atom:link href="/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP 통신과정 추적해보기 (draft)</title>
      <link>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</link>
      <pubDate>Tue, 20 Apr 2021 23:51:39 +0900</pubDate>
      
      <guid>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</guid>
      <description>추적 과정  추적하기 전에 클라이언트와 서버 코드를 컴파일 한다.
client.c
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define MAXLINE 1024 int main(int argc, char **argv) { struct sockaddr_in serveraddr; int server_sockfd; int client_len; char buf[MAXLINE]; if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(&amp;quot;error : &amp;quot;); return 1; } serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;); serveraddr.sin_port = htons(4000); client_len = sizeof(serveraddr); if(connect(server_sockfd, (struct sockaddr*)&amp;amp;serveraddr, client_len) == -1) { perror(&amp;quot;connect error : &amp;quot;); return 1; } memset(buf, 0x00, MAXLINE); read(0, buf, MAXLINE); if(write(server_sockfd, buf, MAXLINE) &amp;lt;= 0) { perror(&amp;quot;write error : &amp;quot;); return 1; } memset(buf, 0x00, MAXLINE); if(read(server_sockfd, buf, MAXLINE) &amp;lt;= 0) { perror(&amp;quot;read error: &amp;quot;); return 1; } close(server_sockfd); printf(&amp;quot;server:%s\n&amp;quot;, buf); return 0; } server.</description>
    </item>
    
    <item>
      <title>TCP 통신에 대해서 알아보자...</title>
      <link>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</link>
      <pubDate>Tue, 20 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</guid>
      <description>TCP (Transmission Control Protocol)    TCP는 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다.
  TCP는 IP 네트워크를 통해서 통신하는 호스트에서 실행되는 애플리케이션 간에 신뢰할 수 있고, 순서가 정해져있으며, 오류를 체크하고 전송할 수 있다.
  월드 와이드 웹, 이메일, 원격 관리, 파일 전송과 같은 주요 인터넷 애플리케이션은 전송 계층의 일부인 TCP에 의존한다.
  SSL/TLS 또한 TCP 위에서 동작한다.
  TCP는 인터넷 프로토콜 (IP)과 작동하여 컴퓨터가 서로 데이터 패킷을 보내는 방법을 정의한다.</description>
    </item>
    
    <item>
      <title>DNS란? (draft)</title>
      <link>/post/2021/04/13/dns%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:15:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/dns%EB%9E%80-draft/</guid>
      <description>DNS(Domain Name System)  내가 활용중인 DNS IP 주소 확인하기   위의 명령어를 통해서, 내가 사용하고 있는 DNS 서버의 IP 주소를 알아낼 수 있다.   위에 명령어를 통해서 나온 주소를 구글에 검색하면, 어떤 DNS 서버를 사용하는지 대략적으로 알 수 있다.  DNS 동작과정 추적하기   위와 같은 과정을 통해서, DNS 서버에 요청하고, 도메인 주소를 통해서 IP 정보를 받아오는 것을 확인할 수 있다.  sudo systemd-resolve --flush-caches  DNS 캐시 정보를 지우고 싶다면 위의 명령어를 입력하면 된다.</description>
    </item>
    
    <item>
      <title>ARP란? (draft)</title>
      <link>/post/2021/04/13/arp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/arp%EB%9E%80-draft/</guid>
      <description>ARP(Address Resolution Protocol)   L2(데이터 링크 계층) 통신 프로토콜이다. IP 네트워크 주소를 데이터 링크 프로토콜에서 사용하는 하드웨어 주소(Mac ADDRESS)에 맵핑하기 위해서 사용하는 프로토콜이다.  arp -n 위의 명령어를 통해서, ARP 테이블을 확인할 수 있다.
ARP 패킷 추적하기   위의 명령어를 통해서, 패킷 추적을 시작한다. 그리고 MAC 주소를 확인하기 위해서 PING 명령어를 자신의 IP 주소로 보내며, 네트워크 패킷이 호출되는 것을 확인한다.   ffff:ffff:ffff는 목적지 주소를 나타내며, 브로드 캐스트의 의미이다.</description>
    </item>
    
    <item>
      <title>ICMP란 (draft)</title>
      <link>/post/2021/04/13/icmp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:52:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/icmp%EB%9E%80-draft/</guid>
      <description>ICMP(Internet Control Message Protocol)    L3(네트워크 계층) 통신 프로토콜로서, 라우터를 포함한 네트워크 장치가 다른 IP 주소와 통신을 할 때 성공 또는 실패를 나타내는 오류 메시지 및 운영정보를 보내는데 사용된다.
  흔히 사용하는 PING 명령어가 ICMP 프로토콜을 사용하고 있다.
  네트워크 패킷 추적하기 sudo apt-get install tshark  위의 명령어를 입력하여 tshark를 설치한다, 네트워크 패킷 분석을 할 수 있는 툴이다.   위의 명령어를 입력해서, ICMP 패킷을 분석을 시작한다.</description>
    </item>
    
    <item>
      <title>MAC 주소란 (draft)</title>
      <link>/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:21:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</guid>
      <description>MAC 주소란?  MAC 주소 알아내는 법   위의 명령어를 이용하면 사용하고 있는 하드웨어의 MAC 주소 및 네트워크 카드 ID, 제조사를 알아낼 수 있다.  참고 문헌  </description>
    </item>
    
    <item>
      <title>라우팅이란 (draft)</title>
      <link>/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:48 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>라우팅이란?   네트워크 패킷이 목적지를 찾아가기 위한, 최적의 경로이다.  요청한 서버까지 라우터를 추적하는 방법   구글 서버까지 굉장히 많은 라우터를 거쳐간다는 것을 확인할 수 있다. 네이버 서버에 요청하였을 때는 보안상의 이유로 라우터가 가려진 것을 확인할 수 있다. 모든 라우터의 주소를 확인할 수 있는 것은 아니다.  참고 문헌  </description>
    </item>
    
    <item>
      <title>웹 클라이언트(브라우저) 부터 웹서버까지의 구조 (draft)</title>
      <link>/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:39 +0900</pubDate>
      
      <guid>/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</guid>
      <description> 브라우저에서 주소를 입력하면 HTTP 통신이 일어나게 되고, DNS 서버에서, 도메인 주소를 IP 주소로 변환하는 요청을 하게 된다. IP 주소를 알아내면, 라우터를 통해서 TCP / IP 통신을 하게 된다. 웹 서버에 도착했을 때는 최종적으로 HTTP 통신이 이루어지게 된다.  참고 문헌   리얼 리눅스  </description>
    </item>
    
    <item>
      <title>클라우드 이벤트 스펙이란?</title>
      <link>/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Mon, 29 Mar 2021 22:55:39 +0900</pubDate>
      
      <guid>/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</guid>
      <description>클라우드 이벤트 스펙이란?    이벤트는 어디에서든지 발생하지만, 이벤트를 생산하는 생산자에 따라서 이벤트를 다르게 정의하는 경향이 있다.
  이벤트를 설명하는 표준이 없기 때문에, 개발자는 이벤트 사용방법을 계속해서 배워야 한다. 또한 SDK, 이벤트 라우터 또는 추적 시스템과 같은 환경에서 이벤트 데이터를 전달하는데 도움이 되는 도구 및 인프라의 잠재력을 제한한다.
  클라우드 이벤트는 서비스, 플랫폼 및 시스템간에 상호 운영성을 제공하기 위해서 이벤트 데이터를 공통 형시으로 설명하기 위한 스펙이다.
    문서를 보면 프로토콜 별로 스펙과 문서를 정의한 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>HTTP란 무엇일까? (draft)</title>
      <link>/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>HTTP    HTTP(Hyper Text Transfer Protocol)의 약자로서, 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.
  HTTP는 요청(REQUEST), 응답(RESPONSE)을 통해서 정보를 주고 받으며, HTTP 메시지 구조는 크게 헤더(HEADER)와 바디(BODY)로 나누어진다.
  CURL 명령어를 통한 요청  요청 헤더 및 응답 헤더
 다음은 curl 명령어를 통해서 구글 서버에 GET 요청을 날려보았다. 요청 헤더 및 응답 헤더를 확인할 수 있다.  응답 바디
 HTML, CSS, JS 파일을 응답한 것을 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>REST 및 베스트 프랙티스</title>
      <link>/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</link>
      <pubDate>Sat, 27 Mar 2021 17:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</guid>
      <description>REST    REST는 웹의 창시자 중의 한 사람인 로이 필딩이 2000년에 발표한 논문에 의해서 처음 소개되었다.
  현대의 아키텍처가 웹의 장점을 잘 활용하지 못하고 있다고 판단했기 때문에 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이바로 Representational Safe Transfer(REST) 이다.
  REST는 근래에 들어 HTTP와 JSON을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 OPEN API는 이 REST 아키텍처를 기반으로 설계 및 구현되고 있다.</description>
    </item>
    
    <item>
      <title>TCP/IP 및 네트워크 계층 및 RFC 791 (draft)</title>
      <link>/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</guid>
      <description>네트워크 통신   네트워크 통신은 관점에 따라 OSI 7 모델과 TCP/IP 모델 두가지로 설명할 수 있다. OSI 7 모델은 1984년에 ISO (국제 표준화 기술)에 의해 표준화되었고, 통신이 이루어지는 과정을 단계별로, 파악할 수 있도록 7 개의 계층인 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구분되어 있으며 네트워크 구현을 연구하고 배우기에 적합한 구조다. 반면에, TCP/IP 모델은 현장에 많이 사용하는 기술 위주로 4계층으로 단순화한 모델로, 실제 사용하는 프로토콜 규약은 이 모델을 따르고 있다.</description>
    </item>
    
    <item>
      <title>최근에 애플리케이션 보안에 관심을 가지게 된 이유</title>
      <link>/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</guid>
      <description>최근에 내가 웹 애플리케이션 보안에 대해서 굉장히 무관심함을 알게 됨과 동시에 데이터베이트 연결이 끊어지는 네트워크 통신과 관련된 장애가 있었다.
장애의 이유를 알지 못하니까 굉장히 답답함과 동시에 문제를 해결할 수 없었다. 따라서 디버깅을 하듯이 네트워크 패킷을 분석해서 원인을 알아 낼 수 있으면 굉장히 좋을 것 같다는 생각을 함과 동시에 내가 주도하면서 진행하는 토이 프로젝트가 보안에 대해서 굉장히 견고한 애플리케이션이 되었으면 하는 마음이 있다. 따라서, 앞으로 웹 애플리케이션 보안에 대해서 공부하고 견고한 시스템을 구축해나갈 생각이다.</description>
    </item>
    
  </channel>
</rss>
