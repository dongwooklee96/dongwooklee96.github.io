<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="개발자 이동욱의 블로그 입니다.">
    <title>메시지 큐를 이용한 비동기처리 및 에러 처리 | 개발자 이동욱</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/theme-override.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="/">개발자 이동욱</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/categories/">categories</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/tags/">tags</a>
      </li>
      

      

    </ul>
  </nav>
</header>

    <meta name="google-site-verification" content="8He6x5Jy_qOvk1-o8TaN16TjmT9bZUA07bfm25WJhT0" />
  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">메시지 큐를 이용한 비동기처리 및 에러 처리</span></h1>
<h2 class="author">이동욱</h2>
<h2 class="date">2021/03/29</h2>
<p class="terms">
  
  
  Categories: <a href="/categories/%EC%95%A0%ED%94%84%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98">애프리케이션</a> 
  
  
  
  Tags: <a href="/tags/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90">메시지 큐</a> 
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <h2 id="메시지-큐를-이용한-비동기-요청-처리">메시지 큐를 이용한 비동기 요청 처리</h2>
<hr>
<p><img src="https://user-images.githubusercontent.com/14002238/112848087-a9295900-90e2-11eb-82ce-b6dd8ec80708.png" alt="engineering linecorp"></p>
<ul>
<li>
<p>요청을 처리하는 방법에는 전통적인 동기식 방식도 있지만, 비동기식 방식도 있는데, 동기 방식이 클라이언트가 요청을 보내면 처리한 다음에 응답이 오는 방식이라면 비동기 방식은 요청을 보낸 후 비즈니스 로직이 처리가 완료되지 않은 상태에서 다음 로직을 진행한다.</p>
</li>
<li>
<p>서버로 전달된 요청은 나중에 처리되며 나중에 클라이언트로 응답이 전달된다. (응답을 전달하지 않을 때도 있다.)</p>
</li>
<li>
<p>동기식 방식과 비동기식 방식의 가장 큰 차이점은 동기식 방식은 응답이 올 때까지 클라이언트가 대기하는 것이고, 비동기식 방식은 요청만 보내놓고 응답이 오는 것과 상관없이 클라이언트 대기 없이 다음 로직을 수행한다.</p>
</li>
<li>
<p>선택적으로 콜백 메시지를 보내는 경우가 있는데, 콜백은 클라이언트에게 비동기로 요청된 작업이 끝났음을 알려주는 호출이다.</p>
</li>
<li>
<p>예를 들어서, 페이스북 사진을 첨부해서 글을 올리면, 브라우저에서는 글이 등록되었다고는 하지만 바로 타임라인에 표시되지 않고 1 ~ 2 초 후에 업데이트 되는 것을 확인할 수 있다.</p>
</li>
<li>
<p>이는 브라우저에서 글쓰기 요청을 받으면 먼저 클라이언트에게 완료되었다는 응답을 보낸 후 서버는 뒷단에서 그림의 크기를 조정하는 등의 추가적인 작업을 한후에 데이터베이스에 저장한 후 타임라인에 반영하기 때문이다. 이러한 처리가 대표적인 비동기 처리의 예이다.</p>
</li>
<li>
<p>주로 시간이 오래 걸리는 대규모 작업에 유리하고, 동영상 인코딩 같은 변환 작업이나 시간이 오래 걸리는 계산 작업, 또는 하나의 메시지를 보냈지만 여러 개의 작업이 필요한 경우 등 여러 시나리오에 폭 넓게 사용할 수 있다.</p>
</li>
<li>
<p>이러한 비동기식 패턴 구현에는 일반적으로 메시지 큐라는 것을 사용한다.</p>
</li>
<li>
<p>이 메시지 큐는 들어온 요청을 쌓아놓는 임시 공간으로, 쌓여있는 요청 메시지는 뒤의 비즈니스에 의해서 처리 된다.</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/14002238/112851308-d3c8e100-90e5-11eb-8524-592565d189ff.jpg" alt="download"></p>
<h2 id="에러-처리">에러 처리</h2>
<hr>
<ul>
<li>
<p>이러한 비동기식 구현에서 가장 중요하게 고려해야 할 사항은 전달된 요청 메시지가 잘 처리되었느냐이다.</p>
</li>
<li>
<p>클라이언트는 단순하게 요청을 보내고, 그에 대한 응답을 받지 않기 때문에, 해당 요청이 제대로 처리되었는지 보장할 방법이 없다.</p>
</li>
<li>
<p>예를 들어서 클라이언트는 요청을 보내고 메시지 큐에 잘 저장된 후에 응답을 받는다. 이 상태에서 클라이언트는 이 메시지가 제대로 처리될 것을 기대하지만, 메시지 큐에서 해당 메시지를 읽어서 처리하는 서버가 메시지를 꺼내서 처리하다가 장애를 일으켜서 정지하였다고 가정해보면 그 메시지는 유실되고 처리되지 않게 된다.</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/14002238/112852203-ab8db200-90e6-11eb-9746-2c7cd11dc9d2.png" alt="download"></p>
<ul>
<li>
<p>따라서 이러한 비동기 구현에서는 에러 처리 부분에 가장 많은 신경을 써야 한다.</p>
</li>
<li>
<p>비즈니스 컴포넌트에서 메시지 처리 중 에러가 났을 때, 해당 메시지를 에러 큐라는 재처리용 큐로 전달한다. 메시지의 에러 처리 정책을 정해서 에러를 어떻게 처리할지를 지정할 수 있는데, 비동기 메시지 처리에서는 다음과 같이 크게 4가지 정책을 사용하고 있다.</p>
</li>
</ul>
<h4 id="1-재처리-retry">1. 재처리 (Retry)</h4>
<ul>
<li>메시지 처리 중 에러가 발생하였을 때, 다시 처리를 시도하도록 하는 방법ㅇ다.</li>
<li>메시지를 처리하는 비즈니스 컴포넌트가 일시적인 장애 (네트워크 문제, 리소스 부족 등) 일 경우에는 효율적으로 사용할 수 있다.</li>
<li>재처리를 할 때는 반드시 최대 재처리 횟수를 지정해야 한다. (통상적으로 3 ~ 5 번 정도를 사용한다).</li>
<li>그리고 재처리를 할 때, 에러 발생 후 바로 재처리를 시도하면 같은 원인으로 같은 에러가 발생할 수 있기 때문에 일정 시간을 기다렸다가 다시 처리하는 것이 좋다.</li>
</ul>
<h4 id="2-무시-ignore">2. 무시 (Ignore)</h4>
<ul>
<li>에러가 난 메시지는 무시하고 메시지를 없애 버리는 방식이다. 중요하지 않는 로그 정보를 저장할 때와 같이 메시지 유실이 허용되는 경우에만 사용한다.</li>
</ul>
<h4 id="3-알림-notify">3. 알림 (Notify)</h4>
<ul>
<li>메시지 처리 중 에러가 발생하였을 때 이메일, <code>SMS</code>등을 이용하여 관리자에게 통보하여 관리자가 직접 에러에 대한 후 처리를 할 수 있도록 하는 방식이다.</li>
</ul>
<h4 id="4-사람이-처리하도록-함-human-interaction">4. 사람이 처리하도록 함 (Human Interaction)</h4>
<ul>
<li>에러가 발생하였을 때, 자동으로 처리하지 않고 관리자가 직접 처리할 수 있는 사용자 인터페이스를 제공한다.</li>
<li>관리자가 에러난 메시지를 확인하고 재처리할지 무시할지 등을 결정하도록 한다.</li>
<li>에러 재처리 부분이 복잡하거나 규모가 큰 경우 이런 메시지에 대한 에러 처리를 별도의 컴포넌트로 구현하기도 하는데, 이를 <code>Error Hospital</code> 이라고 부른다.
처리 중 에러가 난 메시지를 모아서 다양한 에러 처리 정책에 따라서 재처리를 할 수 있는 기능을 갖는다.</li>
</ul>
<h3 id="참고-문헌">참고 문헌</h3>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
      <hr/>
      <a href="mailto:sh95119@gmail.com">Mail</a> | <a href="https://github.com/dongwooklee96">Github</a> | <a href="https://www.linkedin.com/in/michael--lee96/">LinkedIn</a>
      
    </footer>
    <script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//analytics.example.com/tracker.js', 'fathom');
fathom('set', 'siteId', 'ABCDE');
fathom('trackPageview');
</script>

  </body>
</html>

