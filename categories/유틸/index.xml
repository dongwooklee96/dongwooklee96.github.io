<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>유틸 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EC%9C%A0%ED%8B%B8.html</link>
    <description>Recent content in 유틸 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 06 Jun 2021 14:44:39 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EC%9C%A0%ED%8B%B8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>프로그래머처럼 생각하라 정리 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-2.html</link>
      <pubDate>Sun, 06 Jun 2021 14:44:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-2.html</guid>
      <description>&lt;h3 id=&#34;프로그래머는-단순하게-생각한다&#34;&gt;프로그래머는 단순하게 생각한다&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래머는 &lt;strong&gt;항상 목적을 달성하기 위한 최단 경로를 모색한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;쓸모없는 것을 생략하고, 사물을 단순하게 생각한다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 단순하게 생각하기 위해서, 모델을 사용하여 생각한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사물을 단순하게 표현하기 위해서는 복잡한 사물로부터, 본질은 남겨둔 채 쓸모없는 부분을 제거해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델-작성법&#34;&gt;모델 작성법&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;사물을-단순화-한다&#34;&gt;사물을 단순화 한다.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120914101-ca0bbd00-c6d6-11eb-8ace-0bd78c36f759.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가능한 한 불필요한 부분을 제거하고, 사물의 본질을 돋보이도록 해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;피카소의 그림에서 알 수 있듯이 처음부터, 단순화된 황소를 그리려고 한 것이 아니라, 여러 번 스케치를 해봄으로써 황소의 어떤 부분이 본질인지를 찾아내려고 노력하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 만들때도, 이와 같은 현상이 일어난다. &lt;strong&gt;생각하기 위해서 모델을 만들고, 모델을 만듦으로써 더 깊이 있게 생각할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;머리속에서 생각만 하는것만으로는 막다른 길에서 움직이지 못하는 경우가 많다. 이때 생각하고 있는 것을 바깥으로 꺼내서 표현해봄으로써 새로운 아이디어를 얻을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;맨 처음부터 훌륭한 모델을 만들자는 것이 아니라, 우선은 머리속에서 생각하고 있는 것을 머리 바깥으로 끄집어내서 모델 형태로 표현하고, 그 모델을 살펴보면서 다시 생각해보는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델의-기본-구조란&#34;&gt;모델의 기본 구조란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델은 &amp;lsquo;요소와 요소 사이의 관계&amp;rsquo;를 나타낸 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람들은 흔히 &amp;lsquo;이해하려면 분해해보라&amp;rsquo;고 한다. 복잡한 사물을 있는 그대로 이해하는 것이 힘들기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 작성할 때 중요한 점은 &lt;strong&gt;목적과 관점을 명확하게 하는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은 대상으로 하더라도, 목적이 다르면 관점이 달라져서 사물을 바라보는 형식이 서로 다르게 되기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 사물에 관한 모델은 유일 무이하게 단 한 개만 존재하는 것이 아니라, 목적과 관점에 따라서 다양하게 만들어질 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요소를-추출하여-작성한다&#34;&gt;요소를 추출하여 작성한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;복잡한 사물은 여러 개의 요소로 구성되어 있다. &lt;strong&gt;모델링에서 가장 바람직한 방법은 각 요소를 모두 찾아내서 열거하는 작업 부터 시작해보는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발상을 위한 사고법에서는 &amp;lsquo;발산&amp;rsquo;과 &amp;lsquo;수렴&amp;rsquo;의 사고과정을 반복한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델의 상세한 내용을 작성하는 경우, 깊이 있게 숙고 하고, 다시 폭넓게 생각하면서 이번 작업의 목적에 부합하지 않는 요소들을 제거하여 대담하게 수렴시켜 나가는 과정을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 작업의 초기에서는 무엇이든지 머리속에서 생각나는 것을 끄집어내서 표현해보도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;중요한-것을-요소로-만든다&#34;&gt;중요한 것을 요소로 만든다&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그러나 정말로 무엇이든지 생각나는 모든 것을 끄집어내서 표현하면 다 좋다는 의미는 아니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;복잡한 사물을 구성하는 &amp;lsquo;중요한 요소들&amp;rsquo;을 모두 열거해 보는 것&lt;/strong&gt;이 이 단계에서 해야할 작업이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;요소는-명사로-작성한다&#34;&gt;요소는 명사로 작성한다&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델이라는 것은 사물을 단순하게 표현한 것이므로 때에 따라서는 모호함이 표함되어 있어서 그 의미를 전달하기 어려운 경우도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;요소를 명사로 한다&amp;rsquo;라는 점을 주의해서 모델링하면 자신의 의도와 모델의 표현을 서로 일치하게 만들 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;관계를-명확하게-한다&#34;&gt;관계를 명확하게 한다&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요소를 추출하여, 열거한 후에는 각 요소 사이의 관계를 찾아내도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러고 나서 요소를 사각형으로 표현하고 관계를 연결선으로 나타낸다. 이러한 작업만으로 복잡한 사항을 정리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배치를-조정한다&#34;&gt;배치를 조정한다.&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;모델링 작업에서 무엇을 요소로 추출할 것인가 그리고 요소들 사이의 관계를 어떻게 표현할 것인가가 가장 중요하지만, 이와 거의 같은 수준으로 중요한 작업이 바로 모델의 전체 모습(어떻게 알기 쉽게 표현할 것인가의 문제) 즉 배치문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델을-사용하면-얻게-되는-장점&#34;&gt;모델을 사용하면 얻게 되는 장점&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;1. 도식화의 이점을 누릴 수 있다.
2. 전체 모습을 파악할 수 있다.
3. 논리적으로 생각할 수 있다.
4. 발상을 넓힐 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;빈약한-모델에서-발견할-수-있는-네-가지-공통점&#34;&gt;빈약한 모델에서 발견할 수 있는 네 가지 공통점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델을 작성한다는 것은 처음에는 간단한 듯하지만 뜻밖에 깊이가 있는 작업으로 익숙해지지 않으면 좀처럼 좋은 모델을 만들어낼 수 없는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈약한 모델의 공통점은 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 목적과 관점이 정해져있지 않거나, 명확하지 않다.
2. 요소가 망라되어 있지 않거나, 불필요한 요소를 포함하고 있다.
3. 요소의 추상화 수준이 너무 높거나 너무 낮다.
4. 요소들 사이의 관계를 잘 표현하고 있지 못한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;자신의-입장을-확인한다&#34;&gt;자신의 입장을 확인한다.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모델링 대상에 대해서, 자신이 어떤 위치에 있는지를 의식할 수 있다면, 자연스럽게 자신이 그 대상물의 어떤 측면에 초점을 맞춰야할 것인지 (또는 맞추고 싶은지)가 명확해진다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델링은 무엇때문에 하는가? 라는 질문에 대해서 한마디로 대답해보는 것도 목적과 관점을 명확하게 하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목적과 관점은 모델을 만들어가면서 결정해간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음부터 모델을 만드는 목적과 관점이 명확하게 결정된 경우는 그리 많지 않다. 따라서, 목적을 처음부터 명확하게 한마디로 대답할 수 없더라도 괜찮다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 모델을 만들면서 목적과 관점에 대해서 다시 생각해보고 모델을 만들고.. 이러한 과정을 반복하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;필요한-요소들을-부족함-없이-망라하기-위한-기법&#34;&gt;필요한 요소들을 부족함 없이 망라하기 위한 기법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;요소를 일단 삭제해보고, 그래도 모델을 이해할 수 있는지 아닌지를 확인해보는 것이다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;요소가 부족한 경우에는, 모델의 만든 후에 위화감 또는 불안정감이 있는지를 확인하고, 시행착오를 거쳐가면서 모델을 수정해나간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;관계를-적절하게-표현하기-위한-요령&#34;&gt;관계를 적절하게 표현하기 위한 요령&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;관계에 빠진 점이 없는지를 확인한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문장으로 성립되는지를 확인한다. &lt;strong&gt;요소와 요소 사이의 관계가 정말로 성립하는지 논리적으로 생각해봄으로써 관계의 적절성을 확인할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;나무에서 떨어진다&amp;rsquo;와 같은 동사구를 명사화하여 요소로 추출하는 것이 때로는 더 좋은 모델을 만드는데 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://book.interpark.com/product/BookDisplay.do?_method=detail&amp;amp;sc.prdNo=266905788&amp;amp;gclid=Cj0KCQjwweyFBhDvARIsAA67M71SioU7M-0HZlQ00iMvRZJ8237_ixAt3Bos56hRrRlURVnzfdlnweQaAhAEEALw_wcB&#34;&gt;프로그래머처럼 생각하라&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로그래머처럼 생각하라 정리 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-1.html</link>
      <pubDate>Sun, 06 Jun 2021 14:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-1.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120913629-646a0180-c6d3-11eb-89f0-b623930b731f.jpg&#34; alt=&#34;266905788g&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주말에 오래전에 사놓고 읽지 않은 책을 읽고 정리를 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;객체지향 사고를 할 때 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 사물을 깊게 이해하고 싶다.
2. 어떤 사물이나 개념을 상대방이 알기 쉽게 전달하고 싶다.
3. 새롭고 혁신적인 발상을 하고 싶다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 능력을 가지고 싶다면 방법은 하나이다. &amp;lsquo;단순하게 생각하기&amp;rsquo;를 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;단순하게 생각하기&amp;rsquo; 이것이 무엇인지 알기 힘들다면, 답은 프로그래머들의 사고 방식에서 찾아 볼 수 있고 이를 활용하면 위의 세가지 문제를 해결할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프로그래머는-사물을-단순하게-생각한다&#34;&gt;프로그래머는 사물을 단순하게 생각한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래머들은, 보통 번잡하고 귀찮은 것을 싫어 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획성 없이 프로그램을 만들다 보면, 최종 단계에서 무엇인가 맞지 않게 되어서, 결국 쓸데 없는 작업이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 능숙한 프로그래머들은 여러 부품을 만들고, 어떻게 배치할지를 미리 생각하면서 작업한다. 이럴때 사용하는 것이 바로 모델이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 생각을 토대로, 모델의 핵심을 추출하여 일반적으로 사용할 수 있도록 만든 최강 단순 사고법이 바로 &lt;strong&gt;모델 기반 사고법&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델이란-무엇인가&#34;&gt;모델이란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;모델이란 &amp;lsquo;사물을 단순하게 표현한 것&amp;rsquo;이라고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120913795-beb79200-c6d4-11eb-842f-68abd4ce850c.JPG&#34; alt=&#34;IMG_5740&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;지극히 단순하게 사물을 표현하는 방법으로, 사각형(요소)과 연결선(관계)을 사용하여 모델을 표현&lt;/strong&gt; 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 사용하여, 복잡한 사물들을 어느 정도 단순하고, 이해하기 쉽게 표현하고 있음을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델을-사용하여-발상한다&#34;&gt;모델을 사용하여 발상한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;사물을 정리하여 이해하거나 알기 쉽게 전달하기 위한 목적으로만 모델을 사용하는 것은 아니다, 발상하기 위해서도 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://book.interpark.com/product/BookDisplay.do?_method=detail&amp;amp;sc.prdNo=266905788&amp;amp;gclid=Cj0KCQjwweyFBhDvARIsAA67M71SioU7M-0HZlQ00iMvRZJ8237_ixAt3Bos56hRrRlURVnzfdlnweQaAhAEEALw_wcB&#34;&gt;프로그래머처럼 생각하라&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>이력서를 작성할 때의 팁</title>
      <link>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81.html</link>
      <pubDate>Sun, 09 May 2021 18:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81.html</guid>
      <description>&lt;h2 id=&#34;이력서를-작성하게-된-이유&#34;&gt;이력서를 작성하게 된 이유&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;일반적으로 이력서는 이직할 때, 작성하지만 나는 평소에 미리미리 준비하고 싶었다.
이력서를 작성하다 보니, 매우 형편없는 것 같아서 인터넷을 찾아보았는데 아주 좋은 글들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 글을 읽어보고 나서 내 이력서의 문제점이 자세히 보이기 시작했다.&lt;/p&gt;
&lt;p&gt;틈틈히 완성도 있는 이력서를 완성시키고 무엇보다 지금부터 이력서에 내용을 적을 활동을 해야겠다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>마크다운으로 슬라이드 쇼 만드는 방법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft.html</link>
      <pubDate>Wed, 28 Apr 2021 11:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기존에 슬라이드 쇼를 만드는데, 콘텐츠에 집중하기 보다는 부가적인 요소에 집중할 때가 많았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 발표 자료는 사실, 슬라이드 디자인이 크게 영향을 미치지 않는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프레젠테이션을 만들때 드는 비용을 많이 줄여줄 수 있다고 생각을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 웹에서 동작하기 때문에, 커스터 마이징을 할 수 있고 더 실험적인 동작을 할 수 있을 것 같다. (예제 코드를 실행해보기)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래에 비슷한 툴들이 많이 있다. 따라서 이를 통해서 슬라이드를 만들어보면 좋을 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark.show/#/&#34;&gt;MarkShow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4136&#34;&gt;마크다운으로 슬라이드 쇼 만들기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jxnblk/mdx-deck#presenter-mode&#34;&gt;MDX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marpit.marp.app/markdown&#34;&gt;Marpit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이트 타임 및 표준 규격에 대해서 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft.html</link>
      <pubDate>Tue, 27 Apr 2021 18:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ISO_8601&#34;&gt;ISO 8061 - WIKI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2822&#34;&gt;RFC 2822&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>문서화를 코드로 관리하는 법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 15:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114509642-b745b080-9c70-11eb-95f6-f5083a8b8f5e.jpg&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에 프로젝트를 진행할 때는 문서화에 대한 고민이 정말로 많았다. 왜냐하면 요구사항은 나날이 변경되는데, 요구사항에 맞춰서 문서화를 변경하는 일은 손이 많이가고 귀찮은 일이었기 때문이다. 또한 변경사항이 변경할 때마다, 어느 부분을 어떤 이유로 수정하였는지 추적하기도 힘이 들었다.&lt;/p&gt;
&lt;p&gt;따라서 추후에 프로젝트를 다시 시작할 때 무조건 문서화를 코드에 가깝게 두려고 노력을 했다. 또한 깃으로 상태 관리를 할 수 있었으면 좋겠다는 생각을 하기도 하였다. 그러던 중에, &lt;code&gt;plantuml&lt;/code&gt; 이라는 도구를 알게 되었다. 이 도구는 아키텍처를 도식화할 때 사용할 수 있는 툴로써 다양한 다이어그램을 그릴 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://plantuml.com/ko/&#34;&gt;Plantuml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kroki.io/&#34;&gt;Kroki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>성능 엔지니어링 및 절차</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8.html</link>
      <pubDate>Sun, 28 Mar 2021 23:24:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8.html</guid>
      <description>&lt;h2 id=&#34;1성능-엔지니어링이란&#34;&gt;1.성능 엔지니어링이란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;성능 엔지니어링은 시스템의 목표 성능 (응답 시간과 동시 접속자 수)를 정의하고 이를 달성하기 위해서 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좁게 생각하면 코드 상의 병목을 잡고 시스템의 설정을 바꿔서 성능을 높이는 튜닝으로 생각할 수 있지만, 성능 목표의 정의부터 최적의 성능을 위한 디자인 및 구현 같은 개발 초기의 설계 부분과 개발 후의 운영 단계 그리고 모니터링까지 전 과정을 포함한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능-엔지니어링을-해야하는-시기&#34;&gt;성능 엔지니어링을 해야하는 시기&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-분석-단계&#34;&gt;1. 분석 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;초기 요구사항 분석 및 시스템 기획 단계에서 성능에 대한 목표를 정해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표시간 , 시스템을 사용할 사용자 수와 시스템을 사용하는 동시 접속자수가 어떻게 되는지와 같은 성능 목표를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 성능 모델을 만들어서, 시스템에 부하가 어떤 패턴으로 들어오는지를 정의할 필요가 있다. 예를 들어서, 주부를 대상으로 하는 사이트라면 시스템의 부하는 한국 시간으로 아이들이 학교나 유치원에 간 시간에 많이 몰릴 것이라고 추측할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-디자인-단계&#34;&gt;2. 디자인 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 디자인 단계에서는 목표 성능과 용량을 달성할 수 있는 규모로 시스템 설계를 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 관점에서 시스템 디자인은 항상 피크 타임(최대 성능)에 맞춰서 디자인 된다. 전체 시스템이 감당할 수 있는 용량과 응답 시간을 고려해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 성능과 용량은 애플리케이션 디자인뿐만 아니라 기술을 결정하는 데도 많은 도움을 준다. 어떤 미들웨어나 프레임워크를 사용할 것인지에 따라서 성능의 차이가 많이 발생하기 때문에, 디자인 단계부터 성능과 용량을 고려해서 시스템을 설계 해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하드웨어 관점에서는 예전에는 성능 모델을 산정하고, 피크 타임을 기준(최대 성능 요구)으로 시스템을 설계하고 하드웨어를 구매하였으나, 근래에는 클라우드를 이용하여 필요 시에만 하드웨어를 탄력적으로 사용하는 오토 스케일 모델을 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 성능이나 용량에 관련된 제품 선정이나 설계는 돌려 보지 않으면 확신하기 어렵다 따라서 사용할 기술은 선택한 다음에, 간단한 프로토타입을 구현하고 시나리오가 단순한 대규모 성능 및 용량 테스트를 해보는 &lt;code&gt;PoC(Proof of Concept)&lt;/code&gt;같은 작업을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-개발-단계&#34;&gt;3. 개발 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발 단계는 리스크가 높은 부분과, 아키텍처에 관련되는 부분, 난도가 높은 부분, 핵심 기능 등을 개발 초기의 스프린트에서 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 스프린트가 끝나고 릴리즈 돼서 성능 테스트나 가능한 &lt;code&gt;QA&lt;/code&gt;나 스테이징 환경으로 시스템이 이전되면 성능 엔지니어링 역량을 이 단계에서 집중하여 시스템의 아키텍처와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 단계에서 성능 목표의 달성 가능 여부가 판단되어야 아키텍쳐 변경이 가능하고 주요 성능 이슈들을 초반에 발견해야 성능에 대해서 같은 문제가 발생하지 않도록 디자인 가이드나 코딩 가이드를 개발자들에게 배포하여 위험을 줄인다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-최종-테스트-단계&#34;&gt;4. 최종 테스트 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞의 단계에서 성능과 용량을 고려해서 설계했고 개발 초기 단계에서 성능과 용량 부분의 검증을 제대로 하였다면, 최종 테스트 단계에서는 개발된 최종 시스템에 대한 성능, 용량 부분의 측정, 미세 튜닝을 하는 정도로 마무리되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정에서는 실수로 잘못한 설정이나, 코딩의 검증이 이루어진다. 예를 들어서 로그 파일을 &lt;code&gt;NFS&lt;/code&gt;와 같은 리모트 디스크에 쓴다든지, 인텔 계열의 &lt;code&gt;CPU&lt;/code&gt;에서 하이퍼스레딩 &lt;code&gt;ON&lt;/code&gt;을 하지 않았든지 같은 실수가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 오류들이 해결되면 실제 미세 튜닝에 들어가는데, &lt;code&gt;JVM&lt;/code&gt; 튜닝이나 톰캣의 설정 튜닝, &lt;code&gt;SQL&lt;/code&gt; 튜닝 등이 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 미세 튜닝에서 성능이 비약적으로 향상되지는 않는다, 보통 &lt;code&gt;20%&lt;/code&gt; 내외 정도의 성능이 올라간다고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-운영-단계&#34;&gt;5. 운영 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 시에 발견되지 않은 성능 문제가 있을 수 있기 때문에, 모니터링 도구를 사용하여 지속적으로 성능을 모니터링하고 성능 상태에 문제가 있는 부분을 지속적으로 수정해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 및 목표 용량 설정은 매우 중요한 과정이다. 기존 업무 시스템의 사용 패턴을 분석하는 것이 효율적이기 때문에, 운영 시스템의 로그를 수집하고 분석하여 성능 모델을 분석 및 보유해두는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2시스템-용량-산정&#34;&gt;2.시스템 용량 산정&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;response-time-응답-시간&#34;&gt;Response Time (응답 시간)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사용자가 서버에 요청을 한 시간부터 응답을 받을 때까지의 모든 시간을 포함한다. 이 응답 시간은 내부적으로 세분화 하여 분리된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Time(또는 Latency Time) : 서버에 요청을 보내고 받을 때 소요되는 네트워크 시간&lt;/li&gt;
&lt;li&gt;Transaction Time : 서버에서 실제 트랜잭션에 처리되는 시간을 의미한다.&lt;/li&gt;
&lt;li&gt;Think Time : 사용자가 보낸 요청에 대한 응답을 받고, 웹 페이지를 보거나 화면을 보는 시간을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrent-user동시-사용자&#34;&gt;Concurrent User(동시 사용자)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112756483-512a1e00-9020-11eb-9d33-9da5f8dac741.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템을 사용하는 사용자를 말한다. 웹 사이트를 사용하기 위해서 현재 브라우저를 열어놓고 웹 사이트를 보는 것과 같이 현재 시스템을 사용하는 사용자 수를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;active-user액티브-사용자&#34;&gt;Active User(액티브 사용자)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템에 트랜잭션을 실행하여 부하를 주는 사용자를 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;는 클릭을 통해 그 시간에 서버에 트랜잭션을 발생시키는 사용자를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 서버에서 순간 실행되고 있는 스레드 수(스레드 기반의 자바 서버인 경우)나 프로세스의 수와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 실제로 서버가 동시에 처리할 수 있는 트랜잭션의 양을 판단할 수 있는 기준이 되기 때문에, 매우 중요한 성능 요인이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transaction-트랜잭션&#34;&gt;Transaction (트랜잭션)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션이란 사용자로부터 요청을 다루는 단위를 말한다.&lt;/li&gt;
&lt;li&gt;이러한 트랜잭션의 정의는 무엇을 판단 기준으로 할 것인가에 따라 결정되는데, 예를 들어 리소스를 톰캣과 같은 애플리케이션 서버에서 처리하지 않고 앞단의 &lt;code&gt;CDN&lt;/code&gt;이나 웹 서버에서 처리할 때, 톰캣은 리소스에 대한 트랜잭션 요청을 받지 않는다.&lt;/li&gt;
&lt;li&gt;리소스에 대한 로딩은 비즈니스 로직 처리보다 부하가 상대적으로 적고, 일반적으로 브라우저에 캐시 되기 때문에, 보통 서버의 성능 측정 시 이러한 리소스 로딩에 대한 부하는 트랜잭션 단위로 처리하지 않는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tpstransaction-per-second&#34;&gt;TPS(Transaction per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;초당 처리할 수 있는 트랜잭션의 양을 말한다.&lt;/li&gt;
&lt;li&gt;보통 서버의 성능 평가 기준이 된다, &lt;code&gt;Active User&lt;/code&gt;가 순간 트랜잭션을 처리한다고 하면 이는 목표 응답시간 &lt;code&gt;(Response Time)&lt;/code&gt;으로 나눈 값이 목표 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;li&gt;예를 들어서 &lt;code&gt;Active User&lt;/code&gt;가 50 명이고 개당 응답 시간이 2초라고 하면 이 시스템의 &lt;code&gt;TPS&lt;/code&gt;는 25 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hpshit-per-second&#34;&gt;HPS(Hit Per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 처리할 수 있는 모든 웹 요청의 초당 처리량이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TPS&lt;/code&gt;가 비즈니스 트랜잭션에 대한 처리 시간만을 정의한다면 &lt;code&gt;HPS&lt;/code&gt;는 리소스(이미지, 자바 스크립트)에 대한 요청 처리량을 포함하기 때문에 &lt;code&gt;TPS&lt;/code&gt;보다 약 10 ~ 20 배 높게 나온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-테스트와-모니터링&#34;&gt;3. 테스트와 모니터링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;부하 테스트를 할 때, 주요 성능 요인을 모니터링하고 기록해야한다.&lt;/li&gt;
&lt;li&gt;주요 모니터링 해야하는 대상 및 관점은 애플리케이션, 미들웨어, 인프라 관점으로 나눌 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;애플리케이션-관점&#34;&gt;애플리케이션 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적으로 애플리케이션, 즉 시스템의 성능을 측정해야한다. 주요 모니터링 내용은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Response Time&lt;/code&gt; : 요청(&lt;code&gt;Request&lt;/code&gt;)별 응답시간&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TPS(Throughput per second)&lt;/code&gt; 초당 요청(&lt;code&gt;Request&lt;/code&gt;) 처리량&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 요인들이 성능의 궁극적인 최종 목표 값이 되기 때문에, 가장 중요한 성능 요인이 되며 부하 생성 도구를 통해서 쉽게 측정 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;미들웨어-관점&#34;&gt;미들웨어 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;미들웨어는 애플리케이션이 동작하기 위한 기본적인 솔루션이다.&lt;/li&gt;
&lt;li&gt;아파치와 같은 웹 서버나 톰캣과 같은 웹 애플리케이션 서버, &lt;code&gt;RabbitMQ&lt;/code&gt;와 같은 메시지 큐, &lt;code&gt;MySQL&lt;/code&gt;과 같은 데이터베이스가 해당한다.&lt;/li&gt;
&lt;li&gt;각 성능 시나리오 별로 거쳐가는 모든 미들웨어를 모니터링 해야하는데, 이를 위해서는 각 솔루션에 대한 깊은 이해가 필요하다.&lt;/li&gt;
&lt;li&gt;웹 서버는 성능이 문제가 되는 부분은 거의 없다, 성능 문제는 대부분 네트워크 아웃 바운드 (&lt;code&gt;IO&lt;/code&gt;, 대역폭) 쪽에서 발생할 때가 많다.&lt;/li&gt;
&lt;li&gt;웹 서버가 설치된 하드웨어 네트워크 아웃바운드 &lt;code&gt;IO&lt;/code&gt;의 대역폭을 모니터링하는 것이 유용하다.&lt;/li&gt;
&lt;li&gt;대부분의 성능 문제는 실제 애플리케이션 로직이 수행되는 톰캣과 같은 애플리케이션 서버와 데이터베이스 단에서 많이 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;애플리케이션 서버는 스레드의 수오 큐의 길이가 1차 모니터링 대상이 된다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;서버가 용량을 추가하게 되면 유휴 스레드(&lt;code&gt;Idle Thread&lt;/code&gt;) 수가 떨어지게 되고 유휴 스레드가 0이 되면 요청 메시지가 앞단의 큐에 저장된다.&lt;/li&gt;
&lt;li&gt;따라서 이 두개를 모니터링 하면, 시스템이 병목 상태인지 아닌지를 판단할 수 있다.&lt;/li&gt;
&lt;li&gt;이 값들은 &lt;code&gt;JMX(Java Management Extenstion)&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;를 이용하여 모니터링 하면된다.&lt;/li&gt;
&lt;li&gt;DB의 경우에는 슬로우 쿼리를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다.&lt;/li&gt;
&lt;li&gt;슬로우 쿼리를 찾았으면, &lt;code&gt;EXPLAIN&lt;/code&gt; 명령어를 이용하여 쿼리의 수행 내용을 분석한 후에 인덱스 등의 튜닝을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인프라-관점--cpu-메모리-네트워크-io-디스크-io&#34;&gt;인프라 관점 : CPU, 메모리, 네트워크 IO, 디스크 IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하드웨어 인프라 모니터링은 전문적인 인프라 모니터링 도구를 사용하거나 &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;sar&lt;/code&gt;와 같은 기본적인 유닉스 또는 리눅스 명령어를 사용해도 가능하다.&lt;/li&gt;
&lt;li&gt;부하 테스트 중에 &lt;code&gt;top&lt;/code&gt;을 띄워놓고 모니터링 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 &lt;code&gt;CPU&lt;/code&gt;는 대부분 잘 모니터링 한다.&lt;/li&gt;
&lt;li&gt;목표 성능을 달성할 시에는 보통 70 ~ 80 퍼센트를 사용하는 것이 좋고 항상 20 ~ 30 퍼센트의 여유를 두는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;메모리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로, 메모리 부분이다. 피크 타임시에 메모리가 얼마나 사용되느냐가 중요한데, 자바 애플리케이션은 특성상 전체 &lt;code&gt;JVM&lt;/code&gt; 프로세스가 사용할 메모리 양을 미리 정해놓기 때문에, 부하 테스트 중에도 메모리 사용량은 크게 변화지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만, 스와핑 (&lt;code&gt;Swapping Status&lt;/code&gt;)를 자주 놓치게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스, 유닉스 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해서 가상 메모리라는 개념을 사용하고 스와핑 공간이라는 디스크 공간에 자주 사용하지 않는 메모리의 내용을 덤프해 저장해여, 다시 사용할 때 메모리에 로딩하는 방식을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런데 이 메모리의 내용을 디스크에 저장 및 로드 하는 과정 (스와핑)이 실제 디스크 &lt;code&gt;IO&lt;/code&gt;를 발생시키기 때문에 실제 메모리 액세스 성능이 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 시스템에서 스와핑이 발생하면 시스템 성능이 장애 수준으로 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;디스크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디스크 &lt;code&gt;IO&lt;/code&gt;는 파일 시스템에 파일을 저장하는 시나리오나 로그를 저장하는 모듈, 그리고 데이터베이스와 같이 뒷단에서 파일 시스템을 요구하는 모듈에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디스크 IO에 대한 병복은 여러 가지 해결 방법이 있다. 먼저 하드웨어 인프라 자체에서 접근하는 방식은 디스크 자체를 &lt;code&gt;SSD&lt;/code&gt;로 변경하거나, 버퍼가 크거나 &lt;code&gt;RPM&lt;/code&gt;이 높은 디스크로 변경하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RAID&lt;/code&gt; 구성을 스트리핑 방식으로 변경해서,&lt;code&gt;IO&lt;/code&gt;를 여러 디스크로 분산시키는 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 차원에서는 데이터베이스 앞에 &lt;code&gt;Memcached&lt;/code&gt;와 같은 캐싱을 사용하거나, 로깅의 경우에는 중간에 메시지 큐를 써서 로그를 다른 서버에 쓰도록 하여 &lt;code&gt;IO&lt;/code&gt;를 분산시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 백 라이트(&lt;code&gt;Back Write&lt;/code&gt;)같은 방식으로 로그 메시지가 발생할 때마다, 디스크에 쓰는 것이 아니라, 20, 30개씩 한꺼번에 디스크로 플러싱하는 방식을 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조금 더 높은 아키텍처 수준으로는, 디스크 &lt;code&gt;IO&lt;/code&gt;가 많이 발생하는 로직은 동기 처리에서, 메시지 큐를 이용하는 비동기 방식으로 시스템 설계를 변경하는 방법을 고민할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 사진을 올려서 변환하는 서비스는 파일을 업로드 하는 시나리오와 변경하는 모듈을 분리하여, 파일 업로드가 끝나면 사용자에게 동기 방식으로 바로 응답을 줘서 응답 시간을 빠르게 하고, 업로드된 파일은 뒷단에서 비동기 프로세스를 통한 변환 과정을 끝낸 후에 사용자에게 결과를 알려주는 방법을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 &lt;code&gt;IO&lt;/code&gt;는 특히 고용량의 파일이나 이미지 전송에서 병목이 주로 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주로 &lt;code&gt;Reverse Proxy&lt;/code&gt;, &lt;code&gt;NAT(Network Address Translator)&lt;/code&gt;, 라우터, 로드 밸런서 등에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지 지점과 장비에 대해서 모니터링해야하기 때문에, 일반적인 유닉스, 리눅스 명령어를 사용하는 것 보다는 전문적인 툴을 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래프를 보면서 추이를 지켜보는 것이 중요한데, 부하를 넣으면 일정 수준이 되어도 시스템들의 &lt;code&gt;CPU&lt;/code&gt;, 메모리, 디스크 등의 기타 자원들은 넉넉한데 네트워크 입력, 출력 수준이 일정 수준 이상으로 올라가지 않는 경우가 있다. 이러한 경우는 네트워크 병목일 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 소프트웨어 기반의 로드 밸런서 및 소프트웨어 기반의 &lt;code&gt;NAT&lt;/code&gt; 장비에서 많이 발생하는데 이미지와 같은 정적 콘텐츠는 될 수 있으면 &lt;code&gt;CDN&lt;/code&gt;이나 분리된 웹 서버를 이용해서 서비스 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우는 특히나 소프트웨어기반의 &lt;code&gt;NAT&lt;/code&gt; 및 로드밸런서를 사용해서 문제가 생기는 경우가 많은데, &lt;code&gt;NAT&lt;/code&gt;의 경우에는 여러 개의 &lt;code&gt;NAT&lt;/code&gt;을 사용해서 로드를 분산하도록 하고 로드 밸런서의 경우에도 충분히 용량이 큰 로드 밸런서를 사용하거나 두 개 이상의 로드 밸런서를 사용하고 &lt;code&gt;DNS&lt;/code&gt; 라운드 로빈을 사용하는 방법을 고려해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>인코딩과 캐릭터 셋의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Sat, 27 Mar 2021 17:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;p&gt;최근에 인코딩과 캐릭터 셋의 차이를 아는지에 대한 질문을 받았고, 제대로 답변하지 못한 기억이 난다. 따라서 이 두개의 차이점 및 추가적인 궁금증에 대해서 조사를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112772028-8c9d0a80-9069-11eb-85a4-adb185619b6b.png&#34; alt=&#34;Screen Shot 2021-03-29 at 8 33 54 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;유니코드와-utf-8-utf-16은-무엇이-다른가&#34;&gt;유니코드와 &lt;code&gt;UTF-8&lt;/code&gt;, &lt;code&gt;UTF-16&lt;/code&gt;은 무엇이 다른가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;유니코드는 문자 집합으로, 문자 집합만 의미하며, 실제로 저장되는 방식(바이트로 맵핑)에 대해서는 아무런 설명을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16 은 문자열 또는 바이트 배열에서 바이트로 문자를 맵핑하는 방법을 정의하는 인코딩이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16, UTF-32는 기본적으로 일부 문자를 인코딩하는데, 사용되는 바이트의 양이 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8은 ASCII에 정의된 문자에 대해서 1바이트를 사용하고, 다른 문자에 대해서는 2~4 사이의 바이트를 사용합니다. UTF-32는 각 문자에 대해서 4바이트를 지속적으로 사용하므로 문자열의 문자에 대한 반복은 사소한 것이지만 공통 문자열의 경우에는 더 많은 공간을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;캐릭터-셋과-인코딩의-차이점&#34;&gt;캐릭터 셋과 인코딩의 차이점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;캐릭터 셋은 단순히 특정 인코딩으로 나타낼 수 있는, 문자의 집합을 의미한다.&lt;/li&gt;
&lt;li&gt;예를 들면, &amp;lsquo;☯&amp;rsquo; 같은 문자는 유니코드 문자 집합과 다른 문자 집합에도 사용할 수 있다. 하지만 이 문자에 대한 인코딩을 서로 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Unicode character: ☯
UTF-8 encoded: 0xE2 0x98 0xAF
UTF-16 encoded: 0x26 0x2F
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kore-nordmann.de/blog/php_charset_encoding_FAQ.html#what-is-the-difference-between-a-charset-and-an-encoding&#34;&gt;what is the difference between a charset and an encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>테크니컬 라이팅 4대 원칙이라는 글을 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</link>
      <pubDate>Thu, 04 Mar 2021 18:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</guid>
      <description>&lt;h3 id=&#34;테스트-코드-및-메서드-주석에-대한-고민&#34;&gt;테스트 코드 및 메서드 주석에 대한 고민&lt;/h3&gt;
&lt;p&gt;코드를 작성하면서 테스트 코드에 어떤 테스트라는 것을 어떻게 명확하게 표현할까, 그리고 모듈 및 클래스, 메서드 주석을 달면서 어떻게 작성해야 좋은 문서가 될까? 라는 고민을 하고 작성하였지만 여전히 어렵기만 했다. 그런던 중에서 카카오 기술 블로그에서 도움이 될 만한 글을 발견하였다.&lt;/p&gt;
&lt;h4 id=&#34;테크닐컬-라이팅의-4대-원칙&#34;&gt;테크닐컬 라이팅의 4대 원칙&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109958056-21da0700-7d29-11eb-8f4f-779e11801b92.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;명확성&#34;&gt;명확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;테크니컬 라이팅의 첫 번째 원칙은 명확성이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;명확성이란 핵심어나 핵심 문장이 모호하게 사용되지 않고, 대상 독자가 기술 문서를 읽을 때, 내용의 모호함이나 혼란 없이 한번에 이해하도록 하는 글이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 문서를 읽을 때, 독자 입장에서 이해가 가지 않아 특정 부분을 몇 번이고 다시 읽게 된다면, 이는 명확성이 떨어지는 글이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성이 떨어지는 이유는 대부분의 경우 대상 독자를 제대로 파악하지 못해서 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자라면 모두 아는 내용인데 적어야할까?&amp;rdquo; 라는 의문이 생기더라도 모두 적어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자들이라면 다 안다&amp;quot;라는 생각은 굉장히 주관적일 수 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대학생들이나 외부의 초급 개발자들도 쉽게 따라 할 수 있을 정도의 상세한 문서여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959088-6023f600-7d2a-11eb-9a7f-cfb1012115e6.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 44 05 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;간결성&#34;&gt;간결성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간결성이란 특정 독자가 기술적인 내용을 신속하고 정확하게 이해할 수 있도록 미사여구나 감탄사 등을 사용하지 않고, 쉬운 단어와 간결한 문장을 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문장을 길고 복잡하게 복문으로 써야 더 있어보이고, 더 많은 정보를 담게 될 것이라는 생각은 금물이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기술 문서에서는 &amp;ldquo;~는 ~입니다.&amp;rdquo; 라는 형식의 단문을 사용할 때 더욱 명확하고 가독성이 높은 글을 작성할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959559-040da180-7d2b-11eb-8d7a-a0ad03e6e701.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959668-2a334180-7d2b-11eb-924d-1945a49faf98.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 49 40 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;정확성&#34;&gt;정확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;독자가 필요로 하는 정보를 기술적 오류 없이 정확하게 제공하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성과, 간결성이 떨어지지만 정확성이 확보된 기술문서라면, 독자들은 시간이 많이 걸린다고 해도 해당 문서를 이해할 수 있지만 반대의 경우에는 잘못된 정보를 전달하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959933-7da58f80-7d2b-11eb-9144-7ca86c041707.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 51 58 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;일관성&#34;&gt;일관성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서에 용어, 표현, 그리고 어조 등을 일관성 있게 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 한번 언급된 단어를 다른 방식으로 언급하는 것은 독자에게 큰 혼란을 줄 수 있고, 결과적으로 문서의 신뢰도와 가독성이 저하된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;정리&#34;&gt;정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;짧게 써라&amp;quot;라고 시작하는 문장은 테크니컬 라이팅 대 원칙중 &amp;ldquo;간결성&amp;quot;을 &amp;ldquo;명료하게 써라&amp;quot;는 &amp;ldquo;명확성에 해당한다&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;그림처럼 써라&amp;quot;라는 문장은 독자가 어떤 시스템이나 기능의 아키텍처를 보다 쉽게 이해할 수 있도록 논리적으로 기술하거나 개발 시나리오나 개발 흐름 등의 시각 자료를 활용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakaoenterprise.com/102&#34;&gt;테크니컬 라이팅 4대 원칙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>테스트 코드를 작성하는 순서</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html</guid>
      <description>&lt;h3 id=&#34;테스트-코드를-작성하는-순서&#34;&gt;테스트 코드를 작성하는 순서&lt;/h3&gt;
&lt;p&gt;테스트 코드를 작성하는 것도 무작성 작성하는 것보다는 순서를 지켜가면서 작성하는 것이 훨씬 좋다.&lt;/p&gt;
&lt;h4 id=&#34;테스트는-다음과-같은-순서를-따르면서-작성-해야한다&#34;&gt;테스트는 다음과 같은 순서를 따르면서 작성 해야한다.&lt;/h4&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;쉬운 경우에서, 어려운 경우로 진행&lt;/li&gt;
&lt;li&gt;예외적인 경우에서, 정상적인 경우로 진행&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;한번에 완벽한 코드를 만들면 좋겠지만, 모두가 슈퍼 개발자인 것은 아니다. 보통의 개발자는 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고
나중에 버그를 잡기 위해 많은 시간을 허비하게 된다. 당연히 테스트 통과 시간도 길어진다.&lt;br&gt;
그 뿐만 아니라, 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름도 자주 끊기게 된다.&lt;br&gt;
중간에 화장실도 다녀오고 커피도 마시게 된다. 자리에 돌아오면 이전까지 했던 흐름을 이어가 기 위한 시간도 필요하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;따라서 테스트를 코드를 작성할 때, 순서에 유의해서 작성 해야 한다 가장 구현하기 쉬운 경우부터 시작하고, 보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다. 그래야만 점진적으로 구현을 완성해갈 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한번에 구현하는 시간이 짧아지면 디버깅 할 때에 유리하다.&lt;/li&gt;
&lt;li&gt;작성한 코드가 많지 않고 작성 시간도 짧으면 머리속에 코드에 대한 내용이 생생하게 남아있기 때문에, 디버깅할 때 문제의 원인을 쉽게 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 문장을 읽고 나서 &amp;ldquo;내가 지금 작성하고 있는 코드를 어떻게 하면 가장 빨리 실행할 수 있을까&amp;rdquo; 라는 생각이 들었고
가장 빠르게 실행 시킬 수 있는 방법은 테스트 코드를 작성하는 것이라는 결론을 내릴 수 있었다.&lt;/p&gt;
&lt;h4 id=&#34;예외-상황을-먼저-테스트해야-하는-이유&#34;&gt;예외 상황을 먼저 테스트해야 하는 이유&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;다양한 예외 상황은 복잡한 &lt;code&gt;if-else&lt;/code&gt; 블록을 동반하기 때문에 예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면, 코드의 구조를 뒤집거나 코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다.&lt;/li&gt;
&lt;li&gt;TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;완급-조절&#34;&gt;완급 조절&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;처음에 테스트 코드를 작성할 때, 어려운 것 중 하나는 한 번에 얼마만큼의 코드를 작성할 것인가이다.&lt;/li&gt;
&lt;li&gt;다음의 순서를 시키면서 TDD를 진행하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;값 비교를 이용해서 정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;다양한 테스트를 추가하면서 구현을 일반화 시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;뻔한 구현이라도 위 단계를 거쳐서 연습하는 것과 바로 구현하는 것과는 차이가 있다.&lt;/li&gt;
&lt;li&gt;테스트를 만들고 통과시키는 과정에서 구현이 막힐 때가 있다. 이럴 때 위 단계를 이용해서 TDD를 연습한 개발자는 조금씩 기능을 구현해 나갈 수 있는 반면에 그렇지 못한 개발자는 구현에 실패하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;지속적인-리팩토링&#34;&gt;지속적인 리팩토링&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트를 통과한 후에는 리펙토링을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 중복은 대표적인 리팩토링 대상이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드가 길어지면 메서드 추출과 같은 기법을 사용해서, 메서드 이름으로 코드의 의미를 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDD를 진행하는 과정에서 지속적으로 리펙토링을 진행하면 코드 가독성이 높아진다. 코드 가독성이 높아지면 개발자는 빠르게 코드를 분석할 수 있어 변경할 코드를 빠르게 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 변경의 어려움을 줄여주어 향후 유지보수에 도움이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  테스트 대상 코드에서 상수를 변수로 바꾸거나 변수 이름을 추출하는 것과 같은 작은 
  리펙토링은 발견하면 바로 실시하는데 반해서 메서드 추출과 같이 메서드의 구조에
  영향을 주는 리펙토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 후에 진행한다.
    
  구현 초기에는 아직 구현의 전반적인 흐름을 모르기 때문에, 메서드 추출과 같은 
  리펙토링을 진행하면 코드 구조를 잘못 잡을 가능성이 있기 때문이다. 코드 구조를 잘못 잡으면
  테스트를 통과 시키는 과정에서 코드가 복잡해지거나 구현을 더는 진행하지 못하고 막힐 수 있다.
  이런 상황이 오면 구현을 멈추고 메서드 추출 리팩토링을 되돌려야 한다. 
  리팩토링을  취소해서 코드를 원상 복구한 뒤에 다음 테스트를 진행하고
   코드의 의미나 구조가 더 명확해지면 그때 다시 리펙토링을 실시한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=233614629&#34;&gt;테스트 주도 개발 시작하기, (최범균, 가메출판사)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
