<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>데이터베이스 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4.html</link>
    <description>Recent content in 데이터베이스 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 23 Mar 2022 23:32:24 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>데이터베이스 락킹과 래치의 차이점</title>
      <link>https://dongwooklee96.github.io/post/2022/03/23/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BD%ED%82%B9%EA%B3%BC-%EB%9E%98%EC%B9%98%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90.html</link>
      <pubDate>Wed, 23 Mar 2022 23:32:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/03/23/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BD%ED%82%B9%EA%B3%BC-%EB%9E%98%EC%B9%98%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rv4u4kvromaeqcf/Screen%20Shot%202022-03-23%20at%208.54.00.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2PL (Two Phase Locking)을 이용하여 B+TREE 인덱스에 접근하는 것은 최악이라는 것을 알게 되었는데, 그 이유는 인덱스에 접근할 때마다 트리의 루트 노드에 접근할기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 인덱스에서는 락킹을 사용하지 않고 래칭을 사용한다는 것을 알게 되었다. 락킹과 래칭의 차이점에 대해서 알고 싶어서 조사를 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.dropbox.com/s/jgy37vuz3317u59/Screen%20Shot%202022-03-23%20at%208.56.49.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 참고 문헌에 나와있는 서베이에 있는 내용이다. 자세히 알고 싶으면 아래 링크를 참조해서 직접 문서를 읽는 편이 도움이 될 것 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 내용을 참고한 결과 락킹은 데이터베이스 애플리케이션 내에서 트랜잭션 단위로 데이터 정합성을 보장하기 위해서 하는 것이고, 래치는 시스템 상에서 여러 스레드가 동시에 자원에 접근할 수 없도록 보장하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;락은 내부적으로 대기 큐 및 그래프를 가지고 있어 데드락을 감지 및 해결할 수 있고(대기 큐 분석 및 타임 아웃), 락 매니저에 의해서 관리된다. 그리고 다양한 락 모드가 있다. (공유 락, 배타 락, 업데이트 락, 인텐드 락&amp;hellip;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;래치는 시스템 상에서 임계 영역에 여러 스레드가 접근하지 못하도록 보장하는 것이다. 락이 데이터베이스 콘텐츠(테이블 데이터, 인덱스, 스키마&amp;hellip;)를 보호하는 것에 비해서 래치는 인메모리에 있는 자료 구조를 보호한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나중에 시간이 있을 때 아래 서베이를 자세히 공부하는 것도 좋을 것 같다. 락킹과 래치에 대해서 많은 공부를 할 수 있을 것 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/3111403/what-is-the-difference-between-a-lock-and-a-latch-in-the-context-of-concurrent-a&#34;&gt;What is the difference between a lock and a latch in the context of concurrent access to a database?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://15721.courses.cs.cmu.edu/spring2016/papers/a16-graefe.pdf&#34;&gt;A Survey of B-Tree Locking Techniques by Goetz Graefe&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로그램을 동적 프로파일링 하자</title>
      <link>https://dongwooklee96.github.io/post/2022/02/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81-%ED%95%98%EC%9E%90.html</link>
      <pubDate>Fri, 25 Feb 2022 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/02/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81-%ED%95%98%EC%9E%90.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 MySQL을 동적으로 프로파일링 하면서, 내부 동작이 어떻게 동작하는지 확인할 수 있는 영상을 시청하였다. &lt;code&gt;ftrace&lt;/code&gt; 부터 시작해서 &lt;code&gt;bpf&lt;/code&gt; 와 같은 툴을 사용하는 것을 확인하고 직접 실습해보았는데 매우 재미 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러던 와중에 &lt;code&gt;strace&lt;/code&gt; 라는 툴을 알게 되었고, 이는 실시간으로 리눅스의 시스템 콜 호출을 확인할 수 있는 툴이였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 밖에 프로파일링 접근 방법에 대한 좋은 글들이 있어서 이번 주말에 읽어보면서 실습을 하면 많은 도움이 될 것 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=sEXgwjrIALQ&#34;&gt;MinervaDB Athena 2020 - Valerii Kravchuk - Dynamic Tracing for Finding and Solving MySQL Performance Problems on Linux&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://franckpachot.medium.com/strace-k-build-with-libunwind-f949d4802322&#34;&gt;strace -k (built with libunwind)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://erthalion.info/2019/12/06/postgresql-stay-curious/#3-vdso&#34;&gt;PostgreSQL at low level: stay curious!&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>POSTGRES 익스텐션 만들기</title>
      <link>https://dongwooklee96.github.io/post/2022/02/20/postgres-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</link>
      <pubDate>Sun, 20 Feb 2022 08:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/02/20/postgres-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;다음 &lt;a href=&#34;http://big-elephants.com/2015-10/writing-postgres-extensions-part-i/&#34;&gt;블로그 포스팅&lt;/a&gt;을 참고하여 &lt;code&gt;POSTGRES&lt;/code&gt; 익스텐션을 만드는 과정을 실습해볼 것이다, 우선 소스코드를 다운로드 받고 디렉터리를 확인해보면 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/6j86bo22nq4ohye/Screen%20Shot%202022-02-20%20at%2014.45.38.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여기서 &lt;code&gt;contrib&lt;/code&gt; 라고 하는 디렉터리가 바로, 익스텐션이 저장되어 있는 디렉터리이다. 소스코드에 포함된 많은 익스텐션을 확인 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 우리는 &lt;code&gt;base36&lt;/code&gt; 인코딩을 하는 익스텐션을 만들어볼 예정이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;설정-파일-생성&#34;&gt;설정 파일 생성&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;우선 익스텐션을 만들려면 총 3가지의 파일이 필요하다. 첫번째는 익스텐션에 대한 정보를 나타내는 &lt;code&gt;*.control&lt;/code&gt; 파일이다. 두 번째는 해당 익스텐션의 소스코드인 &lt;code&gt;*.sql&lt;/code&gt; 이다. 세 번째는 어떻게 빌드할지에 대한 &lt;code&gt;Makefile&lt;/code&gt;이다. 첫번째로 &lt;code&gt;base36.control&lt;/code&gt; 파일부터 작성해보겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# base36 extension
comment = &#39;base36 datatype&#39;
default_version = &#39;0.0.1&#39;
relocatable = true
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;base36 익스텐션에 대한 메타정보이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use &amp;quot;CREATE EXTENSION base36&amp;quot; to load this file. \quit
CREATE FUNCTION base36_encode(digits int)
RETURNS text
LANGUAGE plpgsql IMMUTABLE STRICT
  AS $$
    DECLARE
      chars char[];
      ret varchar;
      val int;
    BEGIN
      chars := ARRAY[
                &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,
                &#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;, &#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;
              ];

      val := digits;
      ret := &#39;&#39;;

    WHILE val != 0 LOOP
      ret := chars[(val % 36)+1] || ret;
      val := val / 36;
    END LOOP;

    RETURN(ret);
    END;
  $$;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PL/pgsql&lt;/code&gt;로 작성된 익스텐션이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;EXTENSION = base36        # the extensions name
DATA = base36--0.0.1.sql  # script files to install

# postgres build stuff
ifdef USE_PGXS
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
else
subdir = contrib/base36
top_builddir = ../..
include $(top_builddir)/src/Makefile.global
include $(top_srcdir)/contrib/contrib-global.mk
endif
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;마지막으로 &lt;code&gt;Makefile&lt;/code&gt; 이다. 빌드를 어떻게 할지를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/jw81zofvmgro81c/Screen%20Shot%202022-02-20%20at%2015.06.03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그리고 나서 &lt;code&gt;sudo make install&lt;/code&gt;을 해당 디렉터리에서 입력하면, 설치가 완료된다. 설치가 된다는 것은 사실 &lt;code&gt;postgres&lt;/code&gt;가 설치된 파일의 &lt;code&gt;extension&lt;/code&gt; 디렉터리로 &lt;code&gt;*.source, *.sql&lt;/code&gt; 파일이 이동하는 것이기는 하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8wgb037vzwivf49/Screen%20Shot%202022-02-20%20at%2015.08.07.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/usqc9fjgagantmp/Screen%20Shot%202022-02-20%20at%2015.13.55.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트에 접속해서 &lt;code&gt;CREATE EXTENSION base36;&lt;/code&gt; 을 실행하면 익스텐션이 생성되었다고 나오며, &lt;code&gt;SELECT base36_encode(123456789);&lt;/code&gt; 다음 쿼리문을 실행하면 성공적으로 인코딩이 이루어지는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;테스트-작성&#34;&gt;테스트 작성&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/lbl8cwrhuv5i04x/Screen%20Shot%202022-02-20%20at%2015.30.16.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sql&lt;/code&gt; 디렉터리를 만든 후에, &lt;code&gt;base36_test.sql&lt;/code&gt; 파일에 익스텐션에서 만든 함수를 사용하는 쿼리를 적는다. 그리고 Makefile 파일로 이동해서, REGRESS 항목에 아까 폴더에 만든 테스트 파일을 입력하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서, &lt;code&gt;sudo make install &amp;amp;&amp;amp; sudo make installcheck&lt;/code&gt; 를 입력하면 자동으로 &lt;code&gt;result&lt;/code&gt; 디렉터리가 만들어지고, 쿼리의 실행결과가 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 실행 결과를 &lt;code&gt;expected&lt;/code&gt; 디렉터리에 만들고 나서, 다시 테스트를 실행하면 예상 결과에 맞다면 테스트가 통과하게 되고 예상 결과와 다르다면 테스트가 실패했다는 사실을 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능-높히기&#34;&gt;성능 높히기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ge3r4n7myft6dmr/Screen%20Shot%202022-02-20%20at%2015.36.49.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;익스텐션을 반복해서 많이 사용하면 성능이 좋지 못하다는 것을 확인할 수 있다. 따라서 이를 &lt;code&gt;C&lt;/code&gt; 로 다시 작성해서 성능을 끌어올려볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;quot;postgres.h&amp;quot;
#include &amp;quot;fmgr.h&amp;quot;
#include &amp;quot;utils/builtins.h&amp;quot;

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(base36_encode);
Datum
base36_encode(PG_FUNCTION_ARGS)
{
    int32 arg = PG_GETARG_INT32(0);
    char base36[36] = &amp;quot;0123456789abcdefghijklmnopqrstuvwxyz&amp;quot;;

    /* max 6 char + &#39;\0&#39; */
    char *buffer = palloc(7 * sizeof(char));
    unsigned int offset = (7 * sizeof(char));
    buffer[--offset] = &#39;\0&#39;;

    do {
        buffer[--offset] = base36[arg % 36];
    } while (arg /= 36);


    PG_RETURN_TEXT_P(cstring_to_text(&amp;amp;buffer[offset]));
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;base36.c&lt;/code&gt; 파일을 생성하고 나서, 위의 코드를 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use &amp;quot;CREATE EXTENSION base36&amp;quot; to load this file. \quit
CREATE FUNCTION base36_encode(integer) RETURN text
AS &#39;$libdir/base36&#39;
LANGUAGE C IMMUTABLE STRICT;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*.sql&lt;/code&gt; 파일에 내용을 다음과 같이 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;EXTENSION = base36        # the extensions name
DATA = base36--0.0.1.sql  # script files to install
REGRESS = base36_test # our test script file (without extension)
MODULE = base36

# postgres build stuff
ifdef USE_PGXS
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
else
subdir = contrib/base36
top_builddir = ../..
include $(top_builddir)/src/Makefile.global
include $(top_srcdir)/contrib/contrib-global.mk
endif
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;그리고 나서, &lt;code&gt;MakeFile&lt;/code&gt; 에 &lt;code&gt;MODULE&lt;/code&gt; 필드에 &lt;code&gt;base36&lt;/code&gt;을 입력해주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://big-elephants.com/2015-10/writing-postgres-extensions-part-i/&#34;&gt;Writing Postgres Extensions - the Basics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>마리아 DB 락 조회 및 해제</title>
      <link>https://dongwooklee96.github.io/post/2022/01/27/%EB%A7%88%EB%A6%AC%EC%95%84-db-%EB%9D%BD-%EC%A1%B0%ED%9A%8C-%EB%B0%8F-%ED%95%B4%EC%A0%9C.html</link>
      <pubDate>Thu, 27 Jan 2022 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/01/27/%EB%A7%88%EB%A6%AC%EC%95%84-db-%EB%9D%BD-%EC%A1%B0%ED%9A%8C-%EB%B0%8F-%ED%95%B4%EC%A0%9C.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 생각없이 UPDATE 문에 조건을 걸지 않고 쿼리를 실행시켰다가 모든 데이터가 변경된 적이 있었다. 물론 테스트 데이터였기 때문에 큰 문제는 없었지만 만약 실 데이터라면 생각만 해도 아찔했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 다음부터는 이러한 실수를 하지 않도록 쿼리를 실행하기 전에 무조건 &lt;code&gt;START TRANSTAION&lt;/code&gt; 을 이용하여 데이터를 수정하고 실수를 했을 떄 롤백을 할 수 있도록 하려고 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;START TRANSACTION; // 트랜잭션 시작

UPDATE 쿼리;

COMMIT or ROLLBACK; // 커밋 또는 롤백을 하여 데이터를 반영하거나 롤백할 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 쿼리를 실행하고 나서, 문제가 없는 것을 확인하였다 그리고 웹 사이트로 가서 특정 로우에 대해서 수정을 하는데 락이 걸려서 실행이 되지 않는 것이다. 이유는 트랜잭션이 종료되지 않아서 인 것 같았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 위와 같은 문제를 재현하려고하였지만, 재현할 수는 없었다. &lt;code&gt;START TRANSATION&lt;/code&gt; 을 한 후에, 커밋 또는 롤백을 하면 자동으로 트랜잭션이 종료되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;트랜잭션-조회&#34;&gt;트랜잭션 조회&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;아무튼 락을 걸고 있는 프로세스를 종료 시켜줘야했다. 따라서 인터넷을 검색해보았을 때 아래와 같은 쿼리를 이용해서 조회를 하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/sjtf2rrwdci141z/Screen%20Shot%202022-01-27%20at%209.33.08.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 화면은 &lt;code&gt;SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX&lt;/code&gt; 쿼리를 사용하였을 때의 조회되는 창인데, 현재 &lt;code&gt;INNODB&lt;/code&gt; 의 트랜잭션 상태 (실행중인지, 잠금 대기 중인지 여부), 트랜잭션이 시작된 시간과 같은 현재 내부에서 실행중인 모든 트랜잭션에 대한 정보를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;trx_mysql_thread_id&lt;/code&gt; 부분이 프로세스 ID 부분이라서 아래 쿼리 문을 통해서 트랜잭션을 종료 시켜주면 중지되지 않은 트랜잭션을 종료시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;KILL 982;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=abc2185&amp;amp;logNo=220756357378&#34;&gt;MySQL Lock 걸린 세션 추적&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.popit.kr/mysql-lock-%EC%83%81%ED%99%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/&#34;&gt;MySQL Lock 상황 문제 해결&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>마리아 DB 이벤트 등록하는 법</title>
      <link>https://dongwooklee96.github.io/post/2022/01/19/%EB%A7%88%EB%A6%AC%EC%95%84-db-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EB%8A%94-%EB%B2%95.html</link>
      <pubDate>Wed, 19 Jan 2022 13:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/01/19/%EB%A7%88%EB%A6%AC%EC%95%84-db-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EB%8A%94-%EB%B2%95.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데브 옵스에서 메일 서버가 ECS에서 제대로 돌지 않아 장기간 테스트를 해보고 싶다고 해서 1시간 마다, 메일 전송 요청을 하는 코드를 요청했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음에 스크립트로 작성할까 하다가, DBMS에도 이러한 비슷한 기능을 찾아보니까 이벤트라는 것이 존재하였다. 귀찮게, 스크립트를 작성하는 것 보다 이벤트를 이용하는 것이 편할 것 같아서 작성해본다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 이벤트 설정 ON
SET GLOBAL EVENT_SCHEDULER = ON;

# 이벤트 설정 ON 확인
SHOW VARIABLES WHERE VARIABLE_NAME = &#39;EVENT_SCHEDULER&#39;;

# 이벤트 생성
CREATE EVENT IF NOT EXISTS LOOP_INSERT_SCH_EMAIL
ON SCHEDULE  EVERY 1 HOUR STARTS NOW()
DO
&amp;lt;원하는 SQL 문을 여기다가 작성하면 된다.&amp;gt;

# 생성된 이벤트 조회
SHOW EVENTS;

# 마지막으로 실행된 이벤트 조회
SELECT LAST_EXECUTED FROM INFORMATION_SCHEMA.EVENTS WHERE EVENT_NAME = &#39;LOOP_INSERT_SCH_EMAIL&#39;;

# 이벤트 삭제
DROP EVENT LOOP_INSERT_SCH_EMAIL
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위는 현재시간 부터 한 시간 마다, 특정 쿼리가 동작하도록 작성된 이벤트이다. 시간은 유동적으로 넣어주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/create-event/&#34;&gt;MARIADB - DOCS (CREATE EVENT)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://plein-de-verite.tistory.com/217&#34;&gt;[MariaDB] EVENT 스케줄러 사용하여 쿼리 자동 반복 실행하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 소팅과 해싱에 대해서 정리</title>
      <link>https://dongwooklee96.github.io/post/2022/01/05/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%86%8C%ED%8C%85%EA%B3%BC-%ED%95%B4%EC%8B%B1%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A0%95%EB%A6%AC.html</link>
      <pubDate>Wed, 05 Jan 2022 19:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2022/01/05/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%86%8C%ED%8C%85%EA%B3%BC-%ED%95%B4%EC%8B%B1%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A0%95%EB%A6%AC.html</guid>
      <description>&lt;h3 id=&#34;데이터베이스에서-정렬이-중요한-이유&#34;&gt;데이터베이스에서 정렬이 중요한 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(DISTINCT, GROUP BY, ORDER BY, UNION)와 같은 많은 SQL 에서 정렬을 사용한다. 또한 조인을 할 때도 소트 머지 조인 같은 방법으로 조인을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 100GB의 데이터를 1GB의 램으로 정렬을 하려고 하면 어떻게 해야하는가? 버추얼 메모리를 사용하면 안되는가?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버추얼 메모리를 사용하면 실제 물리적인 양보다 더 많거나 심지어는 메모리 용량에 제한 받지 않는 것 처럼 사용할 수 있다. 또한 버추얼 메모리는 메모리 주소에 대한 참조를 디스크 입출력으로 변환하고 정렬을 시도할 떄 끔찍한 성능을 보여줄 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메인-메모리를-사용하지-않는-정렬-방법&#34;&gt;메인 메모리를 사용하지 않는 정렬 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;스트리밍 방식으로 데이터를 메인 메모리로 전송하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;데이터를 나누고 (메인 메모리 크기로) 그리고 나서 정복하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트리밍-방식&#34;&gt;스트리밍 방식&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;싱글 버퍼링&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/sxuj6m8huk3k6cq/Screen%20Shot%202022-01-05%20at%2018.46.57.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터가 인풋 버퍼에서 아웃풋 버퍼로 이동하고 중간에 데이터를 변환하는 함수가 있는 형태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;더블 버퍼링&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/bb1f75kfux9w623/Screen%20Shot%202022-01-05%20at%2018.54.18.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;계산하는 부분과 I/O를 처리하는 부분을 두 개의 스레드에서 처리하는 것이다. I/O 작업은 블록킹 되므로 백그라운드에서 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더블 버퍼링 방식은 정렬 뿐만 아니라, 스트리밍에서 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정렬과-해싱&#34;&gt;정렬과 해싱&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ckb4obngpes8yd9/Screen%20Shot%202022-01-05%20at%2019.11.30.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정렬 : 정렬 키 값을 기준으로 정렬된 파일을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해싱 : 동일한 해시 값을 가진 2개의 레코드가 다른 해시 값을 가진 레코드로 분리되지 않도록 파일을 정렬함. 일치하는 레코드는 항상 연속적으로 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정렬-2---way&#34;&gt;정렬 2 - WAY&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/5rw81otbgj8kjcm/Screen%20Shot%202022-01-05%20at%2019.21.11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지를 읽고, 정렬하고 다시 저장하는 방식이다. 더블 버퍼링과는 상관이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정렬---외부-정렬&#34;&gt;정렬 - 외부 정렬&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/kphuwzz714t1e2h/Screen%20Shot%202022-01-05%20at%2019.40.12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;외부 정렬 방식은 처음에 버퍼 크기 만큼 나누고 나서, 이를 서로 병합하는 과정을 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/bvf6z7y0ymrq59p/Screen%20Shot%202022-01-05%20at%2019.41.52.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어서 다음과 같은 데이터가 있다고 가정을 하였을 때 각 버퍼 크기 만큼 나눈후에, 정렬을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/upt2q3dfkgcj2po/Screen%20Shot%202022-01-05%20at%2019.43.10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그리고 나서 정렬된 버퍼끼리 병합을 하는데, 버퍼 상위에 있는 데이터를 화살표로 가리키면서 서서히 내려온다. 이렇게 하면 정렬된 데이터를 얻게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해싱&#34;&gt;해싱&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해싱은 정렬이 필요하지 않은 경우에 사용되는 방법이다. 중복을 제거하거나 GROUP BY를 사용할 때 말이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GROUP BY에 따른 집계를 할 때 키에 따른 데이터의 집합이 필요한 것이지 정렬이 필요한 것은 아니기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해싱의 경우에도 두 단계로 나누어 진다. 바로 분할과 정복이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;분할-divide&#34;&gt;분할 (DIVIDE)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/v1ugskoc2ob104y/Screen%20Shot%202022-01-05%20at%2020.16.43.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해시 함수에 의해서 각 값은 버킷에 담기게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;정복-conquer&#34;&gt;정복 (CONQUER)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/yol3mhiq9lfa5k8/Screen%20Shot%202022-01-05%20at%2020.14.54.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해시 테이블에 담긴 값을 다시 해싱을 하여 분류한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=yookWzvnic0&amp;amp;list=PLzzVuDSjP25Qpsaf7GxFDBEWwvQKCkCVl&amp;amp;index=1&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 버퍼매니저(BUFFER MANAGER)란 무엇인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/12/29/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B2%84%ED%8D%BC%EB%A7%A4%EB%8B%88%EC%A0%80buffer-manager%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</link>
      <pubDate>Wed, 29 Dec 2021 21:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/29/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B2%84%ED%8D%BC%EB%A7%A4%EB%8B%88%EC%A0%80buffer-manager%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</guid>
      <description>&lt;h3 id=&#34;버퍼-매니저&#34;&gt;버퍼 매니저&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/a6e5b0tdkf9ii4m/Screen%20Shot%202021-12-29%20at%209.24.10%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;버퍼 매니저는 인덱스와 디스크 사이에 있는 중간 층이다. 파일과 인덱스 관리를 하는데 중간의 추상 계층을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/qk9oc1kvnugyigj/Screen%20Shot%202021-12-29%20at%209.34.21%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;버퍼 풀은 페이지 단위의 프레임이라고 하는 것의 집합으로 구성되어 있다. 버퍼 매니저의 주요 역할은 메인 메모리에서 디스크에 저장된 데이터를 조작하는 것이다. 따라서 마치 디스크에 접근하는 것이 아니라, 모든 것이 메인 메모리에서 끝나게 느끼는 것이 목적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 실제 모든 데이터 연산은 버퍼 풀과 디스크 사이에 이루어지게 된다. 만약 데이터를 읽고 싶은 요청이 버퍼 매니저에 들어온다면 버퍼 매니저는 디스크 매니저에 다시 요청하게 되며, 버퍼 매니저로 불러온 상태로 데이터를 반환하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 이미 버퍼 매니저에 올라온 데이터를 요청할 경우 디스크 매니저에 요청할 필요없기 바로, 버퍼 매니저에 있는 데이터를 반환하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;더티-페이지&#34;&gt;더티 페이지&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/xkpfqe46zooy94a/Screen%20Shot%202021-12-29%20at%209.46.20%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;더티 페이지는 메모리에 올라간 데이터와 실제 디스크에 있는 데이터의 내용이 상이한 페이지를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더티 페이지를 관리하는데는 두가지 중요한 점이 있는데 버퍼 매니저가 더티 페이지를 어떻게 찾아 낼 것 인가에 대한 문제와 더티 페이지를 나중에 디스크에 어떻게 반영할 것인가이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 문제는 동시성 문제와, 리커버리에서 중요하다. 왜냐하면, 더티 페이지가 디스크에 반영되기 전에 시스템이 충돌하면 데이터가 유실 되기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/a5674e1w73mse9u/Screen%20Shot%202021-12-29%20at%209.52.12%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;버퍼 매니저에서 프레임은 테이블 처럼 관리되며, 페이지 아이디와, 더티 플래그를 가지고 있어서, 디스크에 반영되지 않은 페이지를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 버퍼 매니저는 핀 카운트를 통해서 해당 페이지가 사용되고 있는지를 확인할 수 있다. 그리고 버퍼 매니저가 꽉 채워졌을 때는 교체 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이지-요청-시-버퍼매니저에서-생기는-일&#34;&gt;페이지 요청 시 버퍼매니저에서 생기는 일&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;핀 카운트가 0인 (사용되지 않은) 프레임을 찾는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;만약 프레임이 더티 상태라면 디스크에 반영하여 깨끗한 상태로 만든다. 그리고 디스크 매니저에게 요청한 데이터를 프레임에 채운다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;그리고 핀 카운트를 증가시키고 주소를 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 페이지가 요청 될 것이라고 예상 되면, 미리 디스크로부터 프리 패치한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;요청이 끝나고 나서, 데이터가 변경되면 더티 상태로 만들고, 아니더라도 사용이 끝나면 핀을 해제한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이지-교체&#34;&gt;페이지 교체&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;lru&#34;&gt;LRU&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/0t4xtmmq7jlxzt4/Screen%20Shot%202021-12-29%20at%2010.17.36%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;핀을 해제할 때 해제한 시간을 기록하여, 마지막으로 페이지를 사용한 시간을 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 핀 카운트가 0이면서, 최근에 사용되지 않은 프레임을 찾는데 선형적으로 탐색을 하게 되고 시간이 증가하게 된다. 또한 우선순위 힙 같은 자료 구조를 사용한다고 하더라도, 구조를 유지하기 위해서 LOG(N)의 시간 복잡도를 가진다. 따라서 상수시간에 교체할 페이지를 찾기 위해서는 CLOCK을 사용하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;clock&#34;&gt;CLOCK&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/7auu7w1y1r0bd2a/Screen%20Shot%202021-12-29%20at%2010.25.23%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클락은 시계바늘로 다음에 교체할 페이지를 가리키고 있다. 그리고 각 페이지들은 &lt;code&gt;ref_bit&lt;/code&gt;을 가지는데 최근에 참조된 페이지를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/udd834efl2ursdt/Screen%20Shot%202021-12-29%20at%2010.33.34%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위 그림처럼 페이지 7을 찾는 경우 우선 핀이 없는 페이지를 시계 바늘로 순서대로 찾아간다. 그리고 나서, 페이지 3을 가리킬 때 &lt;code&gt;ref_bit&lt;/code&gt;가 체크되어있다면 체크를 해제하고 다음 페이지로 넘어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;ref_bit&lt;/code&gt;이 체크되어 있지 않은 페이지라면 해당 페이지를 교체하는 식으로 동작한다. 그리고 해당 페이지의 핀 카운트를 증가시킴과 동시에 &lt;code&gt;ref_bit&lt;/code&gt; 또한 체크 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/0gey3a6ku62rpni/Screen%20Shot%202021-12-29%20at%2010.36.48%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이를 코드로 구현한다면 위와 같은 그림으로 보일 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lru--mru-어떤-것이-더-좋은가&#34;&gt;LRU / MRU 어떤 것이 더 좋은가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/bn9y5tuohfg50mb/Screen%20Shot%202021-12-29%20at%2010.42.56%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LRU&lt;/code&gt; 알고리즘의 경우 연속적인 플루딩이라고 위의 예제에서 버퍼 매니저에 프레임이 6개 있고 디스크에 페이지가 총 7개가 있다면 순차적으로 읽으며서 공간이 없을 때마다 버퍼 매니저에서 하나를 방출하고 새로 디스크에서 읽어오고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 경우에 캐시 히트율을 0%이고 LRU의 가장 안좋은 케이스이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연속적으로 반복해서 값을 읽어오는 것은 매우 일반적인 경우이다. 특히 NESTED LOOP에서 반복해서 같은 값을 읽는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 경우에는 MRU를 사용할 수 있다. MRU는 가장 최근에 사용된 페이지를 교체한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 버퍼매니저에 1 ~ 6까지 7 페이지를 읽어야 할 때  6을 제거하고 7을 넣는 것이다. 그려면 다시 1 ~ 5까지의 데이터를 읽을 때는 페이지 교체를 하지 않아도 되므로 연속적인 데이터를 읽을 때 페이지 교체가 덜 일어난다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론은 LRU와 MRU를 같이 사용하는 것이 좋다. 조인을 할 때와 같이 연속적인 데이터에 접근할 때는 MRU를 사용하면 좋고 그 외의 일반적인 경우에는 LRU를 사용하는것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRU와 MRU외에도 2Q, LRU-2, ARC와 같은 페이지 교체 알고리즘이 많이 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프리-패칭&#34;&gt;프리 패칭&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프리 패칭은 연속적인 페이지를 읽을 때 디스크 매니저에서 미리 여러개의 페이지를 요청하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;랜덤 I/O를 줄일 수 있고, I/O 연산을 많이 줄일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;운영체제에-있는-파일시스템으로-버퍼와-페이지를-관리해도-되지-않는가&#34;&gt;운영체제에 있는 파일시스템으로 버퍼와 페이지를 관리해도 되지 않는가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;몇가지 문제점이 있다. 이식성 문제이다 OS 마다 파일 시스템이 달라서 이것이 힘들다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBMS는 강제로 페이지를 디스크로 기록하는 기능이 필요하다. 리커버리 시스템 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBMS는 자체적으로 페이지 참조 패턴을 예측할 수 있어야 한다. 이는 페이지 교체와 프리 패칭에 영향을 준다. B+TREE의 인덱스는 리프 노드 다음에 연속한 페이지가 있다는 것 을 알 수 있지만, OS의 파일 시스템은 오직 물리적인 연속적인 페이지만 알고 있다. 따라서 데이터 구조를 알지 못해 프리패칭을 하기 힘들다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLzzVuDSjP25Q0YDDDpAgfK_da5Ba357Tg&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>인덱스 (INDEX) 정리 2</title>
      <link>https://dongwooklee96.github.io/post/2021/12/25/%EC%9D%B8%EB%8D%B1%EC%8A%A4-index-%EC%A0%95%EB%A6%AC-2.html</link>
      <pubDate>Sat, 25 Dec 2021 16:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/25/%EC%9D%B8%EB%8D%B1%EC%8A%A4-index-%EC%A0%95%EB%A6%AC-2.html</guid>
      <description>&lt;h3 id=&#34;인덱스가-지원하는-연산&#34;&gt;인덱스가 지원하는 연산&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;동등 조회 (=)&lt;/li&gt;
&lt;li&gt;범위 조회 (&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, BETWEEEN)&lt;/li&gt;
&lt;li&gt;B+TREE 인덱스는 위의 두개의 연산을 모두 지원하지만, 해시 인덱스는 오직 동등 연산만 지원을 한다.&lt;/li&gt;
&lt;li&gt;그 밖에 다양한 데이터 종류를 처리하기 위한 많은 종류의 인덱스가 종류한다.  (R-TREE, KD-TREE, GiST)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스-키와-정렬&#34;&gt;인덱스 키와 정렬&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;B+TREE와 같은 정렬된 인덱스는 키를 기준으로 사전 순서대로 정렬된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복합 인덱스의 경우에는 만약 (k1, k2)로 이루어진 경우에는 (k1, k2) 이후에 오는 컬럼에 대해서 동등 연산이나, 범위 연산을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이후에 몇까지 예제를 보여줄 텐데, 초록색으로 표시된 부분은 인덱스가 범위 접근을 할 수 있다는 뜻이고 빨간색으로 표시된 부분은 인덱스가 범위로 접근하지 못한다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;먼저 &amp;lt;AGE, SALARY&amp;gt;에 대해서 복합 인덱스가 있다고 가정을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ar7d3zjy07jdp04/Screen%20Shot%202021-12-25%20at%204.35.27%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약 &lt;code&gt;AGE=31 &amp;amp; SALARY=400&lt;/code&gt; 인 조건에 대해서 인덱스로 빠르게 조회가 가능한지 묻는다면 가능하다. 먼저 31을 빠르게 찾고 나서, SALARY로 정렬되어 있기 때문에 빠르게 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/582hu7tklodcd4z/Screen%20Shot%202021-12-25%20at%204.38.08%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약 &lt;code&gt;AGE=55 % SALARY &amp;gt; 200&lt;/code&gt; 인 경우에 대해서 인덱스로 빠르게 조회가 가능한지 묻는다면 이 역시도 가능하다. 위와 같은 이유로 SALARY 역시 정렬되어 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/fjn2tcz8y8ujpdj/Screen%20Shot%202021-12-25%20at%204.39.49%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;AGE &amp;gt; 31 &amp;amp; SALARY = 400&lt;/code&gt;을 찾는다면 인덱스로 빠르게 조회할 수 없다. 왜냐하면, AGE가 같지 않은 상태에서 SALARY는 더 이상 정렬 상태임을 보장할 수 없기 때문이다. 따라서 AGE에 따라서 인덱스 범위 연산을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 같은 이유로 &lt;code&gt;SALARY = 300&lt;/code&gt; 또한 인덱스를 효율적으로 사용하지 못한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터-엔트리-저장소&#34;&gt;데이터 엔트리 저장소&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;세가지의 구현 방법이 있다. 첫 번째는 값으로 저장하는 것이고 두번째는 값을 가리키는 참조를 생성하는 것이다. 마지막은 리스트 형태로 참조하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-값으로-저장되는-형태&#34;&gt;1. 값으로 저장되는 형태&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/zoif1zn93le8kp0/Screen%20Shot%202021-12-25%20at%204.56.12%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포인터가 필요없는 형태이다. 리프 노드에 실제 레코드가 저장되어 있으며 키와 값을 분리할 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-참조로-가리키는-형태&#34;&gt;2. 참조로 가리키는 형태&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/osx3ygt89cz2o1n/Screen%20Shot%202021-12-25%20at%204.58.32%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 형태로는 우선 키 값으로 데이터를 찾아가면 해당 데이터에 페이지 아이디랑 슬롯 아이디가 적혀 있는 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, (2, JOE)을 찾는다면 인덱스로 키값이 2인 곳을 찾아가면 데이터에는 [1, 1]이 들어있다. 이가 뜻하는 것은 페이지 1, 슬롯 1을 찾아가라는 뜻이다. 아래 그림에 나와있듯이 해당 위치에 가면 값을 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-하나의-키로-여러-레코드를-참조하는-형태&#34;&gt;3. 하나의 키로 여러 레코드를 참조하는 형태&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/21dxclvpotdymhd/Screen%20Shot%202021-12-25%20at%205.06.01%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하나의 키가 많은 레코드를 매칭할 수 있는 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 형태는 키에 따른 중복 데이터가 많은 경우에 유용하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2번과-3번의-차이점&#34;&gt;2번과 3번의 차이점&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/vd0pejzgjpwn6lz/Screen%20Shot%202021-12-25%20at%205.10.48%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인덱스를 통해서 데이터를 참조하는 형태는 하나의 테이블의 여러가지 인덱스를구현하는데 중요하다. 그렇지 않으면 인덱스를 생성할 때마다 튜플을 복제해서 만들어야 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한, 데이터를 참조하는 구조가 아니라면, 테이블의 데이터를 업데이트 할 때마다 엄청난 부하가 생길 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;왼쪽의 경우에는 인덱스가 가리키고 있는 레코드와 일대일로 매칭이 되지만, 오른쪽의 경우에는 인덱스가 여러 개의 레코드를 가리키고 있는 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;클러스트-인덱스와-클러스트-되지-않은-인덱스&#34;&gt;클러스트 인덱스와 클러스트 되지 않은 인덱스&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rlxqjk5xfl45emj/Screen%20Shot%202021-12-25%20at%205.29.25%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위에서 보았던 2, 3번 형태의 참조하는 형태의 인덱스는 클러스트 되거나 클러스터링 되지 않은 인덱스 형태로 만들 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클러스트된 인덱스를 만들려면 먼저 힙 파일을 정렬해야한다, 클러스터링 된 인덱스는 접근하려는 힙 파일이 순차적으로 되어있지만, 클러스터링 되지 않은 인덱스는 힙파일 순서가 정렬되어 있지 않아서, 이곳 저곳 가리키고 있는 모습을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클러스트 되지 않은 인덱스를 통해서 접근하는 경우에는 더 많은 페이지에 접근해야하므로, 더 많은 I/O가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클러스트된-인덱스에-데이터가-삽입-되는-경우&#34;&gt;클러스트된 인덱스에 데이터가 삽입 되는 경우&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/z8lfdwl20h65r1j/Screen%20Shot%202021-12-25%20at%205.36.39%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;삽입하려는 곳에 공간이 빈다면, 바로 삽입하면 되지만, 그렇지 않은 경우에는 새로운 블록을 생성하게 되고 그곳을 가리키게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 많은 데이터가 삽입되면 힙 파일 정렬 구조는 깨지게 되며 다시 힙 파일을 정렬해줘야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클러스터링 된 인덱스는 더 적은 I/O 를 통해서 더 빠른 조회가 가능하다. 또한 범위를 조회할 때 더 빠른 특징을 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 이를 유지하는데 많은 비용이 든다는 단점이 있다. 왜냐하면 업데이트 될 떄마다 구조가 깨지기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 많은 업데이트 연산 후에 백 그라운드 연산으로, 정렬을 다시 해주거나, 힙 파일은 새롭게 더해지는 레코드를 위해서 오직 2/3 만 채우는 식으로 최적화를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스-키로-길이가-변하는-키를-사용하였을-때&#34;&gt;인덱스 키로 길이가 변하는 키를 사용하였을 때&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ldnry21ait4uuxo/Screen%20Shot%202021-12-25%20at%207.05.20%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이전에는 길이가 변하지 않는 정수형을 키로 사용하는 예제를 다루었지만, 이번에는 문자열 같은 가변 데이터를 키로 사용하였을 떄 어떨지를 다루어보겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;prefix로-키를-압축시키는-방법&#34;&gt;PREFIX로 키를 압축시키는 방법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/o41zr22233altju/Screen%20Shot%202021-12-25%20at%207.17.14%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;루트나 중간 노드의 키들의 &lt;code&gt;PREFIX&lt;/code&gt;를 뽑아서 저장하는 방식이다. 하지만 이 방식은 키에 따라서 균일하게 파티셔닝이 안된다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 리프 노드 부터 압축하는 방식을 사용하기로 한다. 이 방식에서는 분할 할 때 최소의 &lt;code&gt;PREFIX&lt;/code&gt;를 결정하고 나서 위로 복사하여 올린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;prefix--suffix로-키를-압축하는-방법&#34;&gt;PREFIX &amp;amp; SUFFIX로 키를 압축하는 방법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/gydyu8bys6eorjw/Screen%20Shot%202021-12-25%20at%207.25.47%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;많은 키들이 &lt;code&gt;PREFIX&lt;/code&gt;로 하였을 떄 많은 공통된 부분이 있다. 따라서 공통된 &lt;code&gt;PREFIX&lt;/code&gt;를 헤더로 보내고 남은 &lt;code&gt;SUFFIX&lt;/code&gt;만 저장하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hSEWD2XIcL4&amp;amp;list=PLzzVuDSjP25QCp7S4_8b-rX9vytv6OqsZ&#34;&gt;LECTURE 6 - INDICES &amp;amp; B+TREE REFINEMENTS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>인덱스 (INDEX) 정리 1</title>
      <link>https://dongwooklee96.github.io/post/2021/12/22/%EC%9D%B8%EB%8D%B1%EC%8A%A4-index-%EC%A0%95%EB%A6%AC-1.html</link>
      <pubDate>Wed, 22 Dec 2021 11:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/22/%EC%9D%B8%EB%8D%B1%EC%8A%A4-index-%EC%A0%95%EB%A6%AC-1.html</guid>
      <description>&lt;h3 id=&#34;데이터에-접근하는-두-가지-방법&#34;&gt;데이터에 접근하는 두 가지 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/kochddz88kb868o/Screen%20Shot%202021-12-22%20at%209.59.14%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터에 접근하는 첫 번째 방법은 바로, 레코드 아이디(페이지 아이디, 슬롯 아이디)를 이용하는 방법이다. 레코드 아이디는 페이지 아이디와, 슬롯 아이디로 구성 되어있으며 이를 통해서 페이지를 찾아 갈 수 있으며 슬롯을 통해서 튜플을 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 방법은, 페이지 시작 부분부터 모두 스캔하는 방법이다. 하지만 이런 방법은 모든 데이터를 접근해야하기 때문에 좋지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스&#34;&gt;인덱스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인덱스란, 데이터를 키를 통해서 매우 빠르게 찾음과 동시에 변경할 수 있는 자료구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인덱스는 많은 연산을 지원하며, 데이터의 종류 (사진, GIS, 비트맵)에 따라서 다양한 종류의 인덱스들이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터들은 인덱스 안에 저장이 되고 일반적으로 다음과 같은 형태로 저장된다. (키, 레코드 아이디) 키를 통해서 레코드 아이디를 확인할 수 있고 레코드 아이디에는 (페이지 아이디, 슬롯 아이디)가 저장되어 있으므로 슬롯 아이디를 통해서 데이터를 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인덱스에는 B+ 트리가 일반적이지만, 해시 인덱스도 많이 사용된다. 그 밖에 R TREE, GiST 등등 많은 종류의 인덱스가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스의-기본-구조&#34;&gt;인덱스의 기본 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;페이지를 연결하기 위해서 포인터를 가져야 하는가? 에 대한 질문의 답은 아니다이다. 왜냐하면 페이지들은 논리적인 순서대로 디스크에 정렬되어 저장되기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/fmvud87v648hogq/Screen%20Shot%202021-12-22%20at%2010.28.32%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 그림은 키에 의해서 정렬된 (키, 페이지 아이디)의 인덱스 구조이다. 실제 데이터보다 적은양의 데이터로 페이지를 가리키고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;키보다 같거나 작은 값은 왼쪽에 저장되며, 같거나 큰 값은 오른쪽에 저장 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 데이터를 검색할 때 루트 인덱스부터 시작해서, 아래로 내려가는 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;향상-시킨-인덱스&#34;&gt;향상 시킨 인덱스&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/66fr03jllhmie9t/Screen%20Shot%202021-12-22%20at%2010.34.13%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 구조를 조금 더 발전 시키는 구조는 위와 같다. 가장 왼쪽에 있는 값을 제거하였는데 이유는 인덱스에 있는 값보다 작으면 왼쪽에 있다는 것을 알 수 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 적은 공간을 사용하는 만큼 더 많은 데이터를 저장할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/v10jue4o6oyi84t/Screen%20Shot%202021-12-22%20at%2010.43.32%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 구조에서 데이터를 더 많이 추가한다고 가정을 해보자. 만약 11과 12를 추가한다고 가정을 해본다면, 위와 같은 그림이 될 것이다. 11까지는 공간이 남아서 저장을 할 수 있지만, 12는 더 이상 저장할 공간이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 페이지를 하나 더 생성하고, 저장한다. 그리고 이전에 저장하려고 했던 페이지에서 새로 생성한 페이지를 가리켜서 데이터에 접근할 수 있도록 한다. 이러한 방식을 ISAM이라고 한다. ISAM 방식은 예전에 IBM 회사에서 사용했던 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 방식의 단점은 데이터 추가가 많이 일어날 수록, 링크드 리스트 형태가 되어, 데이터에 접근하는데 비효율적이게 된다. 이러한 비효율적인 구조를 극복하기 위해서 나온 데이터구조가 바로 B+TREE이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;btree&#34;&gt;B+TREE&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/m2qajiiuuvn9y9r/Screen%20Shot%202021-12-22%20at%2010.51.39%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+TREE는 매우 동적인 데이터 구조이며, 효율적인 삽입과 삭제 연산이 가능하다.ISAM 방식은 LEAF 노드를 증가 시키는 구조인데 반해서, B+TREE 방식은 데이터가 증가 함에 따라서 루트 노드 및 중간 노드가 증가된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터-검색&#34;&gt;데이터 검색&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/jifylll256k11rh/Screen%20Shot%202021-12-22%20at%2011.02.32%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 찾아가는 과정은 우선 루트 노트에서 부터 시작해서, 찾으려고 하는 키가 크고 작음을 비교하며 검색한다. 리프 노드에 도달해서, 해당 레코드 아이디로 원하는 데이터에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터-삽입&#34;&gt;데이터 삽입&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터 삽입의 경우에는 조금 복잡하다. 삽입하려는 노드가 꽉찬 경우에는 분리를 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/4mbvr7ativig51m/Screen%20Shot%202021-12-22%20at%2011.23.22%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아래의 경우 &lt;code&gt;8&lt;/code&gt;을 리프노드에 추가하려고 하는데 자리가 없다. 따라서, (D, D + 1) 이 경우에는 새로운 리프노드 자리를 만들고 2, 3을 왼쪽에 5, 6, 7을 오른쪽에 배치한 후 가운데 값인 5의 값을 복사하여 위로 올린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/g52xi3bkmm6f4va/Screen%20Shot%202021-12-22%20at%2011.25.34%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리프 노드가 아닌 중간 노드에 값을 추가하는 경우 리프노드와 분리하는 것은 비슷하지만, 중간값을 복사하는 것이 아니라, 위로 이동 시킨다는 차이가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;btree-실습-사이트&#34;&gt;B+TREE 실습 사이트&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ehdssujfqfpnh29/Screen%20Shot%202021-12-22%20at%2011.45.31%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html&#34;&gt;B+TREE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음은 B+TREE 를 조작할 수 있는 사이트이다. 직접 실습해볼 수 있어서 이해하기가 훨씬 수월하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;btree-벌크-로딩&#34;&gt;B+TREE 벌크 로딩&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이미 만들어진 테이블에 B+TREE 인덱스를 생성한다면 어떻게 할 것인가? 하나씩 데이터를 집어넣어서 인덱스를 만들 것인가?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 방법은 효율적이지 않다. 왜냐하면 데이터를 넣을 때마다, 루트 노드를 통해서 검색을 해야하며, 데이터가 삽입되면서 많은 페이지들이 변경된다. 그리고 계속 해서 데이터를 하나씩 집어넣어야 하므로, 캐시를 활용할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 데이터를 직접 넣기전에 레코드를 키를 기준으로 정렬하는 방법을 사용한다. 미리 정렬을 한다면, 데이터를 넣기 위해서 루트노드에 접근하지 않아도 된다. 따라서 우리는 모든 리프노드를 미리 생성한 다음에 중간 노드나, 루트 노드를 업데이트 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 미리 생성한 리프 노드를 중간 노드에 추가하는 도중에 공간이 모자르다면 그때 중간 노드나 루트 노드를 분리해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 방식은 캐시를 좀 더 효율적으로 사용할 수 있게 해주고, 리프 노드를 효율적으로 사용할 수 있게 해준다. 그리고 리프 노드가 디스크 상에 순차적으로 저장이 되므로 매우 효율적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=NcuORWy48Qk&amp;amp;list=PLzzVuDSjP25QT0H605qxlcmMy_GBTHi8X&amp;amp;index=1&#34;&gt;LECTURE 6 - INDEX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MYSQL 클라이언트로 RDS 접속하는 법</title>
      <link>https://dongwooklee96.github.io/post/2021/12/20/mysql-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A1%9C-rds-%EC%A0%91%EC%86%8D%ED%95%98%EB%8A%94-%EB%B2%95.html</link>
      <pubDate>Mon, 20 Dec 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/20/mysql-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%A1%9C-rds-%EC%A0%91%EC%86%8D%ED%95%98%EB%8A%94-%EB%B2%95.html</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -h mysql–instance1.123456789012.us-east-1.rds.amazonaws.com -P 3306 -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;접속할 수 있는 &lt;code&gt;mysql&lt;/code&gt; 클라이언트를 설치한다 그리고 나서, 위의 명령어를 주소와 유저를 알맞게 입력하면 접속된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/USER_ConnectToInstance.html&#34;&gt;MySQL 데이터베이스 엔진 기반 DB 인스턴스에 연결하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 페이지 및 레코드 구조</title>
      <link>https://dongwooklee96.github.io/post/2021/12/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%8F-%EB%A0%88%EC%BD%94%EB%93%9C-%EA%B5%AC%EC%A1%B0.html</link>
      <pubDate>Thu, 16 Dec 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%8F-%EB%A0%88%EC%BD%94%EB%93%9C-%EA%B5%AC%EC%A1%B0.html</guid>
      <description>&lt;h3 id=&#34;페이지-구조&#34;&gt;페이지 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/xqzsbjzfgo3bbht/Screen%20Shot%202021-12-16%20at%2011.36.21%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이지에는 페이지 헤더가 있는데 페이지에 대한 메타 정보를 담고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;레코드의 숫자, 남은 공간, 다음 또는 이전 페이지에 대한 포인터, 비트맵 그리고 슬롯 테이블을 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지에 레이아웃은 두 가지 관점이 있는데 첫번째로 페이지 안에 저장될 레코드의 형태가 고정 길이를 가지는 경우와 가변 길이를 가지는 경우가 있다. 두 번째는 페이지가 패킹 되거나 언패킹 되는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지에서 레코드는 레코드 아이디를 통해서 찾을 수 있으며 레코드 아이디는 다음과 같은 형태로 저장이 된다. (페이지 번호, 페이지에서 찾으려는 레코드 아이디) 이와 같은 형태로 저장이 되므로 어떤 페이지에 레코드가 어디에 위치해있는지를 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;고정-길이-레코드-패킹-된-경우-페이지-레이아웃&#34;&gt;고정 길이 레코드, 패킹 된 경우 페이지 레이아웃&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/nw0vysqb4e7hyji/Screen%20Shot%202021-12-16%20at%2011.46.03%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이런 구조인 경우 레코드를 추가할 때 빈 공간을 찾기 쉽다. 우선 페이지 헤더로 가서, 레코드의 숫자를 확인한 다음에 마지막 레코드로 가서 레코드를 추가하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 삭제의 경우에는 삭제하고 나서, 삭제된 레코드 공간을 땡겨야 한다. 맨 끝에 레코드를 삭제하는 경우에는 아무것도 하지 않아도 되지만, 중간 레코드를 삭제 했다면 삭제된 레코드의 공간을 뒤의 레코드부터 땡겨서 앞으로 채워야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 레코드 아이디 또한 변경되게 된다. 따라서 페이지안의 레코드가 변경 되는 경우 연산이 많아 진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;고정-길이-레코드-언패킹&#34;&gt;고정 길이 레코드, 언패킹&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/l3byuyym493t1o2/Screen%20Shot%202021-12-16%20at%2011.54.48%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 구조의 경우 페이지 해더에 비트맵 정보가 포함된다. 이 비트맵 정보를 참조해서 레코드가 비어있는지 아니면 비어있지 않은지 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터를 추가할 경우에는 페이지 헤더에서 비어있는 레코드를 확인할 수 있는 비트맵을 참고하여 가장 먼저 비어있는 페이지를 데이터를 추가하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;삭제하는 경우에는 그냥 간단하게 비트맵에 해당 레코드 위치의 비트를 삭제되었다고 바꾸면 된다. 언패킹 구조의 경우에 추가 및 삭제가 비트 연산을 통해서 이루어지므로, 매우 빠르다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;가변-길이-레코드&#34;&gt;가변 길이 레코드&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/pkcfetc1mbebkat/Screen%20Shot%202021-12-16%20at%201.46.14%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가변 길이 레코드의 경우, 페이지 맨 아래 부분에 슬롯 디렉터리를 가진다. 이를 푸터라고 부른다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;맨 마지막 슬롯은 비어있는 레코드의 위치를 나타낸다. 따라서 항상 맨 마지막 레코드의 끝을 가리키고 있다고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 각 슬롯은 레코드의 위치와 길이를 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/cgfkgeetrkfw3qm/Screen%20Shot%202021-12-16%20at%201.48.56%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이지에서 레코드를 삭제하는 방법은 더 간단하다. 슬롯에서 해당 레코드를 가리키고 있는 슬롯을 지우면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지에서 새로운 레코드를 더하는 것은 빈 슬롯을 찾아서 거기에 새로 추가될 레코드의 주소를 가리키면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇다면 메모리 단편화에 대해서 생각을 해봐야할 것이다. 메모리 단편화를 위해서 빈 메모리 공간을 정리해줄 필요가 있는데 두가지 방식이 있다. 레코드가 업데이트 될 때마다 정리를 해주는 방식과 실제 단편화 때문에 데이터를 넣기 힘들 때 정리를 하는 방식이 있다. 보통 후자를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;레코드-구조&#34;&gt;레코드 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;관계형 모델에서, 테이블에 대한 정보 및 테이블이 가지고 있는 컬럼 및 자료형은 시스템 카탈로그에 저장된다. 그 이유는 레코드에서 타입을 구분하기 위한 노력을 하지 않아도 되므로 저장공간을 더 많이 확보할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 레코드는 저장하는 데이터에 대한 어떠한 정보도 가지고 있지 않으며 테이블 정보는 시스템 카탈로그에 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 레코드에서 필드 타입은 구분되지 않는다. 또한 자바와 같이 직렬화를 하지 않으며 데이터베이스에 저장된 바이트 형태 그대로 메모리에서 보여지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 각 필드를 어떻게 구분할지에 대한 문제가 생기게 된다. 간단하게 생각하면 CSV 파일 처럼, 구분자를 넣어줄 수도 있지만 이는 파싱을 해야하며 또한 낭비되는 메모리가 발생한다. 각 필드마다 &lt;code&gt;,&lt;/code&gt; 구분자를 넣어줘야하기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/wtrimgfa4k9hqy3/Screen%20Shot%202021-12-16%20at%203.57.29%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;결론은 레코드에 해더를 생성하고 그 헤더에서 각 필드의 마지막 위치를 가리키는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가변 길이 필드는 뒤로 늘어나야 하므로, 고정 길이 필드가 앞으로 오게 되고 뒤에 이어서 가변 길이 필드가 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=z26fEmCYdIQ&amp;amp;list=PLzzVuDSjP25SJBxWLPfYLwGlOPHmKL775&amp;amp;index=8&#34;&gt;Lec 4 5 Part 2 Pages for Fixed Length&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gcQgJMRr60Y&amp;amp;list=PLzzVuDSjP25SJBxWLPfYLwGlOPHmKL775&amp;amp;index=10&#34;&gt;Lec 4 5 Part 4 Record Layout&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZOOM4wxUpjU&amp;amp;list=PLzzVuDSjP25SJBxWLPfYLwGlOPHmKL775&amp;amp;index=11&#34;&gt;Lec 4 5 Part 5 Summary&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 파일 구조 방식</title>
      <link>https://dongwooklee96.github.io/post/2021/12/15/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%A1%B0-%EB%B0%A9%EC%8B%9D.html</link>
      <pubDate>Wed, 15 Dec 2021 10:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/15/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%A1%B0-%EB%B0%A9%EC%8B%9D.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;파일은 페이지의 집합으로 구성이 되는데 페이지를 구성하는 많은 방식이 있다. 그 중에서 정렬되지 않은 힙 파일 구조에 대해서 자세히 살펴볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-페이지-레코드&#34;&gt;파일, 페이지, 레코드&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/qffed9qft6488cv/table.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우리가 흔하게 볼 수 있는 데이터베이스에서 데이터가 어떻게 저장되는지 확인하는 방식은 위의 그림과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 테이블은 파일의 형태로 저장이 된다. 파일은 블록과 페이지로 이루어져있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 페이지는 레코드의 집합으로 이루어진 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/h503k6ytqkl6bzx/Screen%20Shot%202021-12-15%20at%2010.56.45%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고 해당 블록과 페이지는 메모리상에서 다음과 같이 나타내진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지는 메인 메모리에서 레코드 형태로 나타내지고, 위의 그림과 같이 저장이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 쿼리를 통해서 조회문으로 레코드를 얻어오는 방식은 특정 레코드 아이디를 참조해서 얻어오는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;레코드 아이디는 (페이지 아이디, 페이지의 위치) 같은 것을 가리키는 포인터라고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터베이스-파일-구조&#34;&gt;데이터베이스 파일 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;정렬되지-않은-힙-파일-구조&#34;&gt;정렬되지 않은 힙 파일 구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;레코드가 임의의 페이지에 저장된 상태, 순서가 따로 존재하지 않는다.&lt;/li&gt;
&lt;li&gt;가장 단순한 구조로서 일반적으로 레코드들이 삽입된 순서대로 파일에 저장된다.&lt;/li&gt;
&lt;li&gt;자료구조에서 나오는 힙과는 다르다. 데이터베이스에서 힙 파일 구조는 레코드들이 정렬되지 않은 상태라고 보면 된다.&lt;/li&gt;
&lt;li&gt;페이지가 할당/해제 될 때마다 파일의 크기가 커졌다가 줄어든다.&lt;/li&gt;
&lt;li&gt;레코드 수준의 연산을 지원한다. 페이지들과, 사용되지 않는 빈 공간, 그리고 페이지에 있는 레코드들을 추적해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/3m1y7f2ukor100s/Screen%20Shot%202021-12-15%20at%2011.27.19%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 그림은 힙 파일 구조를 링크드 리스트 형태로 구현한 것이다. 맨 앞에 헤더 페이지가 있는데 헤더 페이지 아이디와 힙 파일의 이름은 데이터베이스 카탈로그에 저장이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 페이지는 두 개의 포인터를 가지고 있다. 하나는 데이터를 가리키고 있는 포인터이고 다른 하나는 빈 공간을 가리키고 있는 포인터이다. 이 구조의 문제점은 페이지에 20 바이트를 추가하려고 할 때, 모든 페이지를 조회해서 20 바이트의 빈 공간을 가진 페이지를 찾아야 한다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/pm8ertkql63vyx1/Screen%20Shot%202021-12-15%20at%2011.42.43%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 페이지 딕셔너리 방식을 사용 한다. 페이지 딕셔너리 방식은 많은 수의 헤더 페이지를 가진다. 첫 번째 헤더 페이지가 데이터베이스 카탈로그에 저장되며 다른 헤더를 가리키고 있다. 따라서 이러한 헤더들을 디렉터리라고 부른다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 헤더 페이지들은 실제 데이터가 저장되어 있는 페이지를 가리키는 공간을 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식을 사용하면 사용하지 않는 빈 공간을 쉽게 찾을 수 있어 새로운 데이터를 삽입하는데 전체 페이지를 검색하지 않아도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클러스터된-힙-파일&#34;&gt;클러스터된 힙 파일&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;레코드와 페이지가 그룹화된 형태&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;정렬된-파일&#34;&gt;정렬된 파일&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;페이지와 레코드가 정렬된 형태&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인덱스-파일&#34;&gt;인덱스 파일&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;B+트리, 선형 해시 구조, &amp;hellip;&lt;/li&gt;
&lt;li&gt;레코드를 포함하거나, 다른 파일의 레코드를 가리킬 수 도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=XXGmqV1gIug&amp;amp;list=PLzzVuDSjP25SJBxWLPfYLwGlOPHmKL775&amp;amp;index=7&#34;&gt;Lec 4 5 Part 1 Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wkdtjsgur100.github.io/db-summary/&#34;&gt;여러 File Organization의 비용을 비교해보자&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>버클리 대학의 데이터베이스 강의를 수강신청하였다</title>
      <link>https://dongwooklee96.github.io/post/2021/12/09/%EB%B2%84%ED%81%B4%EB%A6%AC-%EB%8C%80%ED%95%99%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%95%EC%9D%98%EB%A5%BC-%EC%88%98%EA%B0%95%EC%8B%A0%EC%B2%AD%ED%95%98%EC%98%80%EB%8B%A4.html</link>
      <pubDate>Thu, 09 Dec 2021 11:23:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/09/%EB%B2%84%ED%81%B4%EB%A6%AC-%EB%8C%80%ED%95%99%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%95%EC%9D%98%EB%A5%BC-%EC%88%98%EA%B0%95%EC%8B%A0%EC%B2%AD%ED%95%98%EC%98%80%EB%8B%A4.html</guid>
      <description>&lt;h3 id=&#34;cs186-barkeyley&#34;&gt;CS186 Barkeyley&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/qtrne7wyyqgk6yy/Screen%20Shot%202021-12-09%20at%2011.30.02%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전에 눈여겨 보기만 했던 강의를 드디어 오늘 수강하였다. 한글 자막이 있어서 이해할 수 있을까 많은 고민을 했지만 생각보다 이해가 잘되었다. 성격이 조금 변해서인지는 몰라도 이전에는 조그만한 내용만 놓쳐도 매우 신경쓰였지만 요즘에는 문맥만 파악하면 별 상관하지 않는 것 같다. 따라서 영어 컨퍼런스도 큰 문제 없이 시청하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 영어 실력을 더 키워야겠다는 생각은 든다. 최근에 영어로 된 자료들을  많이 접하고 있는데 이러한 자료들을 문제 없이 이해하려면 영어 실력을 키워야 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이미 가을 학기가 진행되고 있었는데 두 세번의 강의만 남은 상태이다. 타이밍이 안맞는게 조금 아쉽기는 하지만, 이 강의를 통해서 나의 부족한 &lt;code&gt;DBMS&lt;/code&gt; 지식을 키울 수 있었으면 하는 바람이다. 한국어 자료는 책을 더 선호하는 편이지만, 영어로된 자료는 비디오가 더 이해가 편한 것 같다. 살짝 영어 울렁증이 있는지는 몰라도 영어로 된 문자가 광대하게 펼쳐지만 조금은 어지러운 기분도 든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;강의를 진행하면서, 추가로 궁금한 점은 따로 찾아봐도 좋을 것 같다. 학부때 기초를 탄탄하게 했으면 좋을 것이라는 아쉬움이 든다. 결국에는 기초가 부족하면 처음으로 돌아가야 하는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;일정&#34;&gt;일정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/omwa1uak8058zjp/Screen%20Shot%202021-12-09%20at%2011.40.56%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위에서 보는것과 같이, 한 주에 수업이 두번 정도 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일정이 뒤쳐진 것 같아서 조바심이 나기는 하지만, 욕심을 내지 않고 꾸준하게 요일을 정해서 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프로젝트&#34;&gt;프로젝트&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/w2nwv2mnzx62st6/Screen%20Shot%202021-12-09%20at%2011.34.13%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 강의의 좋은 점은, 과제가 있다는 것이다. 책이나 어떤 것을 배울 때 연습문제나 과제가 있는 것을 선호하는데 왜냐하면 내가 이미 알고있다고 생각하는 착각을 깨버리기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전에는 귀찮다는 이유로 연습문제나 과제를 소흘히 하였다. 하지만 과제를 하고 하지 않고의 중요성을 배운뒤로는 시간이 소모되더라도 과제를 하는 편이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;과제가 없는 경우에는 스스로 과제를 만들려고 하지만, 스스로 과제를 만들기는 조금 어렵다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아쉽게도 확인해본 결과 과제에 접근할 수 있는 권한이 없다. 따라서 과제가 어떤 것인지만 확인이 가능하고 문제를 풀 수 있는 코드는 제공해주지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전에는 기본 지식도 없이, 무작성 공부를 하려니까 재미도 없고 어려웠다. 조금식 체계가 갖춰지는 것 같아서 기분이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 배운 내용을 잘 정리해서 나와 같이 데이터베이스를 잘 알고 싶어하는 사람들에게 이 블로그가 많은 도움이 되었으면 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번 기회에 DBMS 개념에 대해서 기본을 탄탄하게 만드는 계기가 되어서, 분석하는데 많은 도움이 되었으면 좋겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cs186berkeley.net/&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cs186.gitbook.io/project/&#34;&gt;CS186 Berkeyly - Project&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DBMS 랭킹 사이트</title>
      <link>https://dongwooklee96.github.io/post/2021/12/09/dbms-%EB%9E%AD%ED%82%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8.html</link>
      <pubDate>Thu, 09 Dec 2021 10:19:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/09/dbms-%EB%9E%AD%ED%82%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/hjfkvkme0fxlt4v/Screen%20Shot%202021-12-09%20at%2010.18.58%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 랭킹을 매겨주는 사이트를 발견하였다. &lt;a href=&#34;https://db-engines.com/en/&#34;&gt;db-engines&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;점수에 따른 랭킹을 보여주고, 트랜드 또한 보여준다. 그리고 DBMS 종류마다 분류할 수 있어서 나중에 특정 DBMS를 선택할 때 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한국에서 만든 큐브리드나, 알티베이스도 랭크되어있어서 신기했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://db-engines.com/en/&#34;&gt;db-engines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 테스트를 위한 더미 데이터 생성 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/12/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%8D%94%EB%AF%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Wed, 08 Dec 2021 10:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/12/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%8D%94%EB%AF%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우아한 형제들 기술 블로그를 보다가, &lt;code&gt;MySQL&lt;/code&gt;, &lt;code&gt;PostgreSQL&lt;/code&gt;을 비교하는 글을 보게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글에서 더미데이터를 생성하는 방법 및 테이블에 있는 인덱스 크기를 확인하는 방법에 대해서 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실제로 많은 테스트를 해보려면, 이러한 테스트를 많이 해볼 수록 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;더미-데이터-생성-방법&#34;&gt;더미 데이터 생성 방법&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 테이블 생성
CREATE TABLE USERS (
    id int auto_increment primary key,
    id2 int,
    Name varchar(100),
    Address varchar(512)
);

-- 더미 데이터 생성
INSERT INTO USERS(id2, Name, Address)
SELECT FLOOR(1 + RAND() * 50000000),
A.table_name, A.table_name
FROM information_schema.tables A
CROSS JOIN information_schema.tables B
CROSS JOIN information_schema.tables C
CROSS JOIN information_schema.tables D
limit 10000000;

explain select count(*) from USERS A inner join USERS B ON A.id2=B.id2;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 예제는 &lt;code&gt;10000000&lt;/code&gt;의 데이터를 생성하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인덱스-크기를-확인하는-방법&#34;&gt;인덱스 크기를 확인하는 방법&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select table_name,index_name,
round(stat_value*16384/1024/1024) size_in_mb
from mysql.innodb_index_stats
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 예제는 &lt;code&gt;MySQL&lt;/code&gt;에서 인덱스 크기를 확인하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;innodb_index.stats&lt;/code&gt; 라는 통계정보를 저장하는 테이블에서 이를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://techblog.woowahan.com/6550/&#34;&gt;Aurora MySQL vs Aurora PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스를 공부할 때 TRACING을 하는 법을 먼저 배우자</title>
      <link>https://dongwooklee96.github.io/post/2021/11/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-tracing%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B2%95%EC%9D%84-%EB%A8%BC%EC%A0%80-%EB%B0%B0%EC%9A%B0%EC%9E%90.html</link>
      <pubDate>Thu, 25 Nov 2021 18:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-tracing%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B2%95%EC%9D%84-%EB%A8%BC%EC%A0%80-%EB%B0%B0%EC%9A%B0%EC%9E%90.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오라클 성능 고도화라는 강의를 들을 때, &lt;code&gt;AUTO TRACE&lt;/code&gt; 도구로 실제 실행한 쿼리에서 읽은 네트워크 시간 및 IO에 대한 통계를 측정할 수 있는 도구가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 시스템 정보를 나타내는 내부적으로 생성된 테이블이 많이 있다. 이런 것을 통해서도 데이터베이스에 대해서 많은 정보를 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 소스 코드를 먼저 보는 것보다는 문서와 데이터베이스에 어떤 기능이 있는지 그리고 어떻게 확인할 수 있는지를 먼저 보는 것이 우선이 되어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.postgresql.org/docs/14/catalogs-overview.html&#34;&gt;System Catalogs - PostgresSQL&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/information-schema-innodb-tables/&#34;&gt;Information Schema InnoDB Tables - MariaDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>POSTGRES 소스코드로부터 빌드하는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/11/22/postgres-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EB%A1%9C%EB%B6%80%ED%84%B0-%EB%B9%8C%EB%93%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Mon, 22 Nov 2021 08:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/22/postgres-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EB%A1%9C%EB%B6%80%ED%84%B0-%EB%B9%8C%EB%93%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/51279446/how-to-install-the-cube-function-for-postgresql&#34;&gt;PostgreSQL: сборка из исходников и настройка под Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[MOBILE] 플러터에서 위젯이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/11/14/mobile-%ED%94%8C%EB%9F%AC%ED%84%B0%EC%97%90%EC%84%9C-%EC%9C%84%EC%A0%AF%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Sun, 14 Nov 2021 12:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/14/mobile-%ED%94%8C%EB%9F%AC%ED%84%B0%EC%97%90%EC%84%9C-%EC%9C%84%EC%A0%AF%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;플러터 애플리케이션은 위젯으로 만들어지고, 위젯들은 사용자 인터페이스의 일부를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 사용자 상호작용과 사용자가 앱을 탐색할 때 볼 수 있는 모든 것은 위젯으로 만들어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앱 자체가 위젯이라고 보면 된다. 따라서 플러터를 사용하기전에 &amp;ldquo;플러터에서는 모든 것이 위젯이다&amp;rdquo; 라고 보면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 모바일 프레임워크에서는 사용자 인터페이스를 묘사하기 위해서, XML 또는 HTML 형태와 비즈니스 로직을 위한 프로그래밍 언어를 사용하지만 플러터에서는 다트를 사용하여 사용자 인터페이스와 앱의 비즈니스 로직을 모두 묘사한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=273800149&#34;&gt;플러터 프로젝트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>POSTGRES 익스텐션 설치 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/11/12/postgres-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Fri, 12 Nov 2021 10:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/12/postgres-%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98-%EC%84%A4%EC%B9%98-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 &lt;code&gt;POSTGRES&lt;/code&gt;에서 익스텐션을 설치할 일이 있어서 설치하는 방법을 찾아보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 설치할 익스텐션은 &lt;code&gt;tablefunc&lt;/code&gt;, &lt;code&gt;dict_xsyn&lt;/code&gt;, &lt;code&gt;fuzzystrmatch&lt;/code&gt;, &lt;code&gt;pg_tgram&lt;/code&gt;, &lt;code&gt;cube&lt;/code&gt;와 같은 것들이 있었는데&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래와 같이 &lt;code&gt;CREATE EXTENSION&lt;/code&gt;을 쓰고 그 뒤에 원하는 익스텐션을 적으면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE EXTENSION cube;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/51279446/how-to-install-the-cube-function-for-postgresql&#34;&gt;How to install the cube function for Postgresql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Write-Scale Out MariaDB Xpand (10 node cluster) 세미나를 듣고 기록한 내용</title>
      <link>https://dongwooklee96.github.io/post/2021/09/08/write-scale-out-mariadb-xpand-10-node-cluster-%EC%84%B8%EB%AF%B8%EB%82%98%EB%A5%BC-%EB%93%A3%EA%B3%A0-%EA%B8%B0%EB%A1%9D%ED%95%9C-%EB%82%B4%EC%9A%A9.html</link>
      <pubDate>Wed, 08 Sep 2021 14:10:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/08/write-scale-out-mariadb-xpand-10-node-cluster-%EC%84%B8%EB%AF%B8%EB%82%98%EB%A5%BC-%EB%93%A3%EA%B3%A0-%EA%B8%B0%EB%A1%9D%ED%95%9C-%EB%82%B4%EC%9A%A9.html</guid>
      <description>&lt;h3 id=&#34;세미나&#34;&gt;세미나&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.linkedin.com/in/jacob-hyeon-gi-jo-78089858/&#34;&gt;세미나 관련 링크&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;평소에 링크드인을 보면서 대단하다고 느낀분이 있는데 그 분이 세미나를 한다고 하셔서 들어보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분산 데이터베이스 환경에서 WRITE-SCALE-OUT 및 높은 부하를 처리해주는 XPAND라는 것을 설명해주셨는데 조금은 어려웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;관련-내용-정리&#34;&gt;관련 내용 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;분산 데이터베이스에서는 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 는 사용하지 않는 것이 좋다. 키를 만들때마다 각 노드별로 어떤 키를 가지고 있는지 확인해야 하기 때문에 병목의 요소가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AUTO_UNIQUE&lt;/code&gt;를 사용하거나 인조 식별자가 아니라, 업무 식별자를 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분산 환경에서는 네트워크 부하를 최대한 줄이는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ERD&lt;/code&gt;는 반드시 작성하는 것이 좋다. 많은 업체들이 &lt;code&gt;ERD&lt;/code&gt; 없이 작업하는 경우가 많은데 &lt;code&gt;ERD&lt;/code&gt; 테이블은 반드시 작성하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;몰랐던-것&#34;&gt;몰랐던 것&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qps&lt;/code&gt;란 무엇인가?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;초당 처리할 수 있는 쿼리 수를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;배운-점&#34;&gt;배운 점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;실수로 어떤 테이블을 조회할 때 LIMIT를 걸지 않고 조회할 때가 있는데 그렇지 않기 위해서 주의를 해야겠다. 데이터베이스 서버에 많은 부하를 주기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>데드락이란? (DeadLock) (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/24/%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80-deadlock-draft.html</link>
      <pubDate>Thu, 24 Jun 2021 11:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/24/%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80-deadlock-draft.html</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123192882-b8038a00-d4de-11eb-91a0-5e434f43c548.png&#34; alt=&#34;ScreenShot 2021-06-24 at 11 23 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전달된 에러를 추적하다가, 아래와 같은 데드락 에러를 만나게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;InternalError: 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;정확한 문제 해결을 위해서 이번 기회에 데드락에 대해서 한번 더 정리를 해보고, 마리아 데이터베이스에서는 어떠한 경우에 데드락이 발생할 수 있는지를 알아보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데드락이란-무엇인가&#34;&gt;데드락이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123194903-31e94280-d4e2-11eb-8d24-336d333a18c3.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;교착상태 (&lt;code&gt;deadlock&lt;/code&gt;)이란 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 데이터베이스에서 발생하는 데드락은 &lt;code&gt;DBMS&lt;/code&gt;가 감지하여 실행되는 트랙잭션들 사이에 발생하는 데드락으로 각각의 트랜잭션이 사용하는 데이터들 사이의 데드락을 감지하여 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;innodb에서-deadlock-확인하기&#34;&gt;InnoDB에서 DeadLock 확인하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InnoDB&lt;/code&gt;는 트랜잭션을 실행시 데드락이 발생하게 되면 그것을 감지하고, 하나의 트랜잭션을 롤백하여 데드락을 해소하고, 그 정보를 로그로 남긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SHOW ENGINE INNODB STATUS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123194595-bc7d7200-d4e1-11eb-9ceb-57e78504e5f6.png&#34; alt=&#34;Screen Shot 2021-06-24 at 11 45 24 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 구문을 통해서 정보를 얻을 수 있지만 비교적 최신 기록만 남아있다. 따라서 장애가 발생하였을 때 바로 확인해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지 항목이 있는데, 항목의 자세한 값은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123203522-78926900-d4f1-11eb-99ae-2096e41fe46e.png&#34; alt=&#34;Screen Shot 2021-06-24 at 1 38 09 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mysqldba.tistory.com/54&#34;&gt;InnoDB에서 Deadlock 발생 내역 분석하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/show-engine-innodb-status/&#34;&gt;SHOW ENGINE INNODB STATUS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html&#34;&gt;Deadlocks in InnoDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/set-transaction/&#34;&gt;SET TRANSACTION&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html&#34;&gt;How to Minimize and Handle Deadlocks&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jeong-pro.tistory.com/94&#34;&gt;Exclusive Lock과 Shared Lock의 차이&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jsonobject.tistory.com/427#recentComments&#34;&gt;트랜잭션과 격리레벨&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>쿼리 캐시란? (MARIADB)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/04/%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C%EB%9E%80-mariadb.html</link>
      <pubDate>Fri, 04 Jun 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/04/%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C%EB%9E%80-mariadb.html</guid>
      <description>&lt;h3 id=&#34;쿼리-캐시&#34;&gt;쿼리 캐시&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시란, &lt;code&gt;SELECT&lt;/code&gt; 쿼리문을 이용하여 조회한 값을 저장하고 있다가, 같은 쿼리 문을 요청하였을 때 미리 캐싱된 값을 반환하는 &lt;code&gt;DBMS&lt;/code&gt; 기능이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 웹사이트와 같이 쓰기 (&lt;code&gt;WRITE&lt;/code&gt;)보다, 읽는 (&lt;code&gt;READ&lt;/code&gt;) 횟수가 많은 환경에서 유용하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 멀티 코어 시스템 및 처리량이 높은 환경에서는 확장성이 좋지 않으므로 기본적으로 사용되지 않도록 설정된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쿼리-캐시-기능을-사용하기&#34;&gt;쿼리 캐시 기능을 사용하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시 기능을 사용할 수 있는지 확인하려면, 기본적으로 &lt;code&gt;have_query_cache&lt;/code&gt; 설정이 되어 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정이 되어있는지 확인하고 싶다면, 아래와 같은 쿼리 문을 입력한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;HAVE_QUERY_CACHE&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;조회 결과 &lt;code&gt;YES&lt;/code&gt;로 나온다면, 쿼리 캐시 기능을 사용할 수 있다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;QUERY_CACHE_TYPE&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;그 다음에는 현재 시스템에서 쿼리 캐시 기능을 사용하고 있는지를 조회해 볼 것이다. 위의 쿼리 결과가 &lt;code&gt;ON&lt;/code&gt;으로 나온다면 이미 쿼리 캐시 기능을 적용하고 있다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쿼리-캐시가-되지-않는-경우&#34;&gt;쿼리 캐시가 되지 않는 경우&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;아래와 같은 함수를 사용하면, 기본적으로 쿼리가 캐싱되지 않는다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;BENCHMARK()
CONNECTION_ID()
CONVERT_TZ()
CURDATE()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_DATE&lt;/span&gt;()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIME&lt;/span&gt;()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt;()
CURTIME()
&lt;span style=&#34;color:#66d9ef&#34;&gt;DATABASE&lt;/span&gt;()
ENCRYPT() (one &lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt;)
FOUND_ROWS()
GET_LOCK()
LAST_INSERT_ID()
LOAD_FILE()
MASTER_POS_WAIT()
NOW()
RAND()
RELEASE_LOCK()
SLEEP()
SYSDATE()
UNIX_TIMESTAMP()
(&lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;parameters&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;USER&lt;/span&gt;()
UUID()
UUID_SHORT()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;또한 쿼리에 아래와 같은 구문이 있을 경우 쿼리가 캐싱되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; SQL_NO_CACHE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; OUTFILE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; DUMPFILE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; autoincrement_column &lt;span style=&#34;color:#66d9ef&#34;&gt;IS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;쿼리-캐시-크기를-제한하기&#34;&gt;쿼리 캐시 크기를 제한하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120759865-6f475980-c54e-11eb-8b81-ad5975fa0449.png&#34; alt=&#34;Screen Shot 2021-06-04 at 4 03 22 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시 크기를 제한하기 전에, 우선 쿼리 캐시 크기 설정을 살펴보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 설정을 통해서 &lt;code&gt;query_cache_size&lt;/code&gt; 값을 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿼리의 빈도수가 적고, 데이터가 많이 조회되는 쿼리가 있을 것이다. 이런 경우에는 캐싱을 할 필요가 없으므로, &lt;code&gt;query_cache_limit&lt;/code&gt; 옵션으로 크기를 설정해서 특정 결과값의 용량이 설정해놓은 값이 넘으면 캐싱하지 않도록 설정을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;캐시-설정-및-의미&#34;&gt;캐시 설정 및 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SHOW STATUS LIKE &#39;Qcache%&#39;;
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks      | 1158     |
| Qcache_free_memory      | 3760784  |
| Qcache_hits             | 31943398 |
| Qcache_inserts          | 42998029 |
| Qcache_lowmem_prunes    | 34695322 |
| Qcache_not_cached       | 652482   |
| Qcache_queries_in_cache | 4628     |
| Qcache_total_blocks     | 11123    |
+-------------------------+----------+
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 쿼리를 입력하면, 쿼리 캐싱과 관련된 설정 값들이 나오게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;중요한 옵션값만 확인하자면, &lt;code&gt;Qcache_inserts&lt;/code&gt;는 현재, 캐싱된 쿼리의 값을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_hits&lt;/code&gt;는 쿼리를 캐싱하여, 캐싱된 값을 반환한 값을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_lowmem_prunes&lt;/code&gt;는 메모리 값이 부족하여, 캐시에서 이전에 있던 값을 제거한 값이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_lowmem_prunes&lt;/code&gt; 값을 줄이려면 앞서 말했던, &lt;code&gt;query_cache_limit&lt;/code&gt; 값을 적절히 설정해주면 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그 밖에도,  &lt;code&gt;query_cache_wlock_invalidate&lt;/code&gt; 옵션을 끄면,  &lt;code&gt;WRITE&lt;/code&gt; 락이 걸려있더라도, 캐싱된 값을 반환하게 하여, 경합 상태에서도 기다리지 않고 값을 읽을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;캐시된 쿼리를 잘 이용하면, 성능을 높일 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실제 &lt;code&gt;SQL&lt;/code&gt;문은 대소문자를 구분하지 않지만, 캐싱된 쿼리 값을 반환받기 위해서는 대소문자까지 같아야 하므로, 팀 내에서 쿼리문을 통일성 있게 작성하는 노력을 해야할 것이다.그 밖에도 동일한 쿼리라는 것을 인식하려면 여러 값들이 일정해야한다. 이는 아래 내용을 참조하도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120763124-e16d6d80-c551-11eb-9914-0df5d697cc98.png&#34; alt=&#34;Screen Shot 2021-06-04 at 4 28 16 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿼리 캐시 값의 크기를 크게 늘리면, 읽기 속도는 빨라지겠지만, 락 경합 때문에 쓰기 속도는 느려질 수 있다. 최적값을 찾아서 적용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/query-cache/&#34;&gt;Query Cache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>오라클 성능 고도화 강의 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1.html</link>
      <pubDate>Sat, 08 May 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1.html</guid>
      <description>&lt;h3 id=&#34;오라클-성능-고도화-강의&#34;&gt;오라클 성능 고도화 강의&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117525284-6ec5ac80-affc-11eb-8e4f-f245c5ef8828.jpeg&#34; alt=&#34;IMG_5C71B9160877-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에, 한번 튜닝 수업을 들은 적이 있었지만, 아직 경험이 부족한 상태에서 들어서 그런지 이해가 가지 않는 부분이 많았다. 실무를 조금 해보면서, 어느정도 쿼리에 익숙해진 상태에서 강의를 들으면 어떨까라는 생각이 들어서 강의를 수강하게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;sqlp-시험에-실패하는-이유&#34;&gt;SQLP 시험에 실패하는 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SQLP 시험에 실패하는 이유는 주로 글로만 학습해서 그렇다.&lt;/li&gt;
&lt;li&gt;SQLP 시험 설계는 실무 전문가임을 인정해주는 자격증이다.&lt;/li&gt;
&lt;li&gt;따라서 책으로만 학습해서 통과는 어렵고, 실무와 경험을 같이 쌓아야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-방법&#34;&gt;SQLP 시험에 합격하기 위한 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;정확히 알아야한다.&lt;/li&gt;
&lt;li&gt;상황에 따라서 답이 달라짐을 알아야한다. (DBMS 버전, 데이터 량, 데이터 분포 등등&amp;hellip;)&lt;/li&gt;
&lt;li&gt;집합적 사고를 할 줄 알아야한다. 이러한 능력은 실무에서 반복을 통해서 체화된다.&lt;/li&gt;
&lt;li&gt;모델링에 대한 이해가 같이 이루어져야한다. 따라서 모델링도 어느정도는 같이 공부를 해야한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-전략&#34;&gt;SQLP 시험에 합격하기 위한 전략&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;무조건 서술형을 다 맞춰야지 합격이 가능하다. 점수 분포가 서술형에 많은 점수가 있기 때문에 서술형을 다 맞지 않으면 합격이 힘들어진다.&lt;/li&gt;
&lt;li&gt;서술형을 먼저 풀고, 객관식을 풀고 객관식 중에서 쉬운 문제를 먼저 풀고 어려운 문제는 나중에 푼다.&lt;/li&gt;
&lt;li&gt;서술형을 답안을 작성할 때, 정확한 진단을 하고 핵심만 간결하게 그리고 절대로 길게 작성하면 안된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;chap-01-데이터베이스-아키텍처-sql-처리-과정-및-io&#34;&gt;CHAP 01. 데이터베이스 아키텍처, SQL 처리 과정 및 IO&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일단 오라클 아키텍처에 대해서, 제대로 알지 못해서 많이 당황스러웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REDO로그 및 UNDO 로그에 대해서 자세히 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버퍼 캐시 및, 버퍼 캐시 탐색 과정, 그리고 버퍼 캐시 히트율을 계산하는 방법에 대해서, 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시퀀셜 액세스와 랜덤 액세스의 원리 및 &lt;code&gt;Single Block IO&lt;/code&gt;와 &lt;code&gt;Multi Block IO&lt;/code&gt;의 차이에 대해서도 남에게 설명할 수 있을 정도로 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오라클 힌트에 대해서 자세히 공부하고 힌트가 적용되지 않는 경우에 내부적으로 쿼리가 변환되는 경우가 있는데, 이러한 경우에 대해서도 들어본 기억은 있는데 확실하게 개념이 잡혀있지는 않았다. 따라서 힌트 관련해서 많은 것을 배워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc-milti-version-concurrency-control&#34;&gt;MVCC (Milti Version Concurrency Control)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dirty Read : 다른 트랜잭션이 변경중인 데이터를 읽었는데, 그 트랜잭션이 최종 롤백 됨으로써 비일관성 상태에 놓이는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-Repetable Read : 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 값을 수정 또는 삭제 함으로써 읽은 값들이 서로 달라지는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phantom Read : 한 트랜잭션 내에서, 일정 범위의 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가함으로 인해 첫 번째 읽을 때 없던 데이터가 생기는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션이 실행 될 때, &lt;code&gt;UNDO&lt;/code&gt; 세그 먼트 헤더에 위치한 트랜잭션 테이블에서 슬롯을 할당 받는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 &lt;code&gt;UNDOO&lt;/code&gt; 레코드에는 &lt;code&gt;ITL SLOT&lt;/code&gt;이 있고, 블록에 속한 레코드 갱신을 위해서, &lt;code&gt;ITL&lt;/code&gt; 슬롯을 먼저 확보한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋이 이루어지면, 블록 클린아웃을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 클린 아웃 되지 않은 블록에 작업을 하게 되면, &lt;code&gt;SNAP SHOT TOO OLD&lt;/code&gt;가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>윈도우 함수에서 WHERE 절을 사용하지 못하는 이유(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft.html</link>
      <pubDate>Tue, 13 Apr 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learnsql.com/blog/window-functions-not-allowed-in-where/&#34;&gt;Why Window Functions Are Not Allowed in WHERE Clauses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE-LOCK(2PL)이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Wed, 07 Apr 2021 18:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;two-phase-lock&#34;&gt;TWO PHASE LOCK&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949645-b4028d00-984a-11eb-98e5-e1d592569831.png&#34; alt=&#34;100518_0439_DBMSConcurr1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949641-b238c980-984a-11eb-8ae0-64619edcf82c.png&#34; alt=&#34;2PL&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PC(TWO PHASE COMMIT)&lt;/code&gt;과 헷갈리는 개념이 있다. 그것은 바로 &lt;code&gt;2PL(TWO PHASE LOCK)&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2단계 잠금 프로토콜은 트랜잭션 도줌에 락을 걸어서 동일한 데이터에 동시에 접근하려는 트랜잭션을 차단하여 직렬화를 보장하는 &lt;code&gt;DBMS&lt;/code&gt;의 동시 제어 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt;의 동시성 문제를 해결하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 잠금 프로토콜은 트랜잭션의 실행 단계를 세 단계로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 번째 단계에서는 트랜잭션이 실행되기 시작할 때 필요한 락에 대한 권한을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 부분은 트랜잭션이 모든 락 권한을 얻는 부분이다. 트랜잭션이 첫 번째 락을 해제할 때 세번째 단계가 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 세 번째 단계에서는 트랜잭션이 새로운 락을 요청할 수 없으며, 대신 획득한 락을 해제할 수 만 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;2PL&lt;/code&gt;에서는 각 트랜잭션이 두 단계로 락 획득 또는 해제 요청을 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Growing Phase&lt;/strong&gt;: 이 단계에서는 오직 잠금을 획득할 수 있고, 해제할 수는 없다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shrinking Phase&lt;/strong&gt;: 이 단계에서는 트랜잭션이 잠금을 해제할 수는 있지만 새로운 잠금을 획득하지는 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PL&lt;/code&gt; 프로토콜 방식은 직렬화는 보장하지만, 교착 상태가 발생하지 않도록 보장하지 못한다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/two-phase-locking-protocol/&#34;&gt;Two Phase Locking protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.guru99.com/dbms-concurrency-control.html#5&#34;&gt;dbms-concurrency-control&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ARIES란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft.html</link>
      <pubDate>Wed, 31 Mar 2021 22:56:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&#34;&gt;WIKI - ARIES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스에 대해서 배울 수 있는 좋은 강의 (CS186Berkeley)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley.html</link>
      <pubDate>Wed, 31 Mar 2021 20:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley.html</guid>
      <description>&lt;p&gt;우연히 유튜브에서 데이터베이스에 대해서 체계적이고 좋은 영상이 있는 것을 발견하였다.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/ZLtwOp8pz_Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;커리큘럼을 보면, 초반에는 디스크, 버퍼, 파일 및 인덱스 B+Tree 부터 시작해서 간단한 &lt;code&gt;SQL&lt;/code&gt; 및 간단하 쿼리 튜닝까지 배운다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154480-0227f700-9273-11eb-9683-6ac82864c697.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154484-03592400-9273-11eb-8897-6de7f64fb366.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고, 트랜잭션 처리 부터 시작해서, 병렬 쿼리 실행 그리고 분산 트랜잭션 처리까지 철저하게 배운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심지어 과제 및 시험문제도 풀어볼 수 있다. &lt;a href=&#34;https://cs186.gitbook.io/project/assignments/proj0&#34;&gt;CS186&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;남는시간에 틈틈히 DBMS에 대해서 공부하면서 부족했던 기본기를 튼튼하게 하면서, 오픈 소스에 기여할 때 도움이 되도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt; 프로젝트를 이해할 때, 기본기에 대한 부족함을 많이 느꼈다. 따라서 이 강의를 통해서 기본기를 다진다면 한결 흐름을 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/user/CS186Berkeley/videos&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>슬로우 쿼리란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft.html</link>
      <pubDate>Mon, 29 Mar 2021 20:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;슬로우-쿼리란&#34;&gt;슬로우 쿼리란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&#34;&gt;MySql - The Slow Query Log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리플리케이션이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 17:43:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;gelera-리플리케이션&#34;&gt;Gelera 리플리케이션&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113364491-a05caf80-938e-11eb-8a11-e5933db7f28d.png&#34; alt=&#34;Screen Shot 2021-04-02 at 8 36 21 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MariaDB&lt;/code&gt; 클러스터에서, 서버는 트랜잭션과 관련된 쓰기를 클러스터의 모든 노드에 브로드캐스트해서 커밋을 할 때, 모든 노드에 트랜잭션을 복사한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트는 &lt;code&gt;DBMS&lt;/code&gt;에 직접 연결하여 대부분의 경우 기본의 &lt;code&gt;MariaDB&lt;/code&gt;와 유사한 동작을 경험할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wsrep(write set replication API)&lt;/code&gt;를 이용하여 &lt;code&gt;Galera&lt;/code&gt; 리플리케이션과 &lt;code&gt;MariaDB&lt;/code&gt; 사이의 인터페이스를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;동기-vs-비동기-리플리케이션&#34;&gt;동기 vs 비동기 리플리케이션&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동기식 복제와 비동기식 복제의 기본적인 차이점은 동기식 복제는 클러스터에서 한 노드에서 변경이 발생한 경우에, 클러스터의 다른 노드에서 동기적으로 변경이 발생한다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비동기적인 복제는 마스터 노드에 변경사항을 적용하는 것과 슬레이브 노드에 변경사항을 전파 하는 도중에 데이터가 다를 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 마스터 노드가 비동기적인 복제 중에 오류가 생기면 변경 사항중에 일부가 손상 될 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 이점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 가용성이 높다.&lt;/li&gt;
&lt;li&gt;노드중에 하나가 손실 되더라도 데이터는 손실되지 않으며 모든 클러스터 노드는 항상 일관적이다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터를 사용하면, 모든 노드에 동시에 트랜잭션을 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 전체 클러스터에서 인과 관계를 보장할 수 있다. 즉, 클러스터 노드에서 트랜잭션을 실행한 후에 하나의 클러스터 노드에서 &lt;code&gt;SELECT&lt;/code&gt;가 실행되는 경우 해당 트랜잭션의 영향을 확인해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만, 동기식 데이터베이스 복제는 전통적으로 매우 느린것으로 판명된 &lt;code&gt;2PC(two phase commit)&lt;/code&gt;또는 분산 잠금을 통해서 구현되었다.&lt;/li&gt;
&lt;li&gt;동기식 복제의 낮은 성능과 구현의 복잡성으로 인해서 비동기식 복제가 데이터베이스 성능 확장성 및 가용성의 주요 수단으로 사용되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만, &lt;code&gt;Galera&lt;/code&gt;의 리플리케이션은 완전하게 동기화된 것은 아니지만 이것은 가상 동기 리플리케이션이라고 불린다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/about-galera-replication/&#34;&gt;About Galera Replication&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>쿼리 오프 로딩이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 17:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스토리지 티어링이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sat, 27 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;스토리지-티어링이란&#34;&gt;스토리지 티어링이란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>샤딩이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;샤딩&#34;&gt;샤딩&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클러스터링이란?(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;클러스터링&#34;&gt;클러스터링&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/docs/multi-node/galera-cluster/understand-mariadb-enterprise-cluster/#architecture&#34;&gt;Understanding MariaDB Enterprise Cluster&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://kaaproject.github.io/kaa/docs/v0.10.0/Administration-guide/System-installation/Cluster-setup/MariaDB-cluster-setup-guide/&#34;&gt;MariaDB cluster setup&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/what-is-mariadb-galera-cluster/&#34;&gt;What is MariaDB Galera Cluster?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://menakamadushanka.wordpress.com/2017/12/15/how-to-deploy-a-mysql-cluster-from-scratch-with-docker/&#34;&gt;How to deploy a MySQL Cluster from Scratch with Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CONCURRENCY(동시성)와 PARALLELISM(병행성) (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft.html</link>
      <pubDate>Sat, 27 Mar 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft.html</guid>
      <description>&lt;h3 id=&#34;concurrency동시성와-parallelism병행성&#34;&gt;CONCURRENCY(동시성)와 PARALLELISM(병행성)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112660338-af2bf980-8e98-11eb-8aec-e165f24e7fde.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;병행성&#34;&gt;병행성&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성&#34;&gt;동시성&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CONCURRENCY(동시성)&lt;/strong&gt; 에서 가장 중요한 것은 동시에 수행되는 기능들의 빠른 반응이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 빠른 반응은, 운영체제의 핵심인 커널에서 프로세스 스케줄러가 선점형(&lt;code&gt;Preemption&lt;/code&gt;)으로 동작하느냐가 관건이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 자원은 한정되어 있는데 반해서 작업 진행이 필요한 프로세스들은 여러 개가 생길 수 있다. 이때 CPU 자원을 어떻게 분배하느냐가 스케줄링이 필요한 이유이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컴퓨터에서 사용자가 파일을 다운로드 받을 때 파일을 다운로드 받는 프로세스가 &lt;code&gt;CPU&lt;/code&gt; 자원을 할당 받아서 작업을 진행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이때 사용자가 뮤직 플레이를 실행 시켜서 또 다른 프로세스가 생성되었다고 할 때 비선점형의 경우에는 파일을 다운로드 받는 프로세스 작업이 끝나야 음악을 플레이 하는 프로세스가 CPU 자원을 할당 받아서 작업을 진행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 파일 다운로드가 완료될 때까지 음악이 나오지 않을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선점형 스케줄링의 경우에는 스케줄러가 강제로 그 즉시 음악을 플레이하는 프로세스에게 자원을 할당해주고, 상황에 따라서 적당히 &lt;code&gt;CPU&lt;/code&gt; 자원을 분배하여 두 개의 프로세스가 작업을 진행하는데 문제가 없도록 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 자세히 들어가면 비선점형 스케줄링 방식을 사용하더라도 여러 가지 방법을 통해서 동시에 실행되는 것 처럼 보이게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>트랜잭션과 ACID</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid.html</link>
      <pubDate>Fri, 26 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid.html</guid>
      <description>&lt;p&gt;누군가 트랜잭션에 대해서 물어보았을 때, 분명히 알고 있다고 생각한 것인데도 제대로 답변하지 못했다. 이건 평소에 생각이 정리되지 않아서 그런 것 같다. 따라서 이참에 이에 대해서 정리를 해보도록 했다.&lt;/p&gt;
&lt;h3 id=&#34;트랜잭션이란&#34;&gt;트랜잭션이란&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112649044-6de21c80-8e8d-11eb-9e40-2f597a3555ac.png&#34; alt=&#34;트랜잭션&#34;&gt;&lt;/p&gt;
&lt;p&gt;위키 백과에서는 트랜잭션을 다음과 같이 정의하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 트랜잭션은 데이터베이스에 대해서 DBMS 내에서 수행되고 다른 트랜잭션과 무관하게 일관되고 신뢰할 수 있는 방식으로 처리되는 작업 단위를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션은 일반적으로 데이터베이스의 모든 변경 사항이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 환경의 트랜잭션에는 두 가지의 주요 목적이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행 중지 (완전 및 부분적으로) 및 데이터베이스에 대한 많은 작업이 완료되지 않은 상태로 남아있는 경우에 장래로부터 정확하게 복구하고 데이터베이스를 일관성 있게 유지할 수 있는 신뢰할 수 있는 작업 단위를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 동시에 액세스 하는 프로그램 간에 분리를 제공한다. 이러한 분리를 제공하지 않으면 프로그램의 결과가 잘못될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112650101-6707d980-8e8e-11eb-8d32-a92f3bce761b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;ACID 트랜잭션은 관계형 데이터베이스에서 여러 개의 SQL 연산을 하나의 단일 트랜잭션으로 처리하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;여러 개의 테이블에 대해서 읽고 쓰고 하는 행동을 하나의 연산처럼 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID 라는 단어는 분해할 수 없이 원자적(Atomicity)이고, 일관된(Consistency) 데이터 상태를 유지하고, 고립(Isolation)되어 다른 연산이 끼어들 수 없고, 데이터가 영원히(Durability) 반영된 상태로 있는 것을 의미한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;원자성(Atomicity) : 데이터베이스에서 가장 중요한 개념은 원자성일것이다, 여러개의 SQL 연산이 하나의 연산 처럼 동작해야한다. 어느 것 하나라도 실패했다면 모든 연산이 실행되지 않아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 같은 시점에 접속하는 클라이언트는 항상같은 데이터를 보고 있어야 한다는 것이다. 동일한 시간에 A와 B가 요청을 할 때, A가 읽은 데이터와 B가 읽은 데이터가 다르다면 아주 기본적인 일관성이 보장되지 않은 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고립성(Isolation) : 트랜잭션이 수행되는 동안에, 다른 연산이 끼어들지 못한다는 것이다. 이에 대해서는 고립 수준이라는 것이 있는데 이는 나중에 자세히 알아보도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;영속성(Durability) : 트랜잭션이 완료된 이후의 데이터는 업데이트 된 상태 그대로 영원히 반영되어 있다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Database_transaction&#34;&gt;WIKI - Database transaction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CAP 이론이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;cap-정리&#34;&gt;CAP 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112651209-86533680-8e8f-11eb-9579-2d9a2389ce27.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CAP 정리에 의하면 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림에서 볼 수 있듯이, Consistency, Availablity를 합치면, &lt;code&gt;CA&lt;/code&gt; 또는 Consistency와 Partition tolerance를 조합하면 &lt;code&gt;AP&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 모든 속성을 다 포함한 시스템은 절대로 존재할 수 없다는 것이 CAP 정리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;각-특징의-의미&#34;&gt;각 특징의 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. &lt;code&gt;ACID&lt;/code&gt; 원리에서 의미하는 것과 같다. 어떤 데이터베이스 속성에 &lt;code&gt;C&lt;/code&gt;가 있다면, 트랜잭션 기능 또는 그와 비슷한 매커니즘이 존재한다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가용성(Availablity) : 가용성은 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 처리 응답을 보애주어야 한다는 것을 의미한다. 클라이언트가 읽기, 쓰기 요청을 하면 제대로 읽고 쓰는 작업을 해야한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분단 허용성(Partition tolerance) : 분단 허용성은 클러스터가 여러 대 동작하고 있을 때, 해당 클러스터 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 시스템이 잘 동작해야 한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;관계형 데이터베이스는 CA 시스템이다. 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다.
만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;해결책은 간단한데, CA를 포기하면 된다. CA를 포기한다는 뜻이 극단적으로 일관성과 가용성을 포기하는 것이 아닌 1 ~ 100까지의 수치가 있을 때 일관성과 가용성을 100% 지원하던 것에서 수치를 60%로 낮춘다고 생각을 하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;대부분의 NoSQL 데이터베이스는 CA가 아닌 CP나 AP 시스템이다. 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MVCC(다중 버전 동시성 제어)란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE COMMIT 이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;two-phase-커밋이란&#34;&gt;TWO-PHASE 커밋이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113822026-dd260d80-97b7-11eb-8ea8-b3c939d08cec.png&#34; alt=&#34;95&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;투 페이즈 커밋은 여러 노드에 거쳐서 원자성 트랜잭션 커밋을 달성하기 위한 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분산 데이터베이스의 트랜잭션 처리를 위해서 사용하는 고전적인 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC에서는 일반적으로 단일 노드 트랜잭션에서는 나타나지 않는 새로운 구성 요소인 코디네이터(트랜잭션 관리자)를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC 트랜잭션은 애플리케이션이 정상적으로 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋할 준비가 되면 트랜잭션 관리자는 1 단계를 시작한다. 그런 다음에 각 노드에 준비 요청을 보내서 커밋 가능 여부를 묻게 되며, 참가자의 응답에 따라서 커밋을 할지, 롤백을 할지 결정을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 노드가 &amp;ldquo;예&amp;rdquo; 라고 대답하여, 커밋할 준비가 되었다고 하면, 트랜잭션 매니저는 2단계에서 커밋 요청을 전송하고 커밋이 실제로 수행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자가 &amp;ldquo;아니오&amp;quot;라고 대답하면 코디네이터는 2단계의 모든 노드에 중단 요청을 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113823077-32aeea00-97b9-11eb-888f-4a5f9b9d2ae5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 과정은 결혼식에 비유할 수 있는데, 주례자가 신랑과 신부에서 각각 결혼하고 싶은지 물어보고, 모두 결혼을 하고 싶다는 대답을 받고 나서, 결혼식을 마무리하는 과정이라고 비유를 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주례자는 트랜잭션 매니저이며, 신랑과 신부는 각 데이터베이스 노드들이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;two-phase-커밋의-단점&#34;&gt;TWO-PHASE 커밋의 단점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;2PC의 가장 큰 단점은 블록킹이라는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Two-phase_commit_protocol&#34;&gt;Two-phase commit protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ebrary.net/64872/computer_science/introduction_phase_commit&#34;&gt;introduction_phase_commit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>합의(Consensus) 알고리즘이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Consensus_(computer_science)&#34;&gt;WIKI - Consensus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zookeeper.apache.org/doc/r3.4.13/zookeeperInternals.html&#34;&gt;ZOOKEEPER DOCS -  CONSENSUS ALGORITHMS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://betterprogramming.pub/demystifying-consensus-algorithms-and-their-implementations-c52f8aca3020&#34;&gt;Demystifying Consensus Algorithms and Their Implementations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://raft.github.io/&#34;&gt;RAFT 합의 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/5663184&#34;&gt;D2 - Raft 분산 합의 알고리즘과 Python에서의 활용&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy 세션(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft.html</link>
      <pubDate>Fri, 19 Mar 2021 16:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy에서 트랜잭션 사용법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95.html</link>
      <pubDate>Thu, 18 Mar 2021 13:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95.html</guid>
      <description>&lt;p&gt;회사에서 이슈 진행을 하다가, 트랜잭션를 이용하여 처리해야하는 부분을 발견하였다.
따라서 &lt;code&gt;SQLAlchemy&lt;/code&gt;에서는 트랜잭션을 어떻게 사용하는지 정리해보도록 하겟다.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션-관리하기&#34;&gt;트랜잭션 관리하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111575492-ce1ff100-87f1-11eb-9999-bef313b83749.png&#34; alt=&#34;Screen Shot 2021-03-18 at 1 56 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새롭게 생성된 세션은 &lt;code&gt;begin()&lt;/code&gt; 상태이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin()&lt;/code&gt; 상태에서 &lt;code&gt;Session&lt;/code&gt;은 아직 어떠한  &lt;code&gt;Connection&lt;/code&gt; 및  &lt;code&gt;Transactional&lt;/code&gt;과 연관되지 않았다.&lt;/li&gt;
&lt;li&gt;그러한 다음에, &lt;code&gt;Session&lt;/code&gt; 은 데이터베이스 커넥션 요청을 수신한다.&lt;/li&gt;
&lt;li&gt;일반적으로, 이것은 &lt;code&gt;Engine&lt;/code&gt;을 이용하여, 특정 &lt;code&gt;SQL&lt;/code&gt; 문을 수행해야하는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;특정 &lt;code&gt;SQL&lt;/code&gt;문의 수행은 &lt;code&gt;Session.query()&lt;/code&gt;, &lt;code&gt;Session.execute()&lt;/code&gt; 통해 이루어지고  &lt;code&gt;Session.commit()&lt;/code&gt;, &lt;code&gt;Session.flush()&lt;/code&gt;를 할 때 보류된 변경 사항을 비우고 커밋하면서 발생합니다.&lt;/li&gt;
&lt;li&gt;이러한 요청이 수신되면, 새로운 엔진 각각이 세션에서 유지되고 관리하는 트랜잭션 상태와 연결이 된다.&lt;/li&gt;
&lt;li&gt;첫 번째, 엔진이 작동하면 세션은 &lt;code&gt;begin&lt;/code&gt; 상태를 떠나서, &lt;code&gt;transactional&lt;/code&gt; 상태로 전환되었다고 할 수 있다.&lt;/li&gt;
&lt;li&gt;각각의 엔진에 대해서 연결이 되어 있으며, 이러한 연결은 &lt;code&gt;Engine.contextual_connect()&lt;/code&gt; 메서드를 통해서 획득된다.&lt;/li&gt;
&lt;li&gt;롤백 또는 커밋 후에 트랜잭션 상태가 완료되면 모든 트랜잭션 및 연결 리소스를 해제하고, &lt;code&gt;begin&lt;/code&gt; 상태로 돌아간다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin&lt;/code&gt; 상태로 돌아가면, 다시 새로운 &lt;code&gt;SQL&lt;/code&gt; 문을 내보내는 새 요청이 수신될 때 새로운 &lt;code&gt;Connection&lt;/code&gt; 및 &lt;code&gt;Transaction&lt;/code&gt; 객체를 다시 호출합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 위의 라이프 사이클을 보여주는 예제이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;engine = create_engine(&amp;quot;...&amp;quot;)
Session = sessionmaker(bind=engine)

# 새로운 세션, 어떤 커넥션도 사용중이지 않다.
session = Session()
try:
    # 첫 번째 쿼리를 수행하면, 커넥션을 엔진으로 부터 획득하고
    # 트랜잭션이 시작된다.    
    item1 = session.query(Item).get(1)

    # 두 번째 쿼리이다. 같은 커넥션과 트랜젝션이 사용된다.
    item2 = session.query(Item).get(2)

    # 아직 반영되지 않은 변경 사항이 생성된다.
    item1.foo = &#39;bar&#39;
    item2.bar = &#39;foo&#39;
    
    # 커밋을 수행한다.
    # 아직 반영되지 않은 변경사항이 모두 `flush` 된다.
    # 트랜잭션이 커밋되고, 연결 객체가 닫치고 사라진다.
    # DBAPI 연결이 커넥션 풀로 반환된다.
    session.commit()
except:
    # 롤백시에도, 커미과 동일한 상태 종료가 진행된다.
    session.rollback()
    raise
finally:
    # 세션을 닫는다, 이렇게 하면 남아 있는 모든 객체가 영구적으로 삭제되며, 기존 SessionTransaction 상태가 재설정 된다.
    # 일반적으로 이러한 단계는 필수는 아니지만,
    # commit() 또는 rollback() 자체에 예기치 않은 내부 오류가
    # 발생한 경우 close()는 유효하지 않은 상태가 제거되도록 한다.
    session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;savepoint-사용하기&#34;&gt;SAVEPOINT 사용하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;기본 엔진에서 지원하는 경우, &lt;code&gt;SAVEPOINT&lt;/code&gt; 트랜잭션은 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드를 사용할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Session = sessionmaker()
session = Session()
session.add(u1)
session.add(u2)

session.begin_nested() # establish a savepoint
session.add(u3)
session.rollback()  # rolls back u3, keeps u1 and u2

session.commit() # commits u1 and u2
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt;는 여러 번 호출 될 수 있으며, 각 호출에 대해서 고유한 식별자가 있는 새로운 SAVEPOINT를 발행합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각의 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 호출에 대해서, &lt;code&gt;Session.rollback()&lt;/code&gt;또는, &lt;code&gt;Session.commit()&lt;/code&gt;을 수행 해야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 반환 값이 컨텍스트 매니저에 의해서 사용되는 경우 예를 들어서 &lt;code&gt;with&lt;/code&gt; 문에서 &lt;code&gt;rollback&lt;/code&gt; 및 &lt;code&gt;commit&lt;/code&gt;은 컨텍스트를 종료할 때, 컨텍스트 관리자가 실행하므로 명시적으로 추가해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드는 &lt;code&gt;Session.begin()&lt;/code&gt;을 덜 사용하기 위해서 사용하며 컨텍스트 매니저로 작동하는 &lt;code&gt;SessionTransaction&lt;/code&gt;을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 레코드를 삽입할 때, 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for record in records:
    try:
        with session.begin_nested():
            session.merge(record)
    except:
        print(&amp;quot;Skipped record %s&amp;quot; % record)
session.commit()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;트랜잭션-격리-수준-설정--dbapi-autocommit&#34;&gt;트랜잭션 격리 수준 설정 / DBAPI AUTOCOMMIT&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111587615-d08c4600-8805-11eb-8a03-8f3379b7a441.png&#34; alt=&#34;Screen Shot 2021-03-18 at 4 20 02 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 &lt;code&gt;DBAPI&lt;/code&gt;는 설정할 수 있는 트랜잭션 격리 수준의 개념을 지원한다.&lt;/li&gt;
&lt;li&gt;전통적으로 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;, &lt;code&gt;READ COMMITED&lt;/code&gt;, &lt;code&gt;REPEATABLE READ&lt;/code&gt;, 및 &lt;code&gt;SERIALIZABLE&lt;/code&gt;의 네 가지 수준이 있다.&lt;/li&gt;
&lt;li&gt;이는 일반적으로 새로운 트랜잭션을 사용하기 전에, &lt;code&gt;DBAPI&lt;/code&gt; 연결에 적용되며 대부분의 DBAPI는 SQL문이 처음 생성될 때, 트랜잭션을 암시적으로 시작한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;는 &lt;code&gt;create_engine&lt;/code&gt; 수준과, &lt;code&gt;Connection.execution_options()&lt;/code&gt; 수준 모두에서 플래그를 사용하여 엔진 별 또는 연결 별로 설정 가능한 격리 모드를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;세션-메이커-및-엔진-전체에-대한-고립-수준-설정&#34;&gt;세션 메이커 및 엔진 전체에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;전역 적으로 특정 고립 수준으로 &lt;code&gt;Session&lt;/code&gt; 또는 &lt;code&gt;Session Maker&lt;/code&gt;를 설정하려면 첫 번째 기술은 모든 경우에 특정 격리 수준에 대해서 엔진을 설정한 다음에, 세션 메이커의 연결 소스로 사용하는 것이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(
    &amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;,
    isolation_level=&#39;REPEATABLE READ&#39;
)

Session = sessionmaker(eng)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서로 다른 격리 수준을 가진 두 개의 엔진이 있는 경우 유용한 다른 옵션은 &lt;code&gt;Engine.execution_options()&lt;/code&gt; 메서드를 사용하는 것입니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(&amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;)

autocommit_engine = eng.execution_options(isolation_level=&amp;quot;AUTOCOMMIT&amp;quot;)

transactional_session = sessionmaker(eng)
autocommit_session = sessionmaker(autocommit_engine)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 &lt;code&gt;eng&lt;/code&gt;과 &lt;code&gt;autocommit_engine&lt;/code&gt;은 동일한 연결 풀을 공유합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AUTOCOMMIT&lt;/code&gt; 모드는 &lt;code&gt;autocommit_engine&lt;/code&gt;에서 연결할 때 따로 설정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;각각의-세션에-대한-고립-수준-설정&#34;&gt;각각의 세션에 대한, 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;생성자를 직접 사용하거나, 세션 메이커가 생성한 호출 가능한 객체를 호출 할 때, &lt;code&gt;bind&lt;/code&gt; 인자로 바로 전달 할 수 있다.
예를 들어, &lt;code&gt;transactional_session&lt;/code&gt;에서 세션을 만들고, &lt;code&gt;autocommit_engine&lt;/code&gt;을 전달할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;session = transactional_session(bind=autocommit_engine)
# work with session
session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;각각의-트랜잭션에-대한-고립-수준-설정&#34;&gt;각각의 트랜잭션에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;격리 수준과 관련된 주요한 주의 사항은 트랜잭션이 이미 시작된 연결에서 설정을 안전하게 수정할 수 없다는 것이다.&lt;/p&gt;
&lt;p&gt;데이터베이스는 진행중인 트랜잭션의 격리 수준을 변경할 수 없으며 일부 &lt;code&gt;DBAPI&lt;/code&gt; 및 &lt;code&gt;SQLALchemy&lt;/code&gt; 언어에서는 이러한 영역에서 일관적이지 않은 동작이 있다.&lt;/p&gt;
&lt;p&gt;따라서 원하는 격리 수준을 가진 엔진 앞쪽에 바인딩 된 세션을 사용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;그러나 연결 단위의 격리 수준은 트랜잭션이 시작될 때 &lt;code&gt;Session.commection()&lt;/code&gt; 메서드를 사용하여 영향 받을 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sqlalchemy.orm import Session

sess = Session(bind=engine)
with sess.begin():
    sess.connection(execution_options={&#39;isolation_level&#39;: &#39;SERIALIZABLE&#39;})

# commits transaction.  the connection is released
# and reverted to its previous isolation level.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위에서 먼저, 생성자 또는 세션 메이커를 사용하여 세션을 생성한다. 그런 다음에 트랜잭션이 시작되기 전에 연결에 전달되는 실행 옵션을 제공하는 &lt;code&gt;Session.connection()&lt;/code&gt;을 호출하여 트랜잭션 시작을 명시적으로 설정한다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mariadb 유니크 인덱스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4.html</link>
      <pubDate>Tue, 09 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4.html</guid>
      <description>&lt;h2 id=&#34;유니크-인덱스&#34;&gt;유니크 인덱스&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110399859-ed17d800-80b9-11eb-933e-d71a182abcb7.png&#34; alt=&#34;unique&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유니크 키는 유일해야하지만, 널을 허용할 수 있다.&lt;/li&gt;
&lt;li&gt;테이블을 생성한 후 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 또는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 명령을 사용하여, 고유 키를 추가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ALTER TABLE Employees ADD UNIQUE `EmpCode`(`Employee_Code`);
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE UNIQUE INDEX HomePhone ON Employees(Home_Phone);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/getting-started-with-indexes/#unique-index&#34;&gt;mariadb-unique-index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DBMS를 분석하는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Wed, 03 Mar 2021 23:32:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;h3 id=&#34;kcd-2020&#34;&gt;KCD 2020&lt;/h3&gt;
&lt;hr&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/CgxiNF6xigY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;막 오픈소스 컨트리뷰톤을 끝마치고, 오픈소스 개발에 재미를 붙였을 때, KDC 2020이라는 세미나가 열렸다. 오픈소스 데이터베이스 큐브리드에 기여하기라는 제목의 세션을 보았을 때, 오픈소스 DBMS를 개발한다는 부분이 신기했고, 궁금한 점이 있어서 메일을 보내게 되었는데, 친절하게도 아주 장문의 답장을 해주셨다.&lt;/p&gt;
&lt;h3 id=&#34;메일&#34;&gt;메일&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109822109-ffd57b80-7c79-11eb-878d-337a28318428.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 41 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;내가 보낸 메일을 다시 보니까, 많이 부끄럽다;;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109821623-82117000-7c79-11eb-9da5-7f9b3f2d2864.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 37 57 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;매우 유용한 조언을 해주셨고, 실제로 많은 도움이 되었다. 이를 요약하자면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드 레벨에서부터 접근하면 분석하기 쉽지 않다. 특히 DBMS는 여러가지 큰 개념이 모두 함께 유기적으로 동작하기 때문에 (&lt;code&gt;SQL&lt;/code&gt;, &lt;code&gt;Query Rewrite/Optimization&lt;/code&gt;, &lt;code&gt;Index&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞에서 말한 각 모듈들은 코드상으로는 &lt;code&gt;DBMS&lt;/code&gt; 마다 모두 다르게 구현되어 있을 것이다. 따라서 추상적인 개념을 코드로 된 구현체로 최대한 맵핑해보려는 시도를 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어, &amp;ldquo;SQL 파서 모듈은 SQL을 읽어서 파싱 트리라는 구조를 만든다&amp;quot;와 같은 개념들은 DBMS 마다 같지만 코드상으로는 다르게 구현되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQL 파서 모듈과 같이, 각 모듈을 처음부터 코드를 읽어가면서 맨땅부터 이해하는 것은 쉽지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간이 충분하다면 한줄 한줄 분석하면서 파악할 수는 있겠지만 거의 불가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 그 모듈이 어떻게 돌아가는지에 대한 맥락을 먼저 잡아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 현업에서 일을 할 때 도 마찬가지라는 것을 명심해야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;모듈을-분석하는-법&#34;&gt;모듈을 분석하는 법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;1. 개략적인 모듈의 모양을 파악하기 위해서, 모듈의 인터페이스 또는 API나 시작점을 먼저 찾아본다.
2. 모듈을 관통하는 주요 자료구조가 있다면 파악해둔다, (SQL 파서의 경우에는 `파싱트리`) 그 자료구조를 바탕으로 다른 엮여 있는 자료구조나 기능 구현을 파악해나간다.
3. 분석하고 있는 모듈과 관련해서 다른 사람이 이전에 개발했던 기능, 기능/개선, 버그 수정사항에 대한 기록이 있으면 좋다. 
  - 버그 트래킹 시스템이 있으면 먼저 찾아보고, 코드를 보다가 이해되지 않는 부분이 있으면 `git blame`기능으로 어떤 맥락으로 그 코드가 추가되었는지를 찾아보면 좋다.
  - 찾아보았던 기능 개발/개선 기록을 검토하면서 코드 분석을 하다보면 가끔 이전 개발자가 예외 사항들을 놓치는 경우가 있는데 분석한 부분을 잘 이해했다면 기여할 수 있다.
  - 개발자 메뉴얼이나 자료구조/모듈 간의 구조를 그려주는 문서들이 있으면 더 이해가 빠르다. (e.g. https://doxygen.postgresql.org/)
4. 1 ~ 3번을 반복하면서 모듈들을 하나씩 이해해 가다 보면 모듈간에 어떻게 엮여 있는지 개략적으로 알아갈 수 있다. 확실히 코드를 분석하려면 어떤 새로운 기능을 개발하거나 큰 버그를 고친다면 더 자세히 이해할 수 있는 것 같다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 알려주신 개발자 분이 위의 방법대로 한 단계씩 분석을 하면서 각 부분을 접근하고 계신다고 하셨다.
그리고 분석하는 도중에 어떤 버그가 보여서 이건 버그라고 확신할 때 커미터에게 자신이 궁금한 점을 물어보면서 토론을 해보는 것도 좋다고 생각한다고 하셨다.&lt;/p&gt;
&lt;h4 id=&#34;마무리&#34;&gt;마무리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;아쉽게도 현재는 오픈소스 활동을 재개하고 있지 않다. 사실 다시 오픈 소스 활동을 재개하고 싶지만, 현업에서 일을 하다보니 부족한 점이 너무 많아서 부족한 부분을 채우느라 다시 시작할 엄두를 못내고 있다.&lt;/p&gt;
&lt;p&gt;하지만 이번 글을 쓰면서 감사함을 느꼈고 이에 보답하기 위해서라도 오픈 소스 컨트리뷰션을 조만간 다시 재개할 수 있도록 노력을 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doxygen.postgresql.org/&#34;&gt;postgres doxygen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스키마를 관리하는 도구, Flyway</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway.html</link>
      <pubDate>Wed, 03 Mar 2021 20:09:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway.html</guid>
      <description>&lt;h1 id=&#34;데이터베이스-스키마-관리의-필요성&#34;&gt;데이터베이스 스키마 관리의 필요성&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;최근에 회사에서 기존에 &lt;code&gt;AWS&lt;/code&gt;에서 서비스하던 서비스를 &lt;code&gt;ALI&lt;/code&gt; 클라우드에서 제공해야하는 일이 있었다. 따라서 데이터베이스 스키마와 마스터 데이터를 새로운 클라우드 환경으로 이전을 시켜줘야 했다.&lt;/p&gt;
&lt;p&gt;비교적 규모가 큰 서비스는 아니여서, 덤프를 이용해서 간단하게 이전하였고, 데이터베이스 스키마 및 마스터 데이터를 쿼리문 형태로 만들어서 GIT으로 형상관리를 하였다.&lt;/p&gt;
&lt;p&gt;이 정도로 모든 일이 마무리 되기는 하였지만, 어딘가 부족한 느낌이 들었다. 왜냐하면 개발을 하면서 DB 스키마가 변경할 일이 있는데 그럴 때마다 쿼리문으로 테이블 스키마를 변경하고, 스키마 파일을 업데이트 해야했기 때문이다. 문제는 변경해줘야 할 환경이 &lt;code&gt;AWS&lt;/code&gt;, &lt;code&gt;ALI&lt;/code&gt; 각각 &lt;code&gt;DEV&lt;/code&gt;, &lt;code&gt;EDU&lt;/code&gt;, &lt;code&gt;STG&lt;/code&gt;, &lt;code&gt;PROD&lt;/code&gt;이 존재하므로 8 개의 환경을 업데이트 해주어야 했습니다. 그리고 메일 서버가 바라보는 테이블까지 생각하면 서비스가 조금만 더 확장된다면 엄청나게 힘들어 질 것이다.&lt;/p&gt;
&lt;p&gt;게다가 단순한 컬럼 값 추가, 삭제가 아니라 컬럼이 어떤 연산을 통해서 새로운 값을 가져야 하거나, 새로운 테이블을 만들어 기존 데이터를 옮기거나 하는 좀 더 복잡한 작업이 되면 엄청나게 복잡해 질 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 현대적인 애플리케이션 개발 환경에서는 단일 DB 스키마가 아니라, 변화를 다루는 마이그레이션 스크립트를 만들어서 사용한다. 소스 코드 저장소에 함께 포함을 시키고, 모든 환경에서 서버를 구동하기 전에 적용시키는 방법을 사용한다.&lt;/p&gt;
&lt;h1 id=&#34;flyway&#34;&gt;Flyway&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109799728-b5470580-7c5f-11eb-9f0a-6ca5e87ae745.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 32 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flyway&lt;/code&gt;는 오픈소스 데이터베이스 마이그레이션 도구이다.&lt;/li&gt;
&lt;li&gt;마이그레이션은 &lt;code&gt;SQL&lt;/code&gt; 또는 &lt;code&gt;Java&lt;/code&gt;로 작성할 수 있다.&lt;/li&gt;
&lt;li&gt;일곱 가지의 간단한 명령어로 구성되어 있다. (&lt;code&gt;Migrate&lt;/code&gt;, &lt;code&gt;Clean&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Validate&lt;/code&gt;, &lt;code&gt;Undo&lt;/code&gt;, &lt;code&gt;Baseline&lt;/code&gt;, &lt;code&gt;Repair&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;다양한 패키지 및 빌드 도구에서 지원하며 플러그인 형태로도 이용할 수 있다.&lt;/li&gt;
&lt;li&gt;많은 DBMS를 지원한다. (&lt;code&gt;MySQL&lt;/code&gt;, &lt;code&gt;Postgres&lt;/code&gt;, &lt;code&gt;H2&lt;/code&gt;, &amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이그레이션이-필요한-이유&#34;&gt;마이그레이션이 필요한 이유&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109800868-16bba400-7c61-11eb-9b83-9dff2469cf53.png&#34; alt=&#34;Environments&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션의 경우, &lt;code&gt;GIT&lt;/code&gt;과 같은 형상 관리 툴로, 재현 가능한 구조와 CI 환경을 구성할 수 있다.&lt;/li&gt;
&lt;li&gt;릴리즈 및 배포 프로세스를 잘 정의함으로써, 이를 관리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801147-6ef2a600-7c61-11eb-8058-c5086b4a1522.png&#34; alt=&#34;DbRed&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;불행하게도 애플리케이션과 데이터베이스 간의 불일치가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 여전히 많은 프로젝트가 수동으로 적용된 &lt;code&gt;SQL&lt;/code&gt; 스크립트에 의존하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스 마이그레이션은 이러한 혼란을 제어할 수 있는 좋은 방법이다. 마이그레이션은 위와 같은 문제에 대해서 다음과 같은 이점을 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 데이터베이스 다시 만들기&lt;/li&gt;
&lt;li&gt;데이터베이스가 어떤 상태인지 확인&lt;/li&gt;
&lt;li&gt;현재 버전의 데이터베이스에서 새로운 데이터베이스로 마이그레이션&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flyway-작동-원리&#34;&gt;Flyway 작동 원리&lt;/h3&gt;
&lt;p&gt;가장 간단한 경우는 &lt;code&gt;Flyway&lt;/code&gt;가 비어있는 데이터베이스를 가리킬 때입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801736-3bfce200-7c62-11eb-81eb-a3ea67e714dd.png&#34; alt=&#34;EmptyDb&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 비어있으므로, &lt;code&gt;Flyway&lt;/code&gt;는 데이터베이스를 찾지 못하고 대신 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;Flyway&lt;/code&gt;는 마이그레이션을 위해서 파일 시스템 및 응용 프로그램의 클래스 경로를 탐색하기 시작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런 다음에 마이그레이션은 버전 번호를 기준으로 정렬되고 순서대로 적용될 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801958-87af8b80-7c62-11eb-9c7d-0f55a59c44b5.png&#34; alt=&#34;Migration-1-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 마이그레이션이 적용될 때마다 스키마 기록 테이블이 업데이트 되며 이러한 이력 데이터로 특정 버전으로 쉽게 마이그레이션을 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109802186-d9581600-7c62-11eb-958a-c9726222a374.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 55 48 PM&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론&lt;/h1&gt;
&lt;p&gt;현재 진행하는 프로젝트에 도입을 해도 괜찮을 것 같고, 마치 깃을 사용하는 것 같이 특정 버전의 스키마로 쉽게 돌아갈 수 있다는 것이 편리할 것 같다. 기존에는 특정 버전의 스키마를 보려면 깃으로 특정 버전의 스키마를 조회한 다음에 도커 가상 환경에서 마이그레이션을 하고 나서 테스트를 했다. 이렇게 진행하니까 테스트를 하기 위해서 준비해야할 것도 많고 번거로웠다. 지금 당장은 괜찮을지 몰라도 나중을 위해서 우선 시험삼아서 사용해보고 좋다면 팀원에게 소개를 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://flywaydb.org/documentation/getstarted/why&#34;&gt;Flyway, documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
