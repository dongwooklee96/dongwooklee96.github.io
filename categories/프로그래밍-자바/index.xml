<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>프로그래밍 - 자바 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94.html</link>
    <description>Recent content in 프로그래밍 - 자바 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 04 Apr 2021 20:30:23 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GC(Garbage Collector) 종류 및 내부 원리</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</link>
      <pubDate>Sun, 04 Apr 2021 20:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</guid>
      <description>&lt;p&gt;모든 자바 애플리케이션은 JVM(&lt;code&gt;Java Virtual Machine&lt;/code&gt;) 위에서 작동한다. 따라서, &lt;code&gt;JVM&lt;/code&gt;이 작동하는데 있어서 메모리 구조와 &lt;code&gt;GC&lt;/code&gt;는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 맺고 있다.&lt;/p&gt;
&lt;h3 id=&#34;gc란-무엇인가&#34;&gt;GC란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GC(Garbage Collection)는 자바 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C/C++&lt;/code&gt; 같은 언어는 메모리를 할당하고 직접 해제해야했지만, 자바에서는 &lt;code&gt;GC&lt;/code&gt;를 이용하여 개발자들이 메모리 관리를 비교적 신경쓰지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-메모리-영역&#34;&gt;JVM 메모리 영역&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507707-1deb1000-9587-11eb-9ab6-2bbe0091be87.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GC&lt;/code&gt;의 동작 방법을 이해하려면, 먼저 자바의 메모리 구조를 이해할 필요가 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 애플리케이션에서 사용되는 객체는 오래 유지되는 객체보다 잠시 사용되는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507754-5a1e7080-9587-11eb-91e9-f14a446cb441.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바에서는 크게 두 영역으로 메모리를 구분한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Young&lt;/code&gt; 영역과 &lt;code&gt;Old&lt;/code&gt; 영역인데, &lt;code&gt;Young&lt;/code&gt; 영역은 생성된지 얼마 되지 않은 객체들을 저장하는 장소이고 &lt;code&gt;Old&lt;/code&gt; 영역은 생성된지 오래된 객체를 저장하는 장소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;영역&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;New/Young 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;이 영역은 자바 객체가 생성되자마자 저장되고 생긴지 얼마 안 된 객체가 저장되는 곳이다. 자바 객체가 생성되면 이 영역에서 저장되다가 시간이 지남에 따라서 우선 순위가 낮아지면 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮겨진다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Old 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;New/Young&lt;/code&gt; 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어서 저장되는 영역이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Perm 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Class, Method 등의 코드가 저장되는 영역으로, JVM에 의해서 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jvm이-메모리를-관리하는-방식&#34;&gt;JVM이 메모리를 관리하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508143-4c69ea80-9589-11eb-84be-2ec3ff175995.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;New/Young&lt;/code&gt; 영역을 &lt;code&gt;Minor GC&lt;/code&gt; 라고 부른다. &lt;code&gt;New/Young&lt;/code&gt; 영역은 &lt;code&gt;Eden / Survivor&lt;/code&gt; 이라는 두 영역으로 또 나뉘게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 영역은 자바 객체가 생성되자마자 저장되는 곳이다. 이렇게 생성된 객체는 &lt;code&gt;Minor GC&lt;/code&gt;가 발생할 때 &lt;code&gt;Survivor&lt;/code&gt; 영역으로 이동하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt; 영역은 &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 두 영역으로 나뉘는데, &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor1&lt;/code&gt;에 활성 객체를 &lt;code&gt;Survivor2&lt;/code&gt;로 복사한다.&lt;/li&gt;
&lt;li&gt;활성이 아닌 객체는 자연스럽게 &lt;code&gt;Survivor1&lt;/code&gt;에 남아있게 되고, &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Eden&lt;/code&gt; 영역을 클리어 한다. (결과적으로 활성 객체만 &lt;code&gt;Survivor2&lt;/code&gt;)로 이동하게 된 것이다.&lt;/li&gt;
&lt;li&gt;다음번 &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 같은 원리로 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 영역에서 활성 객체를 &lt;code&gt;Survivor1&lt;/code&gt;으로 이동시키게 된다. 계속 이런 방식을 반복하면서 &lt;code&gt;Minor GC&lt;/code&gt;를 수행한다.&lt;/li&gt;
&lt;li&gt;이렇게 &lt;code&gt;Minor GC&lt;/code&gt;를 수행하다가 &lt;code&gt;Survivor&lt;/code&gt; 영역에서 오래된 객체는 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮기게 된다.&lt;/li&gt;
&lt;li&gt;이러한 방식의 &lt;code&gt;GC&lt;/code&gt; 알고리즘을 &lt;code&gt;Copy &amp;amp; Scavenge&lt;/code&gt; 라고 한다. 이 방식은 속도가 매우 빠르며 작은 크기의 메모리를 콜렉팅하는데 매우 효과적이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Minor GC&lt;/code&gt;의 경우에는 자주 일어나기 때문에 &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 짧은 알고리즘을이 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;full-gc&#34;&gt;FULL GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508252-e3cf3d80-9589-11eb-9792-a038da5850d1.jpg&#34; alt=&#34;java-gc-29-638&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Old&lt;/code&gt; 영역의 가비지 컬렉션을 &lt;code&gt;Full GC&lt;/code&gt; 라고 부르며 &lt;code&gt;Full GC&lt;/code&gt;에 사용되는 알고리즘을 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘은 객체들의 참조를 확인하면서 참조가 연결되지 않은 객체를 표시한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 표시하고 이 표시된 객체를 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Full GC&lt;/code&gt;는 속도가 매우 느리며, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 도중에는 순간적으로 자바 애플리케이션이 멈춰버리기 때문에, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 정도와 시간은 애플리케이션의 성능과 안정성에 아주 큰 영향을 미친다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc가-중요한-이유&#34;&gt;GC가 중요한 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;가비지 컬렉션 중에서 마이너 GC의 경우에는 보통 0.5 이내에 끝나기 때문에 큰 문제가 되지 않지만, 그러나 FULL GC의 경우에는 자바 애플리케이션이 멈춰 버리기 때문에, 문제가 될 수 있다.&lt;/li&gt;
&lt;li&gt;멈추는 동안 사용자의 요청이 큐에 들어있다가, 순간적으로 요청이 한꺼번에 들어오기 때문에 과부하에 의한 여러 장애를 만들 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 원활한 서비스를 위해서는 &lt;code&gt;GC&lt;/code&gt;가 어떻게 일어나게 하느냐가 시스템의 안정성과 성능에 큰 변수로 작용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-gc-알고리즘&#34;&gt;다양한 GC 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;앞에서 설명한 방식 말고도 다양한 &lt;code&gt;GC&lt;/code&gt; 방법을 제공하고 있다. 방식은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Default Collector&lt;/li&gt;
&lt;li&gt;Parallel GC for young generator&lt;/li&gt;
&lt;li&gt;Concurrent GC for old generator&lt;/li&gt;
&lt;li&gt;Incremental GC (Train GC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;default-collector&#34;&gt;Default Collector&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 설명했던 전통적인 GC 방식으로, Minor GC로 &lt;code&gt;Scanvenge&lt;/code&gt;를 Full GC로 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508603-f8acd080-958b-11eb-9c89-f025df1daab9.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자바는 멀티 스레드 환경을 지원하지만, 하나의 CPU에서는 동시에 하나의 스레드 밖에 수행할 수 없어서 예전에는 하나의 CPU에서만 GC를 수행하였지만 후에 하나의 CPU에서 동시에 여러 개의 스레드를 실행할 수 있는 하이퍼스레딩 기술이나 여러개의 CPU를 동시에 장착한 하드웨어의 보급으로 하나의 하드웨어에서 동시에 여러 개의 스레드를 수행할 수 있게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parallel GC&lt;/code&gt;에는 크게 두 가지 종류의 옵션을 가지고 있는데, &lt;code&gt;Low-pause&lt;/code&gt; 방식과 &lt;code&gt;Throughput&lt;/code&gt; 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Low-pause&lt;/code&gt; 방식은 GC가 일어날 때 애플리케이션이 멈추는 현상을 최소화하는데 역점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Throughput&lt;/code&gt; 방식의 &lt;code&gt;Parallel&lt;/code&gt; GC는 마이너 GC가 발생하였을 때 되도록이면 신속하게 수행하도록 &lt;code&gt;throughput&lt;/code&gt;에 중점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;concurrent-gc&#34;&gt;Concurrent GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC 즉, Old 영역을 GC하는데 시간이 길고 애플리케이션이 순간적으로 멈춰버리므로, 애플리케이션이 멈추는 현상을 최소화 하는 GC 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full GC에 소요되는 작업을 애플리케이션을 멈추고 진행하는 것이 아니라, 일부는 애플리케이션이 돌아가는 단계에서 수행하고 최소한의 작업만을 애플리케이션이 멈췄을 때 수행하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;incremental-gc-train-gc&#34;&gt;Incremental GC (Train GC)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Train GC&lt;/code&gt;라고도 불리는 &lt;code&gt;GC&lt;/code&gt; 방식은 의도는 &lt;code&gt;Full GC&lt;/code&gt;에서 의해서 애플리케이션이 멈추는 시간을 줄이기 위한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동은 &lt;code&gt;Minor GC&lt;/code&gt;가 일어날 때마다 &lt;code&gt;Old&lt;/code&gt; 영역을 조금씩 &lt;code&gt;GC&lt;/code&gt; 해서 &lt;code&gt;Full GC&lt;/code&gt;가 발생하는 횟수나 시간을 줄이는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Incremental GC&lt;/code&gt;는 많은 자원을 소모하고 &lt;code&gt;Minor GC&lt;/code&gt;를 자주 일으켜서, 그리고 &lt;code&gt;Incremental GC&lt;/code&gt;를 사용한다고 &lt;code&gt;Full GC&lt;/code&gt;가 없어지거나 그 횟수가 획기적으로 줄어드는 것이 아니다. 오히려 느려지는 경우가 많으므로 반드시 테스트를 거치고 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc-로그-수집-방법&#34;&gt;GC 로그 수집 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;에서는 GC 상황에 대한 로그를 남기고자 옵션을 제공하고 있다.&lt;/li&gt;
&lt;li&gt;자바 옵션에 &lt;code&gt;-verbosegc&lt;/code&gt; 라는 옵션을 주면 되고, &lt;code&gt;&amp;gt;&lt;/code&gt; 리다이렉션 명령어를 통해서 파일로 저장하고 분석할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509041-6659fc00-958e-11eb-92e2-bc0633609ea6.png&#34; alt=&#34;자바&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위는 스프링 부트로 만든 간단한 웹 애플리케이션이다. 이를 터미널에서 &lt;code&gt;jar&lt;/code&gt; 파일로 만들어 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./gradlew bootjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509104-b6d15980-958e-11eb-8a43-07b56114335a.png&#34; alt=&#34;jar&#34;&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 생성이 되면, 다음과 같은 경로에 &lt;code&gt;jar&lt;/code&gt; 파일이 생성된다. 터미널을 통해서 이 경로로 이동한다.&lt;/p&gt;
&lt;p&gt;그런 후에 다음과 같은 명령어를 터미널에서 실행 시킨다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;java -jar -verbosegc app.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509189-26474900-958f-11eb-836f-e70adb0a34ac.png&#34; alt=&#34;Screen Shot 2021-04-04 at 9 45 53 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러면 애플리케이션이 실행되자마자 &lt;code&gt;GC&lt;/code&gt;와 관련된 로그들이 출력된다.&lt;/li&gt;
&lt;li&gt;마이너 GC는 &amp;ldquo;GC&amp;quot;로 표기되고, FULL GC는 &amp;ldquo;FULL GC&amp;quot;로 표기된다.&lt;/li&gt;
&lt;li&gt;그 다음의 값은 &lt;code&gt;HEAP SIZE BEFORE GC&lt;/code&gt;인데, GC전의 힙 사용량 (New/Young 영역 + Old 영역 + Perm 영역의) 크기를 나타낸다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 GC가 발생한 후의 HEAP 사용량이다. 마이너 GC가 발생하였을 때는 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor&lt;/code&gt; 영역을 &lt;code&gt;GC&lt;/code&gt; 하게 되므로 &lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 Old 영역의 용량과 유사하다.&lt;/li&gt;
&lt;li&gt;마지막 값은 &lt;code&gt;GC&lt;/code&gt;에 소요된 시간을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-gc-튜닝&#34;&gt;JVM GC 튜닝&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;step-1-애플리케이션의-종류-및-튜닝-목표값을-설정&#34;&gt;STEP 1. 애플리케이션의 종류 및 튜닝 목표값을 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JVM 튜닝을 할 때 가장 중요한 것은 튜닝의 목표를 설정하는 것이다.&lt;/li&gt;
&lt;li&gt;메모리를 적게 사용하는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt; 횟수를 줄이는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 문제인지, 애플리케이션의 성능(&lt;code&gt;Throughput or Response Time&lt;/code&gt;) 향상이 목표인지를 먼저 정하고 나서 목표치에 근접하도록 &lt;code&gt;JVM&lt;/code&gt; 파라미터를 조정하는 것이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-2-힙크기와-perm-크기-설정&#34;&gt;STEP 2. 힙크기와 &lt;code&gt;Perm&lt;/code&gt; 크기 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-ms, -mx 옵션을 이용해서 힙 크기를 정한다. 일반적으로 서버 애플리케이션은 ms와 mx크기를 같게 하는 것이 메모리의 &lt;code&gt;Growing&lt;/code&gt;와 &lt;code&gt;Shrinking&lt;/code&gt;에 의한 불필요한 로드를 막을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ms&lt;/code&gt;와 &lt;code&gt;mx&lt;/code&gt; 크기를 다르게 하는 경우는 애플리케이션의 시간대별 메모리 사용량이 급격하게 변화가 있는 애플리케이션에 효과적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-3-테스트와-로그-분석&#34;&gt;STEP 3. 테스트와 로그 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; 옵션에 &lt;code&gt;GC&lt;/code&gt;로그를 수집하기 위한 &lt;code&gt;-verbosegc&lt;/code&gt; 옵션을 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nGrinder&lt;/code&gt;와 같은 스트레스 테스트 도구로 애플리케이션에 스트레스를 주어서, 그 로그를 수집한다.&lt;/li&gt;
&lt;li&gt;튜닝에 있어서 가장 중요한 것은 목표 산정이지만, 그만큼이나 중요한 것은 실제 튜닝한 파라미터가 애플리케이션에 어떤 영향을 주는지를 테스트 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-4-perm-크기-조정&#34;&gt;STEP 4. Perm 크기 조정&lt;/h4&gt;
&lt;h4 id=&#34;step-5-gc-수행-시간-분석&#34;&gt;STEP 5. GC 수행 시간 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC가 일어나는 횟수가 많아서 &lt;code&gt;Old&lt;/code&gt; 영역을 늘려주면, Full GC 가 일어나는 횟수가 줄어들 것이고, 반대로 Full GC 수행 시간은 늘어날 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 서버 애플리케이션은 Full GC가 일어날 때는 &lt;code&gt;JVM&lt;/code&gt; 자체가 멈춰버리기 때문에 일정 시간동안 응답을 못하는 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 애플리케이션에서 Full GC가 적게 일어나게 하고, Full GC 시간을 양쪽 다 줄이려면 &lt;code&gt;Old&lt;/code&gt; 영역의 메모리를 줄이고 여러 개의 인스턴스를 동시에 띄워서 로드 밸런싱을 해주면 부하가 분산된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇게 되면, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 횟수가 줄어들게 되며 &lt;code&gt;Old&lt;/code&gt; 영역을 줄였기 때문에 Full GC가 수행되는 시간 또한 줄어든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 하나의 서버 인스턴스가 멈춰있는 동안 로드 밸런싱이 되는 다른 서버가 응답하고 있기 때문에 &lt;code&gt;Full GC&lt;/code&gt;로 인하여 애플리케이션이 멈추는 상황에서 받을 영향을 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-6-파라미터-변경&#34;&gt;STEP 6. 파라미터 변경&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 영역의 허용 범위를 기준으로, &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역을 적절하게 조절한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Perm&lt;/code&gt; 크기와 &lt;code&gt;New&lt;/code&gt; 영역의 배분(Eden, Survivor) 영역을 조정한다.&lt;/li&gt;
&lt;li&gt;가장 중요한 것은 &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역의 비율을 어떻게 조정하는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;향상 포인트&lt;/th&gt;
&lt;th&gt;GC 알고리즘&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Perfomance (속도)&lt;/td&gt;
&lt;td&gt;Parallel GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Concurrent GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Incremental GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반&lt;/td&gt;
&lt;td&gt;Default GC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC의 여러가지 구현 방식(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft.html</link>
      <pubDate>Thu, 25 Mar 2021 19:03:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft.html</guid>
      <description>&lt;p&gt;스프링 문서를 보면서, &lt;code&gt;IoC&lt;/code&gt;에 대해서 공부를 하다가, 서비스 로케이터 패턴을 알게 되었다. 서비스 로케이터 패턴을 조사하다가 자연스럽게 다른 &lt;code&gt;IoC&lt;/code&gt; 구현 방식도 알게 되었는데 정리를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292089-15b3ea80-8cd4-11eb-80fd-943416430267.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ahea.wordpress.com/2018/09/09/1754/&#34;&gt;IOC 구현 방식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>빈 펙토리와 애플리케이션 컨텍스트의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Wed, 24 Mar 2021 23:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;h3 id=&#34;궁금증을-가지게-된-이유&#34;&gt;궁금증을 가지게 된 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112328879-10699680-8cfa-11eb-8c22-2db852326801.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 38 22 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 문서를 보면서 공부하다가 위와 같은 문구를 보게 되었다. &lt;code&gt;ApplicationContext&lt;/code&gt;가 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 타입의 인터페이스라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇다면 무슨 차이가 있을까라는 생각을 하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean-facotry&#34;&gt;BEAN FACOTRY&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112329428-88d05780-8cfa-11eb-8c53-63c801dadfbb.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 41 55 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다행스럽게도 위와 같은 문서가 스프링 공식문서에서 제공되고 있었다. 차이점은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API는 &lt;code&gt;Spring IoC&lt;/code&gt; 기능을 위한 기초적인 기반을 제공한다.&lt;/li&gt;
&lt;li&gt;이것의 구체적인 계약은, 주로 스프링의 다른 부분과 관련된 써드 파티 프레임워크와의 통합에 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 및 관련 인터페이스 (예: &lt;code&gt;BeanFactoryAware&lt;/code&gt;, &lt;code&gt;Initializing Bean&lt;/code&gt;, &lt;code&gt;DispisableBean&lt;/code&gt;)는 다른 프레임워크 구성 요소의 중요한 통합지점이다.&lt;/li&gt;
&lt;li&gt;어노테이션이랑 리플렉션이 필요하지 않으므로, 컨테이너와 컴포넌트간에 매우 효율적인 상호작용을 할 수 있다.&lt;/li&gt;
&lt;li&gt;응용 프로그램 수준 빈은 동일한 콜백 인터페이스를 사용할 수 있지만, 일반적으로 어노테이션을 또는 설정을 통한 선언적 종속성 주입을 선호한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API 레벨과, &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 구현에서는 구성 형식이나 사용할 구성 요소 어노테이션에 대해서 가정을 하지 않는다.&lt;/li&gt;
&lt;li&gt;이러한 것은 확장 기능(예: &lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;, &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;)을 통해서 제공되며, 공유 &lt;code&gt;BeanDefinition&lt;/code&gt; 개체에서 핵심 메타데이터 표현으로 작성한다.&lt;/li&gt;
&lt;li&gt;이것이 바로 스프링 컨테이너를 유연하고 확장 가능하게 만드는 본질이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;솔직히 이 부분은 아직 잘 모르겠다&amp;hellip; 그래도 정리를 해둔 기억이 있으니 코딩을 하면서 관련된 API를 사용할 때 다시 한번 확인해봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;빈-펙토리와-애플리케이션-컨텍스트&#34;&gt;빈 펙토리와 애플리케이션 컨텍스트&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112332863-70ae0780-8cfd-11eb-8ad5-23a995c1a92d.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 28 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 섹션에서는 &lt;code&gt;BeanFactory&lt;/code&gt;와 &lt;code&gt;ApplicationContext&lt;/code&gt; 컨테이너 수준 간의 차이와 부트스트래핑에 대한 의미에 대해서 설명한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 부트스트랩핑을 &lt;code&gt;GenericApplicationContext&lt;/code&gt;, &lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;를 이용하여 구현할 것이 아니라면 일반적으로는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 공통 목적을 위해서 스프링의 핵심 컨테이너에 대한 기본 진입 지점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;에는 &lt;code&gt;BeanFactory&lt;/code&gt;의 모든 기능이 포함되므로, &lt;code&gt;BeanFactory&lt;/code&gt;에 대한 완전한 제어가 필요한 시나리오를 제외하고 일반적으로 &lt;code&gt;BeanFactory&lt;/code&gt;보다는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;(일반 애플리케이션 컨텍스트 구현 등) 내에서 몇 가지 종류의 빈이 컨벤션에(특히, &lt;code&gt;post-processors&lt;/code&gt;) 의해서 탐지되는 반면에 일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;는 특별한 빈들에게 대해서 관련이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주석 처리 및 &lt;code&gt;AOP&lt;/code&gt; 프록시와 같은 많은 확장 컨테이너 기능의 경우, &lt;code&gt;BeanPostProcessor&lt;/code&gt; 확장 지점이 필수적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;만 사용하는 경우에는 기본적으로 이러한 사후 프로세스가 탐지 및 활성화 되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈 구성에 아무런 문제가 없기 때문에 이러한 상황은 혼란스러울 수 있지만 오히려 이러한 시나리오에서 컨테이너를 추가 설정을 통해서 완전히 부트스트랩 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112334414-c0410300-8cfe-11eb-87ba-a5566175c744.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 42 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;는 &lt;code&gt;Bean&lt;/code&gt;을 인스턴스화 하거나 와이어링 하는 것 빼고는 &lt;code&gt;ApplicationContext&lt;/code&gt;과 비교해서 많은 기능을 제공하지 않는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;BeanFactory&lt;/code&gt;에서 사후 프로세서를 명시적으로 등록하려면, 다음의 예외 같이 프로그래밍 방식으로 &lt;code&gt;addBeanPostProcessor&lt;/code&gt;를 호출해야한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음에 생각했던 것 과는 달리 기능을 제공하지 않을 뿐, 코드 상으로 설정을 해주면 사용할 수는 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그래도 이렇게 명시적으로 등록을 해주어야 하기 때문에, 다양한 &lt;code&gt;ApplicationContext&lt;/code&gt; 변형이 일반 &lt;code&gt;DefualtListableBeanFactory&lt;/code&gt; 보다 선호 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 일반적인 엔터프라이즈 환경에서 확장 컨테이너 기능을 위해서 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 및 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 인스턴스에 의존하는 경우 더욱 그렇다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일단 내가 생각하기에 가장 와닿는건 빈의 생명주기 관리를 할 수 없고, &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 자동으로 등록해주지 않는다는 것이다. 뭐 수동으로 등록해주면 되기는 하지만, 상당히 불편하다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-introduction&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wonwoo.ml/index.php/post/1571&#34;&gt;ApplicationContext와 BeanFactory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC 컨테이너란 무엇일까</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</link>
      <pubDate>Wed, 24 Mar 2021 18:13:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</guid>
      <description>&lt;p&gt;스프링 전반적인 기술을 주제로 사내 세미나를 하였다. 따라서 이를 공식 문서를 보면서 복습하면서 다시 정리해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112285137-55c39f00-8ccd-11eb-9416-87ba7f879ce0.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 18 09 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 코어 문서 가장 첫 부분에 나와있는 문구이다. 전체적인 기술을 다루지만 특히 스프링 프레임워크의 &lt;code&gt;IoC(Inversion of Control)&lt;/code&gt; 컨테이너가 가장 중요하다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring Framework&lt;/code&gt;의 IoC 컨테이너에 대한 처리는 &lt;code&gt;Spring&lt;/code&gt;의 &lt;code&gt;AOP(Aspect-Oriented Programmin)&lt;/code&gt; 기술을 밀접하게 따르고 있다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프링 프레임워크는 개념적으로 이해하기 쉽고 자바 엔터프라이즈 프로그래밍에서 &lt;code&gt;AOP&lt;/code&gt; 요구사항의 80%를 성공적으로 해결하는 &lt;code&gt;AOP&lt;/code&gt; 프레임워크가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스프링-ioc-컨테이너-및-빈bean&#34;&gt;스프링 IoC 컨테이너 및 빈(Bean)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112286205-6c1e2a80-8cce-11eb-9eef-2ca033148bc9.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 26 06 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 장에서는 제어의 반전(&lt;code&gt;IoC&lt;/code&gt;) 원칙의 스프링 프레임워크 구현에 대해서 다룬다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IoC&lt;/code&gt;는 의존성 주입이라고 알려져 있다. &lt;code&gt;(DI)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DI&lt;/code&gt;는 객체가 생성자 파라미터, 펙토리 메서드에서 반환된 후 객체 인스턴스에 설정된 속성을 통해서만 객체의 종속성을 정의하는 프로세스이다.&lt;/li&gt;
&lt;li&gt;그런 다음에, 컨테이너가 빈을 생성할 때, 이러한 종속성을 주입한다.&lt;/li&gt;
&lt;li&gt;이러한 프로세스는 기본적으로 클래스 직접 구성이나 서비스 로케이터 패턴과 같은 매커니즘을 이용하여, 종속성의 인스턴스 화를 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt;와 &lt;code&gt;org.springframework.context&lt;/code&gt; 패키지들이 스프링 프레임워크 &lt;code&gt;IoC&lt;/code&gt; 컨테이너의 기본 구성을 이루고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 인터페이스는 모든 타입의 객체를 관리할 수 있는 고급 설정 매커니즘을 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;는 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112288026-48f47a80-8cd0-11eb-8efe-6d675e3ae5da.png&#34; alt=&#34;ApplicationContextInterface&#34;&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 그림으로 이해하면 이해하기 편하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단히 말해서 &lt;code&gt;BeanFactory&lt;/code&gt;는 구성 프레임워크와 기본 기능을 제공하며 &lt;code&gt;Application Context&lt;/code&gt;는 더 많은 엔터프라이즈별 기능을 추가한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;에서는 애플리케이션의 핵심을 구성하고, &lt;code&gt;Spring IoC&lt;/code&gt; 컨테이너에 의해서 관리되는 개체를 빈(Bean)이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈은 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너에 의해서 인스턴스화, 조립 및 관리되는 객체이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇지 않으면 빈(Bean)은 응용 프로그램의 여러 객체에 불과하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈과 빈 사이의 종속성은 컨테이너가 사용하는 설정 메타데이터에 의해서 반영된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;컨테이너-개요&#34;&gt;컨테이너 개요&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289026-434b6480-8cd1-11eb-9a2c-3a924dee26c7.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 46 34 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;org.springframework.context.ApplicationContext&lt;/code&gt;는 &lt;code&gt;Spring Ioc&lt;/code&gt; 컨테이너를 나타내며 빈의 인스턴스화 및 구성 및 조립을 담당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 메타데이터 설정을 읽어서, 인스턴스화, 구성 및 조립할 객체에 대한 지침을 가져온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구성 메타데이터는 &lt;code&gt;XML&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt; 어노테이션 또는 &lt;code&gt;Java&lt;/code&gt; 코드로 표시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션을 구성하는 객체와 이러한 객체간의 풍부한 상호 종속성을 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289745-e9976a00-8cd1-11eb-9b9d-8022fe6a673b.png&#34; alt=&#34;container-magic&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 그림은, 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너가 빈 설정정보를 읽어서, &lt;code&gt;ApplicationContext&lt;/code&gt; 생성되고 초기화되면 완전히 구성되고 실행 가능한 시스템 또는 응용 프로그램의 생성을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-스코프와-라이프-사이클bean-scope-and-lifecycle&#34;&gt;빈의 스코프와 라이프 사이클(Bean Scope and LifeCycle)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292568-8f4bd880-8cd4-11eb-95e0-2884097eed6f.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 10 07 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너는 하나 이상의 빈을 관리한다. 이러한 빈은 컨테이너에 제공하는 메타데이터 XML &lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt; 형식으로 제공된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너 자체 내에서 이러한 빈 정의는 &lt;code&gt;BeanDefinition&lt;/code&gt; 객체로 표시되며, 여기에는 (다른 정보 중에서도) 다음과 같은 메타데이터가 포함된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스 이름: 정의되는 빈의 실제 구현 클래스이다.&lt;/li&gt;
&lt;li&gt;빈이 클래스에서 어떻게 동작해야하는지를 나타내는 동작 구성 요소이다. (범위, 라이프 사이클 콜백 등).&lt;/li&gt;
&lt;li&gt;빈이 동작하는데 의존성을 가지는 다른 빈에 대한 참조이다. 이러한 참조를 &lt;code&gt;collaborators&lt;/code&gt; 또는 &lt;code&gt;dependencies&lt;/code&gt; 라고 한다.&lt;/li&gt;
&lt;li&gt;새로 생성된 개체에서 설정할 기타 구성 설정(예: 풀의 크기 제한 또는 연결 풀을 관리하는 빈에서 사용할 연결 수)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112293473-87d8ff00-8cd5-11eb-9250-16ae9694c705.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 17 00 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 표는 빈의 정의를 나타내고 속성은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;: Bean을 생성하기 위한 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;: Bean의 이름을 말한다. Bean이 누군가에 의해 참조되어야 할 때 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scope&lt;/code&gt;: Bean의 생명주기와 관련하여 어느 Scope에 유일하게 존재할 것이냐에 대한 정의이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constructor arguements&lt;/code&gt;: 빈의 생성자로 의존성을 명시 하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Properties&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt;의 생성자로 의존성을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Autowiring&lt;/code&gt;: &lt;code&gt;Autowiring&lt;/code&gt;에 대한 방법을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lazy initializaton&lt;/code&gt;: &lt;code&gt;Lazy&lt;/code&gt; 하게 &lt;code&gt;Bean&lt;/code&gt;을 초기화 시키도록 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Initialization method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 초기화 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destuction method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 파괴 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112295826-9d4f2880-8cd7-11eb-8792-a5ce9d603d7e.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 31 54 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;: (Default) SPRING IoC 컨테이너당 하나의 레퍼런스만 존재하는 스코프입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;: 임의의 수의 객체 인스턴스로 단일 빈의 범위를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;: 단일 빈 정의의 범위를 단일 HTTP 요청의 수명 주기로 지정한다, 각, HTTP 요청에는 단일 빈 정의 뒤에 생성된 빈 인스턴스가 있다, 오직 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 단일 빈 정의의 범위를 HTTP 세션의 생명주기로 지정한다. 오직 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application&lt;/code&gt;: 단일 빈의 정의를 서블릿 컨텍스트의 생명주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt; 에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;websocket&lt;/code&gt;: 단일 &lt;code&gt;bean&lt;/code&gt;의 정의를 &lt;code&gt;WebSocket&lt;/code&gt;의 생명 주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-생명-주기-콜백lifecycle-callbacks&#34;&gt;빈의 생명 주기 콜백(Lifecycle Callbacks)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112397674-e8078980-8d45-11eb-8439-6ab8de4ed0b0.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 41 23 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨테이너의 빈 생명주기와 상호 작용하기 위해서 &lt;code&gt;InitializingBean&lt;/code&gt;, &lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 빈을 초기화 하기 전에 &lt;code&gt;afterPropertiesSet()&lt;/code&gt;을 호출하고 &lt;code&gt;Bean&lt;/code&gt; 소멸시에 &lt;code&gt;destory()&lt;/code&gt;를 호출하여 특정 작업을 수행하게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JSR-250 스펙에서는 &lt;code&gt;@PostConstruct&lt;/code&gt;, &lt;code&gt;@PreDestory&lt;/code&gt; 어노테이션을 사용하는데, 일반적으로 최신 스프링 애플리케이션에서 생명 주기 콜백을 수신하기 위한 좋은 방법이다. 어노테이션을 사용한다는 것은 스프링이 특정 인터페이스에 결합되지 않는다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내부적으로 &lt;code&gt;SpringFramework&lt;/code&gt;는 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 구현을 사용하여 적절한 메서드를 찾아 호출할 수 있는 모든 콜백 인터페이스를 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 기능이 필요하거나, 스프링이 기본적으로 제공하지 않는 다른 라이프 사이클 동작이 필요한 경우 &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 직접 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398510-b8f21780-8d47-11eb-8584-09600530656c.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 54 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InitializingBean&lt;/code&gt; 인터페이스는 불 필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PostConstruct&lt;/code&gt; 주석을 사용하거나 &lt;code&gt;POJO&lt;/code&gt; 초기화 방법을 지정하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XML 기반 구성 메타 데이터의 경우 &lt;code&gt;init-method&lt;/code&gt; 속성을 사용하여 인수없는 빈 서명이 있는 메서드의 이름을 지정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 설정으로는 &lt;code&gt;@Bean&lt;/code&gt;의 &lt;code&gt;initMethod&lt;/code&gt; 속성을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;여러 가지 방법으로 구현할 수 있지만, 인터페이스 방법은 권장하지 않는 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398918-84cb2680-8d48-11eb-8b2a-29065259f433.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 00 11 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.beans.factory.DisposableBean&lt;/code&gt; 인터페이스를 구현하면 이를 포함하는 컨테이너가 소멸될 때, &lt;code&gt;Bean&lt;/code&gt;이 콜백을 받을 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스는 단일 메서드를 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기화와 같이 인터페이스 구현은 불필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PreDestory&lt;/code&gt; 주석을 사용하거나 빈 정의에서 지원하는 일반 메서드를 지정하는 것이 좋습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112400248-4d11ae00-8d4b-11eb-9b5c-8de0b739da81.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 19 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 고유의 &lt;code&gt;InitializingBean&lt;/code&gt; 또는 &lt;code&gt;DisposableBean&lt;/code&gt; 콜백 인터페이스를 사용하지 않는 초기화 및 폐기 메서드 콜백을 작성할 때는 일반적으로 &lt;code&gt;init()&lt;/code&gt;, &lt;code&gt;initialize()&lt;/code&gt;, &lt;code&gt;dispose()&lt;/code&gt;등과 같은 이름으로 작성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이상적으로는 이러한 수명주기 콜백 메서드의 이름은, 모든 개발자가 동일한 메서드 이름을 사용하고 일관성을 보장하기 위함이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;그렇다면 InitializingBean과 DisposableBean 인터페이스를 구현하는 것과 @PostConstruct, @PreDestory를 사용하는 것의 차이점은 무엇일까?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>사내 세미나 과제 피드백 CH10 - Future, ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture.html</link>
      <pubDate>Sat, 13 Mar 2021 11:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture.html</guid>
      <description>&lt;p&gt;회사에서 자바 비동기 처리 및 &lt;code&gt;Future&lt;/code&gt;, &lt;code&gt;CompletableFuture&lt;/code&gt;에 대해서 세미나를 진행하였다.&lt;/p&gt;
&lt;p&gt;과제를 진행하면서, 비동기 프로그래밍 및 자바에서 비동기 프로그래밍을 어떻게 사용하는지 생각해 볼 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dongwooklee96/java-chap10-assignment&#34;&gt;사내 세미나 과제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111016625-5a957280-83f2-11eb-847c-b5e8deaf3ac7.png&#34; alt=&#34;Screen Shot 2021-03-13 at 11 50 40 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;친절하게 피드백을 해주셨기 때문에, 내가 &lt;code&gt;ComputableFuture&lt;/code&gt;를 잘못사용하고 있다는 사실을 알게 되었다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-java8&#34; data-lang=&#34;java8&#34;&gt;repository.retrieveCategories().parallelStream()
                .map(category -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category)))
                .collect(Collectors.toList())
        .parallelStream()
        .map(CompletableFuture::join)     // (1)
        .flatMap(Collection::parallelStream)
        .collect(Collectors.toList())
        .parallelStream()
        .map(book -&amp;gt; CompletableFuture.runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
        .collect(Collectors.toList())
        .forEach(CompletableFuture::join); // (2)
        executors.shutdown();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 코드는 내가 처음에 제출한 코드이다. 문제점을 보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드에서 &lt;code&gt;join&lt;/code&gt;을 사용한 곳이 2개정도 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt;은 현재 &lt;code&gt;Thread&lt;/code&gt;를 블록킹 하여 결과를 기다리는 연산이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;ComputableFuture&lt;/code&gt;는 이러한 &lt;code&gt;join&lt;/code&gt; 없이 &lt;code&gt;CompletionStage&lt;/code&gt;라는 약속을 기반으로 &lt;code&gt;Non blocking&lt;/code&gt; 기반의 비동기 처리를 할 수 있게 도와준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 나는 이러한 특징을 이해하지 못하고, &lt;code&gt;join&lt;/code&gt;을 남발하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 스트림의 중간 연산 단계에서 &lt;code&gt;join&lt;/code&gt;을 호출하면, 게으른 연산을 하는 특성으로 인해서 순차적인 &lt;code&gt;blocking&lt;/code&gt;이 걸릴 수 있다. 따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stream&lt;/code&gt;으로 변환할 때, &lt;code&gt;parallelStream&lt;/code&gt;은 조심해서 사용을 해야한다. &lt;code&gt;parallelStream&lt;/code&gt; 작업을 멀티코어에서 병렬처리 하는 것은 일반적으로 데이터가 많을 때 유리하다. 데이터가 적으면 오히려 분할하는데 시간이 더 걸린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이러한 최적화는 여러번 수행해보면서 반드시 측정을 기반으로 선택이 되어야한다. 그러한 경우가 아니라면 &lt;code&gt;stream&lt;/code&gt;도 충분하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;꼭 필요한 곳이 아니라면, &lt;code&gt;join&lt;/code&gt; 연산은 최종적으로 &amp;ldquo;동기&amp;quot;가 필요한 곳에서 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 피드백을 받은 부분을 개선한 결과는 다음과 같다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;final List&amp;lt;CompletableFuture&amp;lt;List&amp;lt;Book&amp;gt;&amp;gt;&amp;gt; futures
            = repository.retrieveCategories().stream()
            .map(category -&amp;gt; supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category), executors))
            .collect(toList());

        final List&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; updateFutures
            = futures.stream()
            .map(future -&amp;gt; future.thenCompose(books -&amp;gt; allOf(
                books.stream()
                    .map(book -&amp;gt; runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
                    .toArray(CompletableFuture[]::new)
            )))
            .collect(toList());
        updateFutures.forEach(CompletableFuture::join);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ComputableFuture&lt;/code&gt;로 작업을 처리한 후에, 최종적으로 한꺼번에  &lt;code&gt;join&lt;/code&gt; 을 해주고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스프링 시큐리티 아키텍처 (미완성)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1.html</link>
      <pubDate>Thu, 11 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1.html</guid>
      <description>&lt;h2 id=&#34;인증authentication과-인과authorization&#34;&gt;인증(Authentication)과 인과(Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110706470-3f343700-823b-11eb-83e4-103013be399a.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 26 53 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어플리케이션 보안은 두가지의 독립적인 문제로 나뉜다.&lt;/li&gt;
&lt;li&gt;바로 인증(&lt;code&gt;authentication&lt;/code&gt;)과 인가(&lt;code&gt;authorization&lt;/code&gt;)이다.&lt;/li&gt;
&lt;li&gt;인증은 (&lt;code&gt;who are you?&lt;/code&gt;) 이고, 인가는 (&lt;code&gt;what are you allowed to do?&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링 시큐리티는 인증과 인과를 분리하도록 설계된 아키텍처를 가지고 있으며, 두 가지 모두에 대한 전략과 확장 할 수 있는 포인트가 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인증-authentication&#34;&gt;인증 (Authentication)&lt;/h2&gt;
&lt;hr&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인증을 위한, &lt;code&gt;AuthenticationManager&lt;/code&gt; 라는 인터페이스를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;authenticate&lt;/code&gt; 라는 메서드를 제공하는데, 다음과 같은 3가지 일을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;입력이 유효한 주체를 나타내는지 확인할 수 있는 경우, &lt;code&gt;Authentication(authentication=true)&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력이 잘못된 주체를 나타내는 것으로 판단되는 경우에는, 예외를 던집니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약, 결정할 수 없는 경우에는, &lt;code&gt;null&lt;/code&gt;을 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationException&lt;/code&gt; 예외는 런타임 예외이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 응용 프로그램의 스타일이나 목적에 따라 응용 프로그램에서 일반적인 방식으로 처리됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프로그래머가 이러한 예외를 처리하지 않습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110708504-1f524280-823e-11eb-86b2-b33bbe5d09d4.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 48 00 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Authentication Manager&lt;/code&gt;의 가장 일반적으로 사용되는 구현은 &lt;code&gt;ProviderManager&lt;/code&gt;로, &lt;code&gt;AuthenticationProvider&lt;/code&gt; 인스턴스 체인을 지정합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationProvider&lt;/code&gt;는 &lt;code&gt;AuthenticationManager&lt;/code&gt;와 비슷하지만, 함수를 호출하는 사람에게, &lt;code&gt;Authentication&lt;/code&gt; 타입을 질의할 수 있는 메서드를 추가적으로 지원합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProviderManager&lt;/code&gt;는 선택적인 부모 요소를 가질 수 있으며, 모든 &lt;code&gt;ProviderManager&lt;/code&gt;가 &lt;code&gt;null&lt;/code&gt;을 반환하는 경우에 이를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상위의 &lt;code&gt;ProviderManager&lt;/code&gt;를 사용할 수 없는 경우에, &lt;code&gt;AuthenticationException&lt;/code&gt; 예외가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경우에 따라서, 애플리케이션은 접근 권한을 그룹으로 만들어야할 때가 있는데, 그룹 별 권한을 &lt;code&gt;AuthenticationManager&lt;/code&gt;에 위임한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;때때로, 각가의 &lt;code&gt;ProviderManager&lt;/code&gt;는, 상위 요소를 공유한다. 상위 요소는 글로벌 리소스의 일종으로 모든 프로바이더의 예외나 상황을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;authenticationmanager-커스터마이징&#34;&gt;AuthenticationManager 커스터마이징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 시큐리티는 응용 프로그램에 설정된 인증과 관련된 관리자 기능을 빠르게 구성할 수 있도록 몇가지 기능을 제공합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 사용되는 헬퍼는 &lt;code&gt;AuthenticationManagerBuilder&lt;/code&gt;를 사용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

   ... // web stuff here

  @Autowired
  public void initialize(AuthenticationManagerBuilder builder, DataSource dataSource) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser(&amp;quot;dave&amp;quot;)
      .password(&amp;quot;secret&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;@Bean&lt;/code&gt; 메서드로 &lt;code&gt;@Autowired&lt;/code&gt;되므로, &lt;code&gt;AuthenticationManager&lt;/code&gt;를 빌드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인가-authorization&#34;&gt;인가 (Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/guides/topicals/spring-security-architecture&#34;&gt;스프링 시큐리티 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스프링의 세 가지 특징</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95.html</link>
      <pubDate>Wed, 10 Mar 2021 08:00:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95.html</guid>
      <description>&lt;h1 id=&#34;스프링의-세-가지-특징&#34;&gt;스프링의 세 가지 특징&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;회사에서 하는 세미나에서, 자바 세미나가 끝나고 이어서 스프링 세미나를 시작하였다.&lt;/p&gt;
&lt;p&gt;세미나를 진행하면서, 강조했던 스프링의 세 가지 특징에 대해서 설명한 부분을 정리해보겠다.&lt;/p&gt;
&lt;h2 id=&#34;1-ioc--di-dl&#34;&gt;1. IoC / DI, DL&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;스프링 프레임워크는 DL (Dependency Look-up)과 DI(Dependency Injection)를 통해서 IoC (Inversion of Control)을 구현합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 진행하면서, 많은 라이브러리를 사용할 것이다.&lt;/li&gt;
&lt;li&gt;특정 라이브러리에서 원하는 기능을 사용하려면 &lt;code&gt;new&lt;/code&gt; 를 통해서 객체를 생성해야하는데, 이 객체를 생성하기 위해서는 다른 객체를 생성해야하는 등 복잡한 의존 관계가 발생하고 사용자는 파악하기 힘들다.&lt;/li&gt;
&lt;li&gt;따라서 스프링 프레임워크는 이러한 객체에 대한 생성과 객체간의 의존관계에 대한 관리를 개발자가 스프링에게 위임하게 된다.&lt;/li&gt;
&lt;li&gt;개발자는 스프링이 요구하는 대로 설정만 하면, 설정에 따라서 &lt;code&gt;Bean&lt;/code&gt;을 생성하여 컨테이너에 담고 &lt;code&gt;Bean&lt;/code&gt;간의 의존관계를 파악(&lt;code&gt;Dependency Look-up&lt;/code&gt;)하여 주입 (&lt;code&gt;Dependency Injection&lt;/code&gt;)해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;POJO (Plain Java Object)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링에서 생성되어 관리되는 POJO 기반의 객체를 우리는 &lt;code&gt;Spring Bean&lt;/code&gt;이라고 한다.&lt;/li&gt;
&lt;li&gt;여기서 &lt;code&gt;POJO&lt;/code&gt;는 단순 &lt;code&gt;getter/setter&lt;/code&gt;만으로 구성되어 있으며 단순히 &lt;code&gt;new&lt;/code&gt;를 통해서 생성 가능한 형태를 말한다.&lt;/li&gt;
&lt;li&gt;핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있으며 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-aop-aspect-oriented-programming&#34;&gt;2. AOP (Aspect Oriented Programming)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110551571-16e40400-8179-11eb-87cd-901053f4404b.png&#34; alt=&#34;image2021-3-8_18-35-52&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AOP는 관점지향 프로그래밍을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 프로젝트는 고유한 핵심 기능 외에 트랜잭션, 보안처리(인증, 인가), 로깅 등의 공통 기능을 반드시 포함할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;별다른 정책이 없다면, 우리는 매번 프로젝트에서 똑같은 로직을 계속해서 개발할 것이고 버그가 발생하면 여기저기서 수정 작업을 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOP는 어플리케이션의 기능을 핵심 기능과 공통 기능을 각각 종단 관심사와 횡단 관심사로 분리하고 공통 기능을 적절히 끼워넣을 수 있게 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;psa-portable-service-abstraction&#34;&gt;PSA (Portable Service Abstraction)&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;환경의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있는 환경을 제공하려는 추상화 구조를 말한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스프링은 언어가 아닌 기술(구현체의 기술)에 얽메이는 것에 큰 반감을 가짐 (&lt;code&gt;EJB&lt;/code&gt;, &lt;code&gt;Servlet&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링에서 동작할 수 있는 라이브러리들은 &lt;code&gt;POJO&lt;/code&gt; 형태로 되어 있음&lt;/li&gt;
&lt;li&gt;대표적인 추상화의 예
&lt;ul&gt;
&lt;li&gt;JPA의 구현체(&lt;code&gt;Hibernate&lt;/code&gt;, &lt;code&gt;Eclipse Link&lt;/code&gt;)를 추상화하는 &lt;code&gt;Spring Data JPA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mybatis&lt;/code&gt;를 추상화하는 &lt;code&gt;Spring-mybatis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spring Transaction Manager&lt;/code&gt;, &lt;code&gt;Spring Cache Manager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;서비스가 구동되는 환경(&lt;code&gt;Web MVC&lt;/code&gt;, &lt;code&gt;Web Flux&lt;/code&gt;)에 대해서도 추상화를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;버전에 따라서 라이브러리 혹은 프레임워크의 내부 API의 설계나 인터페이스가 달라지더라도, &lt;code&gt;Sping&lt;/code&gt;에서 적절히 감싸 추상화를 하기 때문에 우리의 소스코드는 변경될 일이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8.html</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8.html</guid>
      <description>&lt;h2 id=&#34;mediatypeapplication_json_utf8&#34;&gt;MediaType.APPLICATION_JSON_UTF8&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257472-75767a00-7fe1-11eb-82e2-0f1db1ca3886.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 39 39 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257431-38aa8300-7fe1-11eb-8389-34b865de421b.png&#34; alt=&#34;deprecated&#34;&gt;&lt;/p&gt;
&lt;p&gt;테스트 코드를 작성하다가, &lt;code&gt;MediaType.APPLICATION_JSON_UTF8&lt;/code&gt; 부분이 &lt;code&gt;Deprecated&lt;/code&gt; 된 것을 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 &lt;code&gt;Deprecated&lt;/code&gt; 되었는지 알아보고 &lt;code&gt;API&lt;/code&gt; 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257623-11a08100-7fe2-11eb-93fc-771900030db8.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 44 02 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 주석을 읽어보니 이유는 다음과 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 &lt;code&gt;UTF-8&lt;/code&gt; 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 이제는 &lt;code&gt;APPLICATION_JSON_UTF8&lt;/code&gt;을 사용하는 것 보다는 그냥 &lt;code&gt;APPLICATION_JSON&lt;/code&gt; 을 사용하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258251-fe42e500-7fe4-11eb-8fb8-06b332bf7b95.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 04 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 링크에 나와있듯이, &lt;code&gt;Content-Type&lt;/code&gt;을 &lt;code&gt;application/json&lt;/code&gt;으로 명시를 해도 인코딩이 깨진다고 버그 리포팅을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;charset=utf-8&lt;/code&gt;로 명시했을 때는 동작하지만 &lt;code&gt;charset&lt;/code&gt; 은  &lt;code&gt;application/json&lt;/code&gt;에 명시되어있지 않고 무시 되어야 한다고 문제를 제기하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rfc4627&#34;&gt;RFC4627&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258583-a7d6a600-7fe6-11eb-8654-5aa39d132d55.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 16 46 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258530-6b0aaf00-7fe6-11eb-969c-b32776e629cd.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 15 10 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인코딩 부분을 살펴보면, &lt;code&gt;JSON&lt;/code&gt; 타입은 유니코드로 인코딩 되어야 하며 디폴트로 &lt;code&gt;UTF-8&lt;/code&gt;이 적용된다는 부분을 살펴볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;느낀점&#34;&gt;느낀점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 나였으면 그냥 내가 잘못 한 거구나라고 하면서 &lt;code&gt;charset&lt;/code&gt; 옵션을 주고 스펙까지 확인해볼 생각을 하지 않을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 점은 나도 배워야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4627&#34;&gt;RFC4627&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture.html</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture.html</guid>
      <description>&lt;h2 id=&#34;computablefuture란&#34;&gt;ComputableFuture란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Future를 외부에서 완료시킬 수 없다.&lt;/li&gt;
&lt;li&gt;작업을 취소하거나, &lt;code&gt;get()&lt;/code&gt;에 타임아웃을 설정할 수 없다.&lt;/li&gt;
&lt;li&gt;블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다.&lt;/li&gt;
&lt;li&gt;예외처리용 &lt;code&gt;API&lt;/code&gt;를 제공하지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비동기로-작업-실행하기&#34;&gt;비동기로 작업 실행하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;비동기로 작업을 실행하는 방법은 두가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runAsync()&lt;/code&gt;: 리턴값이 없는 경우 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;supplyAsync()&lt;/code&gt;: 리턴 값이 있는 경우 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음은 &lt;code&gt;ComputableFuture&lt;/code&gt;를 사용한 예제이다. &lt;code&gt;get()&lt;/code&gt;을 호출 했을 때 실행되게 된다.
자바 &lt;code&gt;API&lt;/code&gt;를 살펴보면 &lt;code&gt;supplyAsync()&lt;/code&gt;메서드는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110235572-1e868b80-7f74-11eb-9235-e71a182b912b.png&#34; alt=&#34;runAsync&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환한다. &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;에서 실행중인 태스트에 의해서 비동기적으로 실행된다.&lt;/li&gt;
&lt;li&gt;역시 새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환하지만 차이점은 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스크를 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;ForkJoinPool&lt;/code&gt;을 사용하지 않는다면 다음과 같이 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스트가 처리되도록 할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }, executorService).thenRunAsync(() -&amp;gt; {
            System.out.println(Thread.currentThread().getName());
        }, executorService);
        future.get();
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;콜백-제공하기&#34;&gt;콜백 제공하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenApply(Function)&lt;/code&gt;: 리턴값을 받아서 다른 값으로 바꾸는 콜백&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenAccept(Consumer)&lt;/code&gt;: 리턴값을 또 다른 작업으로 처리하는 콜백 (리턴 없이)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenRun(Runnable)&lt;/code&gt;: 리턴 값을 받지 않고 다른 작업을 처리하는 콜백&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;조합하기&#34;&gt;조합하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCompose()&lt;/code&gt;: 두 작업이 서로 이어서 실행하도록 조합하기&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCompose(Main::getWorld);

        System.out.println(future.get());
    }

    private static CompletableFuture&amp;lt;String&amp;gt; getWorld(String message) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return message + &amp;quot; World&amp;quot;;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCombine()&lt;/code&gt;: 두 작업을 독립적으로 실행하고 둘다 종료했을 때, 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; world = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;World&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCombine(world, (h, w) -&amp;gt; h + &amp;quot; &amp;quot; + w);
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음과 같이 두 작업이 각각 실행하여, 둘다 종료되었을 때, 콜백이 실행되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allOf()&lt;/code&gt;: 여러 작업을 모두 실행하고 모든 작업 결과에 콜백 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anyOf&lt;/code&gt;: 여러 작업중에 가장 빨리 끝난 하나의 결과에 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;예외-처리&#34;&gt;예외 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exceptionally(Funciton)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).exceptionally(ex -&amp;gt; {
            System.out.println(ex);
            return &amp;quot;Error&amp;quot;;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handle(BiFunction)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).handle((result, ex) -&amp;gt; {
            if (ex != null) {
                System.out.println(ex);
                return &amp;quot;ERROR!&amp;quot;;
            }
            return result;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future.html</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future.html</guid>
      <description>&lt;h2 id=&#34;callable과-future&#34;&gt;Callable과 Future&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;과 &lt;code&gt;Runnable&lt;/code&gt;의 차이점은 작업의 결과를 받을 수 있다는 사실이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198342-24f20600-7e95-11eb-827d-e423468801e7.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 &lt;code&gt;Future&lt;/code&gt;에 대해 설명한 API 주석이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기식 계산의 결과를 나타냅니다.&lt;/li&gt;
&lt;li&gt;계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다.&lt;/li&gt;
&lt;li&gt;결과는 계산이 완료된 경우에만 메서드 &lt;code&gt;get&lt;/code&gt;을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다.&lt;/li&gt;
&lt;li&gt;또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.&lt;/li&gt;
&lt;li&gt;작업이 완료되면 이를 취소할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get---결과를-가져오기&#34;&gt;get() - 결과를 가져오기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198530-8d8db280-7e96-11eb-9b45-45b9bae25d57.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;은 오버로딩 된 두가지 메서드를 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계산이 완료될 때까지 기다린 다음에 결과를 검색한다.&lt;/li&gt;
&lt;li&gt;최대 지정된 시간까지 기다렸다가 사용 가능한 경우 결과를 검색합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Future&amp;lt;String&amp;gt; helloFuture = executorService.submit(hello);
        System.out.println(&amp;quot;Started!&amp;quot;);

        helloFuture.get(); // blocking call

        System.out.println(&amp;quot;End!!&amp;quot;);
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음과 같은 경우에는 터미널에 &lt;code&gt;Started!&lt;/code&gt; 라는 글씨가 적히고 나서, 2초간 대기를 한 후에 &lt;code&gt;End!!&lt;/code&gt; 라는 글씨가 찍히게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;타임아웃(최대로 기다릴 시간)을 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isdone-iscancelled---작업-상태-확인하기&#34;&gt;isDone(), isCancelled() - 작업 상태 확인하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198688-a64a9800-7e97-11eb-8f77-8bd8a28d5757.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isDone&lt;/code&gt;은 작업이 완료되었으면 참을 반환하고 아닌 경우에는 거짓을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isCancelled&lt;/code&gt;는 작업이 완료된 경우 참을 반환한다. 작업이 정상적으로 종료되거나, 예외 또는, 취소된 경우도 역시 참으로 반환된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cancel---작업-취소하기&#34;&gt;cancel() - 작업 취소하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199234-d3e51080-7e9a-11eb-9fb7-1ff63519640f.png&#34; alt=&#34;작업 취소&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작업을 취소할 때 사용한다.&lt;/li&gt;
&lt;li&gt;작업이 이미 완료되었거나, 취소되었거나, 다른 이유로 취소할 수 없는 경우에는 실패한다.&lt;/li&gt;
&lt;li&gt;이 메서드가 실행된 후에 &lt;code&gt;isDone()&lt;/code&gt;는 항상 참을 반환한다.&lt;/li&gt;
&lt;li&gt;일반적으로 작업이 이미 정상적으로 완료되었기 때문에, 작업을 취소할 수 없는 경우에는 거짓을 반환하고 그렇지 않으면 참을 반환한다.&lt;/li&gt;
&lt;li&gt;성공적으로 취소했으면, 참 아니면 거짓을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;invokeall과-invokeany의-차이점&#34;&gt;invokeAll()과 invokeAny()의 차이점&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;invokeall&#34;&gt;invokeAll&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199536-2d017400-7e9c-11eb-8b43-33862e419425.png&#34; alt=&#34;invokeAll&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;태스크를 실행하고 모두 완료되거나 시간 초과가 만료될 때, 상태 및 결과를 저장하고 있는 &lt;code&gt;Future&lt;/code&gt; 목록을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future.isDone&lt;/code&gt;은 반환된 목록의 각 요소에 대해서 적용됩니다.&lt;/li&gt;
&lt;li&gt;반환시에 완료되지 않은 태스크는 취소됩니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정한 컬렉션이 수정되면 메서드의 결과가 정의되지 않습니다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 가장 오래걸리는 작업만큼 시간이 소요된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = executorService.invokeAll(Arrays.asList(hello, java, dongwook));

        for (Future&amp;lt;String&amp;gt; f : futures) {
            System.out.println(f.get()); // Hello, Java, Dong Wook 순서대로 출력된다.
        }
        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;invokeany&#34;&gt;invokeAny&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199641-adc07000-7e9c-11eb-8c91-a79c559268e2.png&#34; alt=&#34;invokeAny&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성공적으로 완료된 태스크의 결과를 반환합니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정된 컬렉션이 수정되면 이 메서드의 결과가 정의되지 않는다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 제일 짧게 걸리는 작업만큼 시간이 걸린다.&lt;/li&gt;
&lt;li&gt;이 역시 또한 블록킹 콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        String futures = executorService.invokeAny(Arrays.asList(hello, java, dongwook));

        System.out.println(futures); // Dong Wook
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces.html</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces.html</guid>
      <description>&lt;h1 id=&#34;executor-interfaces&#34;&gt;Executor Interfaces&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;, 태스크를 관리하는 인터페이스 입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt;는 &lt;code&gt;Executor&lt;/code&gt;의 하위 인터페이스이며 태스트와 &lt;code&gt;Exector&lt;/code&gt;의 라이프 사이클을 관리하는 기능을 포함하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;는 &lt;code&gt;ExecutorService&lt;/code&gt;의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executor-인터페이스&#34;&gt;Executor 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109464198-a159a300-7aa9-11eb-87f8-85c69935a454.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 16 49 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465577-bf280780-7aab-11eb-98d3-3fd65c0177ec.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 32 36 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt; 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executorservice-인터페이스&#34;&gt;ExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465963-542b0080-7aac-11eb-929c-517e84df5f5c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 36 24 PM&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.submit(() -&amp;gt; {
            System.out.println(&amp;quot;Thread &amp;quot; + Thread.currentThread().getName());
        });

        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다음작업이 들어올 때가지 계속 대기를 하기 때문에 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;showdown()&lt;/code&gt; 메서드를 사용하여 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shutdown-과-shutdownnow의-차이점&#34;&gt;shutdown() 과 shutdownNow()의 차이점&lt;/h4&gt;
&lt;p&gt;메서드 주석을 읽어본 결과 다음과 같은 차이가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109467219-35c60480-7aae-11eb-920c-201a60fb2a75.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt; 메서드는 이전에 제출된 태스트가 실행이 되고 더 이상 새로운 태스크는 수락하지 않으며 작업을 종료하기 시작한다. 하지만 &lt;code&gt;shutdownNow()&lt;/code&gt; 메서드는 실행 중인 작업이 종료될 때까지 기다리지 않고 실행중인 작업 처리를 중단 하려는 보장을 할 수 없다고 되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scheduledexecutorservice-인터페이스&#34;&gt;ScheduledExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465999-61e08600-7aac-11eb-892d-ee3b46714715.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 37 15 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt; 인터페이스는 지정한 지연시간 후에 실행 또는 호출 가능한 태스크를 실행하는 기능을 지원한다.&lt;/li&gt;
&lt;li&gt;지정된 태스크를 정의된 간격으로 반복적으로 실행하는 &lt;code&gt;scheduledWithFixedDelay&lt;/code&gt; 및 &lt;code&gt;ScheduledAtFixedRate&lt;/code&gt;를 정의합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰레드-풀&#34;&gt;쓰레드 풀&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109468299-bcc7ac80-7aaf-11eb-8e93-2e15be786920.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 패키지의 Executor 구현은 대부분은 워커 쓰레드로 구성된 쓰레드 풀을 사용한다. 이러한 종류의 스레드는 &lt;code&gt;Runnable&lt;/code&gt; 및 &lt;code&gt;Callable&lt;/code&gt;로 각각 존재하며 여러가지 태스크를 실행하는데 종종 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;워커 쓰레드를 사용하면 스레드 생성으로 인한 오버헤드가 최소화 된다. 스레드 개체는 상당한 양의 메모리를 사용하며, 대규모 애플리케이션에서는 많은 스레드 개체를 할당 및 할당 해제하면 상당한 메모리 관리 오버헤드가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 유형의 쓰레드 풀은 쓰레드의 개수가 고정되어 있고 이 유형의 풀에서는 항상 지정된 수의 스레드가 실행되며, 스레드가 동작할 때 갑자기 종료되면 새로운 스레드로 교체되어 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;태스크는 큐를 통해서 풀에 제출되며 풀에 있는 스레드보다 많은 태스크가 있을 때는 잠시 큐에서 대기한다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;runnable-과-callable의-차이&#34;&gt;Runnable 과 Callable의 차이&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469393-4d52bc80-7ab1-11eb-89d4-24e040a2161c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 스레드에 의해서 실행되도록 설계된 모든 클래스에 의해 구현되어야 한다.&lt;/li&gt;
&lt;li&gt;클래스는 &lt;code&gt;Run()&lt;/code&gt; 메서드를 정의해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469486-6fe4d580-7ab1-11eb-886c-bdddc2d8fa90.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과를 반환하고 예외를 발생시킬 수 있는 작업이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 인터페이스는 다른 스레드에 의해서 잠재적으로 실행될 수 있다는 점에서 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스와 유사하지만 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 결과를 반환하지 않으며 선택한 예외를 발생시킬 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;forkjoin-프레임워크&#34;&gt;Fork/Join 프레임워크&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109471877-c1429400-7ab4-11eb-91fa-723f310cf9b9.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 37 04 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포크/조인 프레임워크는 여러 프로세서를 활용할 수 있도록 지원하는 &lt;code&gt;ExecutorService&lt;/code&gt; 인터페이스의 구현이다.&lt;/li&gt;
&lt;li&gt;반복적으로 작은 조각으로 쪼개 질 수 있는 작업을 위해서 고안이 되었다.&lt;/li&gt;
&lt;li&gt;다른 &lt;code&gt;ExecutorService&lt;/code&gt; 구현과 마찬가지로 포크/조인 프레임워크도 쓰레드 풀에 있는 워커 쓰레드에게 작업을 할당한다.&lt;/li&gt;
&lt;li&gt;포크/조인 프레임워크는 워크 스틸링 알고리즘을 사용하는 점에서 차이가 있고 할 일이 부족한 워커 쓰레드는 작동중인 다른 쓰레드에서 작업을 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;h1 id=&#34;동시성이란-concurrency&#34;&gt;동시성이란? (Concurrency)&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성-프로그래밍이란&#34;&gt;동시성 프로그래밍이란?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109454793-6438e500-7a98-11eb-9454-cc8af1cbfb76.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 13 30 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다.
유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다. 워드 프로세서 조차도 텍스트 서식을 변경하거나 디스플레이를 업데이트 하는 작업이 아무리 바쁘더라도 키보드 및 마우스 이벤트에 항상 응답을 할 준비가 되어있어야 합니다. 이러한 작업을 수행할 수 있는 소프트웨어를 동시성 소프트웨어라고 합니다.
자바 플랫폼은 동시성 프로그래밍을 지원하도록 처음부터 설계되었습니다. 자바 버전 5.0부터 자바는 높은 수준의 동시성 API를 포함하고 있습니다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&#34;프로세스와-쓰레드&#34;&gt;프로세스와 쓰레드&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109455687-7d429580-7a9a-11eb-9d1f-8155d55cbbf2.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 29 04 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성 프로그래밍에서는 두가지의 기본 실행 단위가 있다. 자바에서는 동시성 프로그래밍은 주로 쓰레드와 관련이 있지만, 프로세스 역시 중요하다. 컴퓨터 시스템에서 일반적으로 많은 프로세스와 스레드가 있다. 이는 단일 코어 시스템에서도 마찬가지이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109456633-99dfcd00-7a9c-11eb-886e-52f965f26b10.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 44 12 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;프로세스&#34;&gt;프로세스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 자체적으로 포함된 실행 환경이 있다. 일반적으로 프로세스에서는 개인적인 리소스 공간이 존재하고 특히 각각의 프로세스에는 자체적인 메모리 공간을 가집니다.&lt;/li&gt;
&lt;li&gt;대부분의 자바 가상 머신 구현은 단일 프로세스로 실행된다. &lt;code&gt;Java&lt;/code&gt;는 &lt;code&gt;ProcessBuilder&lt;/code&gt; 를 이용하여 추가적인 프로세스를 생성할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;쓰레드&#34;&gt;쓰레드&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 때때로 경량 프로세스라고 불리우며, 프로세스와 쓰레드 모두 실행 환경을 제공하지만 새로운 쓰레드를 만드는데 필요한 리소스가 새 프로세를 만드는 것보다 적은 비용이 든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 프로세스 내에 존재하며 모든 프로세스에는 최소한 한 개의 쓰레드가 있다. 쓰레드는 프로세스의 메모리, 열린 파일 및 자원을 공유합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 자원 공유는 쓰레드 간의 소통에 효율적이지만 잠재적으로 문제를 일으킬 수 있습니다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;자바에서-쓰레드를-사용하는-방법&#34;&gt;자바에서 쓰레드를 사용하는 방법&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;자바에서 쓰레드를 사용할 수 있는 방법에는 크게 3가지가 있다.&lt;/p&gt;
&lt;h4 id=&#34;1-thread를-상속-받는-방법&#34;&gt;1. Thread를 상속 받는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();

        System.out.println(&amp;quot;Hello&amp;quot;);
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-runnable을-구현하는-방법&#34;&gt;2. Runnable을 구현하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3-람다를-사용하는-방법&#34;&gt;3. 람다를 사용하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;쓰레드의-주요-기능&#34;&gt;쓰레드의 주요 기능&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&#34;sleep&#34;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460950-d0b9e100-7aa4-11eb-86c8-29276cda855f.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 59 PM&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep&lt;/code&gt; 은 스레드가 지정된 기간 동안 실행을 일시 중단 하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InterruptedException&lt;/code&gt;은 스레드가 슬립된 상태에서 다른 스레드가 현재 스레드를 인터럽트 시킬 떄 발생된다.&lt;/li&gt;
&lt;li&gt;위의 예제에서는 쓰레드가 1초동안 슬립 되었다가 다시 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;interrupt&#34;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460917-ba138a00-7aa4-11eb-85d3-0ad70e163bdf.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 22 PM&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            while (true) {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    System.out.println(&amp;quot;interrupt!&amp;quot;);
                    return;
                }
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        Thread.sleep(3000L);
        thread.interrupt();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;interrupt()&lt;/code&gt; 메서드를 호출 했을 때 &lt;code&gt;InterruptedException&lt;/code&gt; 예외가 발생하고 예외 처리 구문이 실행된다.&lt;/li&gt;
&lt;li&gt;스레드가 인터럽트 되었을 때, 처리하는 방식은 프로그래머가 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460851-a10ad900-7aa4-11eb-8f02-8d5812cd1f80.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 41 37 PM&#34;&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
        });
        thread.start();

        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        thread.join();
        System.out.println(thread + &amp;quot; is finished&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt;을 사용하면 스레드가 다른 스레드가 끝날 때까지 기다려준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;과 마찬가지로 &lt;code&gt;join()&lt;/code&gt;은 인터럽트가 되면  &lt;code&gt;InterruptedException&lt;/code&gt;을 호출하면서 종료 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
