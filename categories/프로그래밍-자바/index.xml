<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>프로그래밍 - 자바 on 개발자 이동욱</title>
    <link>/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94/</link>
    <description>Recent content in 프로그래밍 - 자바 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Thu, 25 Mar 2021 19:03:23 +0900</lastBuildDate><atom:link href="/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IoC의 여러가지 구현 방식(draft)</title>
      <link>/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</link>
      <pubDate>Thu, 25 Mar 2021 19:03:23 +0900</pubDate>
      
      <guid>/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</guid>
      <description>스프링 문서를 보면서, IoC에 대해서 공부를 하다가, 서비스 로케이터 패턴을 알게 되었다. 서비스 로케이터 패턴을 조사하다가 자연스럽게 다른 IoC 구현 방식도 알게 되었는데 정리를 해보았다.
참고 문헌  IOC 구현 방식  </description>
    </item>
    
    <item>
      <title>빈 펙토리와 애플리케이션 컨텍스트의 차이</title>
      <link>/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Wed, 24 Mar 2021 23:30:23 +0900</pubDate>
      
      <guid>/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>궁금증을 가지게 된 이유    스프링 문서를 보면서 공부하다가 위와 같은 문구를 보게 되었다. ApplicationContext가 BeanFactory의 서브 타입의 인터페이스라는 것이다.
  그렇다면 무슨 차이가 있을까라는 생각을 하게 되었다.
  BEAN FACOTRY  다행스럽게도 위와 같은 문서가 스프링 공식문서에서 제공되고 있었다. 차이점은 아래와 같다.
 BeanFactory API는 Spring IoC 기능을 위한 기초적인 기반을 제공한다. 이것의 구체적인 계약은, 주로 스프링의 다른 부분과 관련된 써드 파티 프레임워크와의 통합에 사용된다. BeanFactory 및 관련 인터페이스 (예: BeanFactoryAware, Initializing Bean, DispisableBean)는 다른 프레임워크 구성 요소의 중요한 통합지점이다.</description>
    </item>
    
    <item>
      <title>IoC 컨테이너란 무엇일까</title>
      <link>/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Wed, 24 Mar 2021 18:13:23 +0900</pubDate>
      
      <guid>/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>스프링 전반적인 기술을 주제로 사내 세미나를 하였다. 따라서 이를 공식 문서를 보면서 복습하면서 다시 정리해보았다.
  스프링 코어 문서 가장 첫 부분에 나와있는 문구이다. 전체적인 기술을 다루지만 특히 스프링 프레임워크의 IoC(Inversion of Control) 컨테이너가 가장 중요하다고 나와있다.
  Spring Framework의 IoC 컨테이너에 대한 처리는 Spring의 AOP(Aspect-Oriented Programmin) 기술을 밀접하게 따르고 있다고 한다.
  스프링 프레임워크는 개념적으로 이해하기 쉽고 자바 엔터프라이즈 프로그래밍에서 AOP 요구사항의 80%를 성공적으로 해결하는 AOP 프레임워크가 있다.</description>
    </item>
    
    <item>
      <title>사내 세미나 과제 피드백 CH10 - Future, ComputableFuture</title>
      <link>/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</link>
      <pubDate>Sat, 13 Mar 2021 11:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</guid>
      <description>회사에서 자바 비동기 처리 및 Future, CompletableFuture에 대해서 세미나를 진행하였다.
과제를 진행하면서, 비동기 프로그래밍 및 자바에서 비동기 프로그래밍을 어떻게 사용하는지 생각해 볼 수 있었다.
 사내 세미나 과제  친절하게 피드백을 해주셨기 때문에, 내가 ComputableFuture를 잘못사용하고 있다는 사실을 알게 되었다.
repository.retrieveCategories().parallelStream() .map(category -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category))) .collect(Collectors.toList()) .parallelStream() .map(CompletableFuture::join) // (1) .flatMap(Collection::parallelStream) .collect(Collectors.toList()) .parallelStream() .map(book -&amp;gt; CompletableFuture.runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors)) .collect(Collectors.toList()) .forEach(CompletableFuture::join); // (2) executors.shutdown(); 위의 코드는 내가 처음에 제출한 코드이다.</description>
    </item>
    
    <item>
      <title>스프링 시큐리티 아키텍처 (미완성)</title>
      <link>/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</link>
      <pubDate>Thu, 11 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</guid>
      <description>인증(Authentication)과 인과(Authorization)   어플리케이션 보안은 두가지의 독립적인 문제로 나뉜다. 바로 인증(authentication)과 인가(authorization)이다. 인증은 (who are you?) 이고, 인가는 (what are you allowed to do?) 스프링 시큐리티는 인증과 인과를 분리하도록 설계된 아키텍처를 가지고 있으며, 두 가지 모두에 대한 전략과 확장 할 수 있는 포인트가 존재한다.  인증 (Authentication)  public interface AuthenticationManager { Authentication authenticate(Authentication authentication) throws AuthenticationException; }   인증을 위한, AuthenticationManager 라는 인터페이스를 제공한다.
  AuthenticationManager는 authenticate 라는 메서드를 제공하는데, 다음과 같은 3가지 일을 한다.</description>
    </item>
    
    <item>
      <title>스프링의 세 가지 특징</title>
      <link>/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</link>
      <pubDate>Wed, 10 Mar 2021 08:00:33 +0900</pubDate>
      
      <guid>/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</guid>
      <description>스프링의 세 가지 특징  회사에서 하는 세미나에서, 자바 세미나가 끝나고 이어서 스프링 세미나를 시작하였다.
세미나를 진행하면서, 강조했던 스프링의 세 가지 특징에 대해서 설명한 부분을 정리해보겠다.
1. IoC / DI, DL   스프링 프레임워크는 DL (Dependency Look-up)과 DI(Dependency Injection)를 통해서 IoC (Inversion of Control)을 구현합니다.
  프로젝트를 진행하면서, 많은 라이브러리를 사용할 것이다. 특정 라이브러리에서 원하는 기능을 사용하려면 new 를 통해서 객체를 생성해야하는데, 이 객체를 생성하기 위해서는 다른 객체를 생성해야하는 등 복잡한 의존 관계가 발생하고 사용자는 파악하기 힘들다.</description>
    </item>
    
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</guid>
      <description>MediaType.APPLICATION_JSON_UTF8  테스트 코드를 작성하다가, MediaType.APPLICATION_JSON_UTF8 부분이 Deprecated 된 것을 확인할 수 있었다.
밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 Deprecated 되었는지 알아보고 API 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.
API 주석을 읽어보니 이유는 다음과 같았다.
 크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 UTF-8 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</guid>
      <description>ComputableFuture란   자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.  자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.
 Future를 외부에서 완료시킬 수 없다. 작업을 취소하거나, get()에 타임아웃을 설정할 수 없다. 블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다. 예외처리용 API를 제공하지 않았다.  비동기로 작업 실행하기  비동기로 작업을 실행하는 방법은 두가지가 있다.
 runAsync(): 리턴값이 없는 경우 사용한다. supplyAsync(): 리턴 값이 있는 경우 사용한다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</guid>
      <description>Callable과 Future   Callable과 Runnable의 차이점은 작업의 결과를 받을 수 있다는 사실이다. Future는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.  다음은 Future에 대해 설명한 API 주석이다.
 Future는 비동기식 계산의 결과를 나타냅니다. 계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다. 결과는 계산이 완료된 경우에만 메서드 get을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다. 또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</guid>
      <description>Executor Interfaces  Executor, 태스크를 관리하는 인터페이스 입니다. ExecutorService는 Executor의 하위 인터페이스이며 태스트와 Exector의 라이프 사이클을 관리하는 기능을 포함하고 있다. ScheduledExecutorService는 ExecutorService의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.  Executor 인터페이스  Executor 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다. Executor는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.  ExecutorService 인터페이스 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>동시성이란? (Concurrency)  동시성 프로그래밍이란? 동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다. 유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다.</description>
    </item>
    
  </channel>
</rss>
