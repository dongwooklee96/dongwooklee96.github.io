<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>프로그래밍 - 자바 on 개발자 이동욱</title>
    <link>/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94/</link>
    <description>Recent content in 프로그래밍 - 자바 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Mon, 08 Mar 2021 07:20:33 +0900</lastBuildDate><atom:link href="/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%90%EB%B0%94/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</guid>
      <description>MediaType.APPLICATION_JSON_UTF8  테스트 코드를 작성하다가, MediaType.APPLICATION_JSON_UTF8 부분이 Deprecated 된 것을 확인할 수 있었다.
밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 Deprecated 되었는지 알아보고 API 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.
API 주석을 읽어보니 이유는 다음과 같았다.
 크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 UTF-8 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</guid>
      <description>ComputableFuture란   자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.  자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.
 Future를 외부에서 완료시킬 수 없다. 작업을 취소하거나, get()에 타임아웃을 설정할 수 없다. 블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다. 예외처리용 API를 제공하지 않았다.  비동기로 작업 실행하기  비동기로 작업을 실행하는 방법은 두가지가 있다.
 runAsync(): 리턴값이 없는 경우 사용한다. supplyAsync(): 리턴 값이 있는 경우 사용한다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</guid>
      <description>Callable과 Future   Callable과 Runnable의 차이점은 작업의 결과를 받을 수 있다는 사실이다. Future는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.  다음은 Future에 대해 설명한 API 주석이다.
 Future는 비동기식 계산의 결과를 나타냅니다. 계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다. 결과는 계산이 완료된 경우에만 메서드 get을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다. 또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</guid>
      <description>Executor Interfaces  Executor, 태스크를 관리하는 인터페이스 입니다. ExecutorService는 Executor의 하위 인터페이스이며 태스트와 Exector의 라이프 사이클을 관리하는 기능을 포함하고 있다. ScheduledExecutorService는 ExecutorService의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.  Executor 인터페이스  Executor 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다. Executor는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.  ExecutorService 인터페이스 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>동시성이란? (Concurrency)  동시성 프로그래밍이란? 동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다. 유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다.</description>
    </item>
    
  </channel>
</rss>
