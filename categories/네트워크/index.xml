<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>네트워크 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html</link>
    <description>Recent content in 네트워크 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 15 Aug 2021 02:52:39 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>프로세스 사이의 통신 - 메시지 큐</title>
      <link>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90.html</link>
      <pubDate>Sun, 15 Aug 2021 02:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90.html</guid>
      <description>&lt;h3 id=&#34;메시지-큐&#34;&gt;메시지 큐&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;운영체제는 &lt;code&gt;IPC&lt;/code&gt;를 위해서 메시지 큐라는 객체를 제공한다. 메시지 큐는 말 그대로 큐라는 자료 구조로 구성되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐는 운영체제가 관리하는 별도의 객체로서 따라서 프로세스 A에서 프로세스 B에게 메시지를 전달하고자 프로세스 A에서 메시지 큐에 데이터를 복사하는 과정, 프로세스 B가 메시지 큐에서 데이터를 읽어오는 과정을 거쳐서 통신이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리를 설명했을 때와 유사한 순서로 메시지 큐의 생성, 메시지 큐의 타입 설정, 데이터 읽기, 데이터 쓰기의 과정에 관여하는 함수에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 사용하기 위해서는 &lt;code&gt;mq_open()&lt;/code&gt; 함수를 통해서 기존에 존재하는 메시지 큐에 접근할 수 있는 디스크립터를 얻어오거나 새로운 메시지 큐를 생성한 후에 생성된 메시지 큐에 접근할 수 있는 디스크립터를 얻어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// oflag에 O_CREAT가 명시된 경우
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);

// oflag에 O_CREAT가 명시되지 않은 경우
mqd_t mq_open(const char *name, int oflag);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;name: 메시지 큐 객체를 지칭하기 위한 이름&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oflag: 생성되는 메시지 큐의 특성 정의(공유 메모리의 oflag와 유사함)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mode: 생성되는 메시지 큐 객체의 퍼미션&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attr: 생성되는 메시지 큐 객체의 속성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;oflag&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;는 공유 메모리와 세마포어 함수의 &lt;code&gt;open&lt;/code&gt; 함수에서 사용되는 인자와 비슷한 성격을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct mq_attr {
  long mq_flags; // 메시지 큐의 블록, 논블록 설정 여부
  long mq_maxmsg; // 메시지 큐에 저장될 수 있는 메시지의 최대 수
  long mq_msgsize; // 메시지의 최대 사이즈 (바이트)
  long mq_curmsgs; // 메시지 큐에 들어있는 메시지의 수
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mq_attr&lt;/code&gt; 구조체는 생성되는 메시지 큐의 속성을 지정하기 위해서 사용되며 다음과 같이 정의된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int mq_getattr(mqd_t mqd, struct mq_attr *attr);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mqd: 속성값을 얻어오려고 하는 메시지 큐를 지칭하는 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attr: 속성값을 저장하기 위한 &lt;code&gt;mq_attr&lt;/code&gt; 구조체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐의 속성 정보는 &lt;code&gt;mq_getattr&lt;/code&gt; 함수를 사용하여 조회할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int mq_send(mqd_t mqd, const char *ptr, size_t len, unsigned int prio);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mqd&lt;/strong&gt;: 접근할 메시지 큐를 지정하기 위한 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ptr&lt;/strong&gt;: 전송할 데이터의 시작 지점을 가리키는 포인터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송할 데이터의 길이를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;prio&lt;/strong&gt;: 메시지의 우선순위를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐에 보내야 하는 데이터를 삽입하는 함수는 &lt;code&gt;mq_send&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ssize_t mq_receive(mqd_t mqd, char *ptr, size_t len, unsigned int *prio);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mqd&lt;/strong&gt;: 접근할 메시지 큐를 지정하기 위한 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ptr&lt;/strong&gt;: 전송받는 데이터의 시작 시점을 가리키는 포인터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송받는 데이터의 길이를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;prio&lt;/strong&gt;: 메시지의 우선순위를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반면 메시지 큐에서 데이터를 읽어오는 함수는 &lt;code&gt;mq_receive&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;부모와 자식 프로세스 사이에서 간단한 문자열을 전송하는 프로그램을 작성해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로그램은 자식 프로세스를 하나 생성한다.&lt;/li&gt;
&lt;li&gt;자식 프로세스는 사용자에게 문자열을 입력 받은 후에 메시지 큐를 이용하여 부모 프로세스에게 전송한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스는 화면에 전송받은 문자열을 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;mqueue.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define MQ_NAME &amp;quot;/test_mq&amp;quot;

int main(int argc, char **argv)
{
  mqd_t mqfd;
  int pid;
  unsigned int priority = 10;
  char send_buff[50];
  void *read_buff;
  int read_len;

  struct mq_attr attr;
  attr.mq_flags = 0;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = 10;

  mqfd = mq_open(MQ_NAME, O_CREAT|O_RDWR, 644, &amp;amp;attr);
  if (mqfd == (mqd_t)-1)
  {
    perror(&amp;quot;mq_open failure from main&amp;quot;);
    printf(&amp;quot;Errno = %d\n&amp;quot;,errno);
    exit(0);
  }

  pid = fork();
  if (pid == 0) {
    printf(&amp;quot;child: &amp;quot;);
    scanf(&amp;quot;%s&amp;quot;, send_buff);
    if (mq_send(mqfd, send_buff, strlen(send_buff), priority) == -1) {
      fprintf(stderr, &amp;quot;MQ SEND ERROR\n&amp;quot;);
      exit(1);
    }
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;FORK FAILURE\n&amp;quot;);
    exit(1);
  } else {
    if (mq_getattr(mqfd, &amp;amp;attr) == -1) {
      fprintf(stderr, &amp;quot;MQ_GET_ATTR ERROR \n&amp;quot;);
      exit(1);
    }
    read_buff = malloc(attr.mq_msgsize);
    read_len = mq_receive(mqfd, read_buff, attr.mq_msgsize, &amp;amp;priority);
    printf(&amp;quot;parent receives: %s\n&amp;quot;, (char*)read_buff);
  }
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/yjytov82iozfi4s/Screen%20Shot%202021-08-15%20at%208.51.54%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정상적으로 자식 프로세스에서 보낸 문자열이 부모 프로세스로 전달된 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한가지 주의할 점은 &lt;code&gt;struct mq_attr&lt;/code&gt; 구조체의 값을 설정할 때 현재 시스템에서 허용 가능한 값이 정해져있으므로 시스템에서 정한 값을 넘지 않도록 주의해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 설정값은 &lt;code&gt;/proc/sys/fs/mqueue/&lt;/code&gt; 위치에 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8xbgyr5un86s3q6/Screen%20Shot%202021-08-15%20at%208.56.06%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=kdr0923&amp;amp;logNo=50073835187&#34;&gt;네이버 블로그 - 메시지큐 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 공유 메모리, 세마포어</title>
      <link>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4.html</link>
      <pubDate>Sun, 15 Aug 2021 01:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4.html</guid>
      <description>&lt;h3 id=&#34;공유-메모리&#34;&gt;공유 메모리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/uhpa9tuknwl5qti/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리는 프로세스와 프로세스 사이의 공유할 수 있는 메모리 공간을 지정하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리를 사용하려면 3가지 과정이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;공유 메모리 객체를 만드는 과정&lt;/li&gt;
&lt;li&gt;공유 메모리 객체의 크기를 설정하는 과정&lt;/li&gt;
&lt;li&gt;공유 메모리 객체를 프로세스 메모리 영역과 맵핑하는 과정&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt; // 함수 정의
#include &amp;lt;sys/stat.h&amp;gt; // mode 매크로의 정의
#include &amp;lt;fcntl.h&amp;gt; // 0_로 시작하는 상수 매크로의 정의

int shm_open(const char *name, int oflag, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shm_open()&lt;/code&gt; 함수는 특정 이름을 갖는 공유 메모리 객체를 생성한 후에 그 객체에 접근할 수 있는 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 함수와 마찬가지로, 만약 같은 이름을 갖는 객체가 이미 존재하면 그 객체를 지시하는 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두번째 매개변수로 사용하는 &lt;code&gt;int&lt;/code&gt; 형 &lt;code&gt;oflag&lt;/code&gt; 는 &lt;code&gt;open&lt;/code&gt; 계열 함수에서 공통적으로 사용하는 인자로 객체의 읽기 쓰기 속성과 &lt;code&gt;open&lt;/code&gt;이 실행될 때의 행동들을 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;매크로 이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;O_RDWR&lt;/td&gt;
&lt;td&gt;객체를 읽기 쓰기가 가능한 상태로 설정한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_RDONLY&lt;/td&gt;
&lt;td&gt;객체를 읽기만 가능한 상태로 설정한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_CREAT&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하지 않을 경우 새로운 객체를 생성한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_EXCL&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하면 에러를 발생시킨다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_TRUNC&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하면 사이즈 0으로 만든다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;int ftruncate(int fd, off_t length);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;생성한 공유 메모리의 크기를 지정하는 과정은 &lt;code&gt;ftruncate()&lt;/code&gt; 함수를 통해서 이루어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t off_set);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;맵핑 영역의 보호 수준을 지정하는 &lt;code&gt;prot&lt;/code&gt; 매개변수의 사용을 위해서 다음과 같이 매크로 값이 정의되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;매크로 이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PROT_READ&lt;/td&gt;
&lt;td&gt;데이터의 읽기 작업이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_WRITE&lt;/td&gt;
&lt;td&gt;데이터의 쓰기 작업이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_EXEC&lt;/td&gt;
&lt;td&gt;데이터의 실행이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_NONE&lt;/td&gt;
&lt;td&gt;데이터의 접근이 불가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매개변수 &lt;code&gt;flag&lt;/code&gt;는 맵핑된 데이터의 처리방식에 대한 정보를 지정하며 &lt;code&gt;MAP_SHARED&lt;/code&gt; 값으로 지정하면 다른 프로세스와 맵핑된 영역을 공유하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리 영역의 맵핑을 제거하려면 &lt;code&gt;munmap&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;

int munmap(void *addr, size_t len);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: 맵핑을 제거할 시작 주소&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;: 제거할 사이즈&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;공유-메모리-사용-예제&#34;&gt;공유 메모리 사용 예제&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;공유 메모리 영역을 생성한 후 정수형 카운터를 관리한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스는 카운터 값을 각각 증가시킨다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스 간에 공유되는 정보를 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define SM_NAME &amp;quot;/Test&amp;quot;

int main(int argc, char *argv[]) {
  int shmfd;
  int pid;
  int status;
  int *test_value;

  shmfd = shm_open(SM_NAME, O_RDWR | O_CREAT, 0777);
  if (shmfd == -1) {
    fprintf(stderr, &amp;quot;open error\n&amp;quot;);
    exit(1);
  }

  if (ftruncate(shmfd, sizeof(int)) == -1) {
    fprintf(stderr, &amp;quot;truncate error\n&amp;quot;);
    exit(1);
  }

  test_value = mmap(0, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  close(shmfd);

  *test_value = 10;

  printf(&amp;quot;test value: %d\n&amp;quot;, *test_value);

  pid = fork();
  if (pid == 0) {
    *test_value = *test_value + 1;
    printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
    sleep(3);
    *test_value = *test_value + 1;
    printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
    exit(1);
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;fork failure\n&amp;quot;);
    exit(1);
  }
  else {
    sleep(1);
    *test_value = *test_value + 5;
    printf(&amp;quot;parent process test value: %d\n&amp;quot;, *test_value);
    wait(&amp;amp;status);
  }
  shm_unlink(SM_NAME);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/2ofu5de7n9htzw8/Screen%20Shot%202021-08-15%20at%201.31.57%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;결과를 보면, 공유메모리를 10으로 한 변수를 자식 프로세스에서 1증가시킨 후 &lt;code&gt;sleep()&lt;/code&gt; 상태로 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 후에 부모프로세스에서 공유 메모리 값을 5 증가시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서, 자식 프로세스에서 깨어나서 다시 공유 메모리 값을 증가시킨것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞의 결과에서 부모 프로세스와 자식 프로세스 사이에서 공유 메모리 값이 공유된 다는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세마포어&#34;&gt;세마포어&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리에서는 메모리 영역의 맵핑 이후에 운영체제로 데이터를 복사하기 위한 쓰기 작업, 운영체제로부터 데이터를 가져오기 위한 읽기 작업이 요구되지 않는다는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 정보의 갱신 여부를 다른 프로세스에게 알리는 작업과 공유 메모리 영역에 대한 프로세스 간의 동기화 작업은 프로그래머의 몫으로 남게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번에 프로세스가 공유하는 자원에 대한 동기화를 지원해주는 방법중에 하나인 세마포어에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;크리티컬-섹션에-대한-접근-방법&#34;&gt;크리티컬 섹션에 대한 접근 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스 A와 프로세스 B가 하나의 카운터 변수를 공유하고 있다고 가정을 해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;카운터 변수를 1 증가시키는 방법은 다음과 같은 순서로 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;현재 카운터 변수 값을 읽는다.&lt;/li&gt;
&lt;li&gt;현재 카운터 변수의 값에 1을 더한 값을 계산한다.&lt;/li&gt;
&lt;li&gt;카운터 변수의 값을 2)번 결과물로 대체한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스 A가 카운터 변수의 값을 1 증가시키는 행위를 하는 도중에 프로세스 B가 카운터 변수의 값을 증가시키는 행위를 시도하면 프로세스 B는 A가 증가시킨 수치를 반영하지 못한채로 카운터 변수의 값을 읽어 올 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 프로세스 A, B가 한번씩 호출되어 총 2의 값이 증가해야하지만, 1의 값만 증가하는 현상이 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 같이 프로세스 간에 공동으로 관리되어야 하는 자원에 대한 읽기/쓰기가 이루어지는 코드 부분을 크리티컬 섹션이라고 부른다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 예제에서는 카운터 변수의 값을 읽은 후에 1을 증가시킨 새로운 변수로 카운터 변수의 값을 변경하는 일련의 과정이 크리티컬 섹션에 대응된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/26eahnfm27z9jim/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카운터 변수값의 동기화를 위해 하나의 프로세스가 카운터 변수에 접근하여 값을 읽고 그 값을 변화시키기 전에 다른 프로세스가 해당 변수에 접근하는 것을 방지할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;세마포어 값이 양수일 때만 크리티컬 섹션에 진입할 수 있다.&lt;/li&gt;
&lt;li&gt;프로세스는 크리티컬 섹션에 진입하면서 세마포어 값을 0으로 변경한다.&lt;/li&gt;
&lt;li&gt;프로세스는 크리티컬 섹션을 빠져나오면서 세마포어 값을 증가시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;세마포어의-사용&#34;&gt;세마포어의 사용&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;세마포어를 사용하려면 객체를 세마포어 객체로 생성해야 한다. 아래 함수를 통해서 세마 포어를 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;oflag에 O_CREAT가 설정된 경우&amp;gt;
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);

&amp;lt;oflag에 OCREAT가 설정되지 않은 경우&amp;gt;
sem_t *sem_open(const char *name, int oflag);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;크리티컬 섹션에 접근하려면, 지금 크리티컬 섹션을 수행하고 있는 프로세스가 있는지를 먼저 확인해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한, 크리티컬 섹션에 진입한 프로세스는 다른 프로세스가 크리티컬 섹션에 들어오는 것을 방지하기 위해서 세마포어 값을 감소시켜야 한다. 이러한 기능을 하는 함수는 &lt;code&gt;sem_wait&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sem_wait(sem_t *sem);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sem_wait&lt;/code&gt; 함수는 세마포어의 값을 확인하고 세마포어의 값이 0인 경우 그 값이 양수가 될 때까지 프로세스를 대기 상태로 전환시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세마포어 값이 0이라는 것은 다른 프로세스가 이미 해당 자원을 사용하는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세마포어 값이 양수가 되면 비로소 &lt;code&gt;sem_wait&lt;/code&gt; 함수 호출 이후의 코드가 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;크리티컬 섹션에 진입한 프로세스는 크리티컬 섹션에 해당하는 코드를 실행한 후에 다시 다른 프로세스가 크리티컬 섹션에 진입할 수 있도록 &lt;code&gt;sem_post&lt;/code&gt; 함수를 통해서 자원을 반납해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sem_post(sem_t *sem);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;세마포어와-공유-메모리&#34;&gt;세마포어와 공유 메모리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리로 카운터 변수를 맵핑하여 사용한다고 생각을 해보자. 공유 메모리 영역에 대한 동기화는 전적으로 프로그래머에게 위임되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 아래 예제에서는 세마포어를 사용하여 프로세스 간에 동기화된 카운터를 사용할 수 있는 프로그램을 작성해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;공유 메모리 영역을 한 후 정수형 카운터를 관리한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스는 카운터 값을 각각 증가시킨다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스 간에 공유되는 정보를 확인한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스가 공동으로 접근할 수 있는 공유 메모리의 동기화를 위해서 세마포어를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;nclude &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;semaphore.h&amp;gt;

#define SM_NAME &amp;quot;/Test&amp;quot;
#define SEM_NAME &amp;quot;/SemTest&amp;quot;

int main(int argc, char *argv[]) {
  int shmfd, pid, status, i;
  int *test_value;
  sem_t *sem;

  sem = sem_open(SEM_NAME, O_RDWR | O_CREAT, 0777, 1);
  if (sem == SEM_FAILED) {
    fprintf(stderr, &amp;quot;sem open error\n&amp;quot;);
    exit(1);
  }

  shmfd = shm_open(SM_NAME, O_RDWR | O_CREAT, 0777);
  if (shmfd == -1) {
    fprintf(stderr, &amp;quot;shm open error\n&amp;quot;);
    exit(1);
  }

  if (ftruncate(shmfd, sizeof(int)) == -1) {
    fprintf(stderr, &amp;quot;truncate error\n&amp;quot;);
    exit(1);
  }

  test_value = mmap(0, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  close(shmfd);
  *test_value = 10;
  printf(&amp;quot;test value: %d\n&amp;quot;, *test_value);

  pid = fork();
  if (pid == 0) { // child process
    for (i = 0; i &amp;lt; 10; i++) {
      sem_wait(sem);
      *test_value = *test_value + 1;
      printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
      sem_post(sem);
    }
    exit(1);
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;fork failure\n&amp;quot;);
    exit(1);
  } else {
    for (i = 0; i &amp;lt; 10; i++) {
      sem_wait(sem);
      *test_value = *test_value + 5;
      printf(&amp;quot;parent process test value: %d\n&amp;quot;, *test_value);
      sem_post(sem);
    }
    wait(&amp;amp;status);
  }
  
  shm_unlink(SM_NAME);
  sem_unlink(SEM_NAME);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/4k8sdqd9yex8y8a/Screen%20Shot%202021-08-15%20at%202.18.56%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부모 프로세스나 자식 프로세스에서 세마포어 값을 얻기 위해서 &lt;code&gt;sem_wait&lt;/code&gt;을 호출하고 세마 포어 값이 0으로 만들었다면 &lt;code&gt;sem_post&lt;/code&gt;로 얻은 세마포어 값을 증가시키기전까지는 자식 프로세스에서 접근하지 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 파이프</title>
      <link>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%ED%8C%8C%EC%9D%B4%ED%94%84.html</link>
      <pubDate>Sat, 14 Aug 2021 03:13:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%ED%8C%8C%EC%9D%B4%ED%94%84.html</guid>
      <description>&lt;h3 id=&#34;파이프&#34;&gt;파이프&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/zmenrdqn0icmmou/download.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이프는 프로세스가 파이프 객체 생성을 요청하면 커널은 프로세스가 사용할 수 있는 메모리 공간 (버퍼)를 할당하고 그 버퍼에 접근할 수 있는 두 개의 파일 디스크립터를 프로세스에게 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프 버퍼에 저장되는 데이터는 바이트 흐름으로 취급된다. 두 개의 파일 디스크립터 중 하나는 읽기 작업 전용 나머지 하나는 쓰기 작업 전용으로 사용할 수 있다. 파이프 버퍼에 저장되는 데이터는 바이트 흐름으로 취급된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 개의 파일 디스크립터 중 하나는 읽기 작업 전용 나머지 하나는 쓰기 작업 전용으로 사용할 수 있다. 두 디스크립터 사이에서의 읽기 / 쓰기 작업의 혼용은 허용되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int pipe(int pipefd[2]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인자: &lt;strong&gt;pipefd[2]&lt;/strong&gt;: 파이프 버퍼에 접근하기 위한 두 개의 파일 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프를 생성하기 위해서는 &lt;code&gt;pipe&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 개의 디스크립터 중 &lt;code&gt;pipefd[0]&lt;/code&gt;은 읽기 영역의 끝을 가리키며 &lt;code&gt;pipefd[1]&lt;/code&gt;은 읽기 영역의 끝을 가리킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프 또한 입출력 중 한 가지 방법이다. 따라서 저수준 입출력 함수를 이용하여 읽기/쓰기 작업을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프를 단일 프로세스에서 사용할 때에는 커널에서 제공받은 저장공간일 뿐 활용도가 업다. 파이프를 프로세스 사이의 통신을 위해 사용하려면 &lt;code&gt;fork()&lt;/code&gt; 함수와 함께 사용해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모 프로세스에서 파이프를 생성하고 &lt;code&gt;fork()&lt;/code&gt;를 통해서 자식 프로세스를 생성하면 파이프에 접근할 수 있는 파일 디스크립터들이 복사된다. 따라서 부모 프로세스와 자식 프로세스 사이의 데이터 교환이 가능해지며 또한, 자식 프로세스들끼리도 파이프를 이용하여 통신하는 것이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프는 프로세스 간 통신을 할 때 해당 파이프에 대해서 쓰기 작업을 수행하는 프로세스와 읽기 작업을 하는 프로세스를 정해서 한 방향으로 통신하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 두 프로세스 또는 그 이상의 프로세스가 &lt;code&gt;write()&lt;/code&gt; 함수를 이용하여 파이프에 데이터를 쓰는 것이 가능하지만, 그러나 파이프는 데이터를 연속된 바이트의 흐름으로 처리하기 때문에, 프로세스 별로 쓴 데이터를 구별해주지 않고 파이프 버퍼에 쌓일 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rl7x72prngofxov/images.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 그림처럼 &lt;code&gt;fork()&lt;/code&gt; 함수 이후에 사용하지 않는 프로세스 A의 &lt;code&gt;pipefd[0]&lt;/code&gt;과 프로세스 B의 &lt;code&gt;pipefd[1]&lt;/code&gt;을 &lt;code&gt;close()&lt;/code&gt; 함수를 통해서 닫아주는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이유는 파이프 통신의 종료와 연관되어 있는데, 파이프 &lt;code&gt;write()&lt;/code&gt;에 해당하는 파일 디스크립터로 &lt;code&gt;close()&lt;/code&gt; 함수를 호출하면 &lt;code&gt;read()&lt;/code&gt; 함수는 버퍼에 있는 모든 데이터를 읽고 &lt;code&gt;EOF&lt;/code&gt;를 만난다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;read()&lt;/code&gt; 함수를 호출한 프로세스는 상대방 프로세스가 파이프 연결을 끊었다는 사실을 &lt;code&gt;read()&lt;/code&gt; 함수의 반환값으로 인지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 단위로 운영되는 &amp;lsquo;열린 파일 테이블&amp;rsquo;의 엔트리는 하나의 파일 디스크립터라도 해당 엔트리를 가리키고 있다면 없어지지 않는다. 만약 프로세스 A의 &lt;code&gt;pipefd[0]&lt;/code&gt;이 열려 있더라면, 프로세스 B가 &lt;code&gt;pipefd[0]&lt;/code&gt;을 닫아도 &amp;lsquo;열린 파일 테이블의&amp;rsquo; 해당 엔트리를 사라지지 않으므로 프로세스 A는 프로세스 B가 파이프를 닫았다는 사실을 알 방법이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;부모 프로세스는 사용자에게 문자열을 입력받는다.&lt;/li&gt;
&lt;li&gt;부모 프로세스는 자식 프로세스에게 파이프를 통해서 사용자가 입력한 문자열을 전송한다.&lt;/li&gt;
&lt;li&gt;자식 프로세슨느 부모 프로세스가 전달한 문자열을 파일에 쓴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

void error_proc(const char *);

int main(int argc, char *argv[]) {
  int pipe_fd[2];
  int res;
  char buff[BUFSIZ];
  pid_t pid;
  int read_len, n_write;
  int open_fd, status;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s [file] \n&amp;quot;, argv[0]);
  }

  res = pipe(pipe_fd);
  if (res == -1) error_proc(&amp;quot;pipe&amp;quot;);

  pid = fork();
  
  if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
  if (pid == 0) { // child
    close(pipe_fd[1]);
    open_fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC);
    while (1) {
      read_len = read(pipe_fd[0], buff, BUFSIZ - 1);
      if (read_len == -1) error_proc(&amp;quot;read&amp;quot;);
      if (read_len == 0) break;
      write(open_fd, buff, read_len);
    }
    printf(&amp;quot;parent process closed the pipe. \n&amp;quot;);
    close(open_fd);
    close(pipe_fd[0]);
    return 0;
  } else { // parent
    close(pipe_fd[0]);
    while (1) {
      fgets(buff, BUFSIZ - 1, stdin);
      read_len = strlen(buff);
      if (read_len == 4 &amp;amp;&amp;amp; !strncmp(buff, &amp;quot;END&amp;quot;, 3))
        break;
      n_write = write(pipe_fd[1], buff, read_len);
      if (n_write == -1) error_proc(&amp;quot;write&amp;quot;);
      printf(&amp;quot;%d bytes are written \n&amp;quot;, n_write);
    }
    close(pipe_fd[1]);
    wait(&amp;amp;status);
    return 0;
  }
}

void error_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 시그널</title>
      <link>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EC%8B%9C%EA%B7%B8%EB%84%90.html</link>
      <pubDate>Sat, 14 Aug 2021 01:13:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EC%8B%9C%EA%B7%B8%EB%84%90.html</guid>
      <description>&lt;h3 id=&#34;프로세스-사이의-통신&#34;&gt;프로세스 사이의 통신&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;운영체제는 같은 호스트상에서 실행중인 프로세스 사이의 통신을 가능하게 하는 여러가지 방법을 제공하며, 소켓 API도 그 중에 하나일 뿐이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시그널&#34;&gt;시그널&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우리 몸에는 신체 내부 또는 외부의 자극을 받아들여 다른 부위로 전달하고 반응을 일으키는 신체기관인 신경계가 있다. 컴퓨터에서 이와 비슷한 역할을 하는 것이 바로 시그널이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 프로세스에게 전달되는 특정 정보를 포함하고 있는 신호이다. 리눅스 운영체제의 경우 여러 가지 사건들에 번호를 부여하여 관리하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 운영체제에서 프로세스로 전달할 수 있고 프로세스에서 다른 프로세스로 전달할 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널을 발생시키는 발생시키는 다양한 사건은 크게 에러 발생, 외부에서 발생한 사건, 명시적인 호출과 같이 세 가지 유형으로 분류할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;산술적인 에러, 정수 오버플로우, 정수를 0으로 나눈 경우 등과 같이 프로그램에서 발생한 에러를 운영체제에서 검출했을 경우에도 시그널이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력의 도착, 타이머의 경과, 자식 프로세스 종료와 같은 외부 사건이 발생 했을 때도 시그널은 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 명시적으로 시그널을 발생시키는 라이브러리 함수가 호출된 경우에도 시그널이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ubmet9kiegrgcpm/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시그널이 프로세스로 배달되면 프로세스는 해당 시그널을 위하여 정의된 핸들러 루틴을 실행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 무시하거나, 시그널이 발생하였을 때 처리할 수 있는 함수를 지정하여 해당 함수를 호출하거나 시그널 종료에 따라서 기본 동작을 수행하는 것이 대표적으로 정의된 루틴이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시그널의-종류&#34;&gt;시그널의 종류&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/op31x0lmokqmf3k/Screen%20Shot%202021-08-14%20at%201.26.13%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;signal.h&lt;/code&gt; 파일에는 시그널이 양의 정수 매크로로 정의되어 있다. 정의된 매크로의 값은 &lt;code&gt;kill -l&lt;/code&gt; 명령어를 통해서도 확인 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용빈도가 높은 시그널들을 다음 표에 정리해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;번호&lt;/th&gt;
&lt;th&gt;매크로이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;사용자가 발생시키는 인터럽트 (CTRL + C)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;SIGQUIT&lt;/td&gt;
&lt;td&gt;프로그램 종료와 코어 파일 작성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;SIGFPE&lt;/td&gt;
&lt;td&gt;부동소수점에러가 발생했을 때 발생하는 시스널&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;즉각적인 프로그램 종료를 위해 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;SIGALRM&lt;/td&gt;
&lt;td&gt;지정된 타이머의 경과&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;SIGTERM&lt;/td&gt;
&lt;td&gt;프로그램 종료를 위한 시그널 (kill 명령어의 DEFAULT 시그널)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;SIGHLD&lt;/td&gt;
&lt;td&gt;자식 프로세스의 종료 시에 발생하는 시그널&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;SIGSTOP&lt;/td&gt;
&lt;td&gt;프로세스를 정지시키는 시그널&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;만약 우리가 시그널로 정의 되어 있는 특정 사건의 발생 여부에 관심이 있고 그 사건이 발생할 때 마다 무언가를 하고 싶다면 어떻게 해야할까?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다음과 같은 경우에는 시그널이 발생했을 때 처리를 담당하는 핸들러 함수를 정의하고 운영체제에게 해당 사건이 발생 했을 때, 정의한 핸들러 함수를 호출해달라고 부탁하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void (*signal(int sig, void (*func) (int)))(int);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;핸들러 함수를 운영체제에 등록하는 함수는 위와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;터미널에서 &lt;code&gt;CTRL + C&lt;/code&gt; 입력을 통해서 &lt;code&gt;SIGINT&lt;/code&gt; 시그널이 발생하였을 때, 이벤트가 발생했음을 화면에 출력하는 예제 프로그램이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int global_count = 10;

void sigint_handler(int sig) {
  if (sig == SIGINT) {
    printf(&amp;quot;received SIGINT... %d lives left \n&amp;quot;, global_count--);
  }

  if (global_count &amp;lt;= 0) {
    signal(SIGINT, SIG_DFL);
  }
}

int main(int argc, char *argv[]) {
  int i = 0;
  signal(SIGINT, sigint_handler); // 터미널 창에서 CTRL + C 입력을 받으면 운영체제에게 sigint_handler 함수를 호출해 달라는 요청을 하는 과정이다.
  while (1) {
    printf(&amp;quot;%d: sleep and awake \n&amp;quot;, ++i);
    sleep(5);
  }
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/un56ovw91qk8anq/Screen%20Shot%202021-08-14%20at%201.45.16%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTRL + C&lt;/code&gt;를 누를 때마다, 시그널 핸들러에 등록한 함수가 실행되고, 곧바로 &amp;ldquo;sleep and awake&amp;rdquo; 문자열이 출력되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이것은 시그널이 발생하면 &lt;code&gt;sleep()&lt;/code&gt; 함수의 호출을 통해서 &lt;code&gt;sleep()&lt;/code&gt; 상태에 있는 프로세스가 깨어난다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sigaction-함수&#34;&gt;SIGACTION 함수&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;다음은 &lt;code&gt;signal()&lt;/code&gt; 함수보다는 복잡하지만, 추가적인 기능을 제공하는 &lt;code&gt;sigaction()&lt;/code&gt; 함수에 대해서 이야기를 해보자&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sigaction(int sig, const struct sigaction *act, struct sigaction * oldact);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;sig : 시그널 dml 종류를 지칭하는 시그널 번호&lt;/li&gt;
&lt;li&gt;act: 시그널 발생시 호출되는 시그널 핸들러의 포인터&lt;/li&gt;
&lt;li&gt;oldact: 이전에 등록되었던 시그널 핸들러의 포인터&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;struct sigaction {
  void (*sa_handler)(int);
  sigset_t sa_mask;
  int sa_flags;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sigaction&lt;/code&gt; 함수는 시그널 핸들러 정보를 관리하기 위해서 &lt;code&gt;sigaction&lt;/code&gt; 이라는 구조체를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제-1&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;터미널에서 CTRL + C 입력을 통해서 SIGINT 시그널을 발생시킨다.&lt;/li&gt;
&lt;li&gt;1초에 한번 씩 카운트를 1씩 감소시켜 카운트 값이 0이되면 프로그램을 종료한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

int main(int argc, char *argv[]) {
  int i = 5;
  struct sigaction new_action, old_action;

  new_action.sa_handler = SIG_IGN; // 핸들러로 SIG_IGN 등록
  sigemptyset(&amp;amp;new_action.sa_mask);
  new_action.sa_flags = 0;

  sigaction(SIGINT, &amp;amp;new_action, &amp;amp;old_action);

  while (1) {
    printf(&amp;quot;%d: sleep and awake \n&amp;quot;, i--);
    sleep(1);
    if (i == 0) break;
  }
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/nzeqyb1y8xish4k/Screen%20Shot%202021-08-14%20at%201.57.51%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CTRL + C를 눌러도 프로그램의 루틴이 모두 실행될 때까지 프로그램은 종료되지 않는다. &lt;code&gt;SIGINT&lt;/code&gt; 시그널을 무시하도록 시그널 핸들러를 설정했기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시그널-발생&#34;&gt;시그널 발생&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;지금까지는 시그널을 전달받았을 때, 그것을 처리하는 방법에 대해서 다뤘고, 마지막으로 시그널을 발생시키는 함수에 대해서 다뤄볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

int kill (pid_t pid, int sig);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;pid: 시그널을 전송하려고 하는 목적지 프로세스의 PID&lt;/li&gt;
&lt;li&gt;sig: 시그널의 종류 선택&lt;/li&gt;
&lt;li&gt;결과값: 성공시 0, 실패시 -1&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;kill()&lt;/code&gt; 함수의 첫번째 인자의 PID는 음수또는 0을 입력 받을 수 있는데 의미는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;음수로 입력한 경우에는 pid의 절대값이 지칭하는 프로세스가 속해있는 프로세스 그룹 전체로 시그널이 전달된다.&lt;/li&gt;
&lt;li&gt;0을 입력받는 경우 &lt;code&gt;kill&lt;/code&gt; 함수를 호출한 프로세스가 속해있는 프로세스 그룹 전체로 시그널이 전달된다.&lt;/li&gt;
&lt;li&gt;-1을 입력 받는 경우 &lt;code&gt;kill&lt;/code&gt; 함수를 호출한 프로세스가 시그널을 전송할 수 있는 권한을 가지고 있는 모든 프로세스에게 시그널이 전달된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>멀티 프로세스를 이용한 에코 및 채팅 서버</title>
      <link>https://dongwooklee96.github.io/post/2021/08/13/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EC%BD%94-%EB%B0%8F-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B2%84.html</link>
      <pubDate>Fri, 13 Aug 2021 01:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/13/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EC%BD%94-%EB%B0%8F-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B2%84.html</guid>
      <description>&lt;h3 id=&#34;멀티-프로세스-에코-서버&#34;&gt;멀티 프로세스 에코 서버&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;커널은 파일 디스크립터에 대한 정보를 파일 디스크립터 테이블에 관리한다. 파일 디스크립터 테이블은 프로세스당 하나씩 생성된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터 테이블은 프로세스당 하나씩 생성된다. 또한 커널은 시스템 상에 열려 있는 모든 열린 파일에 대한 정보를 저장하고 있으며, 시스템당 하나만 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터 테이블은 열린 파일 테이블에 대한 링크를 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 &lt;code&gt;fork()&lt;/code&gt;를 이용하여 자식 프로세스를 생성하면 커널은 자식 프로세스를 위한 파일 디스크립터 테이브을 생성하고, 이때 모든 값이 복사되기 때문에 두 파일 디스크립터 테이블은 같은 값을 가지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널의 열린 파일 테이블 입장에서보면, 하나의 열린 파일 엔트리를 가리키는 파일 디스크립터 테이블의 엔트리가 두개 가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상황에서, 하나의 프로세스가 &lt;code&gt;close()&lt;/code&gt; 함수를 실행하면 열린 파일을 가리키고 있는 파일 디스크립터 테이블의 엔트리가 존재하는 한 &lt;code&gt;close&lt;/code&gt; 함수는 열린 파일 디스크립터 테이블의 해당 엔트리만 삭제한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void error_proc();
void error_print();

int main(int argc, char* argv[]) {
  int server_sd, client_sd;
  struct sockaddr_in server_addr, client_addr;

  int client_addr_len, read_len;
  char read_buffer[BUFSIZ];
  pid_t pid;

  if (argc != 2) {
    printf(&amp;quot;usage: %s [port] \n&amp;quot;, argv[0]);
    exit(1);
  }
  printf(&amp;quot;server start...\n&amp;quot;);

  server_sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (server_sd == -1) error_proc();

  memset(&amp;amp;server_addr, 0, sizeof(server_addr));
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(atoi(argv[1]));

  if (bind(server_sd, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr)) == -1) error_proc();

  if (listen(server_sd, 5) &amp;lt; 0) error_proc();

  client_addr_len = sizeof(client_addr);

  while(1) {
    client_sd = accept(server_sd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;client_addr_len);
    if (client_sd == -1) {
      error_print();
      continue;
    }
    printf(&amp;quot;client %s: %d is connected...\n&amp;quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    pid = fork();
    if (pid == 0) { /* child process */
      close(server_sd);
      while (1) {
        read_len = read(client_sd, read_buffer, sizeof(read_buffer) - 1);
        if (read_len == 0) break;
        read_buffer[read_len] = &#39;\0&#39;;
        printf(&amp;quot;client (%d): %s\n&amp;quot;, ntohs(client_addr.sin_port), read_buffer);
        write(client_sd, read_buffer, strlen(read_buffer));
      }
      printf(&amp;quot;client (%d) : is disconnected\n&amp;quot;, ntohs(client_addr.sin_port));
      close(client_sd);
      return 0;
    } else if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
    else {
      close(client_sd);
    }
  }
  close(server_sd);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;간단한-udp-멀티-프로세스-채팅-프로그램&#34;&gt;간단한 UDP 멀티 프로세스 채팅 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;채팅 서버의 역할은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트의 접속 처리&lt;/li&gt;
&lt;li&gt;클라이언트가 전송하는 문자열을 다른 클라이언트들에게 전송&lt;/li&gt;
&lt;li&gt;클라이언트의 접속 종료 처리&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 중에서, 클라이언트가 전송하는 문자열을 다른 클라이언트들에게 전송하는 기능은 여러 클라이언트들의 데이터를 하나의 소켓으로 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;recvfrom&lt;/code&gt; 함수를 통해서 전달받은 문자열을 &lt;code&gt;sendto&lt;/code&gt; 함수로 전송한 클라이언트를 제외한 모든 클라이언트 들에게 전송하면 작업을 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;채팅 서버&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

#define MAX_CLIENT 10

void error_proc(const char*);

int check_sock_list(struct sockaddr_in *entry, struct sockaddr_in *list, int count);

int main(int argc, char* argv[]) {
  int my_sock, read_len, n_recv, res;
  char buff[BUFSIZ];
  char name_buffer[50];
  char *str_addr;
  struct sockaddr_in src_addr, dest_addr;

  socklen_t addr_len;
  int n_client = 0, i = 0, port;
  struct sockaddr_in sockets[MAX_CLIENT];

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s port&amp;quot;, argv[0]);
    return 0;
  }

  memset(&amp;amp;sockets, 0, sizeof(sockets[0])*MAX_CLIENT);
  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);

  memset(&amp;amp;src_addr, 0, sizeof(src_addr));
  src_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  src_addr.sin_family = AF_INET;
  src_addr.sin_port = htons(atoi(argv[1]));

  res = bind(my_sock, (struct sockaddr*)&amp;amp;src_addr, sizeof(src_addr));
  if (res == -1) error_proc(&amp;quot;bind&amp;quot;);
  addr_len = sizeof(dest_addr);

  while (1) {
    n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0,
        (struct sockaddr *) &amp;amp;dest_addr, &amp;amp;addr_len);
    if (n_recv == -1) error_proc(&amp;quot;recvfrom&amp;quot;);
    res = check_sock_list(&amp;amp;dest_addr, sockets, n_client);

    if (res == n_client) {
      if (res == MAX_CLIENT) continue;
      else {
        memcpy(&amp;amp;sockets[res],
            &amp;amp;dest_addr, sizeof(dest_addr));
        n_client++;
      }
    }
    printf(&amp;quot;n_client: %d\n&amp;quot;, n_client);
    str_addr = inet_ntoa(dest_addr.sin_addr);
    sprintf(name_buffer, &amp;quot;%s: %d &amp;gt;&amp;gt; &amp;quot;, str_addr, ntohs(dest_addr.sin_port));

    for (i = 0; i &amp;lt; n_client; i++) {
      if (i == res) continue; // sender == receiver skip
      sendto(my_sock, name_buffer, strlen(name_buffer), 0, (struct sockaddr *) &amp;amp;sockets[i], addr_len);
      sendto(my_sock, buff, n_recv, 0, (struct sockaddr *) &amp;amp;sockets[i], addr_len);
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;채팅 클라이언트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void error_proc(const char*);

int main(int argc, char* argv[]) {
  int my_sock, read_len, n_sent, n_recv;
  char buff[BUFSIZ];
  char str_addr;
  struct sockaddr_in dest_addr;
  socklen_t addr_len;
  pid_t pid;

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  memset(&amp;amp;dest_addr, 0, sizeof(dest_addr));
  dest_addr.sin_addr.s_addr = inet_addr(argv[1]);
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_port = htons(atoi(argv[2]));
  addr_len = sizeof(dest_addr);

  pid = fork();
  if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
  if (pid == 0) {
    while (1) {
      n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0, (struct sockaddr*) &amp;amp;dest_addr, &amp;amp;addr_len);
      if (n_recv == -1) error_proc(&amp;quot;read&amp;quot;);
      write(1, buff, n_recv);
    }
  } else {
    while (1) {
      fgets(buff, BUFSIZ - 1, stdin);
      read_len = strlen(buff);
      if (read_len == 0) error_proc(&amp;quot;fgets&amp;quot;);
      n_sent = sendto(my_sock, buff, read_len, 0, (struct sockaddr*) &amp;amp;dest_addr, addr_len);
      if (n_sent == -1) error_proc(&amp;quot;write&amp;quot;);
      buff[read_len - 1] = &#39;\0&#39;;
      if (!strcmp(buff, &amp;quot;END&amp;quot;)) break;
    }
    kill(pid, SIGTERM);
  }
  return 0;
}

void error_proc(const char* str) {
  fprintf(stderr, &amp;quot;%s:%s \n&amp;quot;, str, strerror(errno));
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;서버 화면&lt;/strong&gt;
&lt;img src=&#34;https://dl.dropbox.com/s/fpxyeusfjxy8d2h/Screen%20Shot%202021-08-13%20at%202.47.58%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/cguiw5wx46zoxjl/Screen%20Shot%202021-08-13%20at%202.47.48%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8f8w1a3j8jrpuf3/Screen%20Shot%202021-08-13%20at%202.47.53%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트 간의 통신이 이루어지는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UDP 소켓 프로그래밍</title>
      <link>https://dongwooklee96.github.io/post/2021/08/09/udp-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</link>
      <pubDate>Mon, 09 Aug 2021 22:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/09/udp-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</guid>
      <description>&lt;h3 id=&#34;udp-소켓-프로그래밍&#34;&gt;UDP 소켓 프로그래밍&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;에서는 &lt;code&gt;TCP&lt;/code&gt;에서 제공하는 신뢰적인 정보 전달, 순차적인 정보 전달, 흐름 제어, 혼잡 제어와 같은 서비스를 제공하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대신 포트번호를 사용하여 데이터를 올바른 프로세스에게 전달해주는 서비스, 즉 전송 계층 프로토콜이 제공해주는 서비스 중 필 수 서비스만을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 위에서 나열한 서비스를 제공하기 위해서 &lt;code&gt;TCP&lt;/code&gt; 모듈 간의 정보를 공유해야하고 이를 위해 결국 네트워크 자원을 소모한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그에 비해서 &lt;code&gt;UDP&lt;/code&gt;는 카운터 파트들 사이에 정보를 공유할 필요가 없으니 그만큼 가볍다고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;는 전송 계층 프로토콜의 핵심 기능인 호스트 안에서의 프로세스 식별을 통한 데이터 배달만을 수행하는 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;TCP&lt;/code&gt; 처럼 안정적이고 순차적인 데이터 전달을 보장하지 않으며, 흐름제어와 혼잡 제어를 수행하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;헤더 구조가 단순하며, 주로 동영상 스트리밍, 인터넷 전화와 같은 실시간 응용에 많이 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 소켓을 생성하고 연결을 한 이후에 통신이 가능하다, 또한 전송되는 &lt;code&gt;TCP&lt;/code&gt; 세그먼트의 성공적인 전달 여부를 확인하기 위해서 수신자 &lt;code&gt;TCP&lt;/code&gt; 모듈은 &lt;code&gt;ACK&lt;/code&gt; 세그먼트를 추가적으로 전달한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;의 경우 전송할 데이터가 생기면 바로 상대방 &lt;code&gt;UDP&lt;/code&gt; 모듈로 전송을 시도한다. 응용 계층으로부터 의뢰받은 데이터에 &lt;code&gt;UDP&lt;/code&gt; 포트 넘버가 적혀있는 &lt;code&gt;UDP&lt;/code&gt; 헤더만을 붙인 이후에 바로 네트워크 계층에 전송 서비스를 의뢰한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-헤더&#34;&gt;UDP 헤더&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/twjz782l8j32syf/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SOURCE PORT, DESTINATION PORT:&lt;/strong&gt; 출발지 포트와, 목적지 포트인 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt; 데이터 그램의 크기를 나타낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CHECK SUM&lt;/strong&gt; 데이터 무결성 검사를 위한 체크섬&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-소켓&#34;&gt;UDP 소켓&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;는 연결지향적이지 않기 때문에, 송신자와 수신자 간의 연결과 연결 종료 절차가 없을 것이고 소켓에 수신자와 송신자 쌍에 대한 정보도 없을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 읽기 쓰기를 할 때는 상대방의 주소 정보를 항상 포함해야 될 것이다. 또한 주고 받는 데이터를 바이트 스트림으로 취급하는 &lt;strong&gt;TCP&lt;/strong&gt;와는 다르게 &lt;strong&gt;UDP&lt;/strong&gt;는 하나의 데이터그램 단위로 읽기/쓰기 작업을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UDP 소켓의 특징&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결 / 연결 종료 절차가 없음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓에 수신자, 송신자 쌍에 대한 정보를 저장하지 않음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터그램 단위로 읽기/쓰기 진행&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-서버-클라이언트-모델&#34;&gt;UDP 서버 클라이언트 모델&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;소켓-생성&#34;&gt;소켓 생성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;전송 계층 프로토콜로 &lt;strong&gt;UDP&lt;/strong&gt;를 사용하려면, &lt;code&gt;socket&lt;/code&gt; 함수의 인자를 다음과 같이 설정해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
socket (AF_INET, SOCK_DGRAM, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;데이터-전송&#34;&gt;데이터 전송&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;소켓 전용 입출력 함수인 &lt;code&gt;sendto&lt;/code&gt;를 이용하여 &lt;strong&gt;UDP&lt;/strong&gt; 데이터그램을 전송하는 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t sendto (
    int sockfd,
    const void *buf,
    size_t len,
    int flags,
    const struct sockaddr *dest_addr,
    socklen_t addrlen
    )
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파라미터에 대한 자세한 설명은 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sockfd&lt;/strong&gt;: 소켓의 파일 디스크립터&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buf&lt;/strong&gt;: 전송할 데이어가 저장되어 있는 곳의 첫 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송할 데이터의 최대 길이&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt;: 부가적인 기능을 설정할 수 있는 플래그&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dest_addr&lt;/strong&gt;: 목적지 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addrlen&lt;/strong&gt;: 목적지 주소 공간의 크기&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sendto()&lt;/code&gt; 함수는 목적지의 주소를 인자로 받는다. 여기서 다음과 같은 의문이 생길 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;소켓의 출발지 주소는 어떻게 설정하는가?
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

void error_proc(const char*);

int main(int argc, char *argv[]) {
  int my_sock, read_len, n_sent;
  char buff[BUFSIZ];
  struct sockaddr_in dest_addr;
  socklen_t addr_len;

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);
  memset(&amp;amp;dest_addr, 0, sizeof(dest_addr));
  dest_addr.sin_addr.s_addr = inet_addr(argv[1]);
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_port = htons(atoi(argv[2]));
  addr_len = sizeof(dest_addr);

  while(1) {
    fgets(buff, BUFSIZ - 1, stdin);
    read_len = strlen(buff);
    n_sent = sendto(my_sock, buff, read_len, 0, (struct sockaddr *) &amp;amp;dest_addr,
addr_len);
    printf(&amp;quot;%d bytes were sent. \n&amp;quot;, n_sent);
  }
  return 0;
}

void error_proc(const char* str) {
  fprintf(stderr, &amp;quot;%s: %s \n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다음 예제를 실행하고 패킷을 캡처해본면 다음과 같은 사실을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;출발지 주소를 설정하지 않고 &lt;code&gt;sendto&lt;/code&gt; 함수를 호출한 경우, 소켓에 자동으로 IP 주소와 포트번호가 할당된다.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;데이터-수신&#34;&gt;데이터 수신&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t recvfrom (
  int socketfd,
  void *buf,
  size_t len,
  int flags,
  struct sockaddr *src_addr,
  socklen_t *addrlen
)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파라미터에 대한 자세한 설명은 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sockfd&lt;/strong&gt;: 소켓의 파일 디스크립터&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buf&lt;/strong&gt;: 수신할 데이어가 저장될 곳의 첫 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;len&lt;/strong&gt;: 수신할 데이터의 최대 길이&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt;: 부가적인 기능을 설정할 수 있는 플래그&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;src_addr&lt;/strong&gt;: 출발지 주소를 저장할 구조체의 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addrlen&lt;/strong&gt;: 출발지 주소 공간의 크기&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞에서 작성한 데이터 전송 프로그램과 통신이 가능한 데이터 수신 프로그램을 만들기 위해서는 수신 프로그램의 포트번호와 전송 프로그램의 목적지 포트가 일치해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 수신 측에서는 &lt;strong&gt;소켓에 주소를 설정해야한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주소의 설정을 위해서 &lt;code&gt;TCP&lt;/code&gt; 소켓과 마찬가지로 &lt;code&gt;bind&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 함수를 이용하여 소켓에 주소 정보를 설정한 후 &lt;code&gt;recvfrom&lt;/code&gt; 함수를 호출하는 형태로 프로그램을 진행해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;전송 프로그램이 sendto 함수의 인자로 전달하는 포트번호 = 수신 프로그램이 bind 함수의 인자로 전달하는 포트번호&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;따라서 수신 프로그램은 다음의 흐름으로 진행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;소켓 생성(socket) -&amp;gt; 소켓에 주소 설정(bind) -&amp;gt; recvfrom 함수 호출(recvfrom)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;수신-프로그램-예제&#34;&gt;수신 프로그램 예제&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void error_proc(const char*);

int main(int argc, char **argv) {
  int my_sock, read_len, n_recv, res;
  char buff[BUFSIZ];

  struct sockaddr_in src_addr, dest_addr;
  socklen_t addr_len;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s port&amp;quot;, argv[0]);
    return 0;
  }

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);

  memset(&amp;amp;src_addr, 0, sizeof(src_addr));
  src_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  src_addr.sin_family = AF_INET;
  src_addr.sin_port = htons(atoi(argv[1]));

  res = bind(my_sock, (struct sockaddr *)&amp;amp;src_addr, sizeof(src_addr));

  if (res == -1) error_proc(&amp;quot;bind&amp;quot;);

  addr_len = sizeof(dest_addr);

  while(1) {
    n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0, (struct sockaddr *)&amp;amp;dest_addr, &amp;amp;addr_len);
  if (n_recv == -1) error_proc(&amp;quot;recv_from&amp;quot;);
  printf(&amp;quot;%d bytes were recv. \n&amp;quot;, n_recv);
  }
  return 0;
}

void error_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;전송-측-화면&#34;&gt;전송 측 화면&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/i5c8w5mne3it4ya/Screen%20Shot%202021-08-09%20at%2011.28.45%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;수신측-화면&#34;&gt;수신측 화면&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/5tviz2rngz6aj6u/Screen%20Shot%202021-08-09%20at%2011.26.43%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;다수의-클라이언트-처리&#34;&gt;다수의 클라이언트 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;recvfrom&lt;/code&gt; 함수의 특징에 대해서 좀 더 살펴보자면, &lt;code&gt;recvfrom&lt;/code&gt;함수를 호출하면 프로그램은 데이터그램이 도착할 때 까지 대기 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터그램이 도착하면 &lt;code&gt;recvfrom&lt;/code&gt; 함수는 다음 코드로 제어권을 넘기며 전달받은 데이터의 출발지 주소를 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 출발지 주소에 관계없이 자신에게 도착한 데이터그램을 가져온다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 알 수 있는 것은 &lt;code&gt;sendto&lt;/code&gt; 함수의 목적지도 한 곳으로 정해져 있는 것은 아니라는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sendto&lt;/code&gt; 함수의 목적지는 호출 시마다 바뀔 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 정리하면 &lt;code&gt;sendto&lt;/code&gt; 함수의 목적지와 &lt;code&gt;recvfrom&lt;/code&gt; 함수의 출발지는 호출 시마다 바뀔 수 있다. 이 말은 하나의 소켓으로 여러 호스트 또는 여러 프로세스와 통신할 수 있다는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;connect-함수의-역할&#34;&gt;connect 함수의 역할&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UDP 소켓은 &lt;code&gt;sendto&lt;/code&gt; 함수나 &lt;code&gt;recvfrom&lt;/code&gt; 함수를 호출했을 때만 커널과 연결되므로 함수 호출이 끝나면 소켓과 커널의 연결이 해제된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널과 소켓이 연결되고 다시 해제되는 과정에서도 무시하지 못할 만큼의 컴퓨팅 자원이 소모된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;connect 함수는 소켓의 목적지 주소를 설정하여 커널과 소켓을 연결시키는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 connect 함수를 사용하면 &lt;code&gt;read&lt;/code&gt; 함수와 &lt;code&gt;write&lt;/code&gt; 함수를 사용할 수 있다. (해당 소켓을 통해서 통신할 수 있는 목적지가 하나로 한정되기 때문에, &lt;code&gt;sendto&lt;/code&gt;, &lt;code&gt;recvfrom&lt;/code&gt;) 을 사용하지 않아도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송 시마다 커널과 소켓 사이의 연결과 연결 해제 과정이 없어서 효율이 좋아진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ICMP&lt;/code&gt; 메시지에 대한 통지를 받을 수 있다. (즉 UDP 다이어그램을 수신하는 상대방의 정상동작 여부를 파악할 수 있다.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP 프로토콜 및 특징</title>
      <link>https://dongwooklee96.github.io/post/2021/08/04/tcp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95.html</link>
      <pubDate>Wed, 04 Aug 2021 07:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/04/tcp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95.html</guid>
      <description>&lt;h3 id=&#34;tcp-소켓&#34;&gt;TCP 소켓&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전송 계층 프로토콜의 핵심 기능은 호스트 안에서의 프로세스 식별을 통한 데이터의 배달이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크를 통해 배달된 데이터가 어떤 프로세스에게 배달된 것인지를 확인한 후 적절한 프로세스에게 전달하는 것이 전송 프로토콜의 메인 임무이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 회사에는 우편 업무를 담당하는 직원 A가 있다.
- 우편물을 보내야하는 직원들은 직원 A에게 우편물 배달을 의뢰한다.
- 직원 A는  직원들이 이뢰한 우편물을 모아서, 우체국에 배달을 의뢰한다.
- 직원 A는 우체국으로부터 배달된 우편물을 해당 직원이 소속되어 있는 부서의 서류함에 넣는다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 비유에서 우편 업무 담당 직원 A가 바로 전송 계층 프로토콜에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우체국은 네트워크 계층 프로토콜에 해당하며 직원 A에게 배달을 의뢰하는 다른 직원들은 응용 계층에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;직원 역할은 크게 두 가지로 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다른 직원의 우편물을 수거하여 우체국에 전달 -&amp;gt; 프로세스 데이터를 IP 계층으로 전달&lt;/li&gt;
&lt;li&gt;도착한 우편물을 각 부서의 서류함으로 분배 -&amp;gt; IP 계층으로부터 받은 데이터를 프로세스에게 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우편물을 각 부서의 서류함으로 정확하게 배달하려면 우편물에 적혀있는 주소 정보를 확인해야하는데. 여기서 주소는 각 부서의 이름일 것이며 이에 해당하는 것이 포트번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;직원 A의 역할이 여기까지라고 볼 수 있고, TCP 통신에서는 다음과 같은 역할이 추가된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;우편물이 목적지까지 제대로 갔는지를 확인한다.&lt;/li&gt;
&lt;li&gt;우편물이 목적지까지 순서대로 갔는지 확인한다.&lt;/li&gt;
&lt;li&gt;목적지 우편함이 가득 차 있어서 우편물이 반송되는 것을 방지할 것.&lt;/li&gt;
&lt;li&gt;우체국이 너무 바쁘면 적절히 우편물의 양을 조절 할 것.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 작업은 혼자서 하기 힘들고 누군가의 도움이 필요하다. 바로 목적지 회사의 직원 A와 유사한 일을 수행하는 직원들이 이러한 일을 돕는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;직원 B와 협력한다면 위의 역할을 해결할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;직원 B가 A에게 우편물을 잘 받았다는 메시지를 전달할 수 있다.&lt;/li&gt;
&lt;li&gt;직원 A가 우편물에 번호를 부여한다면 직원 B는 메시지가 순차적으로 도착했는지를 판단할 수 있다.&lt;/li&gt;
&lt;li&gt;직원 B가 우편함의 여유공간을 직원 A에게 알려준다면 우편함이 가득차서 우편물이 반송되는 현상을 방지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;위의 기능들은 TCP 통신의 기능들을 비유로 설명한 것이다. TCP 통신은 다음과 같은 기능을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;신뢰성 있는 데이터의 전달 보장&lt;/li&gt;
&lt;li&gt;데이터의 순차적인 전달 보장&lt;/li&gt;
&lt;li&gt;흐름제어, 및 혼잡 제어&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정리하자면 TCP는 호스트 안에서의 프로세스 식별을 통산 데이터의 배달이라는 전송 계층 프로토콜의 기본 기능을 지원하는 프로토콜이며 부가적으로 신뢰적이고 순차적인 데이터의 전달을 보장하며 흐름제어 / 혼잡 제어를 수행하는 전송 계층 프로토콜이라고 볼 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp의-기능&#34;&gt;TCP의 기능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;호스트 안에서의 프로세스 식별을 통한 데이터의 배달&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;신뢰적이고 순차적인 데이터 전달&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흐름제어와 혼잡제어&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-헤더&#34;&gt;TCP 헤더&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전의 비유에서 직원 A와 B는 정보를 주고 받아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보를 주고 받는다는 이야기는 둘 사잉에 연결 관계가 형성되어 공유하는 정보가 있다는 의미로 해석할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보를 공유하는 가장 쉬운 방법은 우편물 봉투에 해당 내용을 적어보내는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계층별로 카운터 파트끼리 주고 받는 정보를 주고 받기 위해서 정보를 전송해야할 데이터의 앞에 붙여보낸다. 이를 프로토콜 헤더라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/9pqh7zj84onxwbn/img.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Source Port, Destionation Port&lt;/strong&gt;: TCP 세그먼트를 보내는 프로세스가 사용하는 포트번호와 TCP 세그먼트를 받는 프로세스가 사용하는 포트번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sequence Number&lt;/strong&gt;: TCP는 데이터를 바이트 스트림(바이트의 흐름)으로 처리한다. TCP 세그먼트 중 헤더 다음에 오는 데이터 부분은 바이트 스트림을 순차적으로 잘라서 구성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Acknowledgement Number&lt;/strong&gt;: 성공적인 데이터 전달 여부를 상대방에게 알리기 위해서 사용하는 번호이다. 다음에 전달 받을 데이터의 &lt;code&gt;Sequence Number&lt;/code&gt;가 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Header Length&lt;/strong&gt;: 기본적인 TCP 헤더의 길이는 20 바이트이지만 가변적인 옵션이 붙을 수 있다. 이 필드는 TCP 헤더 길이를 32비트 (4바이트) 단위로 나타낸다. 헤더의 최소 길이는 20바이트이기 때문에, 이 필드의 최소 값은 5(5 * 4 = 20) 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reserved Filed&lt;/strong&gt;: 미래에 기능이 추가되었을 때 사용할 수 있도록 예약 해둔 비트들이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP Flags&lt;/strong&gt;: TCP 세그먼트들의 기능을 표기하기 위한 8가지의 플래그이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CWR: 혼잡 제어 관련 플래그이다.&lt;/li&gt;
&lt;li&gt;ECE: 혼잡 제어 관련 플래그이다.&lt;/li&gt;
&lt;li&gt;URG: 긴급 데이터의 포함 여부를 나타낸다.&lt;/li&gt;
&lt;li&gt;ACK: Acknowledgement 필드의 유효성을 나타낸다.&lt;/li&gt;
&lt;li&gt;PHS: 긴급한 데이터 처리를 요청한다.&lt;/li&gt;
&lt;li&gt;RST: 연결을 리셋한다.&lt;/li&gt;
&lt;li&gt;SYN: 연결을 시작한다.&lt;/li&gt;
&lt;li&gt;FIN: 연결을 종료한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Window Size&lt;/strong&gt;: 수신 버퍼의 크기를 알린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tcp Checksum&lt;/strong&gt;: 세그먼트의 데이터 무결성을 검사하기 위한 필드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Urgent Pointer&lt;/strong&gt;: 긴급 데이터를 가리키는 포인터이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp의-상태&#34;&gt;TCP의 상태&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;연결&#34;&gt;연결&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 연결 지향형 프로토콜이다. 이 말은 통신을 하는 두 호스트에서 실행중인 TCP 모듈은 연결되어 있다는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 되어 있다는 것은 &lt;code&gt;TCP&lt;/code&gt; 모듈끼리 몇몇 수치들을 공유한다는 이야기일 뿐이니 연결이란 자체에 많은 의미를 부여할 필요는 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/assmg20ak7amd07/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 TCP 상태 다이어그램이다. 맨 처음 TCP 모듈은 CLOSED 상태로 존재한다. 여기서 &lt;code&gt;Passive Open(수동형 열기)&lt;/code&gt;를 하면 &lt;code&gt;LISTEN&lt;/code&gt; 상태로 전이되고, &lt;code&gt;Active Open(능동형 열기)&lt;/code&gt;를 하면 &lt;code&gt;SYN_SENT&lt;/code&gt; 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수동형 열기 : TCP 연결을 위해서 대기 상태로 돌입한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;능동형 열기: TCP 연결을 위해서 연결 요청 세그먼트(SYN 세그먼트)를 전송한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP는 양방향 통신이기 때문에 양방향 모두 연결 요청이 완료되고 나서야 비로서 &lt;code&gt;ESTABLISHED&lt;/code&gt; 상태가 된다. &lt;strong&gt;두 페어가 SYN을 보내고 해당 SYN에 대한 ACK를 수신했을 떄 비로서 연결 완료 상태가 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/a8gsowwbcu1zfgy/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 연결 과정은 보통 세번의 세그먼트 교환을 통해서 이루어지기 때문에 3방향 핸드 쉐이크라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;종료&#34;&gt;종료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 연결 종료를 요청하기 위해서, &lt;code&gt;FIN&lt;/code&gt; 세그먼트를 전송한다. &lt;code&gt;SYN_RCVD&lt;/code&gt;, &lt;code&gt;ESTABLISHED&lt;/code&gt; 상태에서 &lt;code&gt;FIN&lt;/code&gt; 전송을 통해 연결 종료 요청을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;호스트 A가 TCP 연결을 끊기 위해서 FIN을 전송하면 호스트 B는 FIN을 기다리게 되는 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에 돌입한다. 이 상태는 FIN을 보내기만 한 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN에 대한 ACK를 수신하게 되면 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 상태로 이동한다. 이 상태는 내 FIN이 상대방에게 도달된 상태를 말한다. 만약 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에서 &lt;code&gt;FIN+ACK&lt;/code&gt;를 수신하게 되면 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 전송하고 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태로 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상태는 상대방이 자신의 &lt;code&gt;FIN&lt;/code&gt;을 받았다는 것을 확인한 상태이며, 상대방도 자신과의 연결을 끊기 원한다는 것까지 확인한 상태라고 볼 수 있다. 만약 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에서 &lt;code&gt;FIN&lt;/code&gt;을 수신하게 된다면 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 전송하고 &lt;code&gt;CLOSING&lt;/code&gt; 상태로 이동한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상태는 자신이 보낸 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;는 받지 못했지만, 상대방이 보낸 &lt;code&gt;FIN&lt;/code&gt;은 받은 상태이다. &lt;code&gt;CLOSING&lt;/code&gt; 상태에서 자신이 보낸 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 수신하면 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태로 이동한다. 상태가 많아서 어려워 보이지만 단순하게 생각하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;연결이 끊어지는 CLOSED 상태가 되기 위해서는 양단 모두가 FIN을 수신해야하면 FIN에 대한 ACK도 수신해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-흐름-제어&#34;&gt;TCP 흐름 제어&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 수신 받은 데이터를 운영체제가 제공하는 버퍼에 순서대로 채운다. 버퍼에 있는 데이터들은 해당 포트에서 대기하고 있는 응용 프로그램들이 그것을 가져갈 때 까지 유지된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버퍼에 사용되는 메모리는 컴퓨터의 중요한 리소스 중 하나이기 때문에, 무한한 크기의 버퍼를 사용할 수는 없다. 따라서 버퍼의 크기는 유한하며 데이터가 가득 찬 경우에는 TCP는 더는 데이터를 받을 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 상황을 방지하기 위해서 TCP는 상대방의 버퍼에 공간이 있을 떄만, 데이터를 전송한다. 이러한 절차와 행동 양식을 흐름제어라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 흐름제어를 위해 슬라이딩 윈도우라는 개념을 사용한다. &lt;code&gt;TCP&lt;/code&gt; 헤더를 살펴보면 윈도우라는 필드가 있는데, 이 원도우 필드의 값에 따라서 보낼 수 있는 공간의 크기가 결정된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rng7cqw2xqknkpw/TCP-sliding-window-mechanism.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;윈도우는 수신하는 TCP 쪽의 남은 버퍼를 의미하며, 스트림이 프로세스에 의해서 처리되어 버퍼가 빌 경우, 윈도우 버퍼가 이동하게 된다. 따라서 옆으로 이동한 윈도우에 의해서 아직 전송하지 못한 바이트 스트림에 대한 전송 공간이 발생하면 그때 전송을 시도한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>간단한 소켓 프로그램</title>
      <link>https://dongwooklee96.github.io/post/2021/08/02/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.html</link>
      <pubDate>Mon, 02 Aug 2021 00:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/02/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.html</guid>
      <description>&lt;h3 id=&#34;간단한-소켓-프로그램&#34;&gt;간단한 소켓 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;서버와 클라이언트를 연결해봄으로써, 간단한 소켓 프로그래밍을 해볼 것이다.&lt;/li&gt;
&lt;li&gt;A와 B가 연결된 상태로 통신을 하려면 둘 중의 하나가 연결 요청을 해야한다. 그리고 나머지 한쪽은 상대방의 연결 요청을 처리할 준비를 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int listen(int sockfd, int backlog);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 함수는 연결 요청을 처리하기 위한 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;listen()&lt;/code&gt; 함수는 해당 소켓을 듣기 상태로 만든다. &lt;code&gt;listen&lt;/code&gt; 함수가 호출되면 해당 소켓은 상대방의 연결 요청을 받을 준비를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램의 흐름은 다음 라인으로 넘어가면 운영체제에게 해당 소켓을 통해 연결 요청이 들어올 경우, 연결 요청 정보를 저장해달라고 부탁한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;backlog&lt;/code&gt;는 저장하고 있을 연결 요청의 최대 수를 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int accept(int sockfd, struct sockaddr *addr, socket_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;accept()&lt;/code&gt; 함수가 호출되는 순간, 커널은 &lt;code&gt;listen&lt;/code&gt; 함수에 의해 생성된 대기열에 연결 요청이 있었는지를 확인한다. 연결 요청이 없으면 &lt;code&gt;accept&lt;/code&gt; 함수는 연결 요청이 발생할 때까지 프로그램의 제어권을 가진 상태로 대기한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결 요청이 있으면 가장 먼저 연결 요청을 한 프로세스와 통신하기 위한 소켓의 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주의해야할 것은 &lt;code&gt;listen&lt;/code&gt; 함수를 통해 듣기 모드에 돌입한 소켓은 &lt;strong&gt;연결 요청을 접수하는 역할을 하는 듣기 소켓이 되고 accept 함수의 결과 반환된 소켓은 실제 데이터 전송에 사용되는 연결 소켓이 된다는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 함수를 통해서, &lt;code&gt;listen()&lt;/code&gt; 함수 호출로 대기하고 있는 프로세스에 연결 요청을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/127778990-5303317c-394f-4399-ac92-2d892f045d22.gif&#34; alt=&#34;7099 epsi&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송을 위한 연결은 &lt;code&gt;connect()&lt;/code&gt; 함수의 인자로 전달된 소켓과 &lt;code&gt;accept()&lt;/code&gt; 함수 호출에 의해 듣기 소켓이 된 소켓은 연결 요청을 처리하는 일만을 담당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 완료된 이후에는 일반 파일과 같이 입출력 함수 (&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;)를 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서버-프로그램&#34;&gt;서버 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단한 예제를 통해서, 다룬 함수들의 실제 사용에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 프로그램의 기능은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;클라이언트쪽으로부터 &amp;ldquo;How old are you?&amp;rdquo; 라는 문자열을 전송받은 후에 이것을 전송한다.
클라이언트쪽으로 &amp;ldquo;I am 20 years old&amp;rdquo; 라는 문자열을 전송한 후에 화면에 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

#define PORT 9001

int main() {
  int srv_sd, client_sd;
  struct sockaddr_in srv_addr, client_addr;
  int client_addr_len, read_len;
  char read_buff[BUFSIZ];
  char write_buff[BUFSIZ] = &amp;quot;I am 20 years old.&amp;quot;;

  srv_sd = socket(PF_INET, SOCK_STREAM, 0);

  if (srv_sd == -1) {
    printf(&amp;quot;socket creation error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;==== server program ====\n&amp;quot;);

  memset(&amp;amp;srv_addr, 0, sizeof(srv_addr));
  srv_addr.sin_family = AF_INET;
  srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  srv_addr.sin_port = htons(PORT);

  if (bind(srv_sd, (struct sockaddr *) &amp;amp;srv_addr, sizeof(srv_addr)) == -1) {
    printf(&amp;quot;bind error&amp;quot;);
    return -1;
  }

  if (listen(srv_sd, 5) == -1) {
    printf(&amp;quot;listen error&amp;quot;);
    return -1;
  }

  client_addr_len = sizeof(client_addr);
  client_sd = accept(srv_sd, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_len);

  if (client_sd == -1) {
    printf(&amp;quot;accept error&amp;quot;);
    return -1;
  }
  write(client_sd, write_buff, sizeof(write_buff));
  printf(&amp;quot;server: %s\n&amp;quot;, write_buff);

  read_len = read(client_sd, read_buff, sizeof(read_buff));
  if (read_len == -1) {
    printf(&amp;quot;read error&amp;quot;);
    return -1;
  }

  read_buff[read_len] = &#39;\0&#39;;
  printf(&amp;quot;client: %s\n&amp;quot;, read_buff);

  close(client_sd);
  close(srv_sd);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;클라이언트-프로그램&#34;&gt;클라이언트 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;같은 호스트 안에 위치한 서버 프로그램에 &lt;code&gt;TCP 9001번 포트로 연결을 시도한다.&lt;/code&gt;
연결 후 서버 프로그램으로 &amp;lsquo;How old are you?&amp;rsquo; 라는 문자열을 전송한 후에 화면에 출력한다.
서버로부터 &amp;lsquo;I am 20 years old.&amp;rsquo; 라는 문자열을 전송 받은 후에 화면에 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define PORT 9001

int main() {
  int client_sd;
  struct sockaddr_in client_addr;

  int client_addr_len, read_len;
  char write_buff[BUFSIZ] = &amp;quot;How old are you?&amp;quot;;
  char read_buff[BUFSIZ];

  client_sd = socket(PF_INET, SOCK_STREAM, 0);
  if (client_sd == -1) {
    printf(&amp;quot;socket creation error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;==== client program ====\n&amp;quot;);

  memset(&amp;amp;client_addr, 0, sizeof(client_addr));
  client_addr.sin_family = AF_INET;
  client_addr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
  client_addr.sin_port = htons(PORT);

  if (connect(client_sd, (struct sockaddr *) &amp;amp;client_addr, sizeof(client_addr)) == -1) {
    printf(&amp;quot;connection error&amp;quot;);
    close(client_sd);
    return -1;
  }

  write(client_sd, write_buff, sizeof(write_buff));
  printf(&amp;quot;client: %s\n&amp;quot;, write_buff);

  read_len = read(client_sd, read_buff, sizeof(read_buff));
  if (read_len == -1) {
    printf(&amp;quot;read error&amp;quot;);
    return -1;
  }
  read_buff[read_len] = &#39;\0&#39;;
  printf(&amp;quot;server: %s\n&amp;quot;, read_buff);
  close(client_sd);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/127781662-add25fdb-1379-4a5f-a7e4-ea5214afd686.png&#34; alt=&#34;Screen Shot 2021-08-02 at 3 32 59 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서버를 실행한 직후 &lt;code&gt;netstat&lt;/code&gt; 명령을 통해서, &lt;code&gt;listen&lt;/code&gt; 상태에 있는 연결을 조회한 결과입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버는 클라이언트의 연결 요청을 기다리는 &lt;code&gt;listen&lt;/code&gt; 상태에 머물러 있다는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소켓 객체를 관리하는 것은 커널이고, 따라서 소켓 관련 함수들은 대부분 시스템 콜과 관련이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 함수들은 경우에 따라 실패할 수 있으므로, 실패의 종류에 따라서 필요한 루틴을 실행하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스에서는 함수 호출 후에 발생한 에러를 저장하는 &lt;code&gt;errno&lt;/code&gt; 라는 전역 변수를 제공한다. &lt;code&gt;errno&lt;/code&gt;는 &lt;code&gt;errno.h&lt;/code&gt; 파일을 &lt;code&gt;include&lt;/code&gt; 해서 사용할 수 있다. 또한, 에러 종류에 대한 매크로도 &lt;code&gt;errno.h&lt;/code&gt;에 정의되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;socket&lt;/code&gt; 함수의 인자 중 프로토콜 패밀리가 잘못되면 &lt;code&gt;socket&lt;/code&gt; 함수는 &lt;code&gt;-1&lt;/code&gt;을 리턴하면 종료하고, 종료하면서 자신이 어떤 에러에 의해서 종료되었는지 &lt;code&gt;errno&lt;/code&gt; 변수에 저장하는데 그 값은 &lt;code&gt;EINVAL&lt;/code&gt;로 미리 정의되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이 경우 다른 작업을 추가할고 싶으면 코드를 다음과 같이 구성하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;client_sd = socket(PF_INET, SOCK_STREAM, 0);

if (client_sd == -1) {
  if (errno == EINVAL) {
    printf(&amp;quot;protocol family error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;socket creation error&amp;quot;);
  return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;화면에 에러 메시지에 대략적인 내용을 출력하는 함수를 만들고 실패가 발생하는 모든 함수에서 에러 처리 루틴을 삽입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void perror(const char *msg);

int foo(int domain, int type, int protocol) {
  int res;
  res = socket(domain, type, protocol);
  if (res == -1) {
    perror(&amp;quot;socket&amp;quot;);
  }
  return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IP 주소 변환</title>
      <link>https://dongwooklee96.github.io/post/2021/08/01/ip-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98.html</link>
      <pubDate>Sun, 01 Aug 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/01/ip-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98.html</guid>
      <description>&lt;h3 id=&#34;주소-변환&#34;&gt;주소 변환&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그램이 사용자에게 입력받는 주소는 &lt;code&gt;Dotted-Decimal&lt;/code&gt; 형태의 문자열인 IP 주소 또는 호스트 이름일 것이다. 따라서 주소를 변환해주어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 입력한 IP 주소 문자열을 &lt;code&gt;uint32_t&lt;/code&gt; 형태로 변환시켜주는 작업이 반드시 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경우에 따라서는 &lt;code&gt;IP&lt;/code&gt; 주소를 다시 문자열 형태로 변환시키는 작업도 필요할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 주소를 변환할 수 있는 API 이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_addr(const char *cp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 주소를 네트워크 바이트 순서 &lt;code&gt;in_addr_t&lt;/code&gt;로 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_network(const char *cp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 주소를 호스트 바이트 순서 &lt;code&gt;in_addr_t&lt;/code&gt;로 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_aton(const char *cp, strcut in_addr *inp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 네트워크 바이트 순서 &lt;code&gt;inp&lt;/code&gt;로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;char *inet_ntoa(struct in_addr in);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;네트워크 바이트 순서로 된 &lt;code&gt;in_addr&lt;/code&gt;구조체 주소에서 IP 주소 문자열 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_pton(int af, const char *src, void *dst);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;af&lt;/code&gt; 인자로 3계층 프로토콜 선택 가능, &lt;code&gt;src&lt;/code&gt; 문자열 주소를 &lt;code&gt;dst&lt;/code&gt;로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;af&lt;/code&gt; 인자로 3계층 프로토콜을 선택 가능, &lt;code&gt;src&lt;/code&gt; 주소 구조체를 문자열 주소로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ip-주소를-정수로-변환하여-출력하는-예제&#34;&gt;IP 주소를 정수로 변환하여 출력하는 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv) {
  uint32_t ip_int;
  char *ip_str = &amp;quot;127.0.0.1&amp;quot;;

  ip_int = inet_network(ip_str);

  printf(&amp;quot;string: %s, decimal: %u, hex: %x\n&amp;quot;,
    ip_str, ip_int, ip_int);

  ip_int = htonl(ip_int);
  printf(&amp;quot;after htonl - decimal: %u, hex: %x \n&amp;quot;,
    ip_int, ip_int);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;inet_network&lt;/code&gt; 함수를 이용하여 문자열로 된 &lt;code&gt;IP&lt;/code&gt; 주소를 &lt;code&gt;uint32_t&lt;/code&gt; 타입 변수에 호스트 바이트 순서로 저장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;htonl&lt;/code&gt; 함수를 이용하여 호스트 바이트 순서로 되어 있는 주소를 네트워크 바이트 순서로 변경한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주소-변환-함수-예제&#34;&gt;주소 변환 함수 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

int print_addr(struct sockaddr_in *);

int main(char argc, char* argv[]) {

  char *sample_ip = &amp;quot;127.0.0.1&amp;quot;;

  int port = 9002;

  struct sockaddr_in sock_addr1, sock_addr2, sock_addr3;

  sock_addr1.sin_family = AF_INET;
  sock_addr1.sin_addr.s_addr = inet_addr(sample_ip);
  sock_addr1.sin_port = htons(port);

  sock_addr2.sin_family = AF_INET;
  inet_aton(sample_ip, &amp;amp;(sock_addr2.sin_addr));
  sock_addr2.sin_port = htons(port);

  sock_addr2.sin_family = AF_INET;
  inet_aton(sample_ip, &amp;amp;(sock_addr2.sin_addr));
  sock_addr2.sin_port = htons(port);

  sock_addr3.sin_family = AF_INET;
  inet_pton(AF_INET, sample_ip, &amp;amp;(sock_addr3.sin_addr));
  sock_addr3.sin_port = htons(port);

  print_addr(&amp;amp;sock_addr1);
  print_addr(&amp;amp;sock_addr2);
  print_addr(&amp;amp;sock_addr3);

  printf(&amp;quot;===== ntoa =====\n&amp;quot;);
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr1.sin_addr));
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr2.sin_addr));
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr3.sin_addr));
  return 0;
}

int print_addr(struct sockaddr_in *address) {
  int port;
  char txt[INET_ADDRSTRLEN];
  port = ntohs(address-&amp;gt;sin_port);
  inet_ntop(AF_INET, &amp;amp;(((struct sockaddr_in *) address) -&amp;gt; sin_addr), txt, sizeof(struct sockaddr_in));
  printf(&amp;quot;ip: %s, port: %d \n&amp;quot;, txt, address-&amp;gt;sin_port);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;호스트-이름과-ip-주소&#34;&gt;호스트 이름과 IP 주소&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실제로 우리가 작성하는 프로그램은 &lt;code&gt;IP&lt;/code&gt; 주소 문자열보다 호스트 이름을 인자로 받을 확률이 높다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;호스트 이름 문자열을 &lt;code&gt;IP&lt;/code&gt; 주소로 변환하는 과정은 단순 변환이 아니다. 네임 서버에 해당 내용을 조회하고 그 결과값을 알려주는 과정이 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
struct hosten *gethostbyname(const char *name);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;호스트 이름을 네임서버에 조회하여 성공하면 네임 서버는 여러 가지 정보를 제공한다. 이 정보를 저장하기 위해서는 &lt;code&gt;hostent&lt;/code&gt; 라는 구조체가 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct hostent {
  char *h_name; // 호스트의 공식 이름
  char **h_aliases; // 가명 리스트 (마지막 인자는 NULL)
  int h_addrtype; // 호스트 주소 타입 (IPv4, IPv6)
  int h_length; // 주소의 길이
  char **h_addr_list; // 주소 리스트 (마지막 인자는 NULL)
}
#define h_addr h_addr_list[0]; // 주소 중 첫 번째 엔트리
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;여러가지 정보 중에 우리가 관심 있는 것은 IP 주소이다. IP 주소는 &lt;code&gt;gethostbyname&lt;/code&gt; 하뭇의 실행 결과 얻을 수 있는 &lt;code&gt;hostent&lt;/code&gt; 구조체의 멤버 변수 중에서 주소 리스트인 &lt;code&gt;h_addr_list&lt;/code&gt;를 통해서 얻어올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;호스트-이름으로-ip-주소를-조회하는-예제&#34;&gt;호스트 이름으로 &lt;code&gt;IP&lt;/code&gt; 주소를 조회하는 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void err_proc(const char *);

int main(int argc, char *argv[]) {
  struct hostent *ent;
  struct in_addr **res;
  int i = 0;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s &amp;lt;hostname&amp;gt; \n&amp;quot;, argv[0]);
    return -1;
  }

  ent = gethostbyname(argv[1]);
  if (ent == NULL) err_proc(&amp;quot;gethostbyname&amp;quot;);

  res = (struct in_addr **) ent-&amp;gt;h_addr_list;
  printf(&amp;quot;hostname: %s \n&amp;quot;, ent-&amp;gt;h_name);
  while(res[i] != NULL) {
    printf(&amp;quot;%s&amp;quot;, inet_ntoa(*res[i]));
    i++;
  }
  printf(&amp;quot;\n&amp;quot;);
}

void err_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(errno);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;예제 프로그램은 프로그램 실행시에 호스트 이름을 입력 인자로 받는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램 실행 시 입력받은 호스트 이름 문자열을 이용하여 &lt;code&gt;gethostbyname&lt;/code&gt; 함수를 실행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>소켓 구조체 및 빅엔디안, 리틀엔디안</title>
      <link>https://dongwooklee96.github.io/post/2021/07/30/%EC%86%8C%EC%BC%93-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%B0%8F-%EB%B9%85%EC%97%94%EB%94%94%EC%95%88-%EB%A6%AC%ED%8B%80%EC%97%94%EB%94%94%EC%95%88.html</link>
      <pubDate>Fri, 30 Jul 2021 02:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/30/%EC%86%8C%EC%BC%93-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%B0%8F-%EB%B9%85%EC%97%94%EB%94%94%EC%95%88-%EB%A6%AC%ED%8B%80%EC%97%94%EB%94%94%EC%95%88.html</guid>
      <description>&lt;h3 id=&#34;소켓-자료-구조&#34;&gt;소켓 자료 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터 네트워크를 이용하여 통신을 하기 위해서는 다음과 같은 사항들이 결정되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 전송 계층 프로토콜
- 네트워크 계층 프로토콜
- Source 호스트의 IP 주소
- Destination 호스트의 IP 주소
- Source 프로세스의 포트번호
- Destination 프로세스의 포트번호
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이중에서 프로토콜들은 &lt;code&gt;socket&lt;/code&gt; 함수의 인자로 결정할 수 있는 부분이다.&lt;/li&gt;
&lt;li&gt;소켓에서는 주소를 다음과 같은 구조체를 이용하여 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr {
  uint8_t sa_len; // 주소 길이
  sa_familiy_t sa_family; // 주소 패밀리
  char sa_data[14]; // 주소 값
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;네트워크 계층 프로토콜로 &lt;code&gt;IPv4&lt;/code&gt;를 사용한다면 아래 구조체를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr_in {
  uint8_t sin_len; // 주소 길이
  sa_familiy_t sin_family; // 주소 패밀리
  in_port_t sin_port; // 포트번호

  struct in_addr sin_addr; // IPv4 주소값
  char sin_zero[8]; // 사용되지 않는 값 (sockaddr 과 길이를 맞추기 위함)
}

struct in_addr {
  uint32_t s_addr; // IP 주소
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;주소를-소켓에-적용시키는-방법&#34;&gt;주소를 소켓에 적용시키는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;소켓을 생성한 후 &lt;code&gt;bind()&lt;/code&gt; 함수를 호출하면 소켓에 &lt;code&gt;IP&lt;/code&gt; 주소와 포트번호 정보가 연결된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt; 함수는 두 번째 인자로 &lt;code&gt;sockaddr&lt;/code&gt; 구조체의 포인터를 사용하기 때문에 &lt;code&gt;sock_addr_in&lt;/code&gt; 구조체를 바로 사용할 수 없고 캐스팅을 해야한다.&lt;/li&gt;
&lt;li&gt;프로토콜 주소의 확장성을 위해서 다양한 주소 체계를 처리할 수 있도록 제작된 형태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빅엔디안과-리틀-엔디안&#34;&gt;빅엔디안과 리틀 엔디안&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터에서 데이터를 바이트 단위로 다룬다. 데이터를 바이트 단위로 다루는 것은 대부분의 컴퓨터에서 공통적인 일이지만, 여러 바이트로 구성된 데이터를 메모리에 저장하는 방식은 컴퓨터 구조에 따라서 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 아래와 같은 연속된 바이트로 구성된 데이터가 있다고 가정하자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| 0x |  12 | 34 | 56 | 78 | 9a | bc | de | f0 |
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;빅엔디안(Big-Endian)&lt;/strong&gt; : 상위 바이트 값이 메모리의 작은 주소에 저장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;리틀 엔디안(Little-Endian)&lt;/strong&gt; : 하위 바이트 값이 메모리의 작은 주소에 저장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 차이 때문에 컴퓨터에서 사용하던 데이터를 네트워크로 그대로 전송하면 컴퓨터마다 해독이 가능할 수도 있고, 불가능할 수 도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크로 흘러가는 데이터는 빅엔디안 방식을 사용하기로 약속하고 이를 네트워크 바이트 순서라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인텔 계열 컴퓨터는 리틀 엔디안으로 사용하기 때문에, 네트워크로 데이터를 전송하기 전에 빅엔디안으로 적절하게 변경해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 함수들은, 두 바이트 오더 간에 변환을 해주는 함수이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;가 뜻하는 것은 호스트이며 &lt;code&gt;n&lt;/code&gt;이 뜻하는 것은 네트워크이다. 데이터의 길이에 알맞게 사용을 하면 된다.&lt;/li&gt;
&lt;li&gt;만약 이미 네트워크 바이트 오더를 사용하는 컴퓨터라면 &lt;code&gt;htons&lt;/code&gt;와 &lt;code&gt;htonl&lt;/code&gt; 함수를 사용해도 값이 변경되지는 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr_in srv_addr;
int port = 9001;

srv_addr.sin_port = htons(port);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;앞의 함수를 사용하여 포트번호를 지정하는 예제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>소켓 프로그래밍이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/07/25/%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Sun, 25 Jul 2021 18:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/25/%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;소켓-프로그래밍-입문&#34;&gt;소켓 프로그래밍 입문&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우리 주변에서 발견할 수 있는 대부분의 프로그래밍은 누군가로부터 정보를 전달 받거나, 누군가에게 정보를 전달하는 작업의 연속이다. 이러한 입력과 출력 작업이 없는 프로그램은 거의 없기 때문에, 모든 프로그래머가 입출력 작업에 노출되어 있다고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입출력의 대상은 화면, 키보드, 파일, 데이터베이스, 다른 프로그램등 정말로 다양하다. 이중에 컴퓨터 네트워크를 대상으로 하는 입출력 행위를 다루는 프로그래밍을 네트워크 프로그래밍 또는 소켓 프로그래밍이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓은 네트워크 대상 입출력을 위한 응용 프로그래밍 인터페이스 (API의) 이름이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 프로그래밍의 정의&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;소켓 API를 이용하여 컴퓨터 네트워크를 사용하는 프로그램을 작성하는 것
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;프로세스 - 소켓 - 컴퓨터 네트워크 - 소켓 - 프로세스로 이어지는 연결 구조에서, 복잡한 컴퓨터 네트워크에서 데이터가 어떻게 전달되는가는 프로그래머의 1차 관심사가 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;소켓과-입출력&#34;&gt;소켓과 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;프로세스의 입장에서, 소켓에 관계된 작업은 다른 프로세스로부터 데이터를 받는 작업과 다른 프로세스에게 데이터를 주는 작업이라고 볼 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래밍을 처음 배울 때 대부분의 책들이 &lt;code&gt;Hello World!&lt;/code&gt; 라는 문자열을 출력하는 프로그램을 작성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 프로그램은 출력 대상이 터미널 화면인 출력 프로그램이다. 입출력의 대상이 될 수 있는 대상은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;표준 입출력, 파일, 장치, 터미널, 소켓&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;간단한-소켓-프로그래밍&#34;&gt;간단한 소켓 프로그래밍&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;

int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;domain&lt;/code&gt; : 소켓 통신을 위한 프로토콜 패밀리를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;: 소켓의 종류를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protocol&lt;/code&gt;: 소켓에서 사용할 포로토콜을 지정한다.&lt;/li&gt;
&lt;li&gt;반환값은 성공시에는 파일의 디스크립터를 반환하고 실패시에는 -1을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
  int sd1, fd1, sd2, fd2;
  sd1 = socket(PF_INET, SOCK_STREAM, 0);
  fd1 = open(&amp;quot;test&amp;quot;, O_RDONLY);
  sd2 = socket(PF_INET, SOCK_STREAM, 0);
  fd2 = open(&amp;quot;test2&amp;quot;, O_RDONLY | O_CREAT);
  printf(&amp;quot;sd1: %d, fd1: %d, sd2: %d, fd2: %d\n&amp;quot;, sd1, fd1, sd2, fd2);
  close(sd1);
  close(fd1);
  close(sd2);
  close(fd2);
  return 0;
}

// result: sd1: 3, fd1: 4, sd2: 5, fd2: 6
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;결과를 통해서 소켓에도 파일과 같은 디스크립터가 할당된 다는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;통신-프로토콜&#34;&gt;통신 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞서 소개한 &lt;code&gt;socket&lt;/code&gt; 함수는 3개의 인자를 받아서 소켓을 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 인자들 (도메인, 소켓타입, 프로토콜)을 이해하려면 컴퓨터 네트워크 통신 프로토콜에 대해서 알아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 소켓 프로그램인 웹 서버를 기준으로 통신 프로토콜에 대해서 알아보도록 하자. 웹서버에 접속하는것은 아래의 세부작업으로 구성되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 우리가 알고 있는 접속 주소를 네트워크 장비들이 이해할 수 있는 주소로 변환하는 작업
2. 교환할 데이터를 패킷으로 만드는 작업
3. 패킷이 이동하는 길의 이정표를 만드는 작업
4. 패킷의 목적지와 이정표를 확인하여 올바른 경로로 패킷을 전달하는 작업
5. 패킷이 목적지까지 제대로 도착했는지를 확인하는 작업
6. 네트워크가 혼잡할 때, 네트워크로 전송하는 패킷의 흐름을 조절하는 작업
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이러한 작업을 수행하기 위해서 네트워크 장비들이 따라야하는 절차와 약속을 정의하고 있는 것이 바로 통신 프로토콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인터넷-프로토콜&#34;&gt;인터넷 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IP는 인터넷 계층 프로토콜로써 컴퓨터 네트워크의 핵심 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP가 컴퓨터 네트워크의 핵심 프로토콜인 이유는 &lt;strong&gt;호스트와 라우터가 사용할 수 있는 통일된 규격의 주소, 즉 IP 주소를 제공하기 때문이다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;택배를 보낸다고 하더라도, 주소가 있어야 정상적으로 목적으로 배송을 할 수 있을 것이다. 또한 통일된 규격인 주소이여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 각각의 호스트들은 통신 기술과는 별개로 인식할 수 있는 주소가 있고 어려움 없이 데이터를 주고 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;전송-계층-프로토콜&#34;&gt;전송 계층 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크의 궁극적인 목적은 다른 호스트상에서 실행되고 있는 프로세스 간의 통신이다. 프로세스는 프로세스 아이디(&lt;code&gt;PID&lt;/code&gt;)로 식별이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 말해서, 프로세스를 특정하려면, &lt;code&gt;PID&lt;/code&gt; 가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;원거리 호스트에서 실행중인 프로그램의 PID를 통신할 때마다 알아야 하는가?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞에서 설명한 IP 주소 덕분에 호스트까지 데이터를 전달하는 것은 가능하지만, 호스트에 데이터가 도착하고 그 데이터가 어떤 프로세스에 전달되어야 하는지를 알려면 &lt;code&gt;PID&lt;/code&gt;로 판별을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 다른 호스트에서 실행되고 있는 &lt;code&gt;PID&lt;/code&gt;를 알아내는 것은 쉽지 않으므로, 그 대신에 도착한 패킷에 있는 정보를 이용하여 해당 프로세스까지 전달해주는 수단이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 일을 전송 계층 프로토콜인 &lt;code&gt;TCP&lt;/code&gt;, &lt;code&gt;UDP&lt;/code&gt;에 의해서 수행된다. &lt;strong&gt;전송 계층에서는 프로세스를 식별하기 위해서 포트라는 주소를 제공한다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 간에 통신할 포트 번호를 미리 약속한다면 &lt;code&gt;PID&lt;/code&gt;를 몰라도 통신하는 것이 가능하기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전송 계층 프로토콜은 통신을 원하는 프로세스들과 직접적인 연관이 있는 것으로, 네트워크 중간에서 패킷을 포워딩하는 라우터에서는 작동하지 않는다. 통신의 시작점과 목적지에서만 역할을 하기 때문에 &lt;code&gt;END-TO-END&lt;/code&gt; 프로토콜이라고 불린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 네트워크 도구 (테스트, 추적, 모니터링 명령어)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4.html</link>
      <pubDate>Wed, 28 Apr 2021 00:12:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4.html</guid>
      <description>&lt;h3 id=&#34;hping3&#34;&gt;hping3&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;hping3 -S www.daum.net -p 80
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP/UDP, ICMP 및 다양한 종류의 패킷을 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 빠른 주기로 패킷을 보내고 싶다면 &lt;code&gt;--fast&lt;/code&gt; 옵션을 줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iptables&#34;&gt;iptables&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이 명령어는 특정 IP 주소의 요청을 막을 수 있는 명령이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# localhost의 UDP 요청을 차단하는 규칙을 추가하였다.
iptables -I OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

# iptables 설정을 확인해본다.
iptables -L -n

# 다른 터미널에서 실제 요청을 보내보지만 응답이 오지 않는다.
hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast

# 위의 설정을 삭제한다.
iptables -D OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

iptables -L -n

# 요청이 정상적으로 보내짐을 확인할 수 있다.

hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 도구를 사용하는 것은 내부적으로 커널의 기능을 사용하는 것이고, 리눅스 커널 안에 넷 필터(&lt;code&gt;NET FILTER&lt;/code&gt;) 라는 기능을 이용하여 구현하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정이 늘어날수록 점점 느려진다는 단점이 있어서, 요즘에는 &lt;code&gt;BPF&lt;/code&gt;라는 툴을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nslookup&#34;&gt;nslookup&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;도메인 이름을 IP 주소로 변환해주는 명령어이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270076-bd33a980-a7b9-11eb-83fc-a8ffaef46022.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 08 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이와 비슷한 도구로 &lt;code&gt;dig&lt;/code&gt; 라는 도구가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270202-dccad200-a7b9-11eb-9f82-fa515cebecdd.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 45 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;nmap&#34;&gt;nmap&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;포트 스캔을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270489-18fe3280-a7ba-11eb-8d79-95571243f764.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 38 40 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어 및 결과는 &lt;code&gt;localhost&lt;/code&gt;에 열려있는 포트들을 터미널에 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iftop&#34;&gt;iftop&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270960-89a54f00-a7ba-11eb-9c44-38576b8ffebf.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 41 42 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bmon&#34;&gt;bmon&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271227-c113fb80-a7ba-11eb-8473-232acc8656c2.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 42 55 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;li&gt;특이한 점은 TUI 그래픽으로 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dstat&#34;&gt;dstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271795-47304200-a7bb-11eb-9aea-bbeba62def27.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 47 14 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 형태로 시스템 정보와 같이 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ss&#34;&gt;ss&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272077-8fe7fb00-a7bb-11eb-869c-6110b9b5a938.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 49 12 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;소켓의 리시브 큐와 센드 큐를 모니터링 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272413-d76e8700-a7bb-11eb-9726-d953b812550b.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 50 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>MSS 그리고 MTU (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft.html</link>
      <pubDate>Tue, 27 Apr 2021 23:44:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116261520-b0f81e00-a7b2-11eb-96dd-03ae4f909358.png&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mss-maximun-segment-size&#34;&gt;MSS (Maximun Segment Size)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262109-3aa7eb80-a7b3-11eb-8648-27d4cdfb5779.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 48 40 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSS는 TCP 상에서 전송할 수 있는 사용자의 데이터(&lt;code&gt;payload&lt;/code&gt;) 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP 헤더를 제외한 데이터의 크기이다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP(L4) 계층에서 데이터의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;위의 사진을 보면, TCP 헤더를 제외한 데이터 부분을 MSS라고 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mtu-maximun-transmission-unit&#34;&gt;MTU (Maximun Transmission Unit)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262489-8bb7df80-a7b3-11eb-8254-7a56a5d13018.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 51 49 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTU는 네트워크에서 전송 될 수 있는 최대 패킷의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MTU는 IP(L3) 계층에서 패킷이라고도 불리운다.&lt;/li&gt;
&lt;li&gt;MTU에서 IP 헤더와 TCP 헤더를 제외하면 그것이 바로 MSS가 된다.&lt;/li&gt;
&lt;li&gt;MTU를 패킷이라고 부른다.&lt;/li&gt;
&lt;li&gt;참고로 L2는 프레임이라는 용어로 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;설정된-mtu-크기를-확인하는-방법&#34;&gt;설정된 MTU 크기를 확인하는 방법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116263219-27e1e680-a7b4-11eb-90c7-995a0ef1d0e5.png&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ip link&lt;/code&gt; 라는 명령어를 치면 현재 리눅스 환경에서 설정된 MTU 값을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;MTU 값이 1500 BYTES 으로 잡혀 있는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;패킷을-보내고-이를-트레이싱-해보자&#34;&gt;패킷을 보내고 이를 트레이싱 해보자&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;패킷을 보내기 위해서 &lt;code&gt;ping&lt;/code&gt; 이라는 도구를 통해서 구글 DNS 서버 (8.8.8.8)에 요청을 보내보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ping -M do -s 68 8.8.8.8&lt;/code&gt; 이 명령어는 서버에 68 바이트를 보내는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264144-03d2d500-a7b5-11eb-8d04-05da9a3b3b39.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 02 18 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사진을 보면 데이터는 68바이트를 보냈지만 실제로는 96 바이트가 전송된 것을 확인할 수 있다. 이유는 데이터에 헤더 부분이 포함되었기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추가로 &lt;code&gt;ping -M do -s 1500 8.8.8.8&lt;/code&gt; 명령어로 패킷의 최대 크기인 1500 MTU 만큼 데이터를 전송해본다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264626-6926c600-a7b5-11eb-9487-b472c8c1264a.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 05 06 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러가 발생하는 것을 확인해볼 수 있는데, 그 이유는 헤더가 포함되었기 때문이다. 하지만 이 에러는 커널 레벨에서 발생한 것은 아니고 &lt;code&gt;ping&lt;/code&gt; 도구에서 발생시킨 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 확인해보기 위해서, &lt;code&gt;ping&lt;/code&gt; 보다 많은 기능을 지원하는 &lt;code&gt;hping3&lt;/code&gt; 도구를 이용해서 테스트 해보겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f icmp -Y &amp;quot;ip.dst == 8.8.8.8 or ip.src == 8.8.8.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용해서 패킷을 캡처하고 아래 명령어를 다른 터미널에서 입력을 해본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo hping3 -d 2000 --icmp 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116265856-61b3ec80-a7b6-11eb-9333-e8b070648840.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 12 05 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 결과를 확인해 볼 수 있다. 자세히 살펴보면, 패킷이 정상적으로 전송이 된 것을 확인해볼 수 있지만 서버로 부터 응답이 오지 않는 것을 확인할 수 있다. 이로서 구글 도메인 서버에 요청할 수 있는 최대 패킷 크기는 1500 bytes 라는 것을 확인할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 2000 바이트를 데이터로 전송을 하였는데 MTU는 최대 1500 바이트이다. 따라서 패킷이 쪼개져서 전송되고 있다는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신과정 추적해보기 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft.html</link>
      <pubDate>Tue, 20 Apr 2021 23:51:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft.html</guid>
      <description>&lt;h3 id=&#34;추적-과정&#34;&gt;추적 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;추적하기 전에 클라이언트와 서버 코드를 컴파일 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;client.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define MAXLINE 1024

int main(int argc, char **argv) {
        struct sockaddr_in serveraddr;
        int server_sockfd;
        int client_len;
        char buf[MAXLINE];

        if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                perror(&amp;quot;error : &amp;quot;);
                return 1;
        }
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
        serveraddr.sin_port = htons(4000);

        client_len = sizeof(serveraddr);

        if(connect(server_sockfd, (struct sockaddr*)&amp;amp;serveraddr, client_len) == -1) {
                perror(&amp;quot;connect error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        read(0, buf, MAXLINE);
        if(write(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;write error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        if(read(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;read error: &amp;quot;);
                return 1;
        }
        close(server_sockfd);
        printf(&amp;quot;server:%s\n&amp;quot;, buf);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;server.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

#define BUFF_SIZE 1024

int main(void){
   int server_socket;
   int client_socket;
   int client_addr_size;
   struct sockaddr_in server_addr;
   struct sockaddr_in client_addr;
   char buff_rcv[BUFF_SIZE+5];
   char buff_snd[BUFF_SIZE+5];

   server_socket = socket(PF_INET, SOCK_STREAM, 0);
   if(-1 == server_socket){
      printf( &amp;quot;server socket 생성 실패n&amp;quot;);
      exit( 1);
   }

   memset(&amp;amp;server_addr, 0, sizeof(server_addr));
   server_addr.sin_family     = AF_INET;
   server_addr.sin_port       = htons(4000);
   server_addr.sin_addr.s_addr= htonl(INADDR_ANY);

   if(-1 == bind(server_socket, (struct sockaddr*)&amp;amp;server_addr, sizeof(server_addr))){
      printf( &amp;quot;bind() 실행 에러n&amp;quot;);
      exit(1);
   }

   while(1){
      if(-1 == listen(server_socket, 5)){
         printf( &amp;quot;대기상태 모드 설정 실패n&amp;quot;);
         exit(1);
      }

      client_addr_size  = sizeof( client_addr);
      client_socket     = accept( server_socket, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_size);

      if (-1 == client_socket){
         printf( &amp;quot;클라이언트 연결 수락 실패n&amp;quot;);
         exit(1);
      }

      read (client_socket, buff_rcv, BUFF_SIZE);
      printf(&amp;quot;receive: %s\n&amp;quot;, buff_rcv);

      sprintf(buff_snd, &amp;quot;%ld : %s&amp;quot;, strlen(buff_rcv), buff_rcv);
      write(client_socket, buff_snd, strlen(buff_snd)+1);          // +1: NULL까지 포함해서 전송
      close(client_socket);
   }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 소스 코드를 복사하여, 파일을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -pg -g -o client client.c
gcc -pg -g -o server server.c
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;그리고 위의 명령어를 통해서 컴파일을 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uftrace&#34;&gt;UFTRACE&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115418135-35d3bc80-a234-11eb-898d-50f3f8eb093e.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 57 42 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서는 &lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;ufrace&lt;/a&gt;를 이용하여 함수를 추적할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UFTACE는 C/C++로 작성된 프로그램의 실행을 추적하고 분석하는 도구이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;uftrace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신에 대해서 알아보자...</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90....html</link>
      <pubDate>Tue, 20 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90....html</guid>
      <description>&lt;h3 id=&#34;tcp-transmission-control-protocol&#34;&gt;TCP (Transmission Control Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115409556-cf976b80-a22c-11eb-9c4c-c2f61110b0e2.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 IP 네트워크를 통해서 통신하는 호스트에서 실행되는 애플리케이션 간에 신뢰할 수 있고, 순서가 정해져있으며, 오류를 체크하고 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;월드 와이드 웹, 이메일, 원격 관리, 파일 전송과 같은 주요 인터넷 애플리케이션은 전송 계층의 일부인 TCP에 의존한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/TLS 또한 TCP 위에서 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 인터넷 프로토콜 (IP)과 작동하여 컴퓨터가 서로 데이터 패킷을 보내는 방법을 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-맺는-과정&#34;&gt;연결을 맺는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411131-2d788300-a22e-11eb-8557-0eb3e42d1096.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN: 클라이언트가 서버에 SYN를 전송한다. 클라이언트는 세그먼트의 시퀀스 번호를 임의의 값으로 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN-ACK: 응답으로 서버는 SYN-ACK로 응답을 한다. 수신된 시퀀스 보다 많은 숫자로 설정 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACK: 마지막으로 클라이언트가 서버에 다시 ACK를 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정을 통해서 서버와 클라이언트는 연결을 맺으며 &lt;code&gt;3 Way HandShake&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;직접 확인하기&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f &amp;quot;tcp port 80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 명령어를 입력하여 포트 번호 80의 TCP 패킷들을 필터링 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이어서 다른 터미널에서 &lt;code&gt;curl www.google.com&lt;/code&gt; 으로 구글 서버에 요청을 날린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414010-a2e55300-a230-11eb-8c2d-07636049b212.png&#34; alt=&#34;today&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정상적으로 연결이 맺어진 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-끊는-과정&#34;&gt;연결을 끊는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411888-d58e4c00-a22e-11eb-82d0-c47393198d7f.png&#34; alt=&#34;520px-TCP_CLOSE svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 종료하는 과정은 &lt;code&gt;4 Way HandShake&lt;/code&gt; 라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 끊겼음에도 클라이언트에서 &lt;code&gt;TIME WAIT&lt;/code&gt;을 하는 이유는 지연되거나 유실된 패킷이 뒤늦게 전송되는 경우가 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;확인해보기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414505-0c656180-a231-11eb-98de-cdabc90dba20.png&#34; alt=&#34;4way&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 했던 것과 같이 패킷을 캡처링 했을 때, 실제로 위와 같은 과정으로 커넥션을 끊는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-헤더-구조&#34;&gt;TCP 헤더 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115412590-6bc27200-a22f-11eb-85e4-619fcac22d79.png&#34; alt=&#34;header&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 전송하는 SYN 패킷과 ACK 패킷은 TCP 헤더에서 위치에 해당하는 비트가 켜져서 전송된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-연결이-맺음과-끊어짐에-따른-소켓의-변화&#34;&gt;TCP 연결이 맺음과 끊어짐에 따른 소켓의 변화&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415800-294e6480-a232-11eb-85f8-ad556e694641.png&#34; alt=&#34;1920px-Tcp_state_diagram_fixed_new svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 맺고 끊을 때마다 소켓의 내부 상태가 변하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트에서 요청을 보내기 위해서 소켓을 생성할 때 파일 디스크립터가 생성되며 연결을 끊고 싶을 때 파일을 닫게 되며, FIN 패킷을 날리게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415367-d07ecc00-a231-11eb-86cb-2b5c569c07f1.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 40 13 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch -n0.6 &amp;quot;netstat -atnp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 watch 명령어를 통해서 0.6초마다 netstat의 결과를 모니터링 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, CURL을 통해서 서버에 요청을 날리면 클라이언트 소캣의 상태를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34;&gt;Transmission Control Protocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DNS란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 23:15:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;dnsdomain-name-system&#34;&gt;DNS(Domain Name System)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;내가-활용중인-dns-ip-주소-확인하기&#34;&gt;내가 활용중인 DNS IP 주소 확인하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567743-7bc9d700-9cae-11eb-82f9-9dcf503ef717.png&#34; alt=&#34;dns&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 내가 사용하고 있는 &lt;code&gt;DNS&lt;/code&gt; 서버의 &lt;code&gt;IP&lt;/code&gt; 주소를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568053-c4819000-9cae-11eb-8d25-3a8be64a3411.png&#34; alt=&#34;dns-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에 명령어를 통해서 나온 주소를 구글에 검색하면, 어떤 &lt;code&gt;DNS&lt;/code&gt; 서버를 사용하는지 대략적으로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns-동작과정-추적하기&#34;&gt;DNS 동작과정 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568459-1b876500-9caf-11eb-8ffb-d43a61af1ffe.png&#34; alt=&#34;dns-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568479-1e825580-9caf-11eb-8d1e-4165d8c43077.png&#34; alt=&#34;dns-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위와 같은 과정을 통해서, DNS 서버에 요청하고, 도메인 주소를 통해서 &lt;code&gt;IP&lt;/code&gt; 정보를 받아오는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114569074-a4060580-9caf-11eb-9311-dff133504ae0.png&#34; alt=&#34;flush&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemd-resolve --flush-caches
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;DNS 캐시 정보를 지우고 싶다면 위의 명령어를 입력하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ARP란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;arpaddress-resolution-protocol&#34;&gt;ARP(Address Resolution Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;L2(데이터 링크 계층) 통신 프로토콜이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IP&lt;/code&gt; 네트워크 주소를 데이터 링크 프로토콜에서 사용하는 하드웨어 주소(Mac ADDRESS)에 맵핑하기 위해서 사용하는 프로토콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565725-84211280-9cac-11eb-9fa7-fef4c8b44361.png&#34; alt=&#34;arp&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arp -n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 명령어를 통해서, ARP 테이블을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;arp-패킷-추적하기&#34;&gt;ARP 패킷 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566386-2ccf7200-9cad-11eb-8ace-088abe48ea0e.png&#34; alt=&#34;arp-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 패킷 추적을 시작한다. 그리고 MAC 주소를 확인하기 위해서 &lt;code&gt;PING&lt;/code&gt; 명령어를 자신의 IP 주소로 보내며, 네트워크 패킷이 호출되는 것을 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566398-2fca6280-9cad-11eb-9b7e-13eb549a4a3c.png&#34; alt=&#34;arp-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566393-2e993580-9cad-11eb-8886-2ee5ee935ad9.png&#34; alt=&#34;arp-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffff:ffff:ffff는 목적지 주소를 나타내며, 브로드 캐스트의 의미이다. 바로 뒤에오는 주소가 바로 송신지의 주소이며 목적지의 MAC 주소를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567037-d0b91d80-9cad-11eb-81a4-dc9aea24b583.png&#34; alt=&#34;arp-4&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MAC&lt;/code&gt; 주소를 확인하면, 나의 &lt;code&gt;MAC&lt;/code&gt; 주소와 일치하는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ICMP란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;icmpinternet-control-message-protocol&#34;&gt;ICMP(Internet Control Message Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;L3(네트워크 계층) 통신 프로토콜로서, 라우터를 포함한 네트워크 장치가 다른 IP 주소와 통신을 할 때 성공 또는 실패를 나타내는 오류 메시지 및 운영정보를 보내는데 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흔히 사용하는 &lt;code&gt;PING&lt;/code&gt; 명령어가 &lt;code&gt;ICMP&lt;/code&gt; 프로토콜을 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564433-45d72380-9cab-11eb-88c5-8529a0adb7ee.png&#34; alt=&#34;ping&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;네트워크-패킷-추적하기&#34;&gt;네트워크 패킷 추적하기&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install tshark
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력하여 &lt;code&gt;tshark&lt;/code&gt;를 설치한다, 네트워크 패킷 분석을 할 수 있는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565051-e299c100-9cab-11eb-8c29-8c0c4a1f914f.png&#34; alt=&#34;ping-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력해서, &lt;code&gt;ICMP&lt;/code&gt; 패킷을 분석을 시작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564927-c3029880-9cab-11eb-8081-63f0837202a8.png&#34; alt=&#34;ping-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제로 &lt;code&gt;PING&lt;/code&gt;을 8.8.8.8 주소로 날리게 되면, 패킷 추적이 되는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>MAC 주소란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:21:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;mac-주소란&#34;&gt;MAC 주소란?&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mac-주소-알아내는-법&#34;&gt;MAC 주소 알아내는 법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114561564-a0bb4b80-9ca8-11eb-822e-f5123ca09728.png&#34; alt=&#34;mac&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용하면 사용하고 있는 하드웨어의 &lt;code&gt;MAC&lt;/code&gt; 주소 및 네트워크 카드 &lt;code&gt;ID&lt;/code&gt;, 제조사를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>라우팅이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:20:48 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;라우팅이란&#34;&gt;라우팅이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 패킷이 목적지를 찾아가기 위한, 최적의 경로이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요청한-서버까지-라우터를-추적하는-방법&#34;&gt;요청한 서버까지 라우터를 추적하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114563693-98fca680-9caa-11eb-85d8-1ea7de69d92a.png&#34; alt=&#34;router&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 서버까지 굉장히 많은 라우터를 거쳐간다는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;네이버 서버에 요청하였을 때는 보안상의 이유로 라우터가 가려진 것을 확인할 수 있다. 모든 라우터의 주소를 확인할 수 있는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>웹 클라이언트(브라우저) 부터 웹서버까지의 구조 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114560424-a5333480-9ca7-11eb-9929-ae4566a72689.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 주소를 입력하면 &lt;code&gt;HTTP&lt;/code&gt; 통신이 일어나게 되고, DNS 서버에서, 도메인 주소를 &lt;code&gt;IP&lt;/code&gt; 주소로 변환하는 요청을 하게 된다.&lt;/li&gt;
&lt;li&gt;IP 주소를 알아내면, 라우터를 통해서 &lt;code&gt;TCP / IP&lt;/code&gt; 통신을 하게 된다.&lt;/li&gt;
&lt;li&gt;웹 서버에 도착했을 때는 최종적으로 &lt;code&gt;HTTP&lt;/code&gt; 통신이 이루어지게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클라우드 이벤트 스펙이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Mon, 29 Mar 2021 22:55:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;클라우드-이벤트-스펙이란&#34;&gt;클라우드 이벤트 스펙이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941452-927a1500-9169-11eb-9947-5291c6d27c86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 06 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트는 어디에서든지 발생하지만, 이벤트를 생산하는 생산자에 따라서 이벤트를 다르게 정의하는 경향이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 설명하는 표준이 없기 때문에, 개발자는 이벤트 사용방법을 계속해서 배워야 한다. 또한 &lt;code&gt;SDK&lt;/code&gt;, 이벤트 라우터 또는 추적 시스템과 같은 환경에서 이벤트 데이터를 전달하는데 도움이 되는 도구 및 인프라의 잠재력을 제한한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우드 이벤트는 서비스, 플랫폼 및 시스템간에 상호 운영성을 제공하기 위해서 이벤트 데이터를 공통 형시으로 설명하기 위한 스펙이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941821-277d0e00-916a-11eb-83bd-4a426cf9ea86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 11 01 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서를 보면 프로토콜 별로 스펙과 문서를 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 카프카에 관심이 있으므로 카프카 메시지에 대한 문서를 살펴보도록 하겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;카프카-메시지-맵핑&#34;&gt;카프카 메시지 맵핑&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112943105-01f10400-916c-11eb-88a1-546ffe6c47a1.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 24 17 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;카프카 &lt;code&gt;0.11.0.0&lt;/code&gt; 이상에서는 이벤트 발신자가 콘텐츠 모드를 선택한다, 특정 콘텐츠 모드를 사용해서 이벤틀르 요청을 허용할 수 있는 프로토콜 사용 패턴은 응용 프로그램에서 정의 할 수 있지만, 여기에서는 정의되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 수신자는 카프카 메시지의 &lt;code&gt;Content-type&lt;/code&gt; 헤더를 검사하여 두 콘첸츠 모드를 구분할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;미디어 타입이 &lt;code&gt;application/cloudevents&lt;/code&gt; 인 경우에는 이벤트 형식의 사용을 나타내고 수신자는 구조화된 모드를 사용합니다. 그렇지 않은 경우에는 디폴트로 바이너리 모드입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 다음과 같은 &lt;code&gt;JSON&lt;/code&gt; 형태로 작성하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------ Message -------------------

Topic Name: mytopic

------------------- key ----------------------

Key: mykey

------------------ headers -------------------

content-type: application/cloudevents+json; charset=UTF-8

------------------- value --------------------

{
    &amp;quot;specversion&amp;quot; : &amp;quot;1.0&amp;quot;,
    &amp;quot;type&amp;quot; : &amp;quot;com.example.someevent&amp;quot;,
    &amp;quot;source&amp;quot; : &amp;quot;/mycontext/subcontext&amp;quot;,
    &amp;quot;id&amp;quot; : &amp;quot;1234-1234-1234&amp;quot;,
    &amp;quot;time&amp;quot; : &amp;quot;2018-04-05T03:56:24Z&amp;quot;,
    &amp;quot;datacontenttype&amp;quot; : &amp;quot;application/xml&amp;quot;,

    ... further attributes omitted ...

    &amp;quot;data&amp;quot; : {
        ... application data encoded in XML ...
    }
}

-----------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34;&gt;cloudevents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec/blob/v1.0.1/kafka-protocol-binding.md&#34;&gt;cloudevents - kafka spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HTTP란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</guid>
      <description>&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol)의 약자로서, 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP는 요청(&lt;code&gt;REQUEST&lt;/code&gt;), 응답(&lt;code&gt;RESPONSE&lt;/code&gt;)을 통해서 정보를 주고 받으며, HTTP 메시지 구조는 크게 헤더(&lt;code&gt;HEADER&lt;/code&gt;)와 바디(&lt;code&gt;BODY&lt;/code&gt;)로 나누어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;curl-명령어를-통한-요청&#34;&gt;CURL 명령어를 통한 요청&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;요청 헤더 및 응답 헤더&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562451-79b14980-9ca9-11eb-9b65-dcee73144654.png&#34; alt=&#34;google&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 &lt;code&gt;curl&lt;/code&gt; 명령어를 통해서 구글 서버에 &lt;code&gt;GET&lt;/code&gt; 요청을 날려보았다.&lt;/li&gt;
&lt;li&gt;요청 헤더 및 응답 헤더를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;응답 바디&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562913-e62c4880-9ca9-11eb-9df8-b399eaa6e1da.png&#34; alt=&#34;response&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;, &lt;code&gt;CSS&lt;/code&gt;, &lt;code&gt;JS&lt;/code&gt; 파일을 응답한 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;웹 서버가 응답하는 파일은 이것이 전부이고, 브라우저에는 응답받은 파일을 통해서 화면에 그려주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>REST 및 베스트 프랙티스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4.html</link>
      <pubDate>Sat, 27 Mar 2021 17:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4.html</guid>
      <description>&lt;h3 id=&#34;rest&#34;&gt;REST&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 웹의 창시자 중의 한 사람인 로이 필딩이 2000년에 발표한 논문에 의해서 처음 소개되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 아키텍처가 웹의 장점을 잘 활용하지 못하고 있다고 판단했기 때문에 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이바로 &lt;code&gt;Representational Safe Transfer(REST)&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 근래에 들어 &lt;code&gt;HTTP&lt;/code&gt;와 &lt;code&gt;JSON&lt;/code&gt;을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 &lt;code&gt;OPEN API&lt;/code&gt;는 이 &lt;code&gt;REST&lt;/code&gt; 아키텍처를 기반으로 설계 및 구현되고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-기본&#34;&gt;REST의 기본&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;REST는 크게 리소스, 메서드, 메시지의 3가지 요소로 구성된다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &amp;ldquo;이름이 Terry인 사용자를 생성했을 때&amp;rdquo; 사용자는 생성되는 리소스, 생성한다라는 행위는 메서드 그리고, 이름이 &lt;code&gt;Terry&lt;/code&gt;는 메시지가 된다.&lt;/li&gt;
&lt;li&gt;이를 REST로 표현해보면 다음과 같은 형태가 된다, &amp;lsquo;생성한다&amp;rsquo;라는 의미가 있는 메서드는 &lt;code&gt;HTTP&lt;/code&gt; &lt;code&gt;POST&lt;/code&gt;가 되고, 생성하고자 하는 대상이 되는 사용자라는 리소스는 &lt;code&gt;http://myweb/users&lt;/code&gt;라는 형태의 URI로 표현되며, 생성하고자 하는 사용자의 구체적인 내용은 &lt;code&gt;JSON&lt;/code&gt; 문서를 이용하여 표현된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;users&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;http-메서드&#34;&gt;HTTP 메서드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;행위에 대한 메서드는 HTTP 메서드를 그대로 사용한다.&lt;/li&gt;
&lt;li&gt;HTTP에는 여러가지 메서드가 있지만, &lt;code&gt;REST&lt;/code&gt;에서는 &lt;code&gt;CRUD(CREATE, READ, UPDATE, DELETE)&lt;/code&gt;에 해당하는 4가지의 메서드만 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112715716-53f41880-8f25-11eb-96a0-52dc9613dc36.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;멱등성은 여러 번 수행해도 결과가 같은 경우를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 연산은 리소스를 추가하는 연산이기 때문에, 멱등성을 성립하지 않지만, 나머지 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;는 반복수행하더라도, 멱등하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;의 경우 게시물의 조회 카운트를 늘려준다거나 하는 기능을 같이 수행했을 때는 멱등하지 않은 메서드로 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REST&lt;/code&gt;는 개별 &lt;code&gt;API&lt;/code&gt;를 상태 없이 수행하게 된다, 따라서 해당 &lt;code&gt;REST&lt;/code&gt; API를 다른 API와 함께 호출하다가 실패했을 때 트랜잭션 복구를 위해서 다시 실행해야하는 경우가 있는데, 멱등하지 않은 메서드의 경우에는 기존 상태를 저장했다가 다시 원상 복구시켜줘야 하는 경우가 있지만, 멱등한 메서드의 경우에는 반복적으로 다시 메서드를 수행하면 된다.&lt;/li&gt;
&lt;li&gt;멱등성을 충족하지 않는 메서드에 대해서는 트랜잭션에 대한 처리에 주의가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-리소스&#34;&gt;REST의 리소스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 리소스 지향 아키텍처 스타일이라는 정의 답게 모든 것을 리소스, 즉 명사로 표현하며, 각 세부 리소스에는 &lt;code&gt;ID&lt;/code&gt;를 붙인다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스가 명사의 형태를 띄우다 보니 명령 성격의 API를 정의하는데 혼동이 올 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동사형을 명사형으로 바꿔서 적용해보면 리소스 형태로 표현하기가 조금 더 수월해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api의-간단한-예제&#34;&gt;REST API의 간단한 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;사용자 생성&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;name&amp;quot;:&amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;:&amp;quot;seoul&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP GET, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;업데이트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP PUT, http://myweb/users/terry 
{
  &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;suwon&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;삭제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP DELETE, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;상당히 간단하다, 단순하게 리소스를 URI로 정해주고, 거기에 HTTP 메서드를 이용해서 CRUD를 구현하고 메세지를 &lt;code&gt;JSON&lt;/code&gt;으로 표현하여 &lt;code&gt;HTTP&lt;/code&gt; 바디에 실어서 보내면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; 에 리소스 ID가 없다는 것을 빼면 크게 신경쓸 부분이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-특성&#34;&gt;REST의 특성&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;유니폼-인터페이스uniform-interface&#34;&gt;유니폼 인터페이스(Uniform Interface)&lt;/h4&gt;
&lt;p&gt;REST는 HTTP 표준에만 따른다면 어떤 기술이든지 사용할 수 있는 인터페이스 스타일이다. 예를 들어, HTTP + JSON으로 REST APII를 정의했다면, 안드로이드 플랫폼이건 IOS 플랫폼이건 특정 언어나 기술에 종속받지 않고, HTTP와 JSON을 모든 플랫폼에서 사용할 수 있는 느슨한 결합이다.&lt;/p&gt;
&lt;h4 id=&#34;무상태성스테이트리스stateless&#34;&gt;무상태성/스테이트리스(Stateless)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 Representational State Transfer의 약어로 Stateless(상태를 유지하지 않음)란ㄴ 특징을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태가 있다 없다는 사용자나 클라이언트의 컨텍스트를 서버에 유지하지 않는다는 의미로, 쉽게 표현하면 HTTP 세션과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메시지로 처리하면 되며, 세션과 같은 컨텍스트 정보를 신경쓸 필요가 없으므로 구현이 단순해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;캐시-가능cacheable&#34;&gt;캐시 가능(Cacheable)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 큰 특징 중에 하나는 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 프로토콜 기반의 로드 밸런서나 SSL은 물론이고, HTTP가 가진 가장 강력한 기능중에 하나인 캐싱 기능을 적용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 시스템에서 &lt;code&gt;60%&lt;/code&gt;에서 많게는 &lt;code&gt;80%&lt;/code&gt; 가량의 트랜잭션이 &lt;code&gt;SELECT&lt;/code&gt;와 같은 조회성 트랜잭션인 것을 고려하면, &lt;code&gt;HTTP&lt;/code&gt;의 리소스들은 웹 캐시 서버 등에 캐싱하는 것은 용량이나 성능 면에서 많은 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 HTTP 프로토콜 표준에서 사용하는 &lt;code&gt;Last-Modified&lt;/code&gt; 태그나 &lt;code&gt;E-Tag&lt;/code&gt;를 이용하면 캐싱을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음과 같이 클라이언트가 HTTP GET을 &lt;code&gt;Last-Modified&lt;/code&gt; 값과 함께 보냈을 때 콘텐츠에 변화가 없으면 &lt;code&gt;REST&lt;/code&gt; 컴포넌트는 &lt;code&gt;304 Not Modified&lt;/code&gt;를 반환하며 클라이언트는 자체 캐시에 저장된 값을 사용하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112716331-0d082200-8f29-11eb-95d1-21b0a40accbe.png&#34; alt=&#34;267E914554241E6512&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이렇게 캐시를 사용하게 되면 네트워크 응답 시간뿐만 아니라, &lt;code&gt;REST&lt;/code&gt; 컴포넌트가 위치한 서버에 트랜잭션을 발생시키지 않기 때문에 전체 응답 시간과 성능 그리고 자원 사용률을 비약적으로 향상시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;자체-표현-구조self-descriptiveness&#34;&gt;자체 표현 구조(Self-descriptiveness)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 가장 큰 특징중의 하나는 REST API 자체가 쉬워서 API 메시지만 보고도 이를 이해할 수 있는 자체 표현 구조로 되어 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스와 메서드를 이용해서, 어떤 메서드에 무슨 행위를 하는지 알 수 있으며, 또한 메시지 포맷 역시 JSON을 이용해서 직관적으로 이해할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 REST 기반 Open API가 API 문서를 제공하고는 있지만, 디자인 사상은 최소한의 문서의 도움만으로 API 자체를 이해할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;클라이언트-서버-구조client-server&#34;&gt;클라이언트 서버 구조(Client-Server)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST 서버는 API를 제공하고 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임 진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 각자의 역할이 확실하게 구분되면서 개발 관점에서 클라이언트와 서버에서 개발해야 할 내용이 명확해지고, 서로의 개발에서 의존성이 줄어들게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;계층형-구조layered-system&#34;&gt;계층형 구조(Layered System)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트로서는 REST API 서버만 호출한다. 그러나 서버는 다중 계층으로 이루어질 수 있다.&lt;/li&gt;
&lt;li&gt;순수 비즈니스 로직을 수행하는 &lt;code&gt;API&lt;/code&gt; 서버와 그 앞단에 사용자 인증(Authentication), 암호화(SSL), 로드 밸런싱을 하는 계층을 추가해서 구조상의 유연성을 둘 수 있다.&lt;/li&gt;
&lt;li&gt;이는 마이크로서비스의 API GATEWAY나 간단한 기능은 리버스 프록시를 이용해서 구현하는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-안티-패턴&#34;&gt;REST 안티 패턴&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;다음은 REST API를 디자인할 때 하지 말아야 할 것들이다.&lt;/p&gt;
&lt;h4 id=&#34;getpost를-이용한-터널링&#34;&gt;GET/POST를 이용한 터널링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 나쁜 디자인 중에 하나가 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 메서드의 실제 동작은 리소스를 업데이트 하는 내용인데, HTTP PUT을 사용하지 않고, GET에 쿼리 파라미터로 이 메서드가 수정 메서드임을 표시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대단히 안좋은 디자인인데, &lt;code&gt;HTTP&lt;/code&gt; 메서드 사상을 따르지 않았기 때문에 REST라고 부를 수 없고, 또한 웹 캐시 인프라도 사용할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 많이 사용하는 안좋은 예는 &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 생성 요청이 아닌데도 바디에 명령을 넘겨서 호출하는 방식인데 좋지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;getuser&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;terry&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;self-descriptiveness-속성을-사용하지-않음&#34;&gt;Self-descriptiveness 속성을 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 특성 중 하나는 자체 표현 구조로, REST URI와 메서드, 그리고 정의된 메시지 포맷에 의해서 쉽게 API를 이해할 수 있는 기능이 되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히나 자체 표현 구조를 갉아 먹는 가장 대표적인 사례가 앞서 언급한 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-응답-코드를-사용하지-않음&#34;&gt;HTTP 응답 코드를 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 많이 하는 실수가 HTTP 응답 코드를 충실하게 따르지 않고, 성공은 200, 실패는 500 같이 1 ~ 2개의 HTTP 응답 코드만 사용하는 경우이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심한 경우에는 에러도 &lt;code&gt;200&lt;/code&gt; 응답 코드와 함께 보내는 경우인데, 이는 &lt;code&gt;REST&lt;/code&gt; 디자인 사상에도 어긋남은 물론이고 자기 표현 구조에도 어긋난다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api-디자인-가이드&#34;&gt;REST API 디자인 가이드&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;단순하고-직관적으로-만들어라&#34;&gt;단순하고 직관적으로 만들어라&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;URI에 리소스명은 동사보다는 명사를 사용하라.&lt;/li&gt;
&lt;li&gt;REST API는 리소스에 대해서, 행동을 정의하는 형태를 사용한다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &lt;code&gt;/dogs&lt;/code&gt;는 리소스를 생성하라는 의미고, URL은 HTTP 메서드에 의해서 CRUD(생성, 수정, 수정, 삭제)의 대상이 되는 개체(명사)라야 한다.&lt;/li&gt;
&lt;li&gt;그리고 될 수 있으면 단수형 명사보다는 복수형 명사를 사용하는 것이 의미상 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;리소스-간의-관계를-표현하는-방법&#34;&gt;리소스 간의 관계를 표현하는 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;REST 리소스 간에는 연관 관계가 있을 수 있다.&lt;/li&gt;
&lt;li&gt;예를 들어서 사용자가 소유한 디바이스 목록이나, 사용자가 가진 강아지들이 예가 될 수 있다.&lt;/li&gt;
&lt;li&gt;사용자 - 디바이스 또는 사용자 - 강아지 등 각각의 리소스 간의 관계를 표현하는 방법에는 여러가지가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 서브 리소스로 표현하는 방법
/&amp;quot;리소스명&amp;quot;/&amp;quot;리소스 아이디&amp;quot;/&amp;quot;관계가 있는 다른 리소스명&amp;quot;
HTTP GET, /users/{userId}/devices
예) /users/1/devices
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;2. 서브 리소스에 관계를 명시하는 방법
HTTP GET, /users/{userid}/likes/devices
예) /uesrs/1/likes/devices
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러 처리의 기본은 &lt;code&gt;HTTP&lt;/code&gt; 응답 코드를 사용한 후 응답 바디(&lt;code&gt;Response Body&lt;/code&gt;)에 에러에 대한 자세한 내용을 서술하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 &lt;code&gt;API&lt;/code&gt; 서비스들이 어떤 응답 코드를 사용하는지를 살펴보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 : &lt;code&gt;200, 201, 304, 400, 401, 403, 404, 409, 410, 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;넷플릭스 : &lt;code&gt;200, 201, 304, 400, 403, 404, 412, 500&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 응답 코드를 사용하면 명시적이긴 하지만, 코드 체계 관리가 복잡해져서 다음과 같이 몇 가지 응답 코드만 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;200 - 성공
400 Bad Request - field validation 실패 시
401 Unauthorized - API 인증, 인가 실패
404 Not Found - 해당 리소스가 없음
500 Internal Server Error - 서버 에러
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러에는 에러 내용에 대한 구체적인 내용을 HTTP 바디에 정의해서 상세한 에러의 원인을 전달하는 것이 디버깅에 유리하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Twillo&lt;/code&gt;의 에러 메시지 형식은 다음과 같은데, 에러 코드 번호와 이 번호에 대한, &lt;code&gt;Error dictionary link&lt;/code&gt;를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자나 트러블 슈팅하는 사람에게 많은 정보를 제공해서 디버깅을 손쉽게 해주는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에러 발생시에 스택 정보를 포함시킬 수 있지만, 이는 대단히 위험한 일이다. 내부적인 코드 구조와 프레임워크 구조를 외부에 노출함으로써, 해커들에게 해킹을 할 수 있는 정보를 제공해주기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 구조에서는 이를 제공하지 않는 것이 일반적이지만 내부 개발중이거나 서비스 개발할 때는 매우 유용하다. 따라서 API 서비스를 개발할 때 프로덕션과 데브 환경을 분리해서 개발하면 디버깅에 매우 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;api-버전-관리&#34;&gt;API 버전 관리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 정의에서 중요한 것은 버전 관리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이미 배포된 API 경우에는 계속해서 서비스를 제공하면서 새로운 기능이 들어간 API를 배포할 때는 하위 호환성을 보장하면서 서비스를 제공해야하기 때문에, 같은 &lt;code&gt;API&lt;/code&gt;라도 버전에 따라서는 다른 기능을 제공하도록 하는 것이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 버전을 정의하는 방법에는 여러가지가 있는데, 다음과 같은 형태를 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{servicename}/{version}/{REST URL}
예) api.server.com/account/v2.0/groups
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이는 서비스의 배포 모델과 관계가 있는데, 자바 애플리케이션의 경우 &lt;code&gt;account.v1.0.war&lt;/code&gt;, &lt;code&gt;account.v2.0.war&lt;/code&gt;와 같이 다른 &lt;code&gt;war&lt;/code&gt;로 각각 배포하여 버전별로 배포 바이너리를 관리할 수 있고, 앞단에 서비스명을 별도로 &lt;code&gt;URL&lt;/code&gt;로 떼어 놓은 것은 서비스가 확장되었을 때, &lt;code&gt;account&lt;/code&gt; 서비스만 별도의 서버로 분리해서 배포하는 경우를 대비하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이징&#34;&gt;페이징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큰 사이즈의 리스트 형태의 응답을 처리하려면 페이징 처리와 부분 응답(Partial Response) 처리가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반환되는 리스트가 &lt;code&gt;100,000,000&lt;/code&gt; 개인데, 이를 하나의 HTTP 응답으로  처리하는 것은 서버 성능, 네트워크 비용도 문제지만, 무엇보다 비현실적이다. 그래서 페이징을 고려하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이징을 처리하려면 여러가지 디자인이 있다. 예를 들어서 100번째부터 125번째 레코드까지 받는 API를 정의하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이스북 API 스타일 : &lt;code&gt;/record?offset=100&amp;amp;limit=25&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;트위터 API 스타일 : &lt;code&gt;/record?page=5&amp;amp;rpp=25&lt;/code&gt; (RPP는 Record Per Page)로 페이지 당 레코드 수로 RPP=25이면 페이지 5는 100~125가 된다.&lt;/li&gt;
&lt;li&gt;링크드인 API 스타일 : &lt;code&gt;/record?start=50&amp;amp;count=25&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;부분-응답-처리&#34;&gt;부분 응답 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리소스에 대한 응답 메시지에 대해서 굳이 모든 필드를 포함할 필요는 없다.&lt;/li&gt;
&lt;li&gt;예를 들어서 페이스북 피드에는 사용자 ID, 이름, 글, 내용, 날짜, 좋아요, 카운트, 댓글, 사용자 사진 등 여러가지 정보를 갖는데, API를 요청하는 클라이언트의 용도에 따라서 선별적으로 몇 가지 필드만이 필요할 수 있다.&lt;/li&gt;
&lt;li&gt;필드를 제한하는 것은 전체 응답의 양을 줄여서 네트워크 대역폭 (특히 모바일에서) 절약할 수 있고, 응답 메시지를 간소화하여 파싱 등을 간략화 할 수 있다.&lt;/li&gt;
&lt;li&gt;이러한 부분 응답 기능을 제공하는 주요 서비스를 보면 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;링크드인 : /people:(id, first-name, last-name, industry)
페이스북 : /terry/friends?fields=id, name
구글 : ?fields=title, media:group(media:thumnail)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;검색-전역-검색과-지역-검색&#34;&gt;검색 (전역 검색과 지역 검색)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;검색은 &lt;code&gt;HTTP&lt;/code&gt; GET에서 쿼리 스트링 검색 조건을 정의하는 경우가 일반적인데, 이 경우 검색 조건이 다른 쿼리 스트링이랑 섞여 버릴 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;name=lee&lt;/code&gt; 이고 &lt;code&gt;region=seoul&lt;/code&gt;인 사용자를 검색하는 검색을 쿼리 스트링만 사용하게 되면 다음과 같이 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/users?name=lee&amp;amp;region=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;추가적으로 페이징 처리를 추가하면 다음과 같이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?name=cho&amp;amp;region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;페이징 처리에 의해서 정의된 offset과 limit 가 검색조건인지 페이징 조건인지 잘 분간이 가지 않으므로 따라서 쿼리 조건은 하나의 쿼리 스트링으로 정의하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/user?q=name=lee, region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이런식으로 구분자를 사용하면, 검색 조건은 다른 쿼리스트링과 분리된다.&lt;/li&gt;
&lt;li&gt;물론 이 검색 조건은 서버에 의해서 토큰 단위로 파싱 되어야 한다.&lt;/li&gt;
&lt;li&gt;다음으로는 검색 범위에 대해서 고민할 필요가 있는데, 전역 검색은 전체 리소스에 대한 검색을, 리소스에 대한 검색은 특정 리소스에 대한 검색을 정의한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어서 특정 리소스 안에 대한 검색은 다음과 같이 리소스명에 쿼리 조건을 붙이는 식으로 표현할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?q=id=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;전역 검색은 다음과 같은 식으로 정의할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/search?q=id=lee
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hateoas를-이용한-처리&#34;&gt;HATEOAS를 이용한 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;HATEOS는 &lt;code&gt;Hypermedia as the engine of application data&lt;/code&gt;의 약자로 하이퍼미디어의 특징을 이용하여, &lt;code&gt;HTTP&lt;/code&gt; 응답에 다음 액션이나 관계된 리소스에 대한 &lt;code&gt;HTTP&lt;/code&gt; 링크를 함께 반환하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  [
    {
      &amp;quot;id&amp;quot;: &amp;quot;user1&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: &amp;quot;user2&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;carry&amp;quot;
    }
  ],
  &amp;quot;links&amp;quot;: [
    {
      &amp;quot;rel&amp;quot;: &amp;quot;pre_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=6&amp;amp;limit=5&amp;quot;
    },
    {
      &amp;quot;rel&amp;quot;: &amp;quot;next_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=11&amp;amp;limit=5&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이징 처리의 경우 반환 시 페이지에 대한 링크를 제공하거나, 위와 같이 표현하거나 연관된 리소스에 대한 디테일한 링크를 표시하는 것에 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HATEOAS&lt;/code&gt;를 API에 적용하게 되면, 자체 표현 구조 특성이 증대되어 API에 대한 가독성이 증가하는 장점을 가지고 있는데 반해서, 응답 메시지가 다른 리소스 &lt;code&gt;URI&lt;/code&gt;에 대한 의존성을 가지기 때문에 구현이 다소 까다롭다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단일-api-엔드-포인트-활용&#34;&gt;단일 API 엔드 포인트 활용&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 서버가 물리적으로 분리된 여러 개의 서버에서 작동하고 있을 때, &lt;code&gt;user.apiserver.com&lt;/code&gt;, &lt;code&gt;car.apiserver.com&lt;/code&gt;과 같이 API 서버마다 URL이 분리되어 있으면 개발자가 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매번 다른 서버로 연결해야 하거나와 중간에 방화벽이라도 있으면 일일히 이를 해제해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 서비스는 물리적으로 서버가 분리되어 있더라도 단일 URL을 사용하는 것이 좋은데, 방법은 &lt;code&gt;HAProxy&lt;/code&gt;와 &lt;code&gt;Reverse Proxy&lt;/code&gt;를 사용하는 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/user/&lt;/code&gt;는 user.apiserver.com으로 라우팅하고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/car/&lt;/code&gt;는 car.apiserver.com으로 라우팅하도록 구현하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 할 경우 향후 뒷단에 API 서버 들이 확장되도라도 &lt;code&gt;API&lt;/code&gt;를 사용하는 클라이언트로서는 단일 엔드포인트를 보면 되고, 관리 관점에서도 단일 엔드 포인트를 통해서 부하 분산 및 로그를 통해서 감사(Audit)을 할 수 있기 때문에 편리하며, API에 대한 라우팅을 Reverse Proxy를 이용해서 함으로써 조금 더 유연한 운영이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP 및 네트워크 계층 및 RFC 791 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft.html</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft.html</guid>
      <description>&lt;h3 id=&#34;네트워크-통신&#34;&gt;네트워크 통신&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112009913-2ba59c00-8b6a-11eb-96f4-c8e28e12bb05.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 통신은 관점에 따라 &lt;code&gt;OSI 7&lt;/code&gt; 모델과 &lt;code&gt;TCP/IP&lt;/code&gt; 모델 두가지로 설명할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OSI 7&lt;/code&gt; 모델은 1984년에 &lt;code&gt;ISO&lt;/code&gt; (국제 표준화 기술)에 의해 표준화되었고, 통신이 이루어지는 과정을 단계별로, 파악할 수 있도록 7 개의 계층인 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구분되어 있으며 네트워크 구현을 연구하고 배우기에 적합한 구조다.&lt;/li&gt;
&lt;li&gt;반면에, &lt;code&gt;TCP/IP&lt;/code&gt; 모델은 현장에 많이 사용하는 기술 위주로 4계층으로 단순화한 모델로, 실제 사용하는 프로토콜 규약은 이 모델을 따르고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네트워크-계층&#34;&gt;네트워크 계층&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;네트워크 계층은 데이터를 전송할 수 있는 여러 경로 중 가장 안전하고 빠른 경로를 찾아주는 역할을 하는 라우팅을 수행하며, 데이터를 다른 네트워크로 전달하여 인터넷을 가능하게 만들어주는 계층이다.&lt;/p&gt;
&lt;h4 id=&#34;ip-프로토콜&#34;&gt;IP 프로토콜&lt;/h4&gt;
&lt;p&gt;네트워크 계층에서 운영되는 IP 프로토콜에는 목적지 위치를 알려주는 고유한 32비트의 주소 값이 있으며, 이를 IP 주소라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112010844-036a6d00-8b6b-11eb-984e-082bf51904f7.jpg&#34; alt=&#34;addressing-design-network-host-1024x576&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP 주소는 네트워크 부분과 호스트로 구분되는데, 위의 그림과 같이 지역을 대표하는 부분을 네트워크, 지역별 사용자 PC에 할당하는 것을 호스트라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;rfc-791&#34;&gt;RFC 791&lt;/h4&gt;
&lt;p&gt;더 자세히 알아보고 싶은 마음에 RFC 791 문서를 살펴보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112071041-5e738280-8bb2-11eb-80a8-472ff7e6aef9.png&#34; alt=&#34;Screen Shot 2021-03-23 at 8 32 38 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 문서는 개요 및 동기 그리고, 범위, 인터페이스에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 패킷을 교환을 통해 상호 연결된 시스템에서 사용하도록 설계 되었다.&lt;/li&gt;
&lt;li&gt;이러한 시스템을 &lt;code&gt;catenet&lt;/code&gt; 이라고 부른다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 데이터그램(&lt;code&gt;datagram&lt;/code&gt;)이라는 데이터 블록들을 소스에서부터 목적지까지 전송한다.&lt;/li&gt;
&lt;li&gt;여기서 말하는 소스 및 목적지는 고정된 길이의 주소로 식별되는 호스트다.&lt;/li&gt;
&lt;li&gt;또한 인터넷 프로토콜은 작은 패킷을 다루는 네트워크를 위해 긴 데이터그램을 조각화하여 나누거나 및 작게 나누어진 데이터그램을 재조립을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;범위&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 특별히 범위를 한정하여 다음과 같은 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;상호 연결된 네트워크 시스템을 통해서 소스에서 목적지까지 비트 패키지(데이터그램)을 전달하는데 필요한 기능이다.&lt;/li&gt;
&lt;li&gt;호스트 간의 프로토콜에서 일반적으로 볼 수 있는 엔드 투 엔드 데이터 신뢰성, 흐름 제어, 시퀀싱, 그리고 기타 서비스를 강화하는 메커니즘은 없다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 지원 네트워크의 서비스를 활용하여 다양한 서비스 유형과 품질을 제공할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;인터페이스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 프로토콜은 네트워크 환경에서 호스트 대 호스트 프로토콜에 의해서 호출된다.&lt;/li&gt;
&lt;li&gt;이 프로토콜은 인터넷 데이터그램을 다음 게이트웨이 또는 대상 호스트로 이동하기 위해 로컬 네트워크 프로토콜을 호출한다.&lt;/li&gt;
&lt;li&gt;예를 들어, TCP 모듈이 네트워크 모듈을 호출하여, TCP 세그먼트(TCP 헤더 및 사용자 정보를 포함)를 사용한다.&lt;/li&gt;
&lt;li&gt;TCP 세그먼트는 데이터 그램의 일부이다.&lt;/li&gt;
&lt;li&gt;TCP 모듈은 인터넷 헤더의 주소와 기타 매개변수를 인수로 네트워크 모듈에게 제공한다.&lt;/li&gt;
&lt;li&gt;그러면 네트워크 모듈은 데이터 그램을 만들고 데이터그램을 전송하기 위해서 로컬 네트워크 인터페이스를 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc791&#34;&gt;RFC 791&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>최근에 애플리케이션 보안에 관심을 가지게 된 이유</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0.html</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0.html</guid>
      <description>&lt;p&gt;최근에 내가 웹 애플리케이션 보안에 대해서 굉장히 무관심함을 알게 됨과 동시에 데이터베이트 연결이 끊어지는 네트워크 통신과 관련된 장애가 있었다.&lt;/p&gt;
&lt;p&gt;장애의 이유를 알지 못하니까 굉장히 답답함과 동시에 문제를 해결할 수 없었다. 따라서 디버깅을 하듯이 네트워크 패킷을 분석해서 원인을 알아 낼 수 있으면 굉장히 좋을 것 같다는 생각을 함과 동시에 내가 주도하면서 진행하는 토이 프로젝트가 보안에 대해서 굉장히 견고한 애플리케이션이 되었으면 하는 마음이 있다.
따라서, 앞으로 웹 애플리케이션 보안에 대해서 공부하고 견고한 시스템을 구축해나갈 생각이다.&lt;/p&gt;
&lt;p&gt;책에서는 다루는 대부분의 내용이 네트워크 공격을 패킷 단위로 분석하고 있다. 실제로도 공격 대응을 위한 분석 단계에서 패킷을 분석하는 빈도가 상당히 높다고 한다. 나는 보안 전문가보다는 웹 애플리케이션 개발자에 가깝기 때문에 실무적으로 패킷을 분석해서 보안 위협을 감지하는 일은 없을 확률이 높지만, 네트워크에 대해서 내부 원리까지 깊게 이해하는 것이 목표이므로, 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;p&gt;첫 장에서는 인터넷 통신의 표준 프로토콜인 &lt;code&gt;TCP/IP&lt;/code&gt;의 계층별 헤더의 구조에 대해서 패킷 단위로 소개하고 있고, 주로 네트워크 공격에 사용되는 네트워크 계층의 &lt;code&gt;IP&lt;/code&gt; 프로토콜과 전송 계층의 &lt;code&gt;TCP&lt;/code&gt;, &lt;code&gt;UDP&lt;/code&gt; 프로토콜의 구조에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;책에서는 한 번에 모든 개념을 숙지하기 보다는, 필요할 때, 찾아보며 각 헤더의 구조를 조금씩 명확히 새기는 것을 권장하고 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
