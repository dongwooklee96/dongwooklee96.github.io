<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
    <description>Recent content in 알고리즘 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 15 Sep 2021 23:02:39 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[알고리즘 문제 풀이] 미로 찾기</title>
      <link>https://dongwooklee96.github.io/post/2021/09/15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EB%AF%B8%EB%A1%9C-%EC%B0%BE%EA%B8%B0.html</link>
      <pubDate>Wed, 15 Sep 2021 23:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EB%AF%B8%EB%A1%9C-%EC%B0%BE%EA%B8%B0.html</guid>
      <description>&lt;h3 id=&#34;문제---미로-탈출&#34;&gt;문제 - 미로 탈출&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N x M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어서 이를 피해서 탈출해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동빈이의 위치는 (1, 1)이고 미로의 출구는 (N, M)의 위치에 존재하며 한 번에 한 칸씩 움직일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;괴물이 있는 부분은 0, 없는 부분은 1로 표시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;탈출하기 위해서 움직여야 하는 최소 개수를 구하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;N, M은 (4 &amp;lt;= N, M &amp;lt;= 200) 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; collections &lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; deque


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(n, m, graph):
    dx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
    dy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bfs&lt;/span&gt;(x, y):
        queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; deque()
        queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append((x, y))

        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; queue:
            x, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;popleft()

            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;):
                nx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dx[i]
                ny &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dy[i]

                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; ny &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; nx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; ny &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; m:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; graph[nx][ny] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; graph[nx][ny] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
                    graph[nx][ny] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; graph[x][y] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
                    queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append((nx, ny))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; graph[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][m &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bfs(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    n, m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())

    graph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        graph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(list(map(int, input())))

    print(solution(n, m, graph))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;배운점&#34;&gt;배운점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;내 힘으로 풀 수 있을 때까지 풀어봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘 문제 풀이] 음료수 얼려 먹기</title>
      <link>https://dongwooklee96.github.io/post/2021/09/10/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4-%EB%A8%B9%EA%B8%B0.html</link>
      <pubDate>Fri, 10 Sep 2021 16:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/10/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4-%EB%A8%B9%EA%B8%B0.html</guid>
      <description>&lt;h3 id=&#34;문제---음료수-얼려먹기&#34;&gt;문제 - 음료수 얼려먹기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N x M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 떄 생성되는 총 아이스크림의 개수를 구하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;입력 조건 :
&lt;ul&gt;
&lt;li&gt;첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 &amp;lt;= N, M &amp;lt;= 1,000)&lt;/li&gt;
&lt;li&gt;두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.&lt;/li&gt;
&lt;li&gt;이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;출력 : 한번에 만들 수 있는 아이스크림의 개수를 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모든 얼음 틀을 왼쪽 상단부터 반복문으로 검사한다. 만약 탐색하지 않은 공간이 있다면 그곳부터, DFS, BFS를 이용하여 탐색을 시작한다. 모두 탐색하고 나서 방문한 곳을 기록하고 아이스크림의 개수를 하나 증가시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더 이상 방문하지 않은 곳이 없으면 아이스크림의 개수를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; typing &lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; List


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(maps: List[List[int]], n: int, m: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(x, y):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; m:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; maps[x][y] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
            maps[x][y] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            dfs(x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y)
            dfs(x, y &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
            dfs(x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y)
            dfs(x, y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dfs(x, y):
                cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cnt


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    n, m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())

    maps &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        maps&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(list(map(int, input())))

    print(solution(maps, n, m))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;배운점&#34;&gt;배운점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;DFS 문제를 어떻게 풀어야할 지 대략적으로 감을 잡은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘] 탐색 알고리즘 DFS / BFS 개념</title>
      <link>https://dongwooklee96.github.io/post/2021/09/06/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-dfs-/-bfs-%EA%B0%9C%EB%85%90.html</link>
      <pubDate>Mon, 06 Sep 2021 17:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/06/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-dfs-/-bfs-%EA%B0%9C%EB%85%90.html</guid>
      <description>&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DFS&lt;/code&gt;는 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/sskwl4z7ouea8fn/download99.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그래프의 기본 구조를 살펴보자면 그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 또한 두 노드가 간선으로 연결되어 있다면 두 노드는 인접하다고 표현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩 테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해서 바르게 알고 있도록 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인접 행렬 : 2차원 배열의 그래프로 연결 관계를 표현하는 방식&lt;/li&gt;
&lt;li&gt;인접 리스트 : 리스트로 그래프의 연결관계를 표현하는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인접-행렬-방식&#34;&gt;인접 행렬 방식&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;graph = [
	[0, 7, 5],
	[7, 0, float(&#39;inf&#39;)],
	[5, float(&#39;inf&#39;), 0]
]

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;먼저 인접 행렬 방식은 2차우너 배열에 각 노드가 연결된 형태를 기록하는 방식이다.&lt;/li&gt;
&lt;li&gt;파이썬에서는 2차원 리스트로 이를 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;연결이 되어있지 않은 노드끼리는 무한의 비용이라고 작성하면 된다. 실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값으로 초기화하는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인접-리스트&#34;&gt;인접 리스트&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장 (노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장 (노드, 거리)
graph[2].append((0, 5))

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정볼르 차례대로 연결하여 저장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인접 리스트는 &amp;lsquo;연결 리스트&#39;라는 자료구조를 이용하여 구현하는데 파이썬은 기본 리스트로 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dfs-1&#34;&gt;DFS&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DFS는 탐색을 위해서 사용되는 알고리즘이다. 이 알고리즘은 특별한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문 한 후, 다시 돌아가서 다른 경로를 탐색하는 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구체적인 동작 과정은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.&lt;/li&gt;
&lt;li&gt;스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다.&lt;/li&gt;
&lt;li&gt;3번과 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;깊이 우선 탐색 알고리즘인 DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다. 실제로는 스택을 사용하지 않아도 되며 탐색을 수행함에 있어서 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀 함수를 이용하였을 때 매우 간결하게 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def dfs(graph, v, visited):
    # 현재 노드를 방문 처리 한다.
    visited[v] = True
    print(v, end=&#39; &#39;)
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문한다.
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)


# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

dfs(graph, 1, visited)

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;인접 리스트로 이를 구현하게 되면 다음과 같은 순서로 방문하게 된다. &lt;code&gt;1 2 7 6 8 3 4 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bfs&#34;&gt;BFS&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BFS 알고리즘은 &amp;lsquo;너비 우선 탐색&amp;rsquo; 이라는 의미를 가진다. 쉽게 말해서 가까운 노드부터 탐색하는 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DFS&lt;/code&gt;는 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다고 했는데, BFS는 그 반대이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BFS 구현에서는 선입 선출 방식인 큐 자료구조를 이용하는 것이 정석이다. 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘의 정확한 동작은 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;탐색 시작 노드를 큐에 넣고 방문 처리를 한다.&lt;/li&gt;
&lt;li&gt;큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.&lt;/li&gt;
&lt;li&gt;3, 2번의 과정을 더 이상 수행할 수 없을 떄까지 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;너비 우선 탐색 알고리즘은 BFS는 큐 자료구조에 기초한다는 점에서 구현이 간단하다.&lt;/li&gt;
&lt;li&gt;실제로 구현함에 있어 앞서 언급한 대로 &lt;code&gt;deque&lt;/code&gt; 라이브러리를 사용하는 것이 좋으며 수행함에 있어 O(N)의 시간이 소요된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;from collections import deque
from typing import List


def bfs(graph: List[List[int]], start: int, visited: bool) -&amp;gt; None:
    # 큐 구현을 위해서 deque 라이브러리를 사용했다.
    queue = deque([start])
    # 현재 노드를 방문 처리한다.
    visited[start] = True
    # 큐가 완전히 빌때까지 반복한다.
    while queue:
        v = queue.popleft()
        print(v, end=&#39; &#39;)
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입한다.
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

bfs(graph, 1, visited)

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘 문제 풀이] 왕실의 나이트</title>
      <link>https://dongwooklee96.github.io/post/2021/09/01/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%99%95%EC%8B%A4%EC%9D%98-%EB%82%98%EC%9D%B4%ED%8A%B8.html</link>
      <pubDate>Wed, 01 Sep 2021 09:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/01/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%99%95%EC%8B%A4%EC%9D%98-%EB%82%98%EC%9D%B4%ED%8A%B8.html</guid>
      <description>&lt;h3 id=&#34;문제---왕실의-나이트&#34;&gt;문제 - 왕실의 나이트&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;8 X 8 좌표 평면이 있다. 왕실 정원의 특정한 한 칸에 나이트가 서 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기.&lt;/li&gt;
&lt;li&gt;수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;8 X 8 좌표 평면상에 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;왕실의 정원에서 행을 표시할 때는 1 ~ 8로 표시하고, 열 위치를 표현할 때는 a ~ h로 표현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이동할 수 있는 좌표를 X, Y로 나누어서 리스트에 담는다. 총 8개가 나온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각 좌표를 순회하면서 범위에 넘지 않으면 개수를 더한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개수를 출력한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;solution(x: int, y: int) -&amp;gt; int:
    count = 0
    xx = [-2, -1, 1, 2, 2, 1, -1, -2]
    yy = [1, 2, 2, 1, -1, -2, -2, -1]

    for i in range(len(xx)):
        if 1 &amp;lt;= (x + xx[i]) &amp;lt;= 8 and 1 &amp;lt;= y + yy[i] &amp;lt;= 8:
            count += 1
    return count


def solution2():
    input_data = input()
    x = int(input_data[1])
    y = int(ord(input_data[0])) - int(ord(&#39;a&#39;)) + 1

    steps = [
        (-2, -1), (-1, -2), (1, -2), (2, -1),
        (2, 1), (1, 2), (-1, 2), (-2, 1)
    ]
    result = 0
    for step in steps:
        next_row = x + step[0]
        next_col = y + step[1]

        if 1 &amp;lt;= next_row &amp;lt;= 8 and 1 &amp;lt;= next_col &amp;lt;= 8:
            result += 1
    print(result)


if __name__ == &#39;__main__&#39;:
    split = list(input())
    hash_table = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6, &#39;g&#39;: 7, &#39;h&#39;: 8}

    print(solution(hash_table[split[0]], int(split[1]))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;개선할-점&#34;&gt;개선할 점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;튜플로 좌표를 해결하니 조금 더 가독성이 좋아지는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;붙어 있는 문자열을 각각 분리하는 방법이 여러 가지가 있는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘 문제 풀이] 시각</title>
      <link>https://dongwooklee96.github.io/post/2021/09/01/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%8B%9C%EA%B0%81.html</link>
      <pubDate>Wed, 01 Sep 2021 08:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/01/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%8B%9C%EA%B0%81.html</guid>
      <description>&lt;h3 id=&#34;문제---시각&#34;&gt;문제 - 시각&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하라&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;첫째 줄에 정수 N이 입력된다. (0 &amp;lt;= N &amp;lt;= 23)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;반복문&#34;&gt;반복문&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;반복문을 돌면서 3이 포함되는 경우 개수를 센다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(n: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; h &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; [h &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, h &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, m &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, m &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, s &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, s &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]:
                    ret &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(n: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; h &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; str(h) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; str(m) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; str(s):
                    count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; count

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(input())
    print(solution(n))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;개선할-점&#34;&gt;개선할 점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;처음에 3이 나오는 경우인줄 알고, 코드를 다르게 작성하였는데 문제를 꼼꼼히 읽어봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문자열도 &lt;code&gt;in&lt;/code&gt; 연산이 되는지 몰랐었는데 다음부터는 리스트로 변환하지말고 바로 문자열에 &lt;code&gt;in&lt;/code&gt; 연산을 사용해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘 문제 풀이] 상하좌우</title>
      <link>https://dongwooklee96.github.io/post/2021/08/31/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0.html</link>
      <pubDate>Tue, 31 Aug 2021 08:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/31/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0.html</guid>
      <description>&lt;h3 id=&#34;문제---상하좌우&#34;&gt;문제 - 상하좌우&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여행가 A는 N X N 크기의 정사각형 공간위에 서 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 공간은 1 X 1 크기의 정사각형으로 나누어져있다. 가장 왼쪽 좌표는 (1, 1)이며, 가장 오른쪽 좌표는 (N, N)에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며 시작 좌표는 항상 (1, 1)이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀있고 각 문자의 의미는 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;L: 왼쪽으로 한 칸 이동&lt;/li&gt;
&lt;li&gt;R: 오른쪽으로 한 칸 이동&lt;/li&gt;
&lt;li&gt;U: 위로 한 칸 이동&lt;/li&gt;
&lt;li&gt;D: 아래로 한 칸 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이때 여행가 A가 N X N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;입력&#34;&gt;입력&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;첫 째 줄에 공간을 나타내는 N이 주어진다. (1 ~ 100)&lt;/li&gt;
&lt;li&gt;둘 째 줄에 여행가 A가 이동할 계획서가 주어진다. (1 ~ 100)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;출력&#34;&gt;출력&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백으로 구분하여 출력한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정사각형 공간을 벗어나는 움직임은 무시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;계획서를 읽고 현재 좌표에 더해본다. (L, R, U, D)&lt;/li&gt;
&lt;li&gt;정사각형 공간을 벗어났는지 판단한다.
&lt;ul&gt;
&lt;li&gt;IF (1 &amp;lt;= X &amp;lt;= N, 1 &amp;lt;= Y &amp;lt;= N)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이상이 없다면 좌표를 갱신하고 다음 계획서를 끝날때까지 읽는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;from typing import List
from typing import Tuple


def solution(n: int, maps: List[str]) -&amp;gt; Tuple[int, int]:
    current_x = 1
    current_y = 1

    for map in maps:
        if map == &#39;L&#39;:
            if 1 &amp;lt;= current_x - 1 &amp;lt;= n:
                current_x -= 1
        elif map == &#39;R&#39;:
            if 1 &amp;lt;= current_x + 1 &amp;lt;= n:
                current_x += 1
        elif map == &#39;U&#39;:
            if 1 &amp;lt;= current_y - 1 &amp;lt;= n:
                current_y -= 1
        elif map == &#39;D&#39;:
            if 1 &amp;lt;= current_y + 1 &amp;lt;= n:
                current_y += 1

    return current_y, current_x


def solution2(n: int, plans: List[str]) -&amp;gt; Tuple[int, int]:
    x, y = 1, 1
    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]
    move_types = [&#39;L&#39;, &#39;R&#39;, &#39;U&#39;, &#39;D&#39;]

    for plan in plans:
        for i in range(len(move_types)):
            if plan == move_types[i]:
                nx = x + dx[i]
                ny = y + dy[i]
            if nx &amp;lt; 1 or ny &amp;lt; 1 or nx &amp;gt; n or ny &amp;gt; n:
                continue
            x, y = nx, ny
    return x, y


if __name__ == &#39;__main__&#39;:
    n = int(input())
    maps = list(input().split())
    print(solution(n, maps))

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;개선할-점&#34;&gt;개선할 점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좌표 문제를 풀 때 배열에 미리 상, 하, 좌, 우 값을 입력해두는 것이 좀 더 깔끔한것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;맵을 읽을 때 리스트에 가능한 수를 넣어두고 반복문으로 일치하는지 확인하는 패턴도 유용하게 사용할 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>알고리즘 문제 - 1이 될때까지</title>
      <link>https://dongwooklee96.github.io/post/2021/08/27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-1%EC%9D%B4-%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80.html</link>
      <pubDate>Fri, 27 Aug 2021 17:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-1%EC%9D%B4-%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80.html</guid>
      <description>&lt;h3 id=&#34;문제---1이-될때까지&#34;&gt;문제 - 1이 될때까지&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;어떠한 수 N이 1이 될떄가지 다음의 두 과정 중에 하나를 반복적으로 선택하여 수행하려고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;N에서 1을 뺀다.&lt;/li&gt;
&lt;li&gt;N을 K로 나눈다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;두 번째 연산은 N이 K로 나누어질때만 선택할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 N이 17, K가 4라면 1번의 과정을 1번하면 16이 되고 이후 2번의 과정을 2번하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N과 K가 주어질 때, N이 1이 될떄까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;그리디&#34;&gt;그리디&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;K로 나눌 수 있는지 보고, 나눌 수 없으면 1을 뺀다.&lt;/li&gt;
&lt;li&gt;N이 1이 될때까지 위의 과정을 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;재귀&#34;&gt;재귀&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;K로 나눈 경우와, 1을 뺀 경우를 선택한다.&lt;/li&gt;
&lt;li&gt;그리고 결과적으로 더 작은 값을 선택한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;def solution(n: int, k: int) -&amp;gt; int:
    &amp;quot;&amp;quot;&amp;quot;
    :param n: 특정한 수
    :param k: 나눌 수
    :return: 수행한 최소 횟수
    &amp;quot;&amp;quot;&amp;quot;
    tot = 0
    while not n == 1:
        if n % k == 0:
            n //= k
        else:
            n -= 1
        tot += 1
    return tot


def solution2(n: int, k: int) -&amp;gt; int:
    result = 0

    while n &amp;gt;= k:
        while n % k != 0:
            n -= 1
            result += 1
        n //= k
        result += 1

    while n &amp;gt; 1:
        n -= 1
        result += 1
    return result


if __name__ == &amp;quot;__main__&amp;quot;:
    n, k = map(int, input().split())
    print(solution(n, k))

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;더-나은-방법&#34;&gt;더 나은 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조금 더 효율적으로 풀 수 있는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력이 적을 때는 일일이 하나씩 빼도 문제가 없지만, 큰 숫자를 빼야하는 경우에는 N이 K의 배수가 되도록 효율적으로 한번에 빼는 것 이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>알고리즘 문제 - 1이 될때까지</title>
      <link>https://dongwooklee96.github.io/post/2021/08/27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-1%EC%9D%B4-%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80.html</link>
      <pubDate>Fri, 27 Aug 2021 17:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-1%EC%9D%B4-%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80.html</guid>
      <description>&lt;h3 id=&#34;문제---1이-될때까지&#34;&gt;문제 - 1이 될때까지&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;어떠한 수 N이 1이 될떄가지 다음의 두 과정 중에 하나를 반복적으로 선택하여 수행하려고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;N에서 1을 뺀다.&lt;/li&gt;
&lt;li&gt;N을 K로 나눈다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;두 번째 연산은 N이 K로 나누어질때만 선택할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 N이 17, K가 4라면 1번의 과정을 1번하면 16이 되고 이후 2번의 과정을 2번하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N과 K가 주어질 때, N이 1이 될떄까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;그리디&#34;&gt;그리디&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;K로 나눌 수 있는지 보고, 나눌 수 없으면 1을 뺀다.&lt;/li&gt;
&lt;li&gt;N이 1이 될때까지 위의 과정을 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;재귀&#34;&gt;재귀&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;K로 나눈 경우와, 1을 뺀 경우를 선택한다.&lt;/li&gt;
&lt;li&gt;그리고 결과적으로 더 작은 값을 선택한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;def solution(n: int, k: int) -&amp;gt; int:
    &amp;quot;&amp;quot;&amp;quot;
    :param n: 특정한 수
    :param k: 나눌 수
    :return: 수행한 최소 횟수
    &amp;quot;&amp;quot;&amp;quot;
    tot = 0
    while not n == 1:
        if n % k == 0:
            n //= k
        else:
            n -= 1
        tot += 1
    return tot


def solution2(n: int, k: int) -&amp;gt; int:
    result = 0

    while n &amp;gt;= k:
        while n % k != 0:
            n -= 1
            result += 1
        n //= k
        result += 1

    while n &amp;gt; 1:
        n -= 1
        result += 1
    return result

def solution3(n: int, k: int) -&amp;gt; int:
    cnt = 0

    while not n &amp;lt;= 1:
        if n % k == 0:
            n //= k
            cnt += 1
        else:
            target = (n // k) * k
            cnt += n - target
            n = target

    return cnt


if __name__ == &amp;quot;__main__&amp;quot;:
    n, k = map(int, input().split())
    print(solution(n, k))

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;더-나은-방법&#34;&gt;더 나은 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조금 더 효율적으로 풀 수 있는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력이 적을 때는 일일이 하나씩 빼도 문제가 없지만, 큰 숫자를 빼야하는 경우에는 N이 K의 배수가 되도록 효율적으로 한번에 빼는 것 이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞으로 하나씩 빼는 패턴이 보이면 한번에 뺄 수 없는지 고민을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>숫자카드 게임</title>
      <link>https://dongwooklee96.github.io/post/2021/08/27/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C-%EA%B2%8C%EC%9E%84.html</link>
      <pubDate>Fri, 27 Aug 2021 10:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/27/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C-%EA%B2%8C%EC%9E%84.html</guid>
      <description>&lt;h3 id=&#34;문제---숫자카드-게임&#34;&gt;문제 - 숫자카드 게임&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한장을 뽑은 게임이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단 게임의 룰이 있는데 그 룰은 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;숫자가 쓰인 카드들이 N x M 형태로 놓여있다. 이때 N은 행의 수를 의미하며, M은 열의 개수를 의미한다.&lt;/li&gt;
&lt;li&gt;먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.&lt;/li&gt;
&lt;li&gt;그 다음에 선택된 행에 포함된 카드 들 중에 가장 숫자가 낮은 카드를 뽑아야 한다.&lt;/li&gt;
&lt;li&gt;따라서 처음에 카드를 골라낼 행을 선택할 때 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;각 행에서 가장 작은 숫자의 카드를 뽑을 수 있다.&lt;/li&gt;
&lt;li&gt;최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.&lt;/li&gt;
&lt;li&gt;입력 조건 : 1 &amp;lt;= N,M &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;둘째 줄부터 N&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;구현-문제&#34;&gt;구현 문제&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;각 행을 반복하면서 열에 있는 숫자중에 가장 작은 숫자를 뽑는다.&lt;/li&gt;
&lt;li&gt;모든 행을 순회하면서 뽑은 숫자중에서 가장 큰 숫자를 뽑는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; typing &lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; List


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;, matrix: List[List[int]]):
    min_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; matrix:
        min_list&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(min(m))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(min_list)


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution2&lt;/span&gt;():
    n, m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()))

        min_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(data)
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, min_value)
    print(result)


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution3&lt;/span&gt;():
    n, m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()))
        min_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-inf&amp;#39;&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
            min_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(min_value, d)

        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, min_value)


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    n, m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())
    matrix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        matrix&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(list(map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())))

    print(solution(matrix&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;matrix))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>큰 수의 법칙</title>
      <link>https://dongwooklee96.github.io/post/2021/08/26/%ED%81%B0-%EC%88%98%EC%9D%98-%EB%B2%95%EC%B9%99.html</link>
      <pubDate>Thu, 26 Aug 2021 20:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/26/%ED%81%B0-%EC%88%98%EC%9D%98-%EB%B2%95%EC%B9%99.html</guid>
      <description>&lt;h3 id=&#34;문제---큰-수의-법칙&#34;&gt;문제 - 큰 수의 법칙&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과해서 더해질 수가 없는 것 이 특징이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 순서대로 2, 4, 5, 4, 6 으로 이루어진 배열이 있을 때 M이 8이고 K가 3이라고 가정하자. 이 경우에 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;특정 수가 K 번을 초과해서 더해질 수 없다.&lt;/li&gt;
&lt;li&gt;첫째 줄에 N(2 &amp;lt;= N &amp;lt; 1000), M (1 &amp;lt;= M &amp;lt;= 10,000), K (1 &amp;lt;= K &amp;lt;= 10000)의 자연수가 주어진다.&lt;/li&gt;
&lt;li&gt;둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 각각의 자연수는 1 이상 ~ 10,000 이하의 수로 주어진다.&lt;/li&gt;
&lt;li&gt;입력으로 주어지는 K는 항상 M보다 작거나 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;반복문&#34;&gt;반복문&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;정렬을 하여 가장 큰 수와 그 다음으로 큰 수를 순서대로 구한다.&lt;/li&gt;
&lt;li&gt;크게 M번 만큼 순회를 한다.&lt;/li&gt;
&lt;li&gt;K번 만큼 개수를 세어서 만약 K번 만큼 수행하였을 때 그 다음 큰수로 변경하여 한번 더하는 것을 M번이 끝날 때까지 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도 : O(N)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;나누기&#34;&gt;나누기&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;정렬을 하여 가장 큰 수와 그 다음으로 큰 수를 구한다.&lt;/li&gt;
&lt;li&gt;크게 M 번만큼 반복을 한다.&lt;/li&gt;
&lt;li&gt;증가하는 요소를 K로 나눈 나머지가 0으로 나누어 떨어지면 그 다움으로 큰 수로 더한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;반복되는-수열-파악&#34;&gt;반복되는 수열 파악&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해진다.&lt;/li&gt;
&lt;li&gt;M을 (K + 1)로 나눈 몫 만큼 반복이 되어지며 K를 곱하면 나누어 떨어질 때 가장 큰수를 곱하는 경우이다., 여기에 일정하게 나누어 떨어지지 않는 경우도 있으므로  M을 (K + 1)로 나눈 나머지를 더해주면 된다.&lt;/li&gt;
&lt;li&gt;총 수행할 개수 M에서 가장 큰 수를 더하는 횟수를 빼면 두번째로 큰 숫자를 더하는 숫자가 나온다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; typing &lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; List


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(n: int, m: int, k: int, lists: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    lists&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
    first, second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    tot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
        cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cnt &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; k:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
            cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tot


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution1&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
    first, second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], arrays[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    tot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tot


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution2&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
    first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(k):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
            result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
            m &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
        m &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution3&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
    first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(m &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; k
    count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (count) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; first
    result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (m &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; count) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; second


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    n, m, k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())
    lists &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()))
    print(solution1(n, m, k, lists))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동전 거스름돈 문제</title>
      <link>https://dongwooklee96.github.io/post/2021/08/25/%EB%8F%99%EC%A0%84-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C.html</link>
      <pubDate>Wed, 25 Aug 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/25/%EB%8F%99%EC%A0%84-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C.html</guid>
      <description>&lt;h3 id=&#34;문제---거스름돈&#34;&gt;문제 - 거스름돈&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;거스름돈으로 사용할 돈이 500, 100, 50, 10 원짜리 동전이 무수히 많이 존재한다고 가정을 했을 때
거슬러 주어야할 최소한의 개수를 구하라. 단, 거슬러 주어야 할 돈은 항상 10의 배수이다.&lt;/p&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;거슬러 주어야할 돈은 항상 10의 배수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;그리디&#34;&gt;(그리디)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 동전부터 비교를 해서 만약 동전의 크기보다 크다면 작을 때까지 뺀 후 횟수를 더한다.&lt;/li&gt;
&lt;li&gt;그 다음 크기의 동전을 비교한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;그리디---개선된-버전&#34;&gt;(그리디 - 개선된 버전)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 동전으로 거스름돈을 나누고 몫만큼을 곱한 값을 뺀다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;몫만큼을 횟수로 포함시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(exchange: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
  cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  coins &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; coin:
      exchange &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; coin
      cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cnt

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution2&lt;/span&gt;(exchange: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
  cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  coins &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
      cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; coin
      exchange &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; coin
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cnt

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
  n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(input())
  print(solution2(n)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>정렬 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/08/23/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
      <pubDate>Mon, 23 Aug 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/23/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
      <description>&lt;h3 id=&#34;정렬-알고리즘&#34;&gt;정렬 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정렬은 알고리즘 학습에 있어서 가장 기본적으로 알아두어야 하는 개념중에 하나이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정렬을 하면서 다양한 문제를 쉽게 해결할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;찾기 : 정렬된 리스트는 특정 아이템을 쉽게 찾을 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;선택: 찾기와 마찬가지로 정렬된 리스트에서 다양한 아이템에 접근하여 얻어올 수 있다. 예를 들어서 리스트에서 3번째 큰 수를 가져온다던가 중간값을 찾거나 하는 일들이 쉽게 처리 될 수 있다.&lt;/li&gt;
&lt;li&gt;중복 검출 : 정렬되어 있다면 중복 아이템 찾기도 쉽게 처리할 수 있다.&lt;/li&gt;
&lt;li&gt;분포 : 리스트에서 가장 많이 있거나 적게 있는 아이템들을 쉽게 골라낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;거품-정렬-bubble-sort&#34;&gt;거품 정렬 (Bubble Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬은 정렬 중에서 가장 직관적인 정렬 방식이다. 거품 정렬은 알고리즘 동작이 각 순회의 가장 큰 요소가 맨 뒤로 이동하는 방식이기 때문에 지어진 이름이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 배열에 요소가 다음과 같이 있다고 가정을 하자. [8, 2, 6, 4, 5] 그렇다면 가장 처음에 있는 요소를 뒤의 요소와 비교하여 뒤의 요소보다 크다면 서로 값을 바꾼다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;교환된 요소는 뒤의 숫자보다 크므로 계속 비교되어 끝까지 이동하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한 번의 순회가 끝나면 다음 순회를 이어서 진행한다. 거품 정렬에서 1번의 순회는 가장 큰 수를 맨 뒤로 보내기 때문에 마지막 요소와 비교할 필요가 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        done_sort = True

        for j in range(n - i - 1):
            if arr[j] &amp;gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

                done_sort = False
        if done_sort:
            break
    return arr


if __name__ == &amp;quot;__main__&amp;quot;:
    input_arr = [8, 2, 6, 4, 5]
    print(f&#39;{bubble_sort(input_arr)}&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시간 복잡도는 최악의 경우와 평균적인 경우 &lt;code&gt;O(N^2)&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;done_sort&lt;/code&gt; 플래그로 인해서 이미 정렬된 배열을 정렬하는 경우 한 번의 순회만 진행하므로 &lt;code&gt;O(N)&lt;/code&gt;이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 비슷하게 삽입 정렬도 직관적인 구현으로 이해하기 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과는 다르게 리스트 내 하나의 요소를 선택하여 다른 요소와 비교하여 알맞은 위치에 삽입하는 정렬이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def insertion_sort(arr):
    n = len(arr)

    for i in range(1, n):
        key_item = arr[i]

        j = i - 1

        while j &amp;gt;= 0 and arr[j] &amp;gt; key_item:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key_item
    return arr

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 삽입 정렬의 시간 복잡도는 동일하기 때문에 같은 성능으 가진 알고리즘으로 판단할 수 있는데 실제 데이터를 입력해보고 확인하면 평균적으로 삽입 정렬이 거품 정렬보다 비교 횟수가 적다는 것을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;삽입 정렬의 시간 복잡도가 높아 거품 정렬과 함께 실제로는 사용되지 않을 것이라고 생각할 수 있는데, 하지만 삽입 정렬은 적은 데이터 개수를 가지는 데이터 셋에서 다른 정렬보다 평균적으로 좋은 성능을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 파이썬, 자바, 최신 C++에 사용되는 내장 정렬 함수는 작은 데이터 셋에 대해서 삽입 정렬을 사용하도록 구혆되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서 사용하는 내장 함수 &lt;code&gt;sorted()&lt;/code&gt;는 팀 정렬이라는 정렬 기법으로 병합 정렬과 삽입 정렬을 선택적으로 사용하도록 구현되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/cmybgze3qmszxl5/download13.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 삽입 정렬보다 높은 효율을 보이는 정렬 알고리즘이다. 병합 정렬은 분할 정복 접근을 기반으로 복잡한 문제를 해결 할 때 사용하는 강력한 알고리즘 기술이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분할 정복을 이해하기 위해서는 재귀를 이해하는 것이 필요하다. 재귀는 분할 정복이 필요한 문제를 해결 가능한 하위 문제로 쪼갤 수 있는 방법을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분할 정복은 기본적으로 문제를 작게 만들어 해결하고, 해결된 결과를 다음 하위 문제로 전달 후에 전체 문제를 해결하려고 시도하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def merge_sort(arr):
    def merge(left, right):
        left_len = len(left)
        right_len = len(right)

        result = []

        left_index = right_index = 0

        while len(result) &amp;lt; left_len + right_len:
            if left[left_index] &amp;lt;= right[right_index]:
                result.append(left[left_index])
                left_index += 1
            else:
                result.append(right[right_index])
                right_index += 1
            if right_index == right_len:
                result.extend(left[left_index:])
                break
            if left_index == left_len:
                result.extend(right[right_index:])
                break
        return result

    n = len(arr)
    if n &amp;lt; 2:
        return arr
    mid_index = n // 2
    left = merge_sort(arr[:mid_index])
    right = merge_sort(arr[mid_index:])
    return merge(left, right)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;병합 정렬은 O(nlogn)의 시간 복잡도를 안정적으로 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;퀵-정렬quick-sort&#34;&gt;퀵 정렬(Quick Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;병합 정렬과 비슷하게 분할 정복 방법을 이용한 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 점은 입력 리스트를 두 리스트로 나눌 때 한쪽은 특정 값보다 작은 값만 모으고 다른 하나는 특정 값보다 큰 값만 모은다. 이를 재귀적으로 완전히 정렬이 될 때까지 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 값을 퀵 정렬에서 피벗이라고 부르는데 피벗을 결정하는 방식에 따라서 성능 차이가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력 리스트를 나누는 것을 파티셔닝이라고 부른다. 분할할 때마다 피벗을 선택하여 두 부류 (작은 값 - LOW, 큰 값 - HIGH)로 나누는 작업을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 파티셔닝마다 피벗 값을 결정해야하는데 많은 고민이 필요하다. 만약 피벗 값이 리스트 마지막 요소로 선택되어있는 경우, 이미 정렬된 리스트라면 계속 작은 값에 남은 요소가 다 들어가게 되므로 시간 복잡도가 O(N^2)이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이것을 방지하기 위해서 무작위로 피벗을 결정하여 최악의 경우를 최소화하는 방향이나 중간 값을 찾아서 LOW / HIGH 분배를 하면 안정적으로 O(nlogn)의 시간 복잡도를 가질 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def quicksort(arr):
    arr_len = len(arr)
    if arr_len &amp;lt; 2:
        return arr

    low, same, high = [], [], []

    pivot = arr[randint(0, arr_len - 1)]

    for item in arr:
        if item &amp;lt; pivot:
            low.append(item)
        elif item == pivot:
            same.append(item)
        elif item &amp;gt; pivot:
            high.append(item)
    return quicksort(low) + same + quicksort(high)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;극단적으로 임의 값이 매번 가장 작은 값이거나 가장 큰 값이라면, N번 분리되고 N번 합치는 과정이 필요하여 최악의 경우에는 O(N^2)이 되지만 평균적으로는 O(nlogn)이 되는 정렬 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 최악의 상황으로는 정렬 성능이 나오지 않기 때문에 피벗을 선택할 때 무조건 중앙 값으로 선택할 수 있다면 LOW, HIGH가 정확히 반으로 나누어지기 때문에 O(nlogn)을 유지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;팀-정렬tim-sort&#34;&gt;팀 정렬(Tim Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬은 기존의 알고리즘의 특징을 잘 파악하고 최적으로 조합하여 탄생한 알고리즘이라고 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬은 삽입 정렬과 병합 정렬을 섞어서 사용한다. 다만 삽입 정렬의 비교 연산을 줄이기 위해서 선택된 요소의 알맞은 위치 탐색을 선형 탐색이 아닌 이진 탐색으로 하고 이 위치에 요소 삽입을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;당연한 이야기지만 선형 탐색은 O(N)이고 이진 탐색의 요소는 O(logN)이기 때문에 더 성능이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이제 살펴봐야하는 팀 정렬의 키워드는 런이다. 데이터 셋이 적다면 (32개 혹은 64개 이하) 이진 삽입 정렬만으로 정렬해도 충분히 빨리 하겠지만, 그보다 큰 개수의 데이터라면 팀 정렬은 런 단위로 나누어서 이진 삽입 정렬을 진행하고 모두 완료되면 병합 정렬한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;막연하게 특정 개수로 런을 나누는 것이 아니라 규칙이 있다. 앞의 삽입 정렬은 이미 정렬되었거나 거의 정렬된 상태에서 빠르게 완료되는 정렬이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬의 최소 런 값은 보통 64나 32로 설정하여 구성한다. 배열의 요소를 확인하면서 오름차순이나 내림차순으로 정렬된 구간을 최소 런 값에 맞춰서 구성할 수 있다. 예를 들어서 특정 구간의 요소의 오름차순으로 정렬된 개수가 24개라고 하자. 그리고 최소 런(min run)의 개수는 64개로 설정되어 있다면, 그 뒤에 따르는 40개의 요소를 하나로 묶어 런을 구성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이진 삽입 정렬은 어느정도 정렬이 되어 있는 배열을 정렬할 때 좋은 성능을 발휘하므로 최소 런의 개수를 64개 혹은 32개로 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래는 팀정렬을 간소하게 구현해본 예제이다. 실제 사용되고 있는 팀 정렬 알고리즘을 살펴보면 설명한 내용 이외에도 성능을 높이기 위한 내용이 추가적으로 더 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def binary_search(arr, key, start, end):
    if end - start &amp;lt;= 1:
        if arr[start] &amp;gt; key:
            return start - 1
    else:
        return start

    mid = (start + end) // 2

    if arr[mid] &amp;lt; key:
        return binary_search(arr, key, mid, end)
    elif arr[mid] &amp;gt; key:
        return binary_search(arr, key, start, mid)
    else:
        return mid


def insertion_sort(arr, run_s=0, run_e=None):
    if run_e is None:
        run_e = len(arr) - 1

    for i in range(run_s + 1, run_e + 1):
        v = arr[i]
        pos = binary_search(arr, v, run_s, i) + 1

        for k in range(i, pos, -1):
            arr[k] = arr[k - 1]
        arr[pos] = v


def timsort(arr):

    def merge(left, right):
        left_len = len(left)
        right_len = len(right)

        result = []

        left_index = right_index = 0

        while len(result) &amp;lt; left_len + right_len:
            if left[left_index] &amp;lt;= right[right_index]:
                result.append(left[left_index])
                left_index += 1
            else:
                result.append(right[right_index])
                right_index += 1
            if right_index == right_len:
                result.extend(left[left_index:])
                break
            if left_index == left_len:
                result.extend(right[right_index:])
                break
        return result

    min_run = 32

    n = len(arr)

    for i in range(0, n, min_run):
        insertion_sort(arr, i, min((i + min_run - 1), n - 1))

    size = min_run
    while size &amp;lt; n:
        for start in range(0, n, size * 2):
            mid = start + size - 1
            end = min((start + size * 2 - 1), (n - 1))

            merged = merge(arr[start:mid + 1], arr[mid + 1:end + 1])
            arr[start:start + len(merged)] = merged
        size *= 2
    return arr

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최소 런의 개수를 32개로 정했다. 데이터를 많이 가져갈 것이 아니기 때문에 32개로 지정하여 과정을 살펴보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 먼저 32개 만큼 배열을 건너 뛰면서 앞서 구현한 이진 삽입 정렬을 호출한다. 만약 100 개의 요소가 있는 배열을 정렬한다면 인덱스를 기준으로 0 ~ 31, 32 ~ 63, 64 ~ 95, 96 ~ 99으로 구간이 나누어지고 각 구간은 이진 삽입 정렬로 정렬된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 정렬은 2개씩 짝을 지어서 &lt;code&gt;merge()&lt;/code&gt; 함수를 호출하는데 처음 0 ~ 31과 32 ~ 64 구간이 합쳐지고 원본 배열이 업데이트 되면 64 ~ 95와 96 ~ 99 구간이 병합이 진행된다. 앞 두 구간이 업데이트 되었으므로 합쳐진 64개의 구간이 병합되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=267996120&#34;&gt;쓰면서 익히는 알고리즘과 자료구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[알고리즘] 파이썬 스택과 큐 사용법</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%81%90-%EC%82%AC%EC%9A%A9%EB%B2%95.html</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%81%90-%EC%82%AC%EC%9A%A9%EB%B2%95.html</guid>
      <description>&lt;h3 id=&#34;스택&#34;&gt;스택&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)

stack.pop()
stack.append(4)
stack.pop()

print(stack)
print(stack[::-1])

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;스택은 선입 후출 구조로, 박스쌓기로 비유하면 박스는 아래에서부터 위로 차곡차곡 쌓는데, 아래에 있는 박스를 치우기 위해서는 위에 있는 박스를 먼저 내려야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;큐&#34;&gt;큐&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;큐는 대기줄에 비유할 수 있다. 나중에 온 사람일수록 나중에 들어가기 때문에 이러한 구조를 선입 선출이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue)
queue.reverse()
print(queue)

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
      <description>&lt;h1 id=&#34;그리디-알고리즘&#34;&gt;그리디 알고리즘&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;현재 상황에서 좋아 보이는 것만을 선택하는 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 문제가 있을 때 단순 무식하게 탐욕적으로 푸는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;여기서 탐욕적이라는 말은 &amp;lsquo;현재 상황에서 지금 당장 좋은 것을 고르는 방법&#39;을 의미한다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 유형&amp;rsquo; 이라는 특징이 있다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘 유형의 문제는 매우 다양하기 때문에, 암기한다고 해서 항상 잘 풀수 있는 것은 아니다.&lt;/li&gt;
&lt;li&gt;많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;문제-1-거스름돈&#34;&gt;문제 1: 거스름돈&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한이 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def solve(money):
    ret = 0
    if money &amp;gt;= 500:
        ret += money // 500
        money %= 500

    if money &amp;gt;= 100:
        ret += money // 100
        money %= 100

    if money &amp;gt;= 50:
        ret += money // 50
        money %= 50

    if money &amp;gt;= 10:
        ret += money // 10
        money %= 10

    return ret
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;from problem import solve


def test_solve1():
    assertMoney(1300, 5)
    assertMoney(1260, 6)
    assertMoney(500, 1)
    assertMoney(260, 4)
    assertMoney(200, 2)
    assertMoney(150, 2)
    assertMoney(110, 2)
    assertMoney(100, 1)
    assertMoney(90, 4)
    assertMoney(80, 4)
    assertMoney(60, 2)
    assertMoney(50, 1)
    assertMoney(40, 4)
    assertMoney(10, 1)
    assertMoney(0, 0)


def assertMoney(money, count):
    assert (solve(money), count)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;코드를 보면 화폐의 종류 만큼 반복을 수행해야하는 것을 알 수 있다. 따라서 화폐의 종류가 &lt;code&gt;K&lt;/code&gt;개라고 할 때, 위 소스 코드의 시간 복잡도는 &lt;code&gt;O(K)&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토를 해야한다.&lt;/li&gt;
&lt;li&gt;어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고 문제를 해결할 수 있는 탐욕적인 해결책이 있는지 고민을 해보자.&lt;/li&gt;
&lt;li&gt;만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 그때는 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결 할 수 있는지를 재차 고민해보는 것도 한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
