<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
    <description>Recent content in 알고리즘 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Thu, 26 Aug 2021 20:02:39 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>큰 수의 법칙</title>
      <link>https://dongwooklee96.github.io/post/2021/08/26/%ED%81%B0-%EC%88%98%EC%9D%98-%EB%B2%95%EC%B9%99.html</link>
      <pubDate>Thu, 26 Aug 2021 20:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/26/%ED%81%B0-%EC%88%98%EC%9D%98-%EB%B2%95%EC%B9%99.html</guid>
      <description>&lt;h3 id=&#34;문제---큰-수의-법칙&#34;&gt;문제 - 큰 수의 법칙&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과해서 더해질 수가 없는 것 이 특징이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 순서대로 2, 4, 5, 4, 6 으로 이루어진 배열이 있을 때 M이 8이고 K가 3이라고 가정하자. 이 경우에 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;특정 수가 K 번을 초과해서 더해질 수 없다.&lt;/li&gt;
&lt;li&gt;첫째 줄에 N(2 &amp;lt;= N &amp;lt; 1000), M (1 &amp;lt;= M &amp;lt;= 10,000), K (1 &amp;lt;= K &amp;lt;= 10000)의 자연수가 주어진다.&lt;/li&gt;
&lt;li&gt;둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 각각의 자연수는 1 이상 ~ 10,000 이하의 수로 주어진다.&lt;/li&gt;
&lt;li&gt;입력으로 주어지는 K는 항상 M보다 작거나 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;반복문&#34;&gt;반복문&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;정렬을 하여 가장 큰 수와 그 다음으로 큰 수를 순서대로 구한다.&lt;/li&gt;
&lt;li&gt;크게 M번 만큼 순회를 한다.&lt;/li&gt;
&lt;li&gt;K번 만큼 개수를 세어서 만약 K번 만큼 수행하였을 때 그 다음 큰수로 변경하여 한번 더하는 것을 M번이 끝날 때까지 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도 : O(N)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;나누기&#34;&gt;나누기&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;정렬을 하여 가장 큰 수와 그 다음으로 큰 수를 구한다.&lt;/li&gt;
&lt;li&gt;크게 M 번만큼 반복을 한다.&lt;/li&gt;
&lt;li&gt;증가하는 요소를 K로 나눈 나머지가 0으로 나누어 떨어지면 그 다움으로 큰 수로 더한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;반복되는-수열-파악&#34;&gt;반복되는 수열 파악&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해진다.&lt;/li&gt;
&lt;li&gt;M을 (K + 1)로 나눈 몫 만큼 반복이 되어지며 K를 곱하면 나누어 떨어질 때 가장 큰수를 곱하는 경우이다., 여기에 일정하게 나누어 떨어지지 않는 경우도 있으므로  M을 (K + 1)로 나눈 나머지를 더해주면 된다.&lt;/li&gt;
&lt;li&gt;총 수행할 개수 M에서 가장 큰 수를 더하는 횟수를 빼면 두번째로 큰 숫자를 더하는 숫자가 나온다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; typing &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; List


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(n: int, m: int, k: int, lists: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    lists&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
    first, second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], lists[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    tot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(m):
        cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cnt &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; k:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
            cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tot


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution1&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort(reverse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
    first, second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], arrays[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    tot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            tot &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tot


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution2&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
    first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(k):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
            result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; first
            m &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; second
        m &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution3&lt;/span&gt;(n: int, m: int, k: int, arrays: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    arrays&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
    first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arrays[n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(m &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; k
    count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (count) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; first
    result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (m &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; count) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; second


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    n, m, k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split())
    lists &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(int, input()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()))
    print(solution1(n, m, k, lists))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동전 거스름돈 문제</title>
      <link>https://dongwooklee96.github.io/post/2021/08/25/%EB%8F%99%EC%A0%84-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C.html</link>
      <pubDate>Wed, 25 Aug 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/25/%EB%8F%99%EC%A0%84-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C.html</guid>
      <description>&lt;h3 id=&#34;문제---거스름돈&#34;&gt;문제 - 거스름돈&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;거스름돈으로 사용할 돈이 500, 100, 50, 10 원짜리 동전이 무수히 많이 존재한다고 가정을 했을 때
거슬러 주어야할 최소한의 개수를 구하라. 단, 거슬러 주어야 할 돈은 항상 10의 배수이다.&lt;/p&gt;
&lt;h3 id=&#34;제한-사항&#34;&gt;제한 사항&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;거슬러 주어야할 돈은 항상 10의 배수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아이디어&#34;&gt;아이디어&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;그리디&#34;&gt;(그리디)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 동전부터 비교를 해서 만약 동전의 크기보다 크다면 작을 때까지 뺀 후 횟수를 더한다.&lt;/li&gt;
&lt;li&gt;그 다음 크기의 동전을 비교한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;그리디---개선된-버전&#34;&gt;(그리디 - 개선된 버전)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;가장 큰 동전으로 거스름돈을 나누고 몫만큼을 곱한 값을 뺀다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;몫만큼을 횟수로 포함시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;(exchange: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
  cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  coins &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; coin:
      exchange &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; coin
      cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cnt

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution2&lt;/span&gt;(exchange: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
  cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  coins &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;]

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; coin &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; coins:
      cnt &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; coin
      exchange &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exchange &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; coin
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cnt

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
  n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(input())
  print(solution2(n)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>정렬 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/08/23/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
      <pubDate>Mon, 23 Aug 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/23/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
      <description>&lt;h3 id=&#34;정렬-알고리즘&#34;&gt;정렬 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정렬은 알고리즘 학습에 있어서 가장 기본적으로 알아두어야 하는 개념중에 하나이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정렬을 하면서 다양한 문제를 쉽게 해결할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;찾기 : 정렬된 리스트는 특정 아이템을 쉽게 찾을 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;선택: 찾기와 마찬가지로 정렬된 리스트에서 다양한 아이템에 접근하여 얻어올 수 있다. 예를 들어서 리스트에서 3번째 큰 수를 가져온다던가 중간값을 찾거나 하는 일들이 쉽게 처리 될 수 있다.&lt;/li&gt;
&lt;li&gt;중복 검출 : 정렬되어 있다면 중복 아이템 찾기도 쉽게 처리할 수 있다.&lt;/li&gt;
&lt;li&gt;분포 : 리스트에서 가장 많이 있거나 적게 있는 아이템들을 쉽게 골라낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;거품-정렬-bubble-sort&#34;&gt;거품 정렬 (Bubble Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬은 정렬 중에서 가장 직관적인 정렬 방식이다. 거품 정렬은 알고리즘 동작이 각 순회의 가장 큰 요소가 맨 뒤로 이동하는 방식이기 때문에 지어진 이름이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 배열에 요소가 다음과 같이 있다고 가정을 하자. [8, 2, 6, 4, 5] 그렇다면 가장 처음에 있는 요소를 뒤의 요소와 비교하여 뒤의 요소보다 크다면 서로 값을 바꾼다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;교환된 요소는 뒤의 숫자보다 크므로 계속 비교되어 끝까지 이동하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한 번의 순회가 끝나면 다음 순회를 이어서 진행한다. 거품 정렬에서 1번의 순회는 가장 큰 수를 맨 뒤로 보내기 때문에 마지막 요소와 비교할 필요가 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        done_sort = True

        for j in range(n - i - 1):
            if arr[j] &amp;gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

                done_sort = False
        if done_sort:
            break
    return arr


if __name__ == &amp;quot;__main__&amp;quot;:
    input_arr = [8, 2, 6, 4, 5]
    print(f&#39;{bubble_sort(input_arr)}&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시간 복잡도는 최악의 경우와 평균적인 경우 &lt;code&gt;O(N^2)&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;done_sort&lt;/code&gt; 플래그로 인해서 이미 정렬된 배열을 정렬하는 경우 한 번의 순회만 진행하므로 &lt;code&gt;O(N)&lt;/code&gt;이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 비슷하게 삽입 정렬도 직관적인 구현으로 이해하기 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과는 다르게 리스트 내 하나의 요소를 선택하여 다른 요소와 비교하여 알맞은 위치에 삽입하는 정렬이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def insertion_sort(arr):
    n = len(arr)

    for i in range(1, n):
        key_item = arr[i]

        j = i - 1

        while j &amp;gt;= 0 and arr[j] &amp;gt; key_item:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key_item
    return arr

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 삽입 정렬의 시간 복잡도는 동일하기 때문에 같은 성능으 가진 알고리즘으로 판단할 수 있는데 실제 데이터를 입력해보고 확인하면 평균적으로 삽입 정렬이 거품 정렬보다 비교 횟수가 적다는 것을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;삽입 정렬의 시간 복잡도가 높아 거품 정렬과 함께 실제로는 사용되지 않을 것이라고 생각할 수 있는데, 하지만 삽입 정렬은 적은 데이터 개수를 가지는 데이터 셋에서 다른 정렬보다 평균적으로 좋은 성능을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 파이썬, 자바, 최신 C++에 사용되는 내장 정렬 함수는 작은 데이터 셋에 대해서 삽입 정렬을 사용하도록 구혆되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서 사용하는 내장 함수 &lt;code&gt;sorted()&lt;/code&gt;는 팀 정렬이라는 정렬 기법으로 병합 정렬과 삽입 정렬을 선택적으로 사용하도록 구현되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/cmybgze3qmszxl5/download13.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;거품 정렬과 삽입 정렬보다 높은 효율을 보이는 정렬 알고리즘이다. 병합 정렬은 분할 정복 접근을 기반으로 복잡한 문제를 해결 할 때 사용하는 강력한 알고리즘 기술이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분할 정복을 이해하기 위해서는 재귀를 이해하는 것이 필요하다. 재귀는 분할 정복이 필요한 문제를 해결 가능한 하위 문제로 쪼갤 수 있는 방법을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분할 정복은 기본적으로 문제를 작게 만들어 해결하고, 해결된 결과를 다음 하위 문제로 전달 후에 전체 문제를 해결하려고 시도하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def merge_sort(arr):
    def merge(left, right):
        left_len = len(left)
        right_len = len(right)

        result = []

        left_index = right_index = 0

        while len(result) &amp;lt; left_len + right_len:
            if left[left_index] &amp;lt;= right[right_index]:
                result.append(left[left_index])
                left_index += 1
            else:
                result.append(right[right_index])
                right_index += 1
            if right_index == right_len:
                result.extend(left[left_index:])
                break
            if left_index == left_len:
                result.extend(right[right_index:])
                break
        return result

    n = len(arr)
    if n &amp;lt; 2:
        return arr
    mid_index = n // 2
    left = merge_sort(arr[:mid_index])
    right = merge_sort(arr[mid_index:])
    return merge(left, right)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;병합 정렬은 O(nlogn)의 시간 복잡도를 안정적으로 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;퀵-정렬quick-sort&#34;&gt;퀵 정렬(Quick Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;병합 정렬과 비슷하게 분할 정복 방법을 이용한 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 점은 입력 리스트를 두 리스트로 나눌 때 한쪽은 특정 값보다 작은 값만 모으고 다른 하나는 특정 값보다 큰 값만 모은다. 이를 재귀적으로 완전히 정렬이 될 때까지 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 값을 퀵 정렬에서 피벗이라고 부르는데 피벗을 결정하는 방식에 따라서 성능 차이가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력 리스트를 나누는 것을 파티셔닝이라고 부른다. 분할할 때마다 피벗을 선택하여 두 부류 (작은 값 - LOW, 큰 값 - HIGH)로 나누는 작업을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 파티셔닝마다 피벗 값을 결정해야하는데 많은 고민이 필요하다. 만약 피벗 값이 리스트 마지막 요소로 선택되어있는 경우, 이미 정렬된 리스트라면 계속 작은 값에 남은 요소가 다 들어가게 되므로 시간 복잡도가 O(N^2)이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이것을 방지하기 위해서 무작위로 피벗을 결정하여 최악의 경우를 최소화하는 방향이나 중간 값을 찾아서 LOW / HIGH 분배를 하면 안정적으로 O(nlogn)의 시간 복잡도를 가질 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def quicksort(arr):
    arr_len = len(arr)
    if arr_len &amp;lt; 2:
        return arr

    low, same, high = [], [], []

    pivot = arr[randint(0, arr_len - 1)]

    for item in arr:
        if item &amp;lt; pivot:
            low.append(item)
        elif item == pivot:
            same.append(item)
        elif item &amp;gt; pivot:
            high.append(item)
    return quicksort(low) + same + quicksort(high)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;극단적으로 임의 값이 매번 가장 작은 값이거나 가장 큰 값이라면, N번 분리되고 N번 합치는 과정이 필요하여 최악의 경우에는 O(N^2)이 되지만 평균적으로는 O(nlogn)이 되는 정렬 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 최악의 상황으로는 정렬 성능이 나오지 않기 때문에 피벗을 선택할 때 무조건 중앙 값으로 선택할 수 있다면 LOW, HIGH가 정확히 반으로 나누어지기 때문에 O(nlogn)을 유지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;팀-정렬tim-sort&#34;&gt;팀 정렬(Tim Sort)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬은 기존의 알고리즘의 특징을 잘 파악하고 최적으로 조합하여 탄생한 알고리즘이라고 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬은 삽입 정렬과 병합 정렬을 섞어서 사용한다. 다만 삽입 정렬의 비교 연산을 줄이기 위해서 선택된 요소의 알맞은 위치 탐색을 선형 탐색이 아닌 이진 탐색으로 하고 이 위치에 요소 삽입을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;당연한 이야기지만 선형 탐색은 O(N)이고 이진 탐색의 요소는 O(logN)이기 때문에 더 성능이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이제 살펴봐야하는 팀 정렬의 키워드는 런이다. 데이터 셋이 적다면 (32개 혹은 64개 이하) 이진 삽입 정렬만으로 정렬해도 충분히 빨리 하겠지만, 그보다 큰 개수의 데이터라면 팀 정렬은 런 단위로 나누어서 이진 삽입 정렬을 진행하고 모두 완료되면 병합 정렬한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;막연하게 특정 개수로 런을 나누는 것이 아니라 규칙이 있다. 앞의 삽입 정렬은 이미 정렬되었거나 거의 정렬된 상태에서 빠르게 완료되는 정렬이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀 정렬의 최소 런 값은 보통 64나 32로 설정하여 구성한다. 배열의 요소를 확인하면서 오름차순이나 내림차순으로 정렬된 구간을 최소 런 값에 맞춰서 구성할 수 있다. 예를 들어서 특정 구간의 요소의 오름차순으로 정렬된 개수가 24개라고 하자. 그리고 최소 런(min run)의 개수는 64개로 설정되어 있다면, 그 뒤에 따르는 40개의 요소를 하나로 묶어 런을 구성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이진 삽입 정렬은 어느정도 정렬이 되어 있는 배열을 정렬할 때 좋은 성능을 발휘하므로 최소 런의 개수를 64개 혹은 32개로 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래는 팀정렬을 간소하게 구현해본 예제이다. 실제 사용되고 있는 팀 정렬 알고리즘을 살펴보면 설명한 내용 이외에도 성능을 높이기 위한 내용이 추가적으로 더 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def binary_search(arr, key, start, end):
    if end - start &amp;lt;= 1:
        if arr[start] &amp;gt; key:
            return start - 1
    else:
        return start

    mid = (start + end) // 2

    if arr[mid] &amp;lt; key:
        return binary_search(arr, key, mid, end)
    elif arr[mid] &amp;gt; key:
        return binary_search(arr, key, start, mid)
    else:
        return mid


def insertion_sort(arr, run_s=0, run_e=None):
    if run_e is None:
        run_e = len(arr) - 1

    for i in range(run_s + 1, run_e + 1):
        v = arr[i]
        pos = binary_search(arr, v, run_s, i) + 1

        for k in range(i, pos, -1):
            arr[k] = arr[k - 1]
        arr[pos] = v


def timsort(arr):

    def merge(left, right):
        left_len = len(left)
        right_len = len(right)

        result = []

        left_index = right_index = 0

        while len(result) &amp;lt; left_len + right_len:
            if left[left_index] &amp;lt;= right[right_index]:
                result.append(left[left_index])
                left_index += 1
            else:
                result.append(right[right_index])
                right_index += 1
            if right_index == right_len:
                result.extend(left[left_index:])
                break
            if left_index == left_len:
                result.extend(right[right_index:])
                break
        return result

    min_run = 32

    n = len(arr)

    for i in range(0, n, min_run):
        insertion_sort(arr, i, min((i + min_run - 1), n - 1))

    size = min_run
    while size &amp;lt; n:
        for start in range(0, n, size * 2):
            mid = start + size - 1
            end = min((start + size * 2 - 1), (n - 1))

            merged = merge(arr[start:mid + 1], arr[mid + 1:end + 1])
            arr[start:start + len(merged)] = merged
        size *= 2
    return arr

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최소 런의 개수를 32개로 정했다. 데이터를 많이 가져갈 것이 아니기 때문에 32개로 지정하여 과정을 살펴보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 먼저 32개 만큼 배열을 건너 뛰면서 앞서 구현한 이진 삽입 정렬을 호출한다. 만약 100 개의 요소가 있는 배열을 정렬한다면 인덱스를 기준으로 0 ~ 31, 32 ~ 63, 64 ~ 95, 96 ~ 99으로 구간이 나누어지고 각 구간은 이진 삽입 정렬로 정렬된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 정렬은 2개씩 짝을 지어서 &lt;code&gt;merge()&lt;/code&gt; 함수를 호출하는데 처음 0 ~ 31과 32 ~ 64 구간이 합쳐지고 원본 배열이 업데이트 되면 64 ~ 95와 96 ~ 99 구간이 병합이 진행된다. 앞 두 구간이 업데이트 되었으므로 합쳐진 64개의 구간이 병합되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=267996120&#34;&gt;쓰면서 익히는 알고리즘과 자료구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
      <description>&lt;h1 id=&#34;그리디-알고리즘&#34;&gt;그리디 알고리즘&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;현재 상황에서 좋아 보이는 것만을 선택하는 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 문제가 있을 때 단순 무식하게 탐욕적으로 푸는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;여기서 탐욕적이라는 말은 &amp;lsquo;현재 상황에서 지금 당장 좋은 것을 고르는 방법&amp;rsquo;을 의미한다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 유형&amp;rsquo; 이라는 특징이 있다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘 유형의 문제는 매우 다양하기 때문에, 암기한다고 해서 항상 잘 풀수 있는 것은 아니다.&lt;/li&gt;
&lt;li&gt;많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;문제-1-거스름돈&#34;&gt;문제 1: 거스름돈&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한이 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def solve(money):
    ret = 0
    if money &amp;gt;= 500:
        ret += money // 500
        money %= 500

    if money &amp;gt;= 100:
        ret += money // 100
        money %= 100

    if money &amp;gt;= 50:
        ret += money // 50
        money %= 50

    if money &amp;gt;= 10:
        ret += money // 10
        money %= 10

    return ret
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;from problem import solve


def test_solve1():
    assertMoney(1300, 5)
    assertMoney(1260, 6)
    assertMoney(500, 1)
    assertMoney(260, 4)
    assertMoney(200, 2)
    assertMoney(150, 2)
    assertMoney(110, 2)
    assertMoney(100, 1)
    assertMoney(90, 4)
    assertMoney(80, 4)
    assertMoney(60, 2)
    assertMoney(50, 1)
    assertMoney(40, 4)
    assertMoney(10, 1)
    assertMoney(0, 0)


def assertMoney(money, count):
    assert (solve(money), count)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;코드를 보면 화폐의 종류 만큼 반복을 수행해야하는 것을 알 수 있다. 따라서 화폐의 종류가 &lt;code&gt;K&lt;/code&gt;개라고 할 때, 위 소스 코드의 시간 복잡도는 &lt;code&gt;O(K)&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토를 해야한다.&lt;/li&gt;
&lt;li&gt;어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고 문제를 해결할 수 있는 탐욕적인 해결책이 있는지 고민을 해보자.&lt;/li&gt;
&lt;li&gt;만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 그때는 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결 할 수 있는지를 재차 고민해보는 것도 한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
