<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>시스템 프로그래밍 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</link>
    <description>Recent content in 시스템 프로그래밍 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 05 Sep 2021 12:00:24 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[시스템 프로그래밍] 파일 메타 정보 확인 및 수정하기</title>
      <link>https://dongwooklee96.github.io/post/2021/09/05/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%BC-%EB%A9%94%ED%83%80-%EC%A0%95%EB%B3%B4-%ED%99%95%EC%9D%B8-%EB%B0%8F-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0.html</link>
      <pubDate>Sun, 05 Sep 2021 12:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/05/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%BC-%EB%A9%94%ED%83%80-%EC%A0%95%EB%B3%B4-%ED%99%95%EC%9D%B8-%EB%B0%8F-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0.html</guid>
      <description>&lt;h3 id=&#34;메타-정보-획득하기&#34;&gt;메타 정보 획득하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 시스템에는 데이터 외에도 다음과 같은 정보가 추가적으로 저장되어 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일의 종류&lt;/li&gt;
&lt;li&gt;크기&lt;/li&gt;
&lt;li&gt;권한&lt;/li&gt;
&lt;li&gt;소유자&lt;/li&gt;
&lt;li&gt;그룹&lt;/li&gt;
&lt;li&gt;작성시간&lt;/li&gt;
&lt;li&gt;변경 시간&lt;/li&gt;
&lt;li&gt;액세스 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;stat2&#34;&gt;stat(2)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int stat(const char *path, struct stat *buf);
int lstat(const char *path, struct stat *buf);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stat()&lt;/code&gt;은 &lt;code&gt;path&lt;/code&gt;로 지정한 엔트리 정보를 취득해서 &lt;code&gt;buf&lt;/code&gt;에 써넣는다. 성공하면 0을 반환하고, 실패하면 -1을 반환하면서 &lt;code&gt;errno&lt;/code&gt;를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lstat()&lt;/code&gt;은 &lt;code&gt;stat()&lt;/code&gt;와 거의 같지만, &lt;code&gt;path&lt;/code&gt;가 심볼릭 링크인 경우 해당 링크를 따라가지 않고 심볼릭 링크 자신의 정보를 반환한다는 점이 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한, 파일 디스크립터에서 동일한 정보를 얻을 수 있는 &lt;code&gt;fstat()&lt;/code&gt;도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/alvpqekrtk3jq87/Screen%20Shot%202021-09-05%20at%2012.54.42%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fstat()&lt;/code&gt;에 관해서는 &lt;code&gt;man&lt;/code&gt; 페이지를 참고하면 자세히 나와 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 &lt;code&gt;struct stat&lt;/code&gt; 구조체와 의미는 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/0gsljbxhc3sedt2/Screen%20Shot%202021-09-05%20at%2012.58.14%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;stat-명령어-만들기&#34;&gt;&lt;code&gt;stat&lt;/code&gt; 명령어 만들기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜 &lt;code&gt;stat()&lt;/code&gt;을 사용하여 &lt;code&gt;stat&lt;/code&gt; 명령어를 만들어 볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

static char *filetype(mode_t mode);

int main(int argc, char *argv[]) {
  struct stat st;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;wrong argument\n&amp;quot;);
    exit(1);
  }

  if (lstat(argv[1], &amp;amp;st) &amp;lt; 0) {
    perror(argv[1]);
    exit(1);
  }

  printf(&amp;quot;type\t%o (%s)\n&amp;quot;, (st.st_mode &amp;amp; S_IFMT), filetype(st.st_mode));
  printf(&amp;quot;mode\t%o\n&amp;quot;, st.st_mode &amp;amp; ~S_IFMT);
  printf(&amp;quot;dev\t%llu\n&amp;quot;, (unsigned long long)st.st_dev);
  printf(&amp;quot;ino\t%lu\n&amp;quot;, (unsigned long)st.st_ino);
  printf(&amp;quot;rdev\t%lu\n&amp;quot;, (unsigned long)st.st_rdev);
  printf(&amp;quot;nlink\t%lu\n&amp;quot;, (unsigned long)st.st_nlink);
  printf(&amp;quot;uid\t%d\n&amp;quot;, st.st_uid);
  printf(&amp;quot;gid\t%d\n&amp;quot;, st.st_gid);
  printf(&amp;quot;size\t%ld\n&amp;quot;, st.st_size);
  printf(&amp;quot;blksize\t%ld\n&amp;quot;, (unsigned long)st.st_blksize);
  printf(&amp;quot;blocks\t%lu\n&amp;quot;, (unsigned long)st.st_blocks);
  printf(&amp;quot;atime\t%s&amp;quot;, ctime(&amp;amp;st.st_atime));
  printf(&amp;quot;mtime\t%s&amp;quot;, ctime(&amp;amp;st.st_mtime));
  printf(&amp;quot;ctime\t%s&amp;quot;, ctime(&amp;amp;st.st_ctime));

  exit(0);
}

static char *filetype(mode_t mode) {
  if (S_ISREG(mode)) return &amp;quot;file&amp;quot;;
  if (S_ISDIR(mode)) return &amp;quot;directory&amp;quot;;
  if (S_ISCHR(mode)) return &amp;quot;chardev&amp;quot;;
  if (S_ISBLK(mode)) return &amp;quot;blockdev&amp;quot;;
  if (S_ISFIFO(mode)) return &amp;quot;fifo&amp;quot;;
  if (S_ISLNK(mode)) return &amp;quot;symlink&amp;quot;;
  if (S_ISSOCK(mode)) return &amp;quot;socket&amp;quot;;
  return &amp;quot;unknown&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8a8mzrp95wvqhdr/Screen%20Shot%202021-09-05%20at%202.37.04%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 결과는 위와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메타-정보-변경하기&#34;&gt;메타 정보 변경하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;메타 정보를 획득하는 시스템 콜은 &lt;code&gt;stat(2)&lt;/code&gt; 한 개지만, 변경하는 시스템 콜은 여러개가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;변경 대상&lt;/th&gt;
&lt;th&gt;사용하는 시스템 콜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;권한&lt;/td&gt;
&lt;td&gt;chmod(2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;오너와 그룹&lt;/td&gt;
&lt;td&gt;chown (2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;최종 액세스 시간과 최종 갱신 시각&lt;/td&gt;
&lt;td&gt;utime(2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;chmod2&#34;&gt;&lt;code&gt;chmod(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/stat.h&amp;gt;

int chmod(const char *path, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chmod&lt;/code&gt;는 경로로 지정한 파일의 모드를 변경한다. 성공하면 0을 반환하고 실패하면 -1을 반환하면서 &lt;code&gt;errno&lt;/code&gt;에 에러 번호를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;는 표에 있는 상수를 &lt;code&gt;OR&lt;/code&gt;로 묶어서 지정하거나 &lt;code&gt;0775&lt;/code&gt; 같은 숫자를 사용한다. C언어에서 숫자에 0을 앞에 두면 8진수가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 권한 644의 경우, &amp;lsquo;0644&amp;rsquo; 또는 &amp;lsquo;S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH`로 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;chown2&#34;&gt;&lt;code&gt;chown(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int chown(const char *path, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chown()&lt;/code&gt;은 파일 &lt;code&gt;path&lt;/code&gt;의 소유 사용자를 &lt;code&gt;owner&lt;/code&gt;로, 소유 그룹을 &lt;code&gt;group&lt;/code&gt;로 변경한다. 그중 하나만을 변경하려는 경우에는 변경하지 않는 쪽에 -1을 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lchown()&lt;/code&gt;의 동작은 &lt;code&gt;chown()&lt;/code&gt;과 거의 같지만, &lt;code&gt;path&lt;/code&gt;가 심볼릭 링크인 경우에는 그 심볼릭 링크 자체의 정보를 변경하는 점이 다르다. 그리고 &lt;code&gt;chown()&lt;/code&gt; 은 심볼릭 링크가 가리키는 파일의 정보를 변경한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;둘 다 성공하면 0을 반환하며, 실패하면 -1을 반환하고 &lt;code&gt;errno&lt;/code&gt;를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어느 시스템 콜이든지 소유 사용자를 변경하려면 슈퍼 사용자 권한이 필요하다. 그리고 소유 그룹을 변경하는 경우에는 해당 파일의 소유 사용자여야 하며, 그리고 자신이 포함된 그룹으로만 변경할 수 있다. 물론, 슈퍼 사용자라면 임의의 그룹으로 변경할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lchown()&lt;/code&gt;이 있다면 &lt;code&gt;lchmod()&lt;/code&gt;도 있을 것 같지만, 리눅스에서는 심볼릭 링크 자체에 권한이 없어 &lt;code&gt;lchmod()&lt;/code&gt;란 존재하지 않는다. 그러나 BSD 계열의 유닉스에는 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;utime2&#34;&gt;&lt;code&gt;utime(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;

int utime(const char *path, struct utimbuf *buf);

struct utimbuf {
  time_t actime; /* 최종 액세스 시간 */
  time_t modetime; /* 최종 갱신 시간 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;utime()&lt;/code&gt;은 경로로 지정한 파일의 최종 액세스 시간과 최종 갱신 시간을 변경한다. 만약 &lt;code&gt;buf&lt;/code&gt;가 NULL이 아니면 &lt;code&gt;buf&lt;/code&gt;의 내용에 따라서 &lt;code&gt;actime&lt;/code&gt;과 &lt;code&gt;modtime&lt;/code&gt;이 설정된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;buf&lt;/code&gt;가 NULL 이라면 양쪽 모두 현재 시간으로 변경된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;chmod-명령어-작성하기&#34;&gt;chmod 명령어 작성하기&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;

int main(int argc, char *argv[]) {
  int mode;
  int i;

  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;no mode given\n&amp;quot;);
    exit(1);
  }

  mode = strtol(argv[1], NULL, 0);
  for (i = 2; i &amp;lt; argc; i++) {
    if (chmod(argv[i], mode) &amp;lt; 0) {
      perror(argv[i]);
    }
  }
  exit(0);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strtol()&lt;/code&gt;은 &lt;code&gt;atoi()&lt;/code&gt; 와 같이 정수가 표현된 문자열을 정수 타입의 값으로 변환하는 함수이다. 그러나 &lt;code&gt;atoi()&lt;/code&gt;와 다르게 세번째 인자로 진수를 설정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[시스템 프로그래밍] 하드 링크 및 심볼릭 링크</title>
      <link>https://dongwooklee96.github.io/post/2021/09/03/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%98%EB%93%9C-%EB%A7%81%ED%81%AC-%EB%B0%8F-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%A7%81%ED%81%AC.html</link>
      <pubDate>Fri, 03 Sep 2021 22:00:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/09/03/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%98%EB%93%9C-%EB%A7%81%ED%81%AC-%EB%B0%8F-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%A7%81%ED%81%AC.html</guid>
      <description>&lt;h3 id=&#34;하드-링크&#34;&gt;하드 링크&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리눅스에는 하나의 파일에 두 개 이상의 이름을 지정할 수 있다. 이를 위해서 링크라는 개념이 존재하는데 이를 하드 링크라고 부르기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;링크란 파일에 새로운 이름을 붙이는 것이다. 예를 들면 다음과 같이 A 라는 파일을 만들었다고 가정을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;echo &#39;this is a file.&#39; &amp;gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이때 파일의 이름과 실체의 관계는 이름이 실체를 포인터처럼 가리키고 있는 모습이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 파일 A의 실체에 새로운 이름 B를 붙여보자. 이때 사용하는 명령어가 바로 &lt;code&gt;ln&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/l8sfgjl3kss323z/hardlink.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln a b
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 작업은 파일 A를 가리키는 하드 링크 B를 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이후에 A의 내용을 변경하면 B의 내용도 동일하게 변경된다. 왜냐하면 A와 B는 같은 것을 가리키고 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일에 부여된 이름의 개수는 &lt;code&gt;ls -l&lt;/code&gt;를 사용하여 확인할 수 있다. 이름이 하나만 있는 파일을 &lt;code&gt;ls&lt;/code&gt; 명령어로 표시하면 다음과 같이 출력 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;rm -f a b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/k7n1p5qp75n0bua/Screen%20Shot%202021-09-01%20at%2010.10.03%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;왼쪽에서 두 번째 란이 이름의 개수를 의미한다. 이것을 링크 카운터라고 한다. 현재 링크 카운터가 두 개인 것을 확인할 수 있고 양쪽 다 모두 2개인 것을 확인할 수 있는데 링크 카운터는 실체에 기록되기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한편, 이름을 삭제하려면 &lt;code&gt;rm&lt;/code&gt; 명령어를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rm&lt;/code&gt; 이 파일을 제거하는 명령어라고 인식하기 쉽지만, 사실은 &lt;code&gt;rm&lt;/code&gt;이 삭제하는 것은 파일이 아닌 파일의 이름이다. 실체를 가리키는 이름이 모두 없어진 시점에서, 즉 링크 카운트가 0이 되었을 때 비로소 실체가 삭제된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/zyhnkt6e7sp99cp/Screen%20Shot%202021-09-01%20at%2010.13.40%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rm&lt;/code&gt;에 의해서 링크 카운터가 다시 1로 되돌아 간 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;link2&#34;&gt;&lt;code&gt;link(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하드 링크를 작성하는 시스템 콜이 &lt;code&gt;link(2)&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int link(const char *src, const char *dest);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;link()&lt;/code&gt;는 &lt;code&gt;src&lt;/code&gt;로 지정한 파일에 새로운 이름 &lt;code&gt;dest&lt;/code&gt;를 추가한다. 두 번째 인자가 새로 만들 이름이라는 점에 유의하기 바란다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성공하면 0을 반환하고 실패하면 -1을 반환하면서 &lt;code&gt;errno&lt;/code&gt;를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한편, &lt;code&gt;link()&lt;/code&gt;에는 다음과 같은 중요한 제약이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;와 &lt;code&gt;dest&lt;/code&gt;에는 동일한 파일 시스템에 있어야 한다. 양쪽 모두가 하나의 파일 시스템에 존재해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;와 &lt;code&gt;dest&lt;/code&gt;에 디렉터리는 사용할 수 없다. 즉, 디렉터리에 하드 링크를 붙일 수 없다. 이 제한은 나중에 언급할 심볼릭 링크를 사용하여 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ln-명령어-작성하기&#34;&gt;ln 명령어 작성하기&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]) {
  if (argc != 3) {
    fprintf(stderr, &amp;quot;%s: wrong arguments\n&amp;quot;, argv[0]);
    exit(1);
  }

  if (link(argv[1], argv[2]) &amp;lt; 0) {
    perror(argv[1]);
    exit(1);
  }
  exit(0);
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/moh0m14brkjpxhi/Screen%20Shot%202021-09-01%20at%2010.31.32%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls -l&lt;/code&gt; 출력하는 항목 중 왼쪽에서 두 번재 열에 주목을 하면 &lt;code&gt;ln.c&lt;/code&gt;의 링크 카운터가 2로 증가한 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;심볼릭-링크&#34;&gt;심볼릭 링크&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;심볼릭 링크는 하드 링크처럼 파일의 실체에 새로운 이름을 붙이는 매커니즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 그 구조는 하드 링크와 상당히 다르다. 하드 링크는 이름과 실체를 연결하는 구조이지만, 심볼링 링크는 이름에 이름을 연결하는 구조이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 실제로 심볼릭 링크에 엑세스가 있을 때 비로소 이름의 실체를 찾는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 심볼링 링크에는 다음과 같은 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;심볼릭 링크에는 대응하는 실체가 존재하지 않아도 된다.
심볼릭 링크는 실제로 액세스 할 때가 아니면 이름의 실체의 맵핑을 하지 않기 때문에 실체가 없어도 만들 수 있다.&lt;/li&gt;
&lt;li&gt;파일 시스템의 경계를 뛰어넘어서 별명을 붙일 수 있다.
하드 링크는 하나의 파일 시스템 내에서만 만들 수 있다는 제약이 있었다. 그러나 심볼릭 링크는 파일 시스템의 경계와 관계없이 만들 수 있다.&lt;/li&gt;
&lt;li&gt;디렉터리에도 별명을 붙일 수 있다.
디렉터리에 대해서는 하드 링크는 만들 수 없지만 심볼릭 링크는 만들 수 있따.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;현재는 하드 링크를 거의 사용하지 않고 파일에 별명을 붙이고 싶을 때는 심볼릭 링크를 사용하는 것 이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;symlink2&#34;&gt;&lt;code&gt;symlink(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;심볼릭 링크를 만드는 시스템 콜은 &lt;code&gt;symlink(2)&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int symlink(const char *src, const char *dest);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;symlink()&lt;/code&gt;는 지정한 경로에 대한 새로운 심볼릭 링크를 만든다. 성공하면 0을 반환하고 실패하면 -1을 반환하면서 &lt;code&gt;errno&lt;/code&gt;를 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;readlink2&#34;&gt;&lt;code&gt;readlink(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;심볼릭 링크가 가리키는 이름을 얻기 위해 &lt;code&gt;readlink(2)&lt;/code&gt;를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int readlink(const char *path, char *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readlink()&lt;/code&gt;는 심볼릭 링크 &lt;code&gt;path&lt;/code&gt;가 가리키는 이름을 &lt;code&gt;buf&lt;/code&gt;에 담아준다. 이때 최대 &lt;code&gt;bufsize&lt;/code&gt; 바이트를 담아주며 &lt;code&gt;bufsize&lt;/code&gt;는 보통의 크기로 지정한다. 또한 &lt;code&gt;readlink()&lt;/code&gt;는 문자열의 마지막에 &lt;code&gt;\0&lt;/code&gt;을 기록하지 않기 때문에 주의해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;호출에 성공하면 &lt;code&gt;buf&lt;/code&gt;에 포함된 바이트 수를 반환한다. 실패하면 -1을 반환하면서 &lt;code&gt;errno&lt;/code&gt;를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;symlink-명령어-만들기&#34;&gt;&lt;code&gt;symlink&lt;/code&gt; 명령어 만들기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;보통 리눅스에서 심볼릭 링크를 만들 때 &lt;code&gt;ln -s&lt;/code&gt;를 사용하는데, 여기서는 전용 명령어처럼 만들어 보기로 하겠다. 이름은 &lt;code&gt;symlink&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]) {
  if (argc != 3) {
    fprintf(stderr, &amp;quot;%s: wrong number of arguments\n&amp;quot;, argv[0]);
    exit(1);
  }

  if (symlink(argv[1], argv[2]) &amp;lt; 0) {
    perror(argv[1]);
    exit(1);
  }
  exit(0);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;심볼링 링크가 제대로 이루어진 것을 확인할 수 있고, 파일 목록을 조회하였을 때 화살표로 어떤 파일을 가리키는지 알려준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/9i0mcnb79hen52p/Screen%20Shot%202021-09-03%20at%2010.36.19%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[시스템 프로그래밍] 디렉터리와 관련된 API 및 프로그램 작성</title>
      <link>https://dongwooklee96.github.io/post/2021/08/31/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-api-%EB%B0%8F-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%91%EC%84%B1.html</link>
      <pubDate>Tue, 31 Aug 2021 16:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/31/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-api-%EB%B0%8F-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%91%EC%84%B1.html</guid>
      <description>&lt;h3 id=&#34;디렉터리-내용-읽어-들이기&#34;&gt;디렉터리 내용 읽어 들이기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;먼저 디렉터리 엔트리를 리스트 하는 API를 설명할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디렉터리도 일반적인 파일과 비슷하다. 즉 &lt;code&gt;open()&lt;/code&gt; 하고 &lt;code&gt;read()&lt;/code&gt; 한 후에 &lt;code&gt;close()&lt;/code&gt; 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디렉터리를 읽으면 디렉터리에 담긴 파일들의 정보를 읽을 수 있다. 파일 한 개당 하나의 구조체에 대응되어, 디렉터리를 읽으면 구조체의 배열을 얻을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디렉터리는 바이트 배열임과 동시에 구조체의 배열인 것이다. 이 구조체를 디렉터리 엔트리라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스의 디렉터리 API는 디렉터리 엔트리 배열 단위로 조작하는 API를 제공하여 개발자가 편리하게 사용할 수 있다. 이 API는 일반적인 파일을 취급하는 API와 비슷하게 &lt;code&gt;opendir(), readdir(), closedir()&lt;/code&gt; 라는 함수를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;openddir3&#34;&gt;&lt;code&gt;openddir(3)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;

DIR *opendir(const char *path);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;opendir()&lt;/code&gt;은 경로로 지정한 디렉터리를 얻기 위해서 &lt;code&gt;open()&lt;/code&gt; 하고 DIR 타입에 대한 포인터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR 타입은 디렉터리를 읽어들이기 위한 스트림을 관리하는 구조체로, 파일을 읽을 때 사용한 FILE 타입에 대응하는 개념이라고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;readdir3&#34;&gt;&lt;code&gt;readdir(3)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;

struct dirent *readdir(DIR *d);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readdir()&lt;/code&gt;은 디렉터리 스트림 d로부터 엔트리를 하나씩 읽어 들여 &lt;code&gt;struct dirent(DIRectory Entry)&lt;/code&gt; 타입으로 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더 읽을 엔트리가 없거나 읽어 들이는데 실패하면 NULL을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;struct dirent&lt;/code&gt;의 내용은 운영체제에 따라서 다른데, 리눅스에는 적어도 엔트리의 이름에 해당하는 &lt;code&gt;char *d_name&lt;/code&gt; 이 있다. &lt;code&gt;d_name&lt;/code&gt;은 &amp;lsquo;\0&amp;rsquo;을 마지막에 담고 있는 문자열이라서 &lt;code&gt;printf(), fputs()&lt;/code&gt;에서 그대로 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readdir()&lt;/code&gt;가 반환한 포인터는 다시 호출했을 때 덮어 쓰이므로 주의해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;closedir3&#34;&gt;&lt;code&gt;closedir(3)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;

int closedir(DIR *d);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;closedir()&lt;/code&gt;은 디렉터리 스트림 d를 닫는 함수이다. 성공하면 0을, 실패하면 -1을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 외에도 파일을 다룰 때 사용한 &lt;code&gt;fseek()&lt;/code&gt;와 &lt;code&gt;ftell()&lt;/code&gt;에 대응하는 &lt;code&gt;seekdir()&lt;/code&gt;와 &lt;code&gt;telldir()&lt;/code&gt;도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ls-명령어-만들어보기&#34;&gt;ls 명령어 만들어보기&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;

static void do_ls(char *path);

int main(int argc, char *argv[]) {
  int i;

  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;%s: no argument\n&amp;quot;, argv[0]);
    exit(1);
  }

  for (i = 1; i &amp;lt; argc; i++) {
    do_ls(argv[i]);
  }
  exit(0);
}

static void do_ls(char *path) {
  DIR *d;
  struct dirent *ent;

  d = opendir(path);

  if (!d) {
    perror(path);
    exit(1);
  }
  while (ent = readdir(d)) {
    printf(&amp;quot;%s\n&amp;quot;, ent-&amp;gt;d_name); // 더 읽어 들일 엔트리가 없을 때까지 (즉, NULL이 반환될 때까지) 이름을 출력한다.
  }
  closedir(d);
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/0lqtqhtpi797aln/Screen%20Shot%202021-08-31%20at%207.02.41%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 결과는 위와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;디렉터리-트리의-순회&#34;&gt;디렉터리 트리의 순회&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지금까지는 디렉터리 밑에 있는 파일에 접근하는 방법을 설명하였지만, 디렉터리 안에는 또 다른 디렉터리가 있을 수도 있는데, 그 안까지 접근하고 싶은 경우에는, 즉 재귀적으로 접근하고 싶을 경우도 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 재귀적으로 접근하고 싶은 경우가 있을 텐데. 이러한 조작을 &amp;lsquo;디렉터리 순회&amp;rsquo;라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기본적으로 순회할 때도 &lt;code&gt;openddir()&lt;/code&gt;, &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;closedir()&lt;/code&gt; 의 세 가지를 사용해서 꾸준히 디렉터리를 타고 들어가면 된다. 단 이때 주의해야할 것은 &amp;lsquo;.&amp;rsquo;, &amp;lsquo;..&amp;lsquo;의 존재이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void
traverse(path) {
  DIR *d = openddir(path);
  struct dirent *ent;

  while (ent = readdir(d)) {
    if /* ent가 디렉터리이면 */ {
      traverse(path/ent);
    }
    /* 처리 */
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드의 문제는 &amp;lsquo;.&amp;lsquo;를 배제하지 않으므로 무한 재귀에 빠지게 된다. 또한 &amp;lsquo;..&amp;rsquo; 를 배제하지 않았으므로 결국 루트 디렉터릮자ㅣ 거슬러 올라와 파일 시스템 전체를 순회하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 문제를 해결하려면 명시적으로 &amp;lsquo;.&amp;rsquo;, &amp;lsquo;..&amp;lsquo;를 제외해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번재 문제로는 심볼릭 링크를 고려하지 않았다. 예를 들면 처리 중인 디렉터리 안에 루트 디렉터리를 가리키는 심볼릭 링크가 있다면 루트 디렉터리로 처리가 이동하고, 그 안에서 또 루트 디렉터리를 가리키는 심볼릭 링크가 있으면 무한 루프에 들어가게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 문제를 피하기 위해서는 뒤에서 서술하는 &lt;code&gt;lstate()&lt;/code&gt;를 사용해서 심볼릭 링크를 명시적으로 제외할 필요가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇듯이 디렉터리 순회 코드는 꽤 주의해서 작성해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;디렉터리-만들기&#34;&gt;디렉터리 만들기&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;mkdir2&#34;&gt;&lt;code&gt;mkdir(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

int mkdir(const char *path, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkdir()&lt;/code&gt;은 &lt;code&gt;path&lt;/code&gt;로 지정한 디렉터리를 만든다. 성공하면 0을 반환하고, 실패하면 -1을 반환하고 errno를 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 인자인 &lt;code&gt;mode&lt;/code&gt;에는 권한을 지정한다. 단 여기서 지정된 값이 그대로 권한이 되는 것은 아니고, 먼저 &lt;code&gt;umask&lt;/code&gt;라는 값과 비트 연산이 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkdir()&lt;/code&gt;은 다른 시스템 콜에 비해서 꽤 빈번하게 실패하는데, 많이 발생하는 실패 원인은 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ENOENT
상위 디렉터리가 없다.&lt;/li&gt;
&lt;li&gt;ENOTDIR
path로 지정한 상위 디렉터리가 디렉터리가 아니다.&lt;/li&gt;
&lt;li&gt;EEXIST
path로 지정한 경로에 이미 파일이나 디렉터리가 존재한다.&lt;/li&gt;
&lt;li&gt;EPERM
상위 디렉터리에 대한 변경 권한이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;umask&#34;&gt;umask&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkdir()&lt;/code&gt;이나 &lt;code&gt;open()&lt;/code&gt;을 사용할 때 만들어질 파일의 권한을 지정할 수 있지만, 두 경우 모두 지정한 값이 그대로 사용되는 것은 아니다. &lt;code&gt;umask()&lt;/code&gt;를 사용해서 변경된 값이 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;umask&lt;/code&gt;는 프로세스 속성 중 하나로, 가장 일반적인 값은 8진수 022다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/qvlrqg02onl9v34/umask.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open()이나 mkdir()에서 실제로 사용하는 권한은 C 언어로 표현하면 &amp;lsquo;mode &amp;amp; ~umask&amp;rsquo;로 계산된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;

mode_t umask(mode_t mask);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;umask()&lt;/code&gt;는 프로세스의 &lt;code&gt;umask()&lt;/code&gt; 값을 &lt;code&gt;mask&lt;/code&gt;로 변경하고, 직전까지의 &lt;code&gt;umask()&lt;/code&gt; 값을 반환한다. &lt;code&gt;umask()&lt;/code&gt;는 절대로 실패하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mkdir-명령어-작성하기&#34;&gt;mkdir 명령어 작성하기&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

int main(int argc, char *argv[]) {
  int i;

  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;%s: no arguments\n&amp;quot;, argv[0]);
    exit(1);
  }

  for (i = 1; i &amp;lt; argc; i++) {
    if (mkdir(argv[i], 0777) &amp;lt; 0) {
      perror(argv[i]);
      exit(1);
    }
  }
  exit(0);
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/5xe4zj3wrn5z3t5/Screen%20Shot%202021-08-31%20at%207.26.23%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;디렉터리-삭제하기&#34;&gt;디렉터리 삭제하기&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;rmdir2&#34;&gt;&lt;code&gt;rmdir(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int rmdir(const char *path);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rmdir()&lt;/code&gt;은 path로 지정한 디렉터리를 삭제한다. 디렉터리는 반드시 비어있어야 한다. 성공하면 0을 반환하고 실패하면 -1을 반환하고나서 errno를 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;reallinux@ubuntu:~/git/system$ clear
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]) {
  int i;
  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;%s: no arguments\n&amp;quot;, argv[0]);
    exit(1);
  }

  for (i = 1; i &amp;lt; argc; i++) {
    if (rmdir(argv[i]) &amp;lt; 0) {
      perror(argv[i]);
      exit(1);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ldi7fgq7pca2qbs/Screen%20Shot%202021-08-31%20at%207.54.59%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GREP 명령어 만들기 및 정규표현식</title>
      <link>https://dongwooklee96.github.io/post/2021/08/01/grep-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</link>
      <pubDate>Sun, 01 Aug 2021 21:46:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/01/grep-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</guid>
      <description>&lt;h3 id=&#34;grep-명령어-만들기-및-정규-표현식&#34;&gt;GREP 명령어 만들기 및 정규 표현식&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libc&lt;/code&gt;에서 제공하는 정규 표현식 API는 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;

int recomp(regex_t *reg, const char *pattern, int flags);
void regfree(regex_t *reg);
int regexec(const regex_t *reg, const char *string, size_t nmatch, regmatch_t pmatch[], int flags);
size_t regerror(int errcode, const regex_t *reg, char *msgbuf, size_t msgbuf_size);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;는 두번째 인자로 넘어온 정규 표현식 문자열을 전용 데이터 형식 &lt;code&gt;regex_t&lt;/code&gt;로 변환한다. 변환한 결과는 첫번째 인자 &lt;code&gt;reg&lt;/code&gt;에 기록된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫번째 인자 &lt;code&gt;reg&lt;/code&gt;의 메모리 영역은 호출하기 전에 할당하여 그 포인터를 전달해야 하는데, 그 외에도 &lt;code&gt;regcomp()&lt;/code&gt;가 독자적으로 메모리를 확보하게 된다. 그것을 해제하는 &lt;code&gt;API&lt;/code&gt;가 바로 &lt;code&gt;regfree()&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;와 &lt;code&gt;regfree()&lt;/code&gt;는 &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt; 처럼 늘 쌍으로 사용되는 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;는 성공하면 0을 반환하고 실패하면, 에러 코드를 반환하는데, 이 에러 코드를 에러 메시지로 변환하는 함수가 &lt;code&gt;regerror()&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;grep-소스-코드&#34;&gt;grep 소스 코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;

static void do_grep(regex_t *pat, FILE *f);

int main(int argc, char *argv[]) {
  regex_t pat;
  int err;
  int i;

  if (argc &amp;lt; 2) {
    fputs(&amp;quot;no pattern\n&amp;quot;, stderr);
    exit(1);
  }
  err = regcomp(&amp;amp;pat, argv[1], REG_EXTENDED | REG_NOSUB | REG_NEWLINE);
  if (err != 0) {
    char buf[1024];
    puts(buf);
    exit(1);
  }
  if (argc == 2) {
    do_grep(&amp;amp;pat, stdin);
  } else {
    for (i = 2; i &amp;lt; argc; i++) {
      FILE *f;

      f = fopen(argv[i], &amp;quot;r&amp;quot;);
      if (!f) {
        perror(argv[i]);
        exit(1);
      }
      do_grep(&amp;amp;pat, f);
      fclose(f);
    }
  }
  regfree(&amp;amp;pat);
  exit(0);
}

static void do_grep(regex_t *pat, FILE *src) {
  char buf[4096];

  while (fgets(buf, sizeof buf, src)) {
    if (regexec(pat, buf, 0, NULL, 0) == 0) {
      fputs(buf, stdout);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;한글-문자열-처리와-국제화&#34;&gt;한글 문자열 처리와 국제화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 &lt;code&gt;grep&lt;/code&gt; 명령어를 한글로 된 텍스트 파일에 적용할 수가 없다. 이유는 한글 문자열을 고려하지 않았기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C언어에서 문자는 사실 숫자이며, 문자열은 숫자의 배열이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;유니코드&#34;&gt;유니코드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;유니코드는 기존의 수많은 언어의 문자 코드를 대부분 포함해 문자 코드가 난립하는 상황을 해결하기 위해서 고안되었다. 그러나, 현실은 유니코드에 포함되지 않은 문자도 존재하며 특히 한자와 관련된 골치아픈 문제들이 남아있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래도 기존의 문자 코드를 여러개 사용하는 것보다는 훨씬 낫고, 달리 대체할 것이 없어 현재는 유니코드가 사실상 표준이 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문자-코드의-구체적인-의미&#34;&gt;문자 코드의 구체적인 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;문자 코드&amp;rsquo; 라는 모호한 개념은 구체적으로 다음과 같이 두 가지로 분해할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;부호화 문자집합&lt;/li&gt;
&lt;li&gt;인코딩&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;부호화-문자-집합&#34;&gt;부호화 문자 집합&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;문자집합 또는 문자 셋은 글자들의 집합이며, 집합 안의 문자들에 음수가 아닌 정수들을 배정한 것을 &lt;strong&gt;부호화된 문자 집합(coded character set)&lt;/strong&gt; 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인코딩&#34;&gt;인코딩&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;부호화 문자 집합에 속하는 각 문자는 하나의 숫자와 대응된다. 그 번호를 실제 바이트 열로 적용할 때의 계산식이 인코딩이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인코딩은 크게 두 가지 종류가 있는데 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;모든 문자에 대해서 같은 바이트 수를 사용하는 인코딩&lt;/li&gt;
&lt;li&gt;문자의 종류에 따라 사용하는 바이트 수를 바꾸는 인코딩&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;전자를 &lt;strong&gt;와이드 문자&lt;/strong&gt;, 후자를 &lt;strong&gt;멀티 바이트 문자&lt;/strong&gt;라고 한다. 둘 다 실제로 사용되고 있는데, 문자열의 저장 및 전송은 멀티 파이트 문자를 사용하고, 프로세스 내에서 데이터를 처리할 때는 와이드 문자도 자주 사용된다. 와이드 문자가 처리하기 쉽기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문자열-처리-방법&#34;&gt;문자열 처리 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞으로 유니코드가 우세할 것은 틀림이 없다. 그리고 특히 데이터 저장 및 전송에 사용되는 인코딩은 &lt;code&gt;UTF-8&lt;/code&gt;로 결정되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 지금까지 작성된 유니코등 이외의 데이터를 어떻게 처리할 것인가 하는 문제가 있는데 아래 방법중에 하나를 선택해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;프로그램에서 사용할 문자 코드를 미리 정한다 (혹은 사용자가 정하도록 한다)&lt;/li&gt;
&lt;li&gt;문자 코드를 추출한다.&lt;/li&gt;
&lt;li&gt;문자열을 주고 받을 때, 문자 코드의 이름도 넘기도록 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 번째 방법은 정해진 문자 코드를 사용하기로 사용자와 합의하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 방법은 유니코드가 등장하기 전까지는 효과적일지 몰라도, 유니코드가 포함되면서 실패할 확률이 늘었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세번재 방법은 문자 코드의 이름을 명시적으로 전달하는 것도 좋은 방법이지만, 이름을 잘못 전달하거나 모르는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결로넉으로 완벽한 대처는 존재하기 힘들고, 가장 합리적인 방법은 사용할 문자 코드를 미리 정하고, 그 이외의 문자 코드는 이름을 넘겨줘서 처리할 수 있도록 대응하는 방법일 것이다.&lt;/p&gt;
&lt;h3 id=&#34;국제화와-다중언어화&#34;&gt;국제화와 다중언어화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지금까지 설명한 것은 하나의 프로그램에서 여러 언어를 처리할 수 있도록 하기 위한 개념들이었고, 이를 다중 언어화라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 비슷한 개념으로 프로그램으 여러 요소를 지역의 관습에 맞추는 작업도 한다. 이것을 지역화(&lt;code&gt;localiszation&lt;/code&gt;)라고 한다. 예를 들어서, 메시지를 사용자가 원하는 언어로 표시하거나 날짜와 시간을 지역의 관습에 맞춰서 표시하는 경우이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 실행시에 해당 지역을 전환할 수 있게 하는 것을 국제화(&lt;code&gt;internationalization&lt;/code&gt;)라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 언어에선 국제화의 기본 구조는 &lt;code&gt;로케일(locale)&lt;/code&gt; 이다. 국가, 언어, 문자의 조합이 로케일이며, 예를 들면 한글 &lt;code&gt;UTF-8&lt;/code&gt;의 경우 &lt;code&gt;ko_KR.UTF-8&lt;/code&gt; 로케일을 사용한다. &lt;code&gt;ko&lt;/code&gt;가 한글, &lt;code&gt;KR&lt;/code&gt;이 한국이라는 지역, &lt;code&gt;UTF-8&lt;/code&gt;이 유니코드를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다중언어-처리와-국제화를-위한-라이브러리&#34;&gt;다중언어 처리와 국제화를 위한 라이브러리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;국제화와 다중 언어 문자열 처리에 사용할 수 있는 라이브러리 몇 가지를 소개한다.&lt;/p&gt;
&lt;h4 id=&#34;libc-로케일-매커니즘&#34;&gt;&lt;code&gt;libc&lt;/code&gt; 로케일 매커니즘&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setlocale()&lt;/code&gt;이 로케일의 기본 API이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;libc-와이드-문자-관련-루틴wchar&#34;&gt;&lt;code&gt;libc&lt;/code&gt; 와이드 문자 관련 루틴(wchar)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libc&lt;/code&gt; 에서는 ANSI &lt;code&gt;C&lt;/code&gt;로 규정되어 있는, 와이드 문자용 &lt;code&gt;API&lt;/code&gt;가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;iconv&#34;&gt;&lt;code&gt;iconv&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iconv&lt;/code&gt;문자 코드 간 상호 변환을 위해 사용하는 라이브러리이다. 예를 들면, &lt;code&gt;EUC-KR&lt;/code&gt;과 &lt;code&gt;UTF-8&lt;/code&gt;등의 변화를 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcreperl-compatible-regular-expression&#34;&gt;&lt;code&gt;PCRE(Perl Compatible Regular Expression)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PCRE(Perl Compatible Regular Expression)&lt;/code&gt;는 &lt;code&gt;UTF-8&lt;/code&gt;에 대응하는 정규 표현 라이브러리이다. 이장에서 소개한 &lt;code&gt;libc&lt;/code&gt; 정규 표현에 더하여 &lt;code&gt;Perl5&lt;/code&gt; 확장 정규 표현에도 대응한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HEAD 명령어 만들기</title>
      <link>https://dongwooklee96.github.io/post/2021/07/27/head-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</link>
      <pubDate>Tue, 27 Jul 2021 00:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/27/head-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HEAD 명령어를 만들어보자. &lt;code&gt;head&lt;/code&gt; 명령어는 파일의 처음 몇 줄만을 출력해주는 명령어이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래는 &lt;code&gt;head&lt;/code&gt; 명령어를 실행하는 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 5 file.c

cat file.c | head -n 5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위처럼 파일의 이름을 실행인자로 전달하면, 그 파일의 처음 몇 줄만을 출력한다. 또한 인자로 파일 이름을 지정하지 않은 경우에는 표준 입력에서 읽어서 출력하는데, 이와 같은 동작이 리눅스에서는 일반적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;headc&#34;&gt;&lt;code&gt;head.c&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 명령어는 비교적 간단한 프로그램이지만, 그렇다고 만만하지는 않다. 따라서 일부 기능만 포함된 버전을 만들고 조금씩 기능을 추가하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 단계적으로 기능을 추가해나가는 것이 일반적으로 프로그램을 만들 때 좋은 접근 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 초보자들은 처음부터 모든 기능을 다 구현하려다 보면 뒤죽박죽이 될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 처음에는 아주 쉬운 기능을 확실히 돌아가게 만들고 나서, 조금씩 기능을 덧붙여 나가는 것이 확실한 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

static void do_cat(const char *path);
static void die(const char *s);

int main(int argc, char *argv[]) {
  int i;
  if (argc &amp;lt; 2) {
    fprintf(stdout, &amp;quot;%s: file name not given\n&amp;quot;, argv[0]);
    exit(1);
  }
  for (i = 1; i &amp;lt; argc; i++) {
    do_cat(argv[i]);
  }
  exit(0);
}

#define BUFFER_SIZE 2048

static void do_cat(const char *path)
{
  int fd;
  unsigned char buf[BUFFER_SIZE];
  int n;

  fd = open(path, O_RDONLY);
  if (fd &amp;lt; 0) die(path);

  for (;;) {
    n = read(fd, buf, sizeof buf);
    if (n &amp;lt; 0) die(path);
    if (n == 0) die(path);
    if (write(STDOUT_FILENO, buf, n) &amp;lt; 0) die(path);
  }
  if (close(fd) &amp;lt; 0) die(path);
}

static void die(const char *s)
{
  perror(s);
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스트림과 관련 라이브러리 함수</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%95%A8%EC%88%98.html</link>
      <pubDate>Sat, 24 Jul 2021 16:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%95%A8%EC%88%98.html</guid>
      <description>&lt;h1 id=&#34;스트림-관련-라이브러리-함수&#34;&gt;스트림 관련 라이브러리 함수&lt;/h1&gt;
&lt;h3 id=&#34;stdio&#34;&gt;&lt;code&gt;stdio&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜만을 이용해서, 프로그램을 작성할 수 있지만, 시스템 콜만을 사용하여 더욱 복잡한 입출력 기능을 구현하려 한다면 다음과 같은 문제에 봉착하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫째, 시스템 콜은 바이트 단위로만 읽고 쓸 수 있다. 우리에게 더 익숙한 단위, 예를 들면 문자 단위나 줄 단위로 문자열을 처리할 수 있다면 더욱 편리할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째로 성능의 문제가 발생한다. 예를 들어서 10 바이트나 20바이트 단위로 &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 호출을 반복한다면 아무리 최신 컴퓨터로도 시간이 오래 걸릴 수 밖에 없다. 스트림에 연결된 장치에 따라서 다르지만, 대체로 &lt;code&gt;1KB&lt;/code&gt; 단위로 시스템 콜을 해야 효율적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 문제를 피해서 편리하게 사용할 수 있게 만들어진 것이 바로 표준 입출력 라이브러리(standard I/O library)이다. 줄여서 &lt;code&gt;stdio&lt;/code&gt; 라고 한다. &lt;code&gt;stdio&lt;/code&gt;는 &lt;code&gt;libc&lt;/code&gt;의 큰 비중을 차지하는 만큼 중요한 라이브러리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;버퍼링&#34;&gt;버퍼링&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stdio&lt;/code&gt;는 커널 수준의 스트림을 쉽게 사용할 수 있는 인터페이스를 제공한다. 예를 들어 바이트 단위로 읽고 쓰는 함수나, 줄 단위로 읽고 쓰는 함수를 제공한다. 또한 숫자나 문자열을 포맷에 맞게 출력하는 함수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜 &lt;code&gt;read()&lt;/code&gt;는 스트림에서 우리가 지정한 &lt;code&gt;buffer&lt;/code&gt;에 지정한 크기만큼 읽어 들이는 반면에, &lt;code&gt;stdio&lt;/code&gt;는 독자적인 버퍼를 사용한다. 여기서 버퍼란 일시적으로 데이터를 저장하는 장소를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 시스템 콜 &lt;code&gt;read()&lt;/code&gt;를 사용하여, 적당한 크기의 데이터를 버퍼에 읽어들이고, 프로그램에서 요구하는 만큼을 다시 반환해준다. 예를 들어 1바이트를 읽어 달라는 요청을 받으면 버퍼에서 1바이트만 다시 반환해준다. 이렇게 버퍼를 이용하여 데이터를 주고 받는 것을 버퍼링이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜로 1바이트를 연속해서 요청하면 속도가 안나는 반면에, &lt;code&gt;stdio&lt;/code&gt;를 사용한다면 성능의 저하 없이 바이트 단위로 읽는 것이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;버퍼링-모드&#34;&gt;버퍼링 모드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 쓸 때도 읽을 때와 마찬가지로 버퍼를 사용한다. 바이트 단위 또는 줄 단위의 데이터를 전달 받아 버퍼가 꽉 차면 시스템 콜 &lt;code&gt;write()&lt;/code&gt;를 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;예외&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그러나 몇가지 중요한 예외가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 스트림이 단말에 연결된 경우에는 버퍼가 가득찰 때까지 기다리지 않고
개행 (\n)을 만나는 시점에서 write()를 실행한다. 이유는, 반대편에 모니터와
같은 단말이 있다면 사람이 출력을 보고 있을 가능성이 높기 때문이다.
버퍼가 가득차기 까지는 오랜 시간이 걸릴 수도 있기 때문에 적절한 순간에
바로 출력해주는 것이 프로그램의 응답이 빨라지고 사용자의 사용성도 좋아진다.

2. 스트림이 비버퍼링 모드(unbuffered mode)로 되어 있는 경우이다. 비버퍼링 모드로 설정된 
stdio 스트림에 데이터를 쓰면 버퍼링 없이 즉시 write()가 수행된다. setvbuf()로 설정할 수 있다.

3. 표준 예외 출력에 해당하는 stderr에 대한 출력이다. stderr은 예외적으로 처음부터
비버퍼링 모드다. 그 이유는 표준 에러 출력의 경우 에러 메시지나 디버깅 정보를 출력하는데 사용되기 때문에 발생한 시점에서 바로 출력하는 것이 바람직하기 때문이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;file-타입&#34;&gt;FILE 타입&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜 레벨에서는 스트림을 지정하기 위해 파일 디스크립터라는 것을 사용했었다. 한편, stdio에서는 비슷한 역할을 하기 위해 &lt;code&gt;FILE&lt;/code&gt; 타입에 대한 포인터를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FILE&lt;/code&gt; 타입은 &lt;code&gt;typedef&lt;/code&gt;으로 정의되어 있어, 그 안에는 파일 디스크립터와 앞서 설명한 &lt;code&gt;stdio&lt;/code&gt; 버퍼의 내부 정보를 포함하고 있다. 라이브러리를 사용하는 입장에서는 &lt;code&gt;FILE&lt;/code&gt; 타입의 내부 구조를 몰라도 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdio의-표준-입출력&#34;&gt;stdio의 표준 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜을 사용할 때, 표준 입출력 스트림을 지정하기 위해 예약된 정수가 있었는데, &lt;code&gt;stdio&lt;/code&gt;에도 이에 대응하여, &lt;code&gt;FILE*&lt;/code&gt; 타입의 변수가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;파일 디스크립터&lt;/th&gt;
&lt;th&gt;정식 명칭&lt;/th&gt;
&lt;th&gt;stdio 변수명&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;STDIN_FILENO&lt;/td&gt;
&lt;td&gt;stdin&lt;/td&gt;
&lt;td&gt;표준 입력&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;STDOUT_FILENO&lt;/td&gt;
&lt;td&gt;stdout&lt;/td&gt;
&lt;td&gt;표준 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;STDERR_FILENO&lt;/td&gt;
&lt;td&gt;stderr&lt;/td&gt;
&lt;td&gt;표준 에러 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;fopen3&#34;&gt;&lt;code&gt;fopen(3)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;표준 입출력 이외의 스트림에 대한 &lt;code&gt;FILE&lt;/code&gt;을 여는 것도 물론 가능하다. 이때는 &lt;code&gt;fopen()&lt;/code&gt; 이라는 &lt;code&gt;API&lt;/code&gt;를 사용한다. 이것은 시스템 콜 &lt;code&gt;open()&lt;/code&gt;에 대응된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

FILE *fopen(const char *path, const char *mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fopen()&lt;/code&gt;은 첫 번째 인자 &lt;code&gt;path&lt;/code&gt;로 지정한 파일에 대한 스트림을 만들고 그것을 관리하는 &lt;code&gt;FILE&lt;/code&gt; 포인터를 반환한다. 만약 실패한 경우 &lt;code&gt;NULL&lt;/code&gt;을 리턴하고, 원인을 나타내는 상수를 &lt;code&gt;errno&lt;/code&gt;에 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 두 번째 인자인 &lt;code&gt;mode&lt;/code&gt;에는 다음과 같은 옵션을 지정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fclose3&#34;&gt;`fclose(3)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜 &lt;code&gt;open()&lt;/code&gt;에 대응하는 API가 &lt;code&gt;fopen()&lt;/code&gt;이라면 &lt;code&gt;close()&lt;/code&gt;에 대응하는 API는 &lt;code&gt;fclose()&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int fclose(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;문자열-입출력&#34;&gt;문자열 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일은 바이트의 연속이다. 그런데 그 바이트의 연속을 문자의 연속으로 본다면 파일은 곧 줄의 연속이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 시스템에서는 &amp;lsquo;줄&amp;rsquo;은 &lt;code&gt;&#39;\n&#39;&lt;/code&gt;를 기준으로 줄이 나뉜다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 파일의 마지막이나 스트림으로부터의 입력이 끝나는 지점에 &lt;code&gt;&#39;\n&#39;&lt;/code&gt;이 없어도 하나의 줄로 간주한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CAT 명령어 만들기 및 기타 시스템 콜</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/cat-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</link>
      <pubDate>Sat, 24 Jul 2021 05:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/cat-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</guid>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

static void do_cat(const char *path);
static void die(const char *s);

int main(int argc, char *argv[]) {
  int i;
  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;%s: file name not given\n&amp;quot;, argv[0]);
    exit(1);
  }
  for (i = 1; i &amp;lt; argc; i++) {
    do_cat(argv[i]);
  }
  exit(0);
}

#define BUFFER_SIZE 2048

static void do_cat(const char *path)
{
  int fd;
  unsigned char buf[BUFFER_SIZE];
  int n;

  fd = open(path, O_RDONLY);
  if (fd &amp;lt; 0) die(path);

  for (;;) {
    n = read(fd, buf, sizeof buf);
    if (n &amp;lt; 0) die(path);
    if (n == 0) die(path);
    if (write(STDOUT_FILENO, buf, n) &amp;lt; 0) die(path);
  }
  if (close(fd) &amp;lt; 0) die(path);
}

static void die(const char *s)
{
  perror(s);
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;파일-오프셋&#34;&gt;파일 오프셋&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터에 대해서 &lt;code&gt;read()&lt;/code&gt; 시스템 콜을 반복해서 호출하면 파일의 마지막에 도달하게 되는데 이것은 스트림이 마지막으로 읽은 파일의 위치를 기억하고 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉, 스트림은 파일의 특정 위치에 연결되어 있다. 이렇게 스트림이 연결되어 있는 위치를 &lt;strong&gt;파일 오프셋&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 오프셋은 스트림의 속성으로 시스템 콜을 사용해서 조작할 수 있다. 파일 오프셋을 조작하는 대표적인 시스템 콜이 &lt;code&gt;lseek()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lseek2&#34;&gt;&lt;code&gt;lseek(2)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
off_t lseek(int fd, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lseek()&lt;/code&gt;는 파일 디스크립터 내부의 파일 오프셋을 지정한 위치로 이동한다. 옮겨갈 위치를 지정하는 방식은 아래와 같고, 그것을 &lt;code&gt;whence&lt;/code&gt;라는 인자에 저장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;제목&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_SET&lt;/td&gt;
&lt;td&gt;파일의 처음을 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_CUR&lt;/td&gt;
&lt;td&gt;현재 위치 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_END&lt;/td&gt;
&lt;td&gt;파일의 마지막을 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;스트림의 반대편에 있는 실체에 따라서 &lt;code&gt;lseek()&lt;/code&gt;를 사용할 수 없는 경우도 있다. 예를 들어서 단말이나 프로세스에 연결된 스트림에 대해서는 &lt;code&gt;lseek()&lt;/code&gt;를 실행하면 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dup2-dup22&#34;&gt;dup(2), dup2(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int dup(int oldfd);
int dup2(int oldfd, int newfd);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dup()&lt;/code&gt;, &lt;code&gt;dup2()&lt;/code&gt;는 인자로 지정한 파일 디스크립터 &lt;code&gt;oldfd&lt;/code&gt;를 복제하는 시스템 콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ioctl2&#34;&gt;ioctl(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/ioctl.h&amp;gt;

int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ioctl()&lt;/code&gt;은 스트림이 연결된 디바이스에 특화된 작업을 모두 포함하는 시스템 콜이다. 예를 들어서 아래와 같은 작업을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;DVD 드라이브 여닫기, 음악 CD 재생
프린터 구동이나 일시정지
SCSI 디바이스 하드웨어 옵션 설정
단말 통신 속도 설정
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;자세한 내용은 메뉴얼에서 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man ioctl_list
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;fcntl2&#34;&gt;fcntl(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ioctl()&lt;/code&gt;의 기능 중에서 파일 디스크립터 관련 작업을 분리하려고 만들어 진 것이 &lt;code&gt;fnctl&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcnt.h&amp;gt;

int fcntl(int fd, int cmd, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;두번째 인자 &lt;code&gt;cmd&lt;/code&gt;에 실제로 수행하는 작업을 지정하고 지정한 작업에 따라서, 세번째 이후의 인자가 결정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스트림과 관련된 시스템 콜</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</link>
      <pubDate>Sat, 24 Jul 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</guid>
      <description>&lt;h3 id=&#34;스트림과-관련된-시스템-콜&#34;&gt;스트림과 관련된 시스템 콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에서 바이트 열을 읽는 &lt;code&gt;read&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;스트림에서 바이트 열을 쓰는 &lt;code&gt;write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;새로운 스트림을 생성하는 &lt;code&gt;open&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;사용 완료한 스트림을 닫는 &lt;code&gt;close&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-디스크립터&#34;&gt;파일 디스크립터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스에서 파일을 읽거나, 쓸 때 혹은 다른 프로세스와 데이터를 주고 받을 때 스트림을 사용한다고 했다. 그렇다면, 우리가 만든 프로그램에서 스트림을 사용하려면 어떻게 해야할까?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 위해서 &lt;strong&gt;파일 리스크립터(file desriptor)&lt;/strong&gt; 라는 것을 사용하는데, 커널이 스트림을 열 때 부여하는 번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널이 만들어준 스트림의 번호(파일 디스크립터)를 알아야 스트림을 본격적으로 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력-표준-출력-표준-에러-출력&#34;&gt;표준 입력, 표준 출력, 표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보통 셸을 통해서 프로세스가 생성되는 경우, 세 개의 스트림이 기본으로 생성되며, 이에 대한 파일 디스크립터 값이 미리 할당된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 새 개의 스트림이란 &lt;strong&gt;표준 입력(standard input)&lt;/strong&gt;, &lt;strong&gt;표준 출력(standard output)&lt;/strong&gt;, &lt;strong&gt;표준 에러 출력(standard error output)&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이들 스트림은 각각 파일 디스크립터 0번, 1번, 2번에 할당된다. 이 값에 대한 매크로도 준비되어 있는데 각각 &lt;code&gt;STDIN_FILENO&lt;/code&gt;, &lt;code&gt;STDOUT_FILENO&lt;/code&gt;, &lt;code&gt;STDERR_FILENO&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력과-표준-출력&#34;&gt;표준 입력과 표준 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 입력과 표준 출력을 잘 활용하면 리눅스 명령어를 조합하여 고도의 작업을 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 명령어를 파이프로 연결하여 데이터를 처리하는 것이 가능한 것도 각 명령어가 표준 입력에서 데이터를 읽어들이고, 처리 결과를 표준 출력에 쓰게 되어 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우의 &amp;lsquo;표준&amp;rsquo;은 &amp;lsquo;디폴트&amp;rsquo;에 가까운 의미이다. 표준 입력은 프로그램의 디폴트 입력 소스이며, 표준 출력은 디폴트 출력지라는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러개의 리눅스 명령어를 조합할 수 있는 것도 각 리눅스 명령어가 표준 입력에서 데이터를 읽고, 표준 출력에 쓰는 약속을 했기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-에러-출력&#34;&gt;표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 에러 출력은, 에러 메시지를 출력하기 위해서 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 표준 출력은 파이프라인을 통해서 다른 프로그램의 표준 입력에 연결된다. 따라서 에러 메시지를 표준 출력으로 내보내면 사람이 에러 발생을 알기 어렵게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 여분의 스트림을 준비해서 일반 메시지는 파이프라인을 통해 표준 출력으로 내보내고, 에러 메시지는 표준 에러 출력으로 출력하도록 한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;파일 디스크립터&lt;/th&gt;
&lt;th&gt;매크로&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준입력, 기본 입력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 출력, 기본 출력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 에러 출력, 별도 메시지 출력용&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;스트림-읽기-및-쓰기&#34;&gt;스트림 읽기 및 쓰기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 데이터를 읽고 쓰기 위해서 &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 라는 시스템 콜을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 바이트 열을 읽기 위해서 사용하는 시스템 콜이 &lt;code&gt;read()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;read2&#34;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t read(int fd, void *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 파일 디스크립터 번호인 &lt;code&gt;fd&lt;/code&gt;에 해당하는 스트림에서 바이트 열을 읽는 시스템 콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt;로 바이트 수를 읽어서 &lt;code&gt;buf&lt;/code&gt;에 기록한다. &lt;code&gt;buf&lt;/code&gt;의 크기는 &lt;code&gt;bufsize&lt;/code&gt;로 할당하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 읽기 작업이 완료되면 읽어들인 바이트 수를 반환한다. 그리고 파일의 끝에 도달한 경우에는 0을 반환하고, 중간에 에러가 발생한 경우에는 -1을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt; 바이트 수 보다 적은 바이트를 읽는 경우도 많으므로 반환값을 체크하도록 코딩해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C언어 문자열에는 임의의 바이트 열을 저장할 수 있지만, 일반적으로 문자열의
끝에는 &#39;\0&#39;을 넣는 것이 관례이다. API 중에도 문자열의 끝에 &#39;\0&#39;이 있다고
전체하는 것과 그렇지 않은 것이 있어서 사용에 주의 해야한다. 
예를 들어, 문자열의 끝에 &#39;\0&#39;이 있다고 전제하는 API에 &#39;\0&#39;로 끝나지 
않는 문자열을 전달하면 문제가 될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read&lt;/code&gt;의 경우에는 읽어들인 데이터의 끝에 &lt;code&gt;\0&lt;/code&gt;가 있다고 전제하지 않는 &lt;code&gt;API&lt;/code&gt;이다. 따라서 &lt;code&gt;read(2)&lt;/code&gt;를 통해서 읽어 들인 문자열의 끝에 &lt;code&gt;\0&lt;/code&gt;이 있다고 생각하고 코드를 작성해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;printf()&lt;/code&gt;의 경우에는 문자열의 끝에 &amp;lsquo;\0&amp;rsquo;이 들어가 있다고 전제하는 &lt;code&gt;API&lt;/code&gt; 이므로, &lt;code&gt;read(2)&lt;/code&gt;로 읽은 문자열을 그대로 &lt;code&gt;printf()&lt;/code&gt;로 전달하면 안된다. 이는 보안상의 취약점이 될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;write2&#34;&gt;&lt;code&gt;write(2)&lt;/code&gt;&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에 바이트 열을 쓸 때는 시스템 콜 &lt;code&gt;write()&lt;/code&gt;를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t write(int fd, const *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;는 인자로 지정한 &lt;code&gt;bufsize&lt;/code&gt; 바이트만큼, &lt;code&gt;buf&lt;/code&gt;의 내용을 &lt;code&gt;fd&lt;/code&gt;로 지정한 파일 디스크립터의 스트림에 쓴다. 반환값의 데이터 타입인 &lt;code&gt;ssize_t&lt;/code&gt;는 부호 있는 정수를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정상적으로 쓴 바이트 수를 반환하고 에러가 발생한 경우에는 &lt;code&gt;-1&lt;/code&gt;를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;가 &lt;code&gt;bufsize&lt;/code&gt;로 지정한 바이트 수만큼 쓸 수 없는 상황은 비교적 드물지만, 발생한 여지는 충분히 있다. 정확한 처리가 필요한 경우에는 반환값을 체크하도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스트림이란&#34;&gt;스트림이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림은 파일 디스크립터로 표현되고, &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 읽고 쓸 수 있다. 예를 들면, 파일을 &lt;code&gt;open()&lt;/code&gt;하면 &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 파일의 내용을 읽거나 쓸 수 있는데, 이것이 바로 스트림이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은 맥락에서 파이프라인이나, 소켓도 스트림으로 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-열기&#34;&gt;파일 열기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;프로세스가 만들어 질 때부터 사용할 수 있는 스트림으로는 표준 입력, 표준 출력, 표준 에러 출력이 있다. 이번에는 이 이외의 스트림을 만드는 방법에 대해서 알아보자.&lt;/p&gt;
&lt;h4 id=&#34;open2&#34;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;파일을 읽고 쓰는 스트림을 만들려면 시스템 콜 &lt;code&gt;open()&lt;/code&gt;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt;은 첫 번째 인자 &lt;code&gt;path&lt;/code&gt;로 지정한 경로의 파일에 대한 스트림을 만들고, 그 스트림을 가리키는 파일 디스크립터를 반환한다. 이러한 과정을 흔히 파일을 연다라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 인자인 &lt;code&gt;flags&lt;/code&gt;에서는 파일을 어떤 모드로 열 것인지 비트 연산자를 사용하여 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;파일을 열 때 사용할 수 있는 &lt;code&gt;flag(1)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;flag&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;쓰기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDWR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽고 쓰기&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;close2&#34;&gt;&lt;code&gt;close(2)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;사용이 끝난 스트림은 &lt;code&gt;close()&lt;/code&gt;로 닫는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int close(int fd);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;close&lt;/code&gt;는 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt;에 연결된 스트림을 해제한다. 이러한 처리를 파일을 닫는다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오류 없이 닫히면 &lt;code&gt;0&lt;/code&gt;, 에러가 발생하면 &lt;code&gt;-1&lt;/code&gt;를 반환한다. 일반적으로 &lt;code&gt;close()&lt;/code&gt;함수를 호출하는 코드는 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;if (close(fd) &amp;lt; 0) {
  /* 에러 처리 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료되면 사용하던 모든 스트림을 커널이 파기 하기 때문에, &lt;code&gt;close()&lt;/code&gt;를 하지 않아도 시스템에 이상이 생기지 않을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 사용이 완료된 스트림은 반드시 종료시켜주는 것이 좋다. 프로세스가 동시에 사용할 수 있는 스트림의 개수에 제한이 있기도 하고, 스트림의 반대편에 프로세스가 &lt;code&gt;close()&lt;/code&gt; 할 대까지 기다리고 있을 수도 있다. 모든 리소스는 사용이 완료되었을 때 닫아주는 것이 바람직하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (2) - 프로세스 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</link>
      <pubDate>Sun, 04 Jul 2021 01:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</guid>
      <description>&lt;h3 id=&#34;posix_spawn-계열-함수&#34;&gt;posix_spawn 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn(pid_t *restrict pid, const char *restrict path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);

int posix_spawnp(pid_t *restrict pid, const char *restrict file, cosnt posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞서 언급했듯이 &lt;code&gt;fork-exec&lt;/code&gt;는 부모 프로세스의 자원을 선택적으로 복제할 수 없으므로, 성능상의 문제와 추가적인 코딩이 복잡해지는 문제가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, &lt;code&gt;posix_spawn&lt;/code&gt; 계열에서는 부모 프로세스의 자원을 선택적으로 복제하거나, 다룰 수 있는 통합 인터페이스가 제안되었는데 이를 가능하게 하는 것이 바로 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수 부분에 &lt;code&gt;NULL&lt;/code&gt;을 지정하면, &lt;code&gt;fork-exec&lt;/code&gt;와 동일한 작동, 즉 부모 프로세스의 자원을 모두 복제한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawn&lt;/code&gt;도 기본적으로는 부모 프로세스가 열었던 파일은 모두 상속 받는다. 만약 추가로 열어야하는 파일이 있거나, 기존에 열은 파일을 닫아야 할 필요가 있는 경우에는 &lt;code&gt;file_actions&lt;/code&gt; 매개변수를 이용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawn_file_actions_t-구조체-조작&#34;&gt;posix_spawn_file_actions_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_destroy(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict file_actions, int fildes, const char *restrict path, int oflag, mode_t mode);
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes);
int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;spawn.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
	int ret_err = 0;
	pid_t pid_child;
	char buf_err[64];
	posix_spawn_file_actions_t posix_faction; /* file action struct */
	char *argv_child[] = { &amp;quot;forkexec_child&amp;quot;, NULL };
	printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());

	if((ret_err = posix_spawn_file_actions_init(&amp;amp;posix_faction)) != 0) { /* init */
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_init :%s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	if ((ret_err = posix_spawn_file_actions_addopen(&amp;amp;posix_faction, 3,
					&amp;quot;pspawn.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0664 )) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_addopen: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	ret_err = posix_spawn(&amp;amp;pid_child,
			argv_child[0],
			&amp;amp;posix_faction,
			NULL,
			argv_child,
			NULL);

	if ((ret_err = posix_spawn_file_actions_destroy(&amp;amp;posix_faction)) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_destory: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	printf(&amp;quot;Parent[%d]: Wait for child(%d)\n&amp;quot;, getpid(), (int)pid_child);
	(void)wait(NULL);
	printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;메모리를 해제하는 부분을 유의해서 보자, 예제에서는 한번 실행되고 곧바로 종료되기 때문에, 해제하지 않아도 메모리 누수를 신경 쓸 필요가 없지만, 연속적으로 실행되는 실무 프로그램에서는 민감한 문제이므로, 꼭 메모리 해제에 신경을 써야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawnattr_t-구조체-조작&#34;&gt;posix_spawnattr_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawnattr_init(posix_spawnattr_t *attr);
int posix_spawnattr_destroy(posix_spawnattr_t *attr);

int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt; 구조체는 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt;로 초기화를 한 뒤에 사용해야만 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 사용이 끝난 구조체는 &lt;code&gt;posix_spawnattr_destroy()&lt;/code&gt;로 메모리를 해제해야 누수가 발생하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 메모리를 해제한 후에, 다시 사용할 필요가 있다면, 다시 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt; 로 초기화를 한 후에 사용하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt;에는 &lt;code&gt;EUID&lt;/code&gt;, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러를 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이중에서 &lt;code&gt;EUID&lt;/code&gt; 설정을 제외한 나머지 기능들은 해당 속성의 &lt;code&gt;on/off&lt;/code&gt;를 의미하는 플래그를 설정하고 개별적으로 속성을 등록하는 함수를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (1) - 프로세스 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</link>
      <pubDate>Sat, 03 Jul 2021 11:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</guid>
      <description>&lt;h3 id=&#34;프로세스&#34;&gt;프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전통적인 프로세스를 복제하는 방법은 &lt;code&gt;fork&lt;/code&gt;를 사용하는 방법이다. 이때 복제할 프로세스를 부모 프로세스라고 하고, 새롭게 복제된 프로세스를 자식 프로세스라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스를 복제하는 이유는 멀티 태스킹을 위해서이다. 싱글 스레드에서, 3개의 태스크, &lt;code&gt;A, B, C&lt;/code&gt;를 실행하는 구조를 멀티 프로세스 구조로 바꾸면 3개의 복제된 자식 프로세스에 일임하는 형식으로 분리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복제된 프로세스는 부모 프로세스와 독립적으로 작동하기 때문에, 복수개의 CPU가 설치된 경우에는 매우 뛰어난 응답성과 성능을 보여줄 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 복제된 프로세스 사이에 데이터를 주고 받는 구조이고, 데이터 통신 처리에 비용이 크다면 오히려 성능 하락이 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 복제가 많이 쓰이는 경우로, 셸(&lt;code&gt;SHELL&lt;/code&gt;)이 있다. 셸에서 &lt;code&gt;ls&lt;/code&gt; 명령을 실행한다고 가정할 때, 셸은 명령어를 받아들인 후에, &lt;code&gt;fork&lt;/code&gt;를 하여 자식 프로세스를 만든다. 그 후에 바로 &lt;code&gt;exec&lt;/code&gt;를 호출하여 &lt;code&gt;bin/ls&lt;/code&gt; 프로그램 이미지로 교체하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;확장된-프로세스-실행-방법&#34;&gt;확장된 프로세스 실행 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 프로세스 실행 방법이 있는데, 이 방법은 기존의 &lt;code&gt;fork-exec&lt;/code&gt;를 대체할 수 있는 기능으로서 더 가볍고 빠른 실행을 위해서 제안되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 &lt;code&gt;fork-exec&lt;/code&gt; 구조에서는 &lt;code&gt;fork&lt;/code&gt;에서 부모 프로세스를 복제할 때, 모든 정적 정보를 복제한다. 예를 들어서 부모 프로세스의 힙 메모리, 정적 메모리, IPC 자원 ID, 열린 파일, 시그널 마스크 등이 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 &lt;code&gt;fork&lt;/code&gt;를 하고 나서, 곧바로 &lt;code&gt;exec&lt;/code&gt;를 호출하는 경우에는 대부분 부모 프로세스의 열린 파일이나, &lt;code&gt;IPC&lt;/code&gt; 자원을 사용하지 않는 경우가 많다. 따라서 사용하지 않는 자원을 복제하는 오버헤드가 존재한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 한두 개의 프로세스가 저런 오버헤드를 가진다고 해도 시스템에 큰 문제가 없지만, 대형 시스템에서 엄청난 수의 프로세스가 실행되거나, 실시간 처리가 중요한 서비스라면 더더욱 큰 문제가 될 수 있다. 따라서 &lt;code&gt;posix_spawn&lt;/code&gt;에서는 부모 프로세스의 자원 중 6가지(&lt;code&gt;열린 파일, 프로세스 그룹 ID, 유저 및 그룹 ID, 시그널 마스크, 스케줄링&lt;/code&gt;)의 자원을 선택적으로 복제 및 관리할 수 있도록 디자인 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fork&#34;&gt;fork()&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; 호출이 성공하면 프로세스가 복제되어 2개가 되고, 리턴값으로 정수인 &lt;code&gt;pid_t&lt;/code&gt; 타입을 리턴한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 리턴 값은 3가지의 반환 형태를 가지며 각각에 따라서 처리 방법을 다르게 코딩해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0 -&amp;gt; 자식 프로세스에게 리턴되는 값
양수 -&amp;gt; 부모 프로세스에게 리턴되며, 자식 프로세스의 PID를 의미한다.
-1 -&amp;gt; 에러, 복제 실패
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 다음과 같이 0인 경우에는, 자식 프로세스가 실행할 부분을 코딩하고 양수인 부분은 부모 프로세스가 실행할 부분으로 코딩한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 &lt;code&gt;fork()&lt;/code&gt;를 사용하면 하나의 소스코드에 부모와 자식 프로세스의 코드가 같이 들어가게 된다. 그리고 부모 프로세스에는 자식 프로세스의 종료를 기다리기 위해서 &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;waitpid&lt;/code&gt;를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;switch (ret = fork()) {
  case 0:
    do_child(); /* 자식 프로세스인 경우에 실행될 코드 */
    break;
  case -1: /* 에러가 난 경우 */
    do_errorcatc();
    break;
  default: /* 양수는 부모 프로세스이며 ret에 자식 프로세스의 PID가 저장됨 */
    do_parent();
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 위와 같이 부모 프로세스가 실행할 부분과, 자식 프로세스가 실행할 부분을 나누어서 코딩할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의할 점은 &lt;code&gt;fork()&lt;/code&gt; 를통해서 자식 프로세스가 분기하는 구조를 제대로 만들지 않으면 이상한 현상이 발생할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int main() {
  int i = 0;
  pid_t ret;

  for (i = 0; i &amp;lt; 3; i++) {
    ret = fork();
    printf(&amp;quot;[%d] PID(%d) PPID(%d)\n&amp;quot;, i, getpid(), getppid());
#ifndef OMIT_SWITCH
    switch (ret) {
      case 0:
        pause();
        return 0;
      case -1:
        break;
      default:
        break;
    }
#endif
  }
  wait(NULL);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 코드를 보면, 전처리기 분기문 처리가 되어있어, &lt;code&gt;OMIT_SWITCH&lt;/code&gt; 매크로가 정의되어 있지 않는다면, 같이 빌드되는 부분이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DOMIT_SWITCH _Wall -o fork_omit_swich fork_process.c 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위와 같이 매크로를 같이 빌드하면, 전처리기 분기문 처리가 빌드되지 않는다. 그리고 나서 프로그램을 실행하면 다음과 같은 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/124343414-2d213e80-dc06-11eb-93b1-7e6ba63954b7.png&#34; alt=&#34;result&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;총 7개의 프로세스가 실행되는 것을 확인할 수 있는데, 부모 프로세스에서 총 3개의 자식 프로세스를 생성하고, 또한 그 자식 프로세스들이 자식 프로세스를 생성하는 구조로 이루어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;exec3-계열-함수&#34;&gt;exec(3) 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열 함수는 현재 실행중인 프로세스의 이미지를 새로운 프로세스 이미지로 대체한다. 즉 쉽게 이야기하면 현재 프로세스에 실행중인 프로그램 파일을 로딩한다는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 이미지가 대체되면 프로세스의 실행코드는 교체되지만, 기본적인 &lt;code&gt;PID&lt;/code&gt;, &lt;code&gt;PPID&lt;/code&gt;, 파일 기술자등 프로세스의 정보는 유지된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열의 첫 번째 인수는 실행되어야 하는 프로그램 파일로서절대 경로나 상대 경로를 사용할 수 있다. 만일 경로가 생략되고 파일 명만 넣으면 &lt;code&gt;execl, execle, execv, execve&lt;/code&gt;는 현재 작업 디렉터리에서 실행되어야 하는 프로그램 파일을 찾고, &lt;code&gt;execlp, exevcp&lt;/code&gt;는 환경 변수에 등록된 디렉터리를 검색하여 실행되어야 하는 프로그램 파일을 찾는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;execl&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;arg&lt;/code&gt; 라는 이름을 쓰고, &lt;code&gt;execv&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;argv&lt;/code&gt;를 사용하는 것을 알 수 있다. 이들의 차이는 execl&lt;code&gt;계열은 실행할 파일의 인수 목록을 리스트로 받기 때문에 가변 인수 리스트를 가진다. 따라서 인수 리스트의 마지막을 알아내기 위해서 맨 끝은&lt;/code&gt;NULL`로 끝내야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;execl 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
execlp(&amp;quot;ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;execv 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execv(&amp;quot;/bin/ls&amp;quot;, argv_exec);

char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execvp(&amp;quot;ls&amp;quot;, argv_exec);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;이 경우에는 기존의 환경변수는 모두 초기화되고 새로 넣은 환경 변수 벡터가 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
  if (execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL) == -1) {
    perror(&amp;quot;excel&amp;quot;);
  }
  printf(&amp;quot;+ arfter execl\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 예제는 작동에는 문제가 없지만, 설계상의 의문이 있는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;왜냐하면, &lt;code&gt;execl&lt;/code&gt; 실행되면서 &lt;code&gt;ls&lt;/code&gt;로 프로세스 이미지를 교체하기 때문에 이후 &lt;code&gt;+ after execl&lt;/code&gt; 메시지는 화면에 출력될 일이 없기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상속되지-않는-파일-기술자&#34;&gt;상속되지 않는 파일 기술자&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로는 &lt;code&gt;exec&lt;/code&gt;는 부모 프로세스의 파일 기술자를 복제한다.&lt;/li&gt;
&lt;li&gt;하지만, 부모 프로세스가 &lt;code&gt;fork&lt;/code&gt;를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플레그를 지정하면 &lt;code&gt;exec&lt;/code&gt;가 실행될 때 해당 파일 기술자는 닫히게 된다. 이를 &lt;code&gt;close-on-exec&lt;/code&gt;라고 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;forkexec_parent.c&lt;/em&gt;*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
  pid_t pid_child;
  printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());
  int fd = open(&amp;quot;forkexec.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0644);

  if (fd == -1) {
    perror(&amp;quot;FAIL: open&amp;quot;);
    exit(EXIT_FAILURE);
  }

  dprintf(fd, &amp;quot;Parent[%d]: Open log file(fd=%d)\n&amp;quot;, getpid(), fd);

#ifdef APPLY_FD_CLOEXEC
  int ret_fcntl;
  if ((ret_fcntl = fcntl(fd, F_SETFD, FD_CLOEXEC)) == -1) {
    perror(&amp;quot;FAIL: fcntl(F_SETFD, FD_CLOEXEC)&amp;quot;);
    exit(EXIT_FAILURE);
  }
#endif

  /* fork-exec code */
  char *argv_exec[] = {&amp;quot;fork_exec_child&amp;quot;, (char*) NULL};

  switch ((pid_child = fork())) {
    case 0: /* child process */
      execv(argv_exec[0], argv_exec);
      break;
    case -1: /* error */
      perror(&amp;quot;FAIL: FORK&amp;quot;);
      break;
    default: /* parent process */
      wait(NULL);
      break;
  }
  printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;forkexec_child.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Start\n&amp;quot;, getpid());
  dprintf(3, &amp;quot;Child[%d]: fd(3): Test fd.\n&amp;quot;, getpid());
  close(3);
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음은 부모 프로세스에서, 파일을 생성하고 기록하고 있다. 그리고 나서, 자식 프로세스에서 파일 디스크립터를 받고 종료하는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;생성된 파일을 살펴보면 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Parent[5935]: Open log file(fd=3)
Child[5936]: fd(3): Test fd.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;하지만, 부모 프로세스를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그를 지정하면, 해당 파일 기술자는 닫히게 된다. 따라서 이를 위해서 &lt;code&gt;APPLY_FD_CLOEXEC&lt;/code&gt; 매크로를 정의하고 빌드를 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DAPPLY_FD_CLOEXEC -o forkexec_parent_fdcloexec forkexec_parent.c
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Parent[6014]: Open log file(fd=3)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매크로를 정의하고 나서는, 부모 프로세스가 자식 프로세스에게 파일 기술자를 상속하지 않으므로, &lt;code&gt;forkexec.log&lt;/code&gt; 파일에 자식 프로세스에는 기록되지 않았음을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론적으로는 &lt;code&gt;fork-exec&lt;/code&gt;를 이용할 때, 자식 프로세스가 사용하지 않는 파일이 복제되는 오버헤드를 피하고 싶다면 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그 사용을 고려하는 것이 좋다. 하지만 더 근본적인 방법으로는 &lt;code&gt;fork-exec&lt;/code&gt; 대신에 &lt;code&gt;posix_spawn&lt;/code&gt;을 사용하는 것이 더 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;system-함수&#34;&gt;system 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system&lt;/code&gt; 함수는 셸을 실행시켜서 명령어를 실행하는 기능으로서, &lt;code&gt;fork-exec&lt;/code&gt;를 간단하게 구현한 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 중요한 차이가 있는데, &lt;code&gt;system&lt;/code&gt;은 실행 명령어가 작동되는 동안에 부모 프로세스가 잠시 정지되고, 자식 프로세스의 정지, 종료 상태를 통보해주는 &lt;code&gt;SIGCHILD&lt;/code&gt;도 블록되고 종료 시그널인 &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGQUIT&lt;/code&gt; 시ㅋ그널도 무시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 중요 시그널이 블록킹 되어, 종종 부모 프로세스가 무한 대기 상태에 빠지는 경우가 발생할 수 있으므로, 정말로 간단한 경우가 아니라면 &lt;code&gt;fork-exec&lt;/code&gt;로 구현하는 것을 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (0) - 서문</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</link>
      <pubDate>Sat, 03 Jul 2021 11:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</guid>
      <description>&lt;h3 id=&#34;서문&#34;&gt;서문&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;책의 서문에서는 코딩이란 예술의 경지이기 때문에 반복해서 사용함으로써 익숙해지고, 좋은 경험을 토대로 새로운 것을 깨닫게 해준다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 수 많은 이론을 머리에 채워넣었다고 하더라도, 절대적으로 코딩을 해본 경험이 적다면, 반쪽 짜리 프로그래머가 될 수 밖에 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이론만 배우고 끝나는 것이 아니라, 실제로 코딩을 하면서 손에 익을 때까지 코딩을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;리눅스의-표준-및-역사&#34;&gt;리눅스의 표준 및 역사&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리눅스가 표준 안을 가지기 전까지, 많은 파생된 버전이 있었다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에일리어싱과-restric-포인터&#34;&gt;에일리어싱과 RESTRIC 포인터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 어떤 한 공간에 대해 복수개의 접근 경로가 있는 경우를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 C언어에서, 중요한 역할을 담당하고 있으며, 가독성 향상이나, 형변환을 위해서 사용되지만 때때로, 최적화를 방해하거나, 문제를 일으킬 소지가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몇몇 함수들은 인수로 받아들이는 주소가 에일리어싱 되었을 때 오류를 방지하기 위해 미리 검사하는 행위 때문에 성능 저하가 발생하기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 함수 인수가 다른 곳에서 참조하지 않음을 보장해준다면 내부적으로 병렬처리를 하거나, 에일리어싱에 대한 검사를 하지 않아도 되므로 상당히 효율적으로 함수를 설계할 수 있고 이를 위해서 &lt;code&gt;restrict&lt;/code&gt; 포인터가 도입되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;restrict&lt;/code&gt; 포인터는 &lt;code&gt;restrict&lt;/code&gt; 포인터가 가리키는 객체를 다른 공간에서 에일리어싱 하지 않도록 강제를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void *memcpy(void *dest, const void *src, size_t n);
void *memcpy(void *restrict s1, const void *restrict s2, size_t n);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서, 상위에 있는 &lt;code&gt;memcpy&lt;/code&gt; 함수는 과거에 사용되던 함수의 원형이고, 아래쪽 &lt;code&gt;memcpy&lt;/code&gt;는 C99 이후에, 적용되는 함수의 원형이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새롭게 적용된 &lt;code&gt;memcpy&lt;/code&gt; 에서는 사용자가 &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;의 접근이 비순차, 비동기적으로 진행되거나 병렬처리 될 수도 있음을 암시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int *p_num, *p_alias;
p_num = (int *) malloc(sizeof(int) * 100);
p_alias = p_num + 20; /* 에일리어싱 되었음 */
memcpy(p_num, p_alias, sizeof(int) * 50);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서 &lt;code&gt;p_num&lt;/code&gt;, &lt;code&gt;p_alias&lt;/code&gt;는 에일리어싱 되었으므로, &lt;code&gt;restict&lt;/code&gt; 포인터 룰을 위반한 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 사이드 이펙트의 발생 가능성이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
