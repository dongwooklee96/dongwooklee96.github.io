<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>디자인 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EB%94%94%EC%9E%90%EC%9D%B8.html</link>
    <description>Recent content in 디자인 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 10 Nov 2021 21:06:33 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EB%94%94%EC%9E%90%EC%9D%B8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>파이썬으로 살펴보는 아키텍처 패턴 - 4장</title>
      <link>https://dongwooklee96.github.io/post/2021/11/10/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-4%EC%9E%A5.html</link>
      <pubDate>Wed, 10 Nov 2021 21:06:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/10/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-4%EC%9E%A5.html</guid>
      <description>&lt;h3 id=&#34;서비스-계층-소개&#34;&gt;서비스 계층 소개&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;플라스크 앱이 하는 일을 살펴보면, 오케스트레이션이라고 부르는 요소가 상당 부분을 차지한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오케이스트레이션은 저장소에서 여러 가지를 가져오고, 데이터베이스 상태에 따라서 입력을 검증하여 오류를 처리하고, 성공적인 경우에는 데이터베이스에 커밋하는 작업을 포함한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import model
from model import OrderLine
from repository import AbstractRepository


class InvalidSku(Exception):
    pass


def is_valid_sku(sku, batches):
    return sku in {b.sku for b in batches}

def allocate(line: OrderLine, repo: AbstractRepository, session) -&amp;gt; str:
    batches = repo.list()
    if not is_valid_sku(line.sku, batches):
        raise InvalidSku(f&#39;Invalid sku {line.sku}&#39;)
    batchref = model.allocate(line, batches)
    session.commit()
    return batchref
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;서비스 계층에서는 다음과 같이, 예외처리를 하거나 커밋을 데이터베이스 커밋을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@flask.route.gubbins
def allocate_endpoint():
    session = get_session()
    repo = repository.SqlAlchemyRepository(session)
    line = model.OrderLine(
        request.json[&#39;orderid&#39;],
        request.json[&#39;sku&#39;],
        request.json[&#39;qty&#39;],
    )
    try:
        batchref = services.allocate(line, repo, session)
    except (model.OutOfStock, services.InvalidSku) as e:
        return jsonify({&#39;message&#39;: str(e)}), 400
    return jsonify({&#39;batchref&#39;: batchref}), 201
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;엔드 포인트에서 좀 더 간단해진 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;엔드포인트에서는 요청전 상태를 관리하고 파라미터로부터 정보를 파싱하여 상태코드를 응답하고 JSON을 처리하는 역할을 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 오케이스트레이션 로직은 유지 케이스 / 서비스 계층에 들어가고, 도메인 로직은 도메인에 그대로 남는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도메인-서비스와-서비스-계층의-차이&#34;&gt;도메인 서비스와 서비스 계층의 차이&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;서비스-계층&#34;&gt;서비스 계층&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서비스는 외부 세계에서 오는 요청을 처리해서 연산을 오케스트레이션한다. 즉 서비스 계층은 데이터베이스에서 데이터를 얻거나, 도메인 모델을 업데이트 하거나, 변경된 내용을 영속화 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 시스템에서 어떤 연산이 일어날 때마다 해야하는 지루한 작업이며 비즈니스 로직과 분리하면 프로그램을 깔끔하게 유지하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;도메인-서비스&#34;&gt;도메인 서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;도메인 서비스는 도메인 모델에 속하지만 근본적으로 상태가 있는 엔티티나 값 객체에 속하지 않는 로직을 부르는 이름이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를들어서 쇼핑 카트 애플리케이션을 만든다면 도메인 서비스로 세금 관련 규칙을 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세금을 계산하는 작업은 쇼핑 카트를 업데이트하는 작업과는 별개이다. 모델에서 중요한 부분이지만, 세금만을 위한 영속적인 엔티티를 사용하는 것은 바람직하지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서비스 계층을 추가하면 다음과 같은 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;플라크스 API 엔드포인트가 아주 얇아지고 작성하기 쉬워진다. 플라스크 API 엔드 포인트는 오직 JSON 파싱이나 정상 경로나 비정상 경로에 따른 올바른 HTTP 코드 반환등의 &amp;lsquo;웹 기능&amp;rsquo;만 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도메인에 대한 명확한 API를 정의하였다. 이런 API는 자신이 API인지 CLI인지 심지어 테스트인지에 관계없이 어댑터가 도메인 모델 클래스를 몰라도 사용할 수 있는 유스케이스나 진입점 집합이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 계층을 사용하면 테스트를 &amp;lsquo;높은 기어비&amp;rsquo;로 작성할 수 있고 도메인 모델을 적합한 형태로 마음껏 리팩터링할 수 있다. 서비스 계층을 활용하면 같은 유스케이스를 제공할 수 있는 한 이미 존재하는 수 많은 테스트를 재작성하지 않고도 새로운 설계를 테스트할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작성한 테스트의 피라미드 구조도 좋아보인다. 테스트 상당 부분은 빠른 단위 테스트이며 E2E나 통합 테스트는 최소화 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=271944317&amp;amp;start=slayer&#34;&gt;파이썬으로 살펴보는 아키텍처 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬으로 살펴보는 아키텍처 패턴 - 2장</title>
      <link>https://dongwooklee96.github.io/post/2021/11/09/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-2%EC%9E%A5.html</link>
      <pubDate>Tue, 09 Nov 2021 21:06:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/09/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-2%EC%9E%A5.html</guid>
      <description>&lt;h3 id=&#34;저장소-패턴-소개&#34;&gt;저장소 패턴 소개&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;저장소 패턴은 영속성 저장소를 추상화 한 것이다. 저장소 패턴은 모든 데이터가 메모리상에 존재하는 것 처럼 가정하여 데이터 접근과 관련된 지루한 세부 사항을 감춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 간단한 저장소에는 메서드가 두 가지 밖에 없다. &lt;code&gt;add()&lt;/code&gt;는 새 원소를 저장소에 추가하고, &lt;code&gt;get()&lt;/code&gt;은 이전에 추가한 원소를 저장소에서 가져온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도메인 서비스 계층에서 데이터에 접근할 때는 엄격하게 이 두가지 메서드만 사용할 수 있다. 이렇게 단순성을 강제로 유지하면 도메인 모델과 데이터베이스 사이의 결합을 끊을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;from collections import abc

import model


class AbstractRepository(abc.ABC):

    @abc.abstractmethod
    def add(self, batch: model.Batch):
        raise NotImplementedError

    @abc.abstractmethod
    def get(self, reference) -&amp;gt; model.Batch:
        raise NotImplementedError

class SqlAlchemyRepository(AbstractRepository):
    def __init__(self, session):
        self.session = session

    def add(self, batch):
        self.session.add(batch)

    def get(self, reference):
        return self.session.query(model.Batch).filter_by(reference=reference).one()

    def list(self):
        return self.session.query(model.Batch).all()
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;따라서 이런 형태의 코드가 나올 것이다. 스프링에서 &lt;code&gt;JPA&lt;/code&gt;를 사용할 때 &lt;code&gt;repository&lt;/code&gt; 코드와 매우 닮아 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;트레이드오프&#34;&gt;트레이드오프&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DDD와 의존성 역전이라는 경로를 택한 이상 저장소 패턴은 이 책에서 나열한 패턴 중에서도 가장 채택하기 쉬운 패턴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드만 고려한다면 저장소 패턴은 단지 &lt;code&gt;SQLAlchemy&lt;/code&gt; 추상화 (&lt;code&gt;session.query(Batch)&lt;/code&gt;)를 우리가 직접 설계한 다른 추상화 (&lt;code&gt;batches_repo.get&lt;/code&gt;)로 바꿔치기 한 것 밖에 되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;테스트에-사용하는-가짜-저장소를-쉽게-만드는-방법&#34;&gt;테스트에 사용하는 가짜 저장소를 쉽게 만드는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;class FakeRepository(AbstractRepository):

    def __init__(self, batches):
        self._batches = set(batches)

    def add(self, batch):
        self._batches.add(batch)

    def get(self, reference):
        return next(b for b in self._batches if b.reference == reference)

    def list(self):
        return list(self._batches)

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 클래스가 &lt;code&gt;set()&lt;/code&gt;을 감싸는 간단한 래퍼이므로 모든 메서드는 한줄로 끝난다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fake_repo = FakeRepository([batch1, batch2, batch3])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추상화를 대신하는 가짜 객체를 만드는 것은 설계에 대한 피드백을 얻는 아주 좋은 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가짜 객체를 만들기 어렵다면 추상화를 너무 복잡하게 설계했기 때문일 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;저장소-패턴-정리&#34;&gt;저장소 패턴 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ORM에 의존성 역전을 적용하자, 도메인 모델은 인프라에 대해서 걱정할 필요가 없어야 한다. ORM은 모델을 임포트해야 하며 모델이 ORM을 임포트해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;저장소 패턴은 영속성 저장소에 대한 단순한 추상화다. 저장소는 컬렉션이 메모리 상에 있는 개체라는 환상을 제공한다. 저장소를 사용하면 핵심 애플리케이션에는 영향을 미치지 않으면서 인프라를 이루는 세부 구조를 변경하거나 목 저장소를 쉽게 작성할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=271944317&amp;amp;start=slayer&#34;&gt;파이썬으로 살펴보는 아키텍처 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬으로 살펴보는 아키텍처 패턴 - 1장</title>
      <link>https://dongwooklee96.github.io/post/2021/11/09/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-1%EC%9E%A5.html</link>
      <pubDate>Tue, 09 Nov 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/11/09/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-1%EC%9E%A5.html</guid>
      <description>&lt;pre&gt;&lt;code&gt;- 대부분의 개발자가 새로운 시스템을 설계하라는 요청을 받으면, 즉시 데이터베이스 스키마를 그리기 시작하고, 그 다음에 객체 모델을 생각한다. 여기서부터 모든 것이 잘못되기 시작한다...
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이에 매우 공감한다. 그 이유는 대학교 졸업 작품을 이런식으로 설계해봤기 때문에 얼마나 비효율적이고 수정이 많이 발생하는지 느꼈기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 아닌 경우도 있지만 대부분 객체를 만들고 저장에 대한 요구사항은 행동에 맞춰서 정의하는 편이 더 나았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 책에서는 아래 4가지의 핵심 설계 패턴을 소개한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 저장소 패턴은 영속적인 저장소에 대한 추상화를 한다.
2. 서비스 계층 패턴은 유스케이스의 시작과 끝을 명확하게 정의하기 위한 패턴이다.
3. 작업 단위 패턴은 원자적 연산을 제공한다.
4. 애그리게이트 패턴은 데이터 정합성을 강화하기 위한 패턴이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;값-객체와-엔티티&#34;&gt;값 객체와 엔티티&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;값 객체는 값들이 실제로 어떤 역할을 하는지에 대해서 실세계에서 갖는 직관과 부합한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 10 파운드를 말할 때 10 파운드라는 값(가치)가 중요하지 어떤 지폐인지는 중요하지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서는 아래와 같이 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@dataclass&lt;/span&gt;(fronzen&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Money&lt;/span&gt;:
    currency: str
    value: str


&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Money&lt;/span&gt;(NamedTuple):
    currency: str
    value: int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그와 반대로, 오래동안 정체성이 존재하는 도메인 객체를 설명할 때는 엔티티라는 용어를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람인 경우에는 자신의 이름이나 결혼 상태를 바꿀 수 있으며 심지어는 성별도 바꿀 수 있다. 하지만 이러한 변경에도 불구하고 모두 같은 사람으로 계속 인식 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람은 이름과 다르게 영속적인 정체성이 있다. 따라서 엔티티에는 정체성 동등성이라는 특징이 있다. 이는 엔티티의 값을 바꾸더라도, 바뀐 엔티티는 이전과 같은 엔티티로 인식된다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Batch&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __eq__(self, other):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; isinstance(other, Batch):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; other&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;reference &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;reference

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __hash__(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; hash(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;reference)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;값 객체의 경우에는, 모든 값 속성을 사용하여 해시를 정의하고 객체를 반드시 불변 객체로 만들어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 클래스에 대해서 &lt;code&gt;@frozen=True&lt;/code&gt;를 지정하면 공짜로 이런 동작을 얻을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;엔티티의 경우, 가장 단순한 선택은 해시를 &lt;code&gt;None&lt;/code&gt;으로 지정하는 것이다. 이 객체에 대해서 해시를 계산할 수 없고 따라서 그에 따라서 집합 등에서 사용할 수 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정한 이유로 엔티티를 집합(&lt;code&gt;SET&lt;/code&gt;)에 넣거나 딕셔너리(&lt;code&gt;DICT&lt;/code&gt;)의 키로 사용해야 한다면 시간과 무관하게 엔티티의 정체성을 식별해주는 속성을 사용하여 해시를 정의해야 한다. 그리고 어떻게 든 이 정체성을 식별해주는 속성을 읽기 전용으로 만들어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도메인-모델링&#34;&gt;도메인 모델링&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;도메인 모델링&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도메인 모델링은 여러분의 코드에서 비즈니스와 가장 가까운 부분이다. 변화가 생길 가능성이 가장 높은 부분이고, 비즈니스에서 가장 큰 가치를 제공하는 부분이다. 도메인 모델링을 이해하고 변경하기 쉽게 만들어보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;엔티티와 값 객체 구분&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 객체는 그 내부의 속성들에 의해서 정의된다. 불변 타입을 사용해서 값 객체를 구현하는 것이 가장 좋다. 반대로 엔티티에는 시간에 따라서 변하는 속성이 포함될 수 있고, 이런 속성은 바뀌더라도 여전히 똑같은 엔티티로 남는다. 어떤 요소가 엔티티를 유일하게 식별하는지 정의하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;모든 것을 객체로 만들 필요가 없다&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이썬은 다중 패러다임 언어이다. 따라서 여러분의 코드에서 동사에 해당하는 부분을 표현하려면 함수를 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 자바를 하다가 파이썬으로 변경하였을 떄 가장 헷갈리는 것중에 하나이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 &lt;code&gt;FooManager(관리 객체)&lt;/code&gt;, &lt;code&gt;BarBuilder(빌더 객체)&lt;/code&gt;, &lt;code&gt;BazFactory(펙토리 객체)&lt;/code&gt; 대신에 함수를 사용하는 것이 가독성이 좋고, 표현력이 더 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;가장 좋은 설계 원칙을 적용할 때다&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOLID 원칙이나 &lt;code&gt;has-a&lt;/code&gt;와 &lt;code&gt;is-a&lt;/code&gt;의 관계 상속 보다는 합성을 사용하라와 같은 좋은 설계법을 살펴보고 이를 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=271944317&amp;amp;start=slayer&#34;&gt;파이썬으로 살펴보는 아키텍처 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>아키텍처란 무엇인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</link>
      <pubDate>Sat, 27 Mar 2021 14:23:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</guid>
      <description>&lt;h3 id=&#34;아키텍처란-무엇인가&#34;&gt;아키텍처란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;아키텍처에 대한 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;아키텍처는 비즈니스 요구사항을 만족하는 시스템을 구축하기 위해서 전체 시스템에 대한 구조를 정의한 문서로, 시스템을 구성하는 컴포넌트와 그 컴포넌트 간의 관계, 그리고 컴포넌트가 다루는 정보(데이터)를 정의한다&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;아키텍처-설계-프로세스&#34;&gt;아키텍처 설계 프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아키텍처 설계 방법론은 여러 가지가 있으나, 주로 사용되는 프레임워크로는 &lt;code&gt;Zachman&lt;/code&gt;, &lt;code&gt;TOGAF&lt;/code&gt;, &lt;code&gt;Federal Enterprise Architecture&lt;/code&gt;등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 이러한 전통적인 방법론은 학문적이고, 그 깊이가 매우 깊어서 일반적인 개발자들이 실무에 적용하기가 매우 어렵다. 따라서 &lt;code&gt;TOGAF&lt;/code&gt;를 경량화한 프로세스를 정의하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;먼저 비즈니스 요구사항을 기반을 한 아키텍처를 정의한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;비즈니스 아키텍처란 구현하고자 하는 소프트웨어의 기능, 시장 상황, 로드맵 등 기능 보다는 비즈니스 관점에서의 소프트웨어를 정의한 모델이다. 주로 요구사항 정의서나 시장 조사서를 기반으로 이를 요약해서 정리해놓은 것을 비즈니스 아키텍처라고 한다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;설계 원칙을 정의한다. 아키텍처 설계 중 여러가지 옵션이 나왔을 때, 의사 결정의 기초가 되는 것으로, 시스템의 설계 사상에 해당한다. 이 아키텍처 설계 원칙과 비즈니스 아키텍처를 기반으로 기술적인 시스템 아키텍처를 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 아키텍처는 관점에 따라서 소프트웨어 코드로 구성되는 애플리케이션 아키텍처, 하드웨어 등 인프라에 대한 테크니컬 아키텍처, 웹 서버 데이터베이스 구성 등에 관련되는 솔루션 아키텍처와 데이터 저장 구조를 기술하는 데이터 아키텍처로 구분된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;아키텍처 설계 과정 중 의사 결정이 필요한 경우에는 앞서 언급한 아키텍처 설계 원칙을 기반으로 하여, 내부적인 의사결정 프로세스에 따른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SOA, 모놀리틱, 그리고 MSA 아키텍처</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.html</link>
      <pubDate>Sat, 27 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.html</guid>
      <description>&lt;h3 id=&#34;soa&#34;&gt;SOA&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOA(Service Oriented Architecture)는 1990년대에 정의되어, 2008년에 유행했던 아키텍처 스타일이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 서버 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 많은 영향을 받았고 많은 분산 아키텍처가 거의 이 &lt;code&gt;SOA&lt;/code&gt; 사상에 기인한다고 해도 될 만큼 중요한 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;soa의-기본-개념&#34;&gt;SOA의 기본 개념&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112712065-4f713500-8f10-11eb-9b36-a603fccd7e3d.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SOA&lt;/code&gt;란 기존 애플리케이션들의 기능을 비즈니스적인 의미가 있는 기능 단위로 묶고, 표준화된 호출 인터페이스를 통해 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을 서로 조합(&lt;code&gt;Orchestration&lt;/code&gt;)하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 시스템이 각각 독립된 업무 시스템으로 개발되어왔던 반면에 &lt;code&gt;SOA&lt;/code&gt;는 기업의 전체 업무가 하나의 거대한 &lt;code&gt;SOA&lt;/code&gt; 시스템으로 구성이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 시스템의 기능들을 업무를 기준으로 주요 기능들로 묶어서 플랫폼에 독립적인 인터페이스(예를 들어 &lt;code&gt;XML/HTTP&lt;/code&gt;, &lt;code&gt;CORBA&lt;/code&gt;, &lt;code&gt;SOAP&lt;/code&gt;)를 구현하여 외부 서비스로 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 제공된 서비스 이벤트를 조합하여, 새로운 기능을 개발할 때, 시스템을 신규 개발하는 것이 아니라, 기존에 제공된 서비스들을 조합하여 하나의 업무를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;수직적 분할(Vertical Slicing) : 수직적 분할이란 애플리케이션을 여러 개의 서비스로 나누고 각각의 서비스를 독립적으로 개발하는 것을 말한다. 따라서 각 서비스간의 의존성이 최소화 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준 인터페이스 기반(Has Standard Interface) : 서비스가 제공하는 인터페이스는 표준 기술로 구현되어야 한다. 서비스를 사용하고자 하는 사람이 &amp;lsquo;서비스 규약&amp;rsquo; 만을 가지고도 해당 서비스를 호출 할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;느슨한 결합(Loosely Coupled) : 수직적 분할에서도 설명하였듯 각 서비스 컴포넌트들은 다른 서비스에 대해서 의존성이 최소화되어 있어서 서비스의 구현 내용을 변경하였을 때 다른 서비스는 이에 거의 영향을 받지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조합 가능(Composable) : 서비스형 컴포넌트들은 서로 연결되어 하나의 조합된 형태의 애플리케이션을 구성해야하기 때문에, 서비스 간에 연결 및 조합이 가능해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모놀리틱-아키텍처&#34;&gt;모놀리틱 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713152-1b4d4280-8f17-11eb-8529-5f69c0d9b17b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마이크로 서비스 아키텍처를 이해하려면 먼저 모놀리틱 아키텍처 스타일에 대해서 이해해야한다.&lt;/li&gt;
&lt;li&gt;모놀리틱 아키텍처 스타일은 기존의 전통적인 웹 시스템 개발 스타일로, 하나의 애플리케이션 내에 모든 로직이 들어가있는 &amp;lsquo;통짜 구조&amp;rsquo;이다.&lt;/li&gt;
&lt;li&gt;각 컴포넌트는 상호 호출을 함수를 이용한 참조에 의한 호출 구조를 취한다.&lt;/li&gt;
&lt;li&gt;전체 애플리케이션을 하나로 처리하기 때문에 개발 도구에서 하나의 애플리케이션만 개발하면 되고, 배포 역시 간편하며 테스트도 하나의 애플리케이션만 수행하면 되므로 간편하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;문제점&#34;&gt;문제점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;작은 크기의 애플리케이션에서는 유리하지만, 규모가 큰 애플리케이션에서는 불리한 점이 많다.&lt;/li&gt;
&lt;li&gt;크기가 커서 빌드 및 배포시간, 서버의 가동 시간이 오래 걸린다.(서버 가동에만 2시간까지 걸리는 경우도 있다)&lt;/li&gt;
&lt;li&gt;시스템 컴포넌트들이 서로 로컬 콜 기반으로 타이트하게 연결되어 있으므로, 전체 시스템의 구조를 제대로 파악하지 않고 개발을 진행하면 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향을 주게 된다.&lt;/li&gt;
&lt;li&gt;이러한 문제를 해결하려면 개발자가 대략적인 전체 시스템의 구조를 이해햐야하는데 시스템의 구조가 커질 수록 이해하기 힘들다.&lt;/li&gt;
&lt;li&gt;특정 컴포넌트를 수정할 때, 컴포넌트 재배포 시 수정된 컴포넌트만 재배포 하는 것이 아니라 전체 애플리케이션을 재컴파일해서 전체를 다시 통을 재배포 해야한다.&lt;/li&gt;
&lt;li&gt;이 때문에 잦은 배포가 있는 시스템은 불리하며 컴포넌트 별로 기능/비기능에 특성에 맞춰서 다른 기술을 도입하고자 할 때 유연하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처&#34;&gt;마이크로 서비스 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처(MSA)는 근래의 웹 기반 분산 시스템의 디자인에 많이 반영되어 있는 스타일로, 특정 사람이 정의한 아키텍처가 아니라 분산 웹 시스템과 비슷한 구조로 설계 되면서 개념적으로만 존재하던 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 대용량 웹 서비스가 많아짐에 따라 정의된 아키텍처인데, 그 근간은 &lt;code&gt;SOA(Service Oriented Architecture)&lt;/code&gt;에 두고 있다. &lt;code&gt;SOA&lt;/code&gt;가 엔터프라이즈 시스템을 중심으로 고안된 아키텍처라면, 마이크로 서비스 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 근간을 두고, 대용량 웹 개발 서비스 개발에 맞는 구조로 사상이 경량화 되고 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스&#34;&gt;서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처에서는 각 컴포넌트를 서비스라는 개념으로 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스는 데이터부터 비즈니스 로직까지 독립적으로 상호 컴포넌트 간의 의존성 없이 개발된 컴포넌트 (이를 수직 분할이라고 함)로, REST API 같은 표준 인터페이스로 그 기능을 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 경계는 구문 또는 도메인 (업무)의 경계를 따른다. 예를 들어 사용자 관리, 상품 관리, 주문 관리와 같이 업무별로 서비스를 나눠서 정의해도 사용자/사품 관리 처럼 여러개의 업무를 동시에 하나의 서비스로 섞어서 정의하지는 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;msa-아키텍처-구조&#34;&gt;MSA 아키텍처 구조&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713447-6b78d480-8f18-11eb-8af4-a41448e23a94.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;배포 구조 관점에서도 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성 없이 독립적으로 배포된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;확장을 위해서 서비스가 배치된 톰캣 인스턴스는 횡적으로 스케일(인스턴스를 더함으로써)이 가능하고, 앞단에 로드 밸런서를 배치하여 서비스 간의 로드를 분산 시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 로직을 분리해서 여러 개의 애플리케이션으로 나눠서 서비스화하고 서비스 별로 톰캣을 분산 배치한 것이 가장 큰 특징이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터-분리&#34;&gt;데이터 분리&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713617-80099c80-8f19-11eb-864a-e539715b08a5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터 저장 관점에서는 중앙 집중화된 하나의 데이터베이스를 사용하는 것이 아니라, 서비스 별로 별도의 데이터베이스를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스의 종류 자체를 다른 데이터베이스로 사용할 수도 있지만, 같은 데이터베이스를 사용하더라도 &lt;code&gt;DB&lt;/code&gt;를 나누는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우 다른 컴포넌트에 대한 의존성 없이 서비스를 독립적으로 개발 및 배포 / 운영 할 수 있다는 장점을 가지고 있으나, 다른 컴포넌트의 데이터를 API 통신을 통해서 가지고 와야하므로, 성능상의 문제를 일으킬 수 있고, 또한 이 기종 데이터베이스 간의 트랜잭션을 묶을 수 없다는 문제점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-gateway&#34;&gt;API GATEWAY&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처 설계에서 가장 많이 언급되는 컴포넌트 중에 하나가 &lt;code&gt;API GATEWAY&lt;/code&gt;라는 컴포넌트이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;는 마치 프록시 서버처럼 &lt;code&gt;API&lt;/code&gt;들 앞에서 모든 &lt;code&gt;API&lt;/code&gt;에 대한 엔드 포인트를 통합하고, 몇 가지 추가적인 기능을 제공하는 미들웨어로, 다음과 같은 기능을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;엔드-포인트-통합-및-토폴로지-정리&#34;&gt;엔드 포인트 통합 및 토폴로지 정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처의 문제점 중 하나는 각 서비스가 다른 서버에 분리, 배포 되기 때문에 API의 엔드포인트, 즉 서버의 URL이 각기 다르다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 컴포넌트는 &lt;code&gt;http://user.server.com&lt;/code&gt;, 상품 컴포넌트는 &lt;code&gt;http://product.server.com&lt;/code&gt;과 같은 분리된 URL을 사용하는데 이는 API 사용자 경험 관점에서도 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 마이크로 서비스 아키텍처는 될 수 있으면 컴포넌트를 업무 단위로 잘게 자르는 작은 덩어리(&lt;code&gt;Fine Grained&lt;/code&gt;)의 서비스를 지향하기 때문에, 컴포넌트의 &lt;code&gt;URL&lt;/code&gt;수는 더 많이 늘어날 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713879-d1fef200-8f1a-11eb-8f72-eb90fa0360e9.png&#34; alt=&#34;t1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 토폴로지의 문제점을 해결하기 위해서, 중앙에 서비스 버스와 같은 역할을 하는 채널을 배치 시켜서 전체 토폴로지를 &lt;code&gt;Hub &amp;amp; Spoke&lt;/code&gt; 방식으로 변화시켜서 서비스 간 호출을 단순화 시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;오케스트레이션-orchestration&#34;&gt;오케스트레이션 (Orchestration)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 포인트 적립과 물품 구매라는 서비스가 있을 때, 이 두 개의 서비스를 묶어서 &amp;lsquo;물품 구매 시 포인트 적립&amp;rsquo; 이라는 새로운 서비스를 만들어 낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 오케스트레이션 기능은 &lt;code&gt;API Gateway&lt;/code&gt;를 통해서 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;공통-기능-처리cross-cutting-function-handling&#34;&gt;공통 기능 처리(Cross Cutting Function Handling)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;에 대한 인증(&lt;code&gt;Authentication&lt;/code&gt;)이나 로깅과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;에서 이러한 공통 기능을 처리하게 되면, API 자체는 비즈니스 로직에만 집중하여 개발중에 발생할 수 있는 중복을 방지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;중재mediation&#34;&gt;중재(Mediation)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;이외에도 &lt;code&gt;XML&lt;/code&gt;이나 네이티브 메시지 포맷을 &lt;code&gt;JSON&lt;/code&gt;으로 상호 변환해주는 메시지 변환 기능이나 프로토콜을 변환하는 기능, 서비스 간의 메시지를 라우팅해주는 여러 가지 고급 중재 기능을 제공하지만, &lt;code&gt;API GATEWAY&lt;/code&gt;를 최대한 가볍게 가져간다는 설계 원칙 아래에서 될 수 있으면 고급 중재 기술을 사용할 때는 높은 설계와 기술적인 노하우를 동반해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배포&#34;&gt;배포&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;마이크로서비스의 큰 장점중에 하나가 바로 유연한 배포 모델이다.&lt;/li&gt;
&lt;li&gt;각 서비스가 다른 서비스와 물리적으로 완벽하게 분리되기 때문에, 변경이 있는 서비스 부분만 부분 배포가 가능하다.&lt;/li&gt;
&lt;li&gt;예를 들어, 사용자 관리 서비스 로직이 변경되었을 때, 모놀리틱 아키텍처는 전체 시스템을 재배포해야하지만, 마이크로 서비스 아키텍처는 변경이 있는 사용자 관리 서비스 부분만 재배포하면 되기 때문에 전체 시스템의 영향을 최소화한 수준에서 빠르게 배포를 진행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;확장성&#34;&gt;확장성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서비스 별로 독립된 배포 구조는 확장성에서도 많은 장점이 있는데, 부하가 많은 특정 서비스에 대해서만 확장할 수 있어서 조금 더 유연한 확장 모델을 가져갈 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모노리틱 아키텍처는 특정 서비스의 부하가 많아서 성능 확장이 필요할 때 전체 서버의 수를 늘리거나 각 서버의 &lt;code&gt;CPU&lt;/code&gt; 숫자를 늘려줘야 하지만, 마이크로 서비스 아키텍처는 부하를 많이 받는 서비스 컴포넌트만 확장시켜주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처의-문제점&#34;&gt;마이크로 서비스 아키텍처의 문제점&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;성능&#34;&gt;성능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모놀리틱 아키텍처는 하나의 프로세스 내에서, 서비스 간의 호출에 참조 호출 모델을 이용하지만, 마이크로서비스 아키텍처는 서비스 간의 호출을 &lt;code&gt;API&lt;/code&gt; 통신을 이용하기 때문에, 값을 &lt;code&gt;JSON&lt;/code&gt;이나 &lt;code&gt;XML&lt;/code&gt;에서 프로그래밍에서 사용하는 데이터 모델(자바 객체)로 변환하는 마샬링 오버헤드가 발생하고 호출을 위해서 이 메시지들이 네트워크를 통해서 전송되기 때문에 그 만큼 시간이 많이 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;테스팅이-어려움&#34;&gt;테스팅이 어려움&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 서비스들이 분리되어 있고, 다른 서비스에 대한 종속성을 가지고 있어서, 특정 사용자 시나리오나 기능을 테스트하고자 할 경우 여러 서비스에 걸쳐서 테스트를 진행해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 때문에 테스트 환경 구축이나, 문제 발생시에 분리된 여러 개의 시스템을 동시에 봐야 하기 때문에 테스팅의 복잡도가 올라간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스간-트랜잭션-처리&#34;&gt;서비스간 트랜잭션 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현상의 가장 어려운 점 중에 하나가 바로 트랜잭션 처리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 해결하기 위한 방법으로 SAGA 패턴이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Choreography SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714624-7df60c80-8f1e-11eb-80f9-071d84562006.png&#34; alt=&#34;0_mcZ5UcSdTd4RvlnH&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하나의 큰 트랜잭션으로 묶지 않고, 각 서비스의 작업을 트랜잭션 단위로 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 서비스의 이벤트에 의해서 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Orchestrator SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714669-ada51480-8f1e-11eb-84f8-516e4d291a38.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 통해서가 아니라, 각 서비스를 관리하는 &lt;code&gt;Orchestration&lt;/code&gt; 클래스가 직접 처리하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 패턴에서처럼 메시지 이벤트를 사용하지 않고 동기식 &lt;code&gt;API&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a&#34;&gt;Event Driven Architecture란?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jjeongil.tistory.com/1100&#34;&gt;MSA - SAGA 패턴&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
