<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GC on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/tags/gc.html</link>
    <description>Recent content in GC on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 04 Apr 2021 20:30:23 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/tags/gc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GC(Garbage Collector) 종류 및 내부 원리</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</link>
      <pubDate>Sun, 04 Apr 2021 20:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</guid>
      <description>&lt;p&gt;모든 자바 애플리케이션은 JVM(&lt;code&gt;Java Virtual Machine&lt;/code&gt;) 위에서 작동한다. 따라서, &lt;code&gt;JVM&lt;/code&gt;이 작동하는데 있어서 메모리 구조와 &lt;code&gt;GC&lt;/code&gt;는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 맺고 있다.&lt;/p&gt;
&lt;h3 id=&#34;gc란-무엇인가&#34;&gt;GC란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GC(Garbage Collection)는 자바 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C/C++&lt;/code&gt; 같은 언어는 메모리를 할당하고 직접 해제해야했지만, 자바에서는 &lt;code&gt;GC&lt;/code&gt;를 이용하여 개발자들이 메모리 관리를 비교적 신경쓰지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-메모리-영역&#34;&gt;JVM 메모리 영역&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507707-1deb1000-9587-11eb-9ab6-2bbe0091be87.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GC&lt;/code&gt;의 동작 방법을 이해하려면, 먼저 자바의 메모리 구조를 이해할 필요가 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 애플리케이션에서 사용되는 객체는 오래 유지되는 객체보다 잠시 사용되는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507754-5a1e7080-9587-11eb-91e9-f14a446cb441.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바에서는 크게 두 영역으로 메모리를 구분한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Young&lt;/code&gt; 영역과 &lt;code&gt;Old&lt;/code&gt; 영역인데, &lt;code&gt;Young&lt;/code&gt; 영역은 생성된지 얼마 되지 않은 객체들을 저장하는 장소이고 &lt;code&gt;Old&lt;/code&gt; 영역은 생성된지 오래된 객체를 저장하는 장소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;영역&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;New/Young 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;이 영역은 자바 객체가 생성되자마자 저장되고 생긴지 얼마 안 된 객체가 저장되는 곳이다. 자바 객체가 생성되면 이 영역에서 저장되다가 시간이 지남에 따라서 우선 순위가 낮아지면 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮겨진다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Old 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;New/Young&lt;/code&gt; 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어서 저장되는 영역이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Perm 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Class, Method 등의 코드가 저장되는 영역으로, JVM에 의해서 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jvm이-메모리를-관리하는-방식&#34;&gt;JVM이 메모리를 관리하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508143-4c69ea80-9589-11eb-84be-2ec3ff175995.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;New/Young&lt;/code&gt; 영역을 &lt;code&gt;Minor GC&lt;/code&gt; 라고 부른다. &lt;code&gt;New/Young&lt;/code&gt; 영역은 &lt;code&gt;Eden / Survivor&lt;/code&gt; 이라는 두 영역으로 또 나뉘게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 영역은 자바 객체가 생성되자마자 저장되는 곳이다. 이렇게 생성된 객체는 &lt;code&gt;Minor GC&lt;/code&gt;가 발생할 때 &lt;code&gt;Survivor&lt;/code&gt; 영역으로 이동하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt; 영역은 &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 두 영역으로 나뉘는데, &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor1&lt;/code&gt;에 활성 객체를 &lt;code&gt;Survivor2&lt;/code&gt;로 복사한다.&lt;/li&gt;
&lt;li&gt;활성이 아닌 객체는 자연스럽게 &lt;code&gt;Survivor1&lt;/code&gt;에 남아있게 되고, &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Eden&lt;/code&gt; 영역을 클리어 한다. (결과적으로 활성 객체만 &lt;code&gt;Survivor2&lt;/code&gt;)로 이동하게 된 것이다.&lt;/li&gt;
&lt;li&gt;다음번 &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 같은 원리로 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 영역에서 활성 객체를 &lt;code&gt;Survivor1&lt;/code&gt;으로 이동시키게 된다. 계속 이런 방식을 반복하면서 &lt;code&gt;Minor GC&lt;/code&gt;를 수행한다.&lt;/li&gt;
&lt;li&gt;이렇게 &lt;code&gt;Minor GC&lt;/code&gt;를 수행하다가 &lt;code&gt;Survivor&lt;/code&gt; 영역에서 오래된 객체는 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮기게 된다.&lt;/li&gt;
&lt;li&gt;이러한 방식의 &lt;code&gt;GC&lt;/code&gt; 알고리즘을 &lt;code&gt;Copy &amp;amp; Scavenge&lt;/code&gt; 라고 한다. 이 방식은 속도가 매우 빠르며 작은 크기의 메모리를 콜렉팅하는데 매우 효과적이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Minor GC&lt;/code&gt;의 경우에는 자주 일어나기 때문에 &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 짧은 알고리즘을이 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;full-gc&#34;&gt;FULL GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508252-e3cf3d80-9589-11eb-9792-a038da5850d1.jpg&#34; alt=&#34;java-gc-29-638&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Old&lt;/code&gt; 영역의 가비지 컬렉션을 &lt;code&gt;Full GC&lt;/code&gt; 라고 부르며 &lt;code&gt;Full GC&lt;/code&gt;에 사용되는 알고리즘을 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘은 객체들의 참조를 확인하면서 참조가 연결되지 않은 객체를 표시한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 표시하고 이 표시된 객체를 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Full GC&lt;/code&gt;는 속도가 매우 느리며, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 도중에는 순간적으로 자바 애플리케이션이 멈춰버리기 때문에, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 정도와 시간은 애플리케이션의 성능과 안정성에 아주 큰 영향을 미친다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc가-중요한-이유&#34;&gt;GC가 중요한 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;가비지 컬렉션 중에서 마이너 GC의 경우에는 보통 0.5 이내에 끝나기 때문에 큰 문제가 되지 않지만, 그러나 FULL GC의 경우에는 자바 애플리케이션이 멈춰 버리기 때문에, 문제가 될 수 있다.&lt;/li&gt;
&lt;li&gt;멈추는 동안 사용자의 요청이 큐에 들어있다가, 순간적으로 요청이 한꺼번에 들어오기 때문에 과부하에 의한 여러 장애를 만들 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 원활한 서비스를 위해서는 &lt;code&gt;GC&lt;/code&gt;가 어떻게 일어나게 하느냐가 시스템의 안정성과 성능에 큰 변수로 작용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-gc-알고리즘&#34;&gt;다양한 GC 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;앞에서 설명한 방식 말고도 다양한 &lt;code&gt;GC&lt;/code&gt; 방법을 제공하고 있다. 방식은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Default Collector&lt;/li&gt;
&lt;li&gt;Parallel GC for young generator&lt;/li&gt;
&lt;li&gt;Concurrent GC for old generator&lt;/li&gt;
&lt;li&gt;Incremental GC (Train GC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;default-collector&#34;&gt;Default Collector&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 설명했던 전통적인 GC 방식으로, Minor GC로 &lt;code&gt;Scanvenge&lt;/code&gt;를 Full GC로 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508603-f8acd080-958b-11eb-9c89-f025df1daab9.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자바는 멀티 스레드 환경을 지원하지만, 하나의 CPU에서는 동시에 하나의 스레드 밖에 수행할 수 없어서 예전에는 하나의 CPU에서만 GC를 수행하였지만 후에 하나의 CPU에서 동시에 여러 개의 스레드를 실행할 수 있는 하이퍼스레딩 기술이나 여러개의 CPU를 동시에 장착한 하드웨어의 보급으로 하나의 하드웨어에서 동시에 여러 개의 스레드를 수행할 수 있게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parallel GC&lt;/code&gt;에는 크게 두 가지 종류의 옵션을 가지고 있는데, &lt;code&gt;Low-pause&lt;/code&gt; 방식과 &lt;code&gt;Throughput&lt;/code&gt; 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Low-pause&lt;/code&gt; 방식은 GC가 일어날 때 애플리케이션이 멈추는 현상을 최소화하는데 역점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Throughput&lt;/code&gt; 방식의 &lt;code&gt;Parallel&lt;/code&gt; GC는 마이너 GC가 발생하였을 때 되도록이면 신속하게 수행하도록 &lt;code&gt;throughput&lt;/code&gt;에 중점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;concurrent-gc&#34;&gt;Concurrent GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC 즉, Old 영역을 GC하는데 시간이 길고 애플리케이션이 순간적으로 멈춰버리므로, 애플리케이션이 멈추는 현상을 최소화 하는 GC 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full GC에 소요되는 작업을 애플리케이션을 멈추고 진행하는 것이 아니라, 일부는 애플리케이션이 돌아가는 단계에서 수행하고 최소한의 작업만을 애플리케이션이 멈췄을 때 수행하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;incremental-gc-train-gc&#34;&gt;Incremental GC (Train GC)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Train GC&lt;/code&gt;라고도 불리는 &lt;code&gt;GC&lt;/code&gt; 방식은 의도는 &lt;code&gt;Full GC&lt;/code&gt;에서 의해서 애플리케이션이 멈추는 시간을 줄이기 위한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동은 &lt;code&gt;Minor GC&lt;/code&gt;가 일어날 때마다 &lt;code&gt;Old&lt;/code&gt; 영역을 조금씩 &lt;code&gt;GC&lt;/code&gt; 해서 &lt;code&gt;Full GC&lt;/code&gt;가 발생하는 횟수나 시간을 줄이는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Incremental GC&lt;/code&gt;는 많은 자원을 소모하고 &lt;code&gt;Minor GC&lt;/code&gt;를 자주 일으켜서, 그리고 &lt;code&gt;Incremental GC&lt;/code&gt;를 사용한다고 &lt;code&gt;Full GC&lt;/code&gt;가 없어지거나 그 횟수가 획기적으로 줄어드는 것이 아니다. 오히려 느려지는 경우가 많으므로 반드시 테스트를 거치고 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc-로그-수집-방법&#34;&gt;GC 로그 수집 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;에서는 GC 상황에 대한 로그를 남기고자 옵션을 제공하고 있다.&lt;/li&gt;
&lt;li&gt;자바 옵션에 &lt;code&gt;-verbosegc&lt;/code&gt; 라는 옵션을 주면 되고, &lt;code&gt;&amp;gt;&lt;/code&gt; 리다이렉션 명령어를 통해서 파일로 저장하고 분석할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509041-6659fc00-958e-11eb-92e2-bc0633609ea6.png&#34; alt=&#34;자바&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위는 스프링 부트로 만든 간단한 웹 애플리케이션이다. 이를 터미널에서 &lt;code&gt;jar&lt;/code&gt; 파일로 만들어 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;./gradlew bootjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509104-b6d15980-958e-11eb-8a43-07b56114335a.png&#34; alt=&#34;jar&#34;&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 생성이 되면, 다음과 같은 경로에 &lt;code&gt;jar&lt;/code&gt; 파일이 생성된다. 터미널을 통해서 이 경로로 이동한다.&lt;/p&gt;
&lt;p&gt;그런 후에 다음과 같은 명령어를 터미널에서 실행 시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar -verbosegc app.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509189-26474900-958f-11eb-836f-e70adb0a34ac.png&#34; alt=&#34;Screen Shot 2021-04-04 at 9 45 53 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러면 애플리케이션이 실행되자마자 &lt;code&gt;GC&lt;/code&gt;와 관련된 로그들이 출력된다.&lt;/li&gt;
&lt;li&gt;마이너 GC는 &amp;ldquo;GC&amp;quot;로 표기되고, FULL GC는 &amp;ldquo;FULL GC&amp;quot;로 표기된다.&lt;/li&gt;
&lt;li&gt;그 다음의 값은 &lt;code&gt;HEAP SIZE BEFORE GC&lt;/code&gt;인데, GC전의 힙 사용량 (New/Young 영역 + Old 영역 + Perm 영역의) 크기를 나타낸다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 GC가 발생한 후의 HEAP 사용량이다. 마이너 GC가 발생하였을 때는 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor&lt;/code&gt; 영역을 &lt;code&gt;GC&lt;/code&gt; 하게 되므로 &lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 Old 영역의 용량과 유사하다.&lt;/li&gt;
&lt;li&gt;마지막 값은 &lt;code&gt;GC&lt;/code&gt;에 소요된 시간을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-gc-튜닝&#34;&gt;JVM GC 튜닝&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;step-1-애플리케이션의-종류-및-튜닝-목표값을-설정&#34;&gt;STEP 1. 애플리케이션의 종류 및 튜닝 목표값을 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JVM 튜닝을 할 때 가장 중요한 것은 튜닝의 목표를 설정하는 것이다.&lt;/li&gt;
&lt;li&gt;메모리를 적게 사용하는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt; 횟수를 줄이는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 문제인지, 애플리케이션의 성능(&lt;code&gt;Throughput or Response Time&lt;/code&gt;) 향상이 목표인지를 먼저 정하고 나서 목표치에 근접하도록 &lt;code&gt;JVM&lt;/code&gt; 파라미터를 조정하는 것이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-2-힙크기와-perm-크기-설정&#34;&gt;STEP 2. 힙크기와 &lt;code&gt;Perm&lt;/code&gt; 크기 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-ms, -mx 옵션을 이용해서 힙 크기를 정한다. 일반적으로 서버 애플리케이션은 ms와 mx크기를 같게 하는 것이 메모리의 &lt;code&gt;Growing&lt;/code&gt;와 &lt;code&gt;Shrinking&lt;/code&gt;에 의한 불필요한 로드를 막을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ms&lt;/code&gt;와 &lt;code&gt;mx&lt;/code&gt; 크기를 다르게 하는 경우는 애플리케이션의 시간대별 메모리 사용량이 급격하게 변화가 있는 애플리케이션에 효과적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-3-테스트와-로그-분석&#34;&gt;STEP 3. 테스트와 로그 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; 옵션에 &lt;code&gt;GC&lt;/code&gt;로그를 수집하기 위한 &lt;code&gt;-verbosegc&lt;/code&gt; 옵션을 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nGrinder&lt;/code&gt;와 같은 스트레스 테스트 도구로 애플리케이션에 스트레스를 주어서, 그 로그를 수집한다.&lt;/li&gt;
&lt;li&gt;튜닝에 있어서 가장 중요한 것은 목표 산정이지만, 그만큼이나 중요한 것은 실제 튜닝한 파라미터가 애플리케이션에 어떤 영향을 주는지를 테스트 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-4-perm-크기-조정&#34;&gt;STEP 4. Perm 크기 조정&lt;/h4&gt;
&lt;h4 id=&#34;step-5-gc-수행-시간-분석&#34;&gt;STEP 5. GC 수행 시간 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC가 일어나는 횟수가 많아서 &lt;code&gt;Old&lt;/code&gt; 영역을 늘려주면, Full GC 가 일어나는 횟수가 줄어들 것이고, 반대로 Full GC 수행 시간은 늘어날 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 서버 애플리케이션은 Full GC가 일어날 때는 &lt;code&gt;JVM&lt;/code&gt; 자체가 멈춰버리기 때문에 일정 시간동안 응답을 못하는 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 애플리케이션에서 Full GC가 적게 일어나게 하고, Full GC 시간을 양쪽 다 줄이려면 &lt;code&gt;Old&lt;/code&gt; 영역의 메모리를 줄이고 여러 개의 인스턴스를 동시에 띄워서 로드 밸런싱을 해주면 부하가 분산된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇게 되면, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 횟수가 줄어들게 되며 &lt;code&gt;Old&lt;/code&gt; 영역을 줄였기 때문에 Full GC가 수행되는 시간 또한 줄어든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 하나의 서버 인스턴스가 멈춰있는 동안 로드 밸런싱이 되는 다른 서버가 응답하고 있기 때문에 &lt;code&gt;Full GC&lt;/code&gt;로 인하여 애플리케이션이 멈추는 상황에서 받을 영향을 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-6-파라미터-변경&#34;&gt;STEP 6. 파라미터 변경&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 영역의 허용 범위를 기준으로, &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역을 적절하게 조절한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Perm&lt;/code&gt; 크기와 &lt;code&gt;New&lt;/code&gt; 영역의 배분(Eden, Survivor) 영역을 조정한다.&lt;/li&gt;
&lt;li&gt;가장 중요한 것은 &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역의 비율을 어떻게 조정하는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;향상 포인트&lt;/th&gt;
&lt;th&gt;GC 알고리즘&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Perfomance (속도)&lt;/td&gt;
&lt;td&gt;Parallel GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Concurrent GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Incremental GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반&lt;/td&gt;
&lt;td&gt;Default GC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
