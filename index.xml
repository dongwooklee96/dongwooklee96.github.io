<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/</link>
    <description>Recent content in Home on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Tue, 17 Aug 2021 00:52:39 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>입출력과 소켓</title>
      <link>https://dongwooklee96.github.io/post/2021/08/17/%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC-%EC%86%8C%EC%BC%93.html</link>
      <pubDate>Tue, 17 Aug 2021 00:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/17/%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC-%EC%86%8C%EC%BC%93.html</guid>
      <description>&lt;h3 id=&#34;입출력-전반&#34;&gt;입출력 전반&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;입력과 출력은 정보 전달을 위한 핵심 과정이다. 프로세스 간의 정보 전달을 궁극적인 목적으로 하는 소켓 프로그래밍에서도 입출력은 핵심 절차이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입출력 시스템의 동작 원리에 대해서 이해한다면 제작하는 프로그램의 완성도를 높일 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-디스크립터-파일-테이블-파일&#34;&gt;파일 디스크립터, 파일 테이블, 파일&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/poobyg7pu5oi4oh/%EC%BA%A1%EC%B2%98.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터는 프로세스가 파일에 접근할 때, 파일을 식별하기 위한 이름표이다. 소켓 또한 생성되면 파일 디스크립터 (소켓 디스크립터)가 부여된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영체제는 프로세스가 접근할 수 있는 자원인 파일을 다루기 위해서 프로세스별로 파일 디스크립터 테이블을 관리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 프로세스 A가 &lt;code&gt;open()&lt;/code&gt; 함수를 이용하여 파일을 열었다면 프로세스 A의 파일 디스크립터 테이블에 파일에 접근하기 위한 정보가 기록된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 운영체제는 시스템 전체에 열려 있는 모든 파일 정보(장치 및 소켓 포함)가 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디스크립터 테이블에는 다음과 같은 두 가지 정보가 저장된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 디스크립터의 속성 정보를 저장하고 있는 &lt;code&gt;flags&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;운영체제가 관리하는 파일 레코드를 가리키는 포인터&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 테이블에는 다음과 같은 세 가지 정보가 저장된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file offset&lt;/code&gt;: 열려 있는 파일 중 현재 읽기 또는 쓰기가 실행될 위치를 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;status flag&lt;/code&gt;: &lt;code&gt;open&lt;/code&gt; 시스템 콜에서 지정하는 파일의 정보들을 저장&lt;/li&gt;
&lt;li&gt;실제 파일 위치를 가리키는 포인터&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-디스크립터-테이블과-열린-파일-테이블의-엔트리entry&#34;&gt;파일 디스크립터 테이블과 열린 파일 테이블의 엔트리(Entry)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 함수 또는 &lt;code&gt;socket()&lt;/code&gt; 함수를 이용하면 프로세스 단위로 파일 디스크립터를 관리하기 위해서 사용되는 파일 디스크립터 테이블에 하나의 엔트리가 생성된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 엔트리에는 열린 파일 테이블의 엔트리를 참조하기 위한 포인터가 포함되어 있다. 또한, 앞의 함수들은 시스템 전체의 열린 파일을 관리하기 위해 사용되는 열린 파일 테이블의 엔트리도 생성하는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/0j0pqm37n5mfs88/image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 엔트리는 실제 파일이나 소켓이 가리키는 포인터를 가지고 있다. 같은 파일을 서로 다른 두 프로세스가 열 경우에 열린 파일 테이블의 엔트리는 두개가 되지만, 두 엔트리에서 가리키는 실제 저장소는 하나가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/lco2nqt6kso2igb/img.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 &lt;code&gt;fork()&lt;/code&gt; 함수에 의해서 복제되면 같은 파일 테이블 엔트리를 가리키는 파일 디스크립터 테이블 엔트리가 생성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ksan0lstok65vni/%EA%B7%B8%EB%A6%BC-3.9-dup%EB%A1%9C-%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0%EB%A5%BC-%EB%B3%B5%EC%A0%9C%ED%95%A0-%EB%95%8C-%EC%97%B4%EB%A0%A4%EC%A7%84-%ED%8C%8C%EC%9D%BC%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dup()&lt;/code&gt; 계열 함수를 호출하면 파일 디스크립터를 복사할 수 있다. &lt;code&gt;dup&lt;/code&gt; 함수에 의해서 생성된 파일 디스크립터는 원본 파일 디스크립터와 동일한 열린 파일 테이블 엔트리를 참조한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int dup(int oldfd);
결과값 : 복사된 파일 디스크립터(새로 부여된 디스크립터)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;같은 프로세스 내에서 파일 디스크립터를 복제하는 함수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int dup2(int oldfd, int newfd);

결과값 : 복사된 파일 디스크립터 (새로 부여된 디스크립터)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;파일-오프셋이란&#34;&gt;파일 오프셋이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 오프셋은 읽기/쓰기의 기준이 되는 포인터 값이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오프셋은 읽기/쓰기의 기준이 파일의 시작지점으로부터 몇 바이트 떨어져있는지를 나타낸다. 예를 들어서, &lt;code&gt;read()&lt;/code&gt; 함수를 호출하여 5바이트를 읽는다면 오프셋 값을 기준으로 파일에서 5바이트의 데이터가 읽혀진다. 또한 이 경우에 오프셋 값은 5만큼 증가한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 소켓에서는 오프셋 값은 의미가 없지만, 파일 입출력을 다룰 때는 오프셋 값에 주의해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주목할만한 포인트는 오프셋 값은 파일 디스크립터 테이블이 아니라, 열린 파일 테이블에 있다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;dup()&lt;/code&gt;로 복제한 파일 디스크립터는 오프셋 값을 원본 디스크립터와 공유한다. 반면에 개별적인 &lt;code&gt;open()&lt;/code&gt; 함수를 통해서 열린 파일 테이블에 독립적인 엔트리를 생성한 두 파일디스크립터들은 오프셋을 공유하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;

#include &amp;lt;unistd.h&amp;gt;

off_t lseek(int fd, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;인자&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fd: 오프셋 값을 조회하거나 변경하고자하는 파일을 가리키는 디스크립터&lt;/li&gt;
&lt;li&gt;offset: 변경할 오프셋의 크기&lt;/li&gt;
&lt;li&gt;whence: 오프셋 변경의 기준이 되는 지점 (세 가지 매크로를 제공한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;결과값&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변경된 매크로 값 반환, 실패시 -1&lt;/li&gt;
&lt;li&gt;whence 값으로 사용가능한 매크로&lt;/li&gt;
&lt;li&gt;SEEK_SET: 파일의 시작 지점&lt;/li&gt;
&lt;li&gt;SEEK_CUR: 현재 오프셋 값&lt;/li&gt;
&lt;li&gt;SEEK_END: 파일의 마지막 지점 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

int main(int argc, char *argv[]) {
  int fd1, fd2, fd3;
  char buff[BUFSIZ];
  int read_len, n_write;
  if (argc != 2) {
    printf(&amp;quot;usage: %s filename \n&amp;quot;, argv[0]);
    return -1;
  }

  fd1 = open(argv[1], O_RDWR | O_CREAT | O_TRUNC);
  fd2 = open(argv[1], O_RDONLY);
  fd3 = dup(fd1);

  fgets(buff, BUFSIZ - 1, stdin);

  read_len = strlen(buff);
  n_write = write(fd1, &amp;quot;abc&amp;quot;, 3);
  n_write += write(fd1, buff, read_len + 1);
  if (n_write == -1) printf(&amp;quot;error&amp;quot;);

  printf(&amp;quot;offset (fd1): %d\n&amp;quot;, (int) lseek(fd1, 0, SEEK_CUR));
  printf(&amp;quot;offset (fd2): %d\n&amp;quot;, (int) lseek(fd2, 0, SEEK_CUR));
  printf(&amp;quot;offset (fd3): %d\n&amp;quot;, (int) lseek(fd3, 0, SEEK_CUR));

  read(fd2, buff, 4);
  write(1, buff, 4);

  printf(&amp;quot;-----\n&amp;quot;);

  printf(&amp;quot;offset (fd1): %d\n&amp;quot;, (int) lseek(fd1, 0, SEEK_CUR));
  printf(&amp;quot;offset (fd2): %d\n&amp;quot;, (int) lseek(fd2, 0, SEEK_CUR));
  printf(&amp;quot;offset (fd3): %d\n&amp;quot;, (int) lseek(fd3, 0, SEEK_CUR));

  close(fd1);
  fgets(buff, BUFSIZ - 1, stdin);
  read_len = strlen(buff);
  n_write += write(fd3, buff, read_len);

  lseek(fd2, 0, SEEK_SET);
  memset(buff, 0, BUFSIZ);
  read_len = read(fd2, buff, n_write);
  write(1, buff, n_write);
  close(fd2);
  close(fd3);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8kcx9hgxucbiljj/Screen%20Shot%202021-08-17%20at%201.36.08%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터 fd1, fd2, fd3를 생성하는데, fd1, fd2는 각각 &lt;code&gt;open()&lt;/code&gt; 함수로 열고 fd3는 fd1을 &lt;code&gt;dup()&lt;/code&gt; 함수를 통해서 복제한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램을 실행하면서 인자로 &lt;code&gt;test.txt&lt;/code&gt; 를 넘겼다. 따라서 실행 파일과 같은 폴더에 &lt;code&gt;test.txt&lt;/code&gt; 파일이 생성된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 다음으로는 사용자에게 문자열을 입력 받는 부분인데, 여기서는 &lt;code&gt;this i a test file&lt;/code&gt; 이라는 문자열이 입력된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문자열 입력 후 파일 디스크립터 &lt;code&gt;fd1&lt;/code&gt;을 이용하여 파일에 쓰기 작업을 수행한다. 이때 사용자에게 입력 받은 문자열에 앞서 &amp;ldquo;abc&amp;rdquo; 라는 문자열을 저장한다. 따라서 문자열 24개와 엔터를 포함한 25개가 오프셋 값으로 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fd2는 fd1과 같은 파일을 가리키고 있지만 서로 다른 열린 파일 테이블을 가리키고 있으므로 오프셋의 값이 0이라는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 후에 fd2를 이용하여 파일의 4글자 값을 읽었을 때 오프셋 값이 증가한 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;소켓-전용-입출력-함수&#34;&gt;소켓 전용 입출력 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지금까지 TCP 소켓에서는 읽기 쓰기는 저수준 입출력 함수인 &lt;code&gt;read&lt;/code&gt; 함수와 &lt;code&gt;write&lt;/code&gt; 함수를 이용했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 함수는 리눅스의 추상화된 파일 (파일, 소켓, 디바이스 장치)에서 공통적으로 사용할 수 있는 저수준 입출력 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 함수와는 별개로 소켓 전용 입출력 함수에 대해서 알아보도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ssize_t send(int socket, const void *buffer, size_t length, int flags);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;인자&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;socket&lt;/strong&gt;: 데이터 전달을 위해서 사용하고자 하는 소켓 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;buffer&lt;/strong&gt;: 전달하려고 하는 데이터를 저장하고 있는 공간의 주소&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;length&lt;/strong&gt;: 전달하려고 하는 데이터의 길이&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;flag&lt;/strong&gt;: 데이터 전송 시 사용할 수 있는 옵션들&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;send()&lt;/code&gt; 함수는 &lt;code&gt;write()&lt;/code&gt; 함수보다 하나의 인자를 더 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓 입출력에서 필요한 옵션들을 지정하는데 사용할 수 있는 &lt;code&gt;flags&lt;/code&gt; 라는 인자이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt;는 파일을 &lt;code&gt;open&lt;/code&gt; 할 때 사용하는 &lt;code&gt;flags&lt;/code&gt; 처럼 여러 설정 값의 비트 연산으로 구성된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt; 인자에 대해서는 읽기 기능을 수행하는 소켓 전용 함수인 &lt;code&gt;recv&lt;/code&gt;를 다룬 후에 자세히 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ssize_t recv(int socket, void *buffer, size_t length, int flags);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;인자&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;socket&lt;/strong&gt;: 데이터 읽기 작업을 위해 사용하고자하는 소켓 디스크립터&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buffer&lt;/strong&gt;: 읽어온 데이터를 저장하려고 하는 공간의 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;length&lt;/strong&gt;: 읽으려고 하는 데이터의 최대 길이&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flag&lt;/strong&gt;: 데이터 읽기 작업을 위해 사용할 수 있는 옵션들&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;flags&#34;&gt;flags&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;두 함수에서 공통으로 사용하는 &lt;code&gt;flags&lt;/code&gt; 인자에 대해서 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSG_OOB: Out of Band 데이터 전송을 위한 옵션이다. TCP의 Urgent 기능에 관한 것으로 MSG_OOB가 설정되면 Urgent 데이터로 취급하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSG_DONTWAIT: 입출력 함수의 동작이 블록 되지 않게 된다. 즉 논 블록으로 동작하게 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음은 &lt;code&gt;send()&lt;/code&gt; 함수에서 사용할 수 있는 &lt;code&gt;flags&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSG_DONTROUTE: 메시지가 라이터를 통해 다른 네트워크로 전달되는 것을 막는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSG_PEEK: 수신 버퍼에 데이터가 들어있는지를 알아보기 위해서 사용한다. &lt;code&gt;MSG_PEEK&lt;/code&gt; 옵션이 활성화 되어 있는 상태에서 &lt;code&gt;recv&lt;/code&gt; 함수로 읽어진 데이터는 수신 버퍼에서 지워지지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;urgent-데이터&#34;&gt;Urgent 데이터&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TCP 기능중에서는 전송하는 데이터 중에 긴급한 메시지가 있음을 알리는 기능이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;전송하는 데이터 중에서 긴급한 메시지가 있으니, 이 부분을 확인하시오.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 긴급한 데이터의 전송은 주목적이 아니라 특수한 목적이기 때문에 &lt;code&gt;In Band&lt;/code&gt;의 반대말인 &lt;strong&gt;Out of Band(OOB)&lt;/strong&gt; 전송으로 불린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예제를 통해서 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제-1&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Urgent 데이터 전송을 위한 서버 / 클라이언트 프로그램&lt;/li&gt;
&lt;li&gt;클라이언트 프로그램은 서버 프로그램으로 다음과 같은 데이터 순서대로 전송한다.
&lt;ul&gt;
&lt;li&gt;Normal_MSG1&lt;/li&gt;
&lt;li&gt;Normal_MSG2&lt;/li&gt;
&lt;li&gt;Urgent_MSG&lt;/li&gt;
&lt;li&gt;Normal MSG4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3번째 데이터는 Urgent Flag를 셋팅하여 전송한다.&lt;/li&gt;
&lt;li&gt;서버 프로그램은 클라이언트 프로그램이 전송하는 데이터를 화면에 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;클라이언트 프로그램&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]) {
  int connect_sd;
  struct sockaddr_in client_addr;
  int client_addr_len, read_len;
  char write_buffer[BUFSIZ];

  if (argc != 3) {
    printf(&amp;quot;usage: %s &amp;lt;IP Address&amp;gt; &amp;lt;Port Number&amp;gt;\n&amp;quot;, argv[0]);
    return -1;
  }

  connect_sd = socket(PF_INET, SOCK_STREAM, 0);

  printf(&amp;quot;=== client program ===\n&amp;quot;);

  memset(&amp;amp;client_addr, 0, sizeof(client_addr));
  client_addr.sin_family = AF_INET;
  client_addr.sin_addr.s_addr = inet_addr(argv[1]);
  client_addr.sin_port = htons(atoi(argv[2]));

  connect(connect_sd, (struct sockaddr *) &amp;amp;client_addr, sizeof(client_addr));

  send(connect_sd, &amp;quot;normal_msg1&amp;quot;, strlen(&amp;quot;normal_msg1&amp;quot;), 0);
  send(connect_sd, &amp;quot;normal_msg2&amp;quot;, strlen(&amp;quot;normal_msg2&amp;quot;), 0);
  send(connect_sd, &amp;quot;urgent_msg&amp;quot;, strlen(&amp;quot;urgent msg&amp;quot;), MSG_OOB);
  send(connect_sd, &amp;quot;normal_msg3&amp;quot;, strlen(&amp;quot;normal_msg3&amp;quot;), 0);
  close(connect_sd);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;서버 프로그램&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int listen_sd, connect_sd;

void urgent_handler(int sig);

int main(int argc, char *argv[]) {
  struct sockaddr_in server_addr, client_addr;
  int client_addr_len, read_len, str_len, state;
  char read_buffer[BUFSIZ];
  pid_t pid;
  struct sigaction act;

  if (argc != 2) {
    printf(&amp;quot;usage: %s [port number]\n&amp;quot;, argv[0]);
    return -1;
  }

  act.sa_handler = urgent_handler;
  sigemptyset(&amp;amp;act.sa_mask);
  act.sa_flags = 0;

  printf(&amp;quot;server start...\n&amp;quot;);
  listen_sd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

  memset(&amp;amp;server_addr, 0, sizeof(server_addr));
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(atoi(argv[1]));

  bind(listen_sd, (struct sockaddr *) &amp;amp;server_addr, sizeof(server_addr));
  listen(listen_sd, 5);

  client_addr_len = sizeof(client_addr);
  connect_sd = accept(listen_sd, (struct sockaddr *) &amp;amp;client_addr, &amp;amp;client_addr_len);
  fprintf(stderr, &amp;quot;a client is connected...\n&amp;quot;);

  fcntl(connect_sd, F_SETOWN, getpid());
  state = sigaction(SIGURG, &amp;amp;act, 0);

  while (1) {
    read_len = recv(connect_sd, read_buffer, sizeof(read_buffer), 0);
    read_buffer[read_len] = &#39;\0&#39;;
    printf(&amp;quot;client: %s\n&amp;quot;, read_buffer);
    if (read_len == 0) {
      close(connect_sd);
      break;
    }
  }
  fprintf(stderr, &amp;quot;the client is disconnected.\n&amp;quot;);
  close(listen_sd);
  return 0;
}

void urgent_handler(int sig) {
  int read_len;
  char read_buffer[BUFSIZ];

  read_len = recv(connect_sd, read_buffer, sizeof(read_buffer), MSG_OOB);
  read_buffer[read_len] = &#39;\0&#39;;
  printf(&amp;quot;client(urgent): %s\n&amp;quot;, read_buffer);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OOB&lt;/code&gt; 전송에 대해서 정리하자면 긴급 데이터 처리를 위해서 &lt;code&gt;OOB&lt;/code&gt; 전송을 하더라도 데이터가 빨리 전송되는 것은 아니며 데이터 중에 한 바이트만 긴급 데이터로 취급된다는 것을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;이 세그먼트에 긴급한 데이터가 있다.&amp;rdquo; 정도의 정보만 수신자 측에 전달할 수 있는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입출력-함수&#34;&gt;표준 입출력 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜은 사용자 모드와 커널 모드를 전환하기 때문에 자원을 많이 소모한다. 사용자 A와 사용자 B가 각각 100 바이트의 데이터를 &lt;code&gt;WRITE&lt;/code&gt; 함수를 사용하여 파일을 작성한다고 생각을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;사용자 A는 100 바이트를 작성하는 &lt;code&gt;write()&lt;/code&gt; 함수를 한 번 호출하여 100 바이트를 작성한다.&lt;/li&gt;
&lt;li&gt;사용자 B는 10 바이트를 작성하는 &lt;code&gt;write()&lt;/code&gt; 함수를 10번 호출하여 100 바이트를 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일을 입력할 때마다 &lt;code&gt;write()&lt;/code&gt; 함수를 호출하는 대신에 누군가가 입력할 데이터를 모아서 데이터가 충분히 많아졌을 때 &lt;code&gt;write()&lt;/code&gt; 함수를 호출하면 시스템 콜을 호출하는 횟수를 줄일 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준 입출력 함수는 자체적으로 버퍼를 가지고 있기 때문에 시스템 콜 실행 횟수를 줄이는 기능을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트림&#34;&gt;스트림&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 입출력 함수들은 시스템 콜의 실행 횟수를 줄이는 기능 이외에 문자열 처리를 쉽게 해준다는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓 프로그래밍을 할 때도 표준 입출력 함수들을 활용하면 복잡한 문자열 작업을 편하게 할 수 있는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스트림은 표준 입출력에서의 파일 시스템을 추상화한 개념이다. &lt;code&gt;fopen()&lt;/code&gt;, &lt;code&gt;fclose()&lt;/code&gt; 같은 표준 입출력 함수는 파일에 접근하기 위해서 FILE 구조체의 포인터를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 제작 의도와는 다르게 스트림을 FILE 구조체의 포인터 자체로 간주하는 사람들도 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준 입출력 함수를 이용하는 프로그램들은 아래 소스와 같은 흐름을 따른다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;FILE *fp;

fp = fopen(&amp;quot;filename.txt&amp;quot;, &amp;quot;r&amp;quot;);
...
fprintffp, &amp;quot;....&amp;quot;);
....
fclose(fp);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위에서 처럼 &lt;code&gt;fscanf()&lt;/code&gt;, &lt;code&gt;fprintf()&lt;/code&gt;, &lt;code&gt;fgets()&lt;/code&gt;, &lt;code&gt;fputs()&lt;/code&gt; 등등의 표준 입출력 함수를 사용하려면, 파일을 가리키는 FILE형 포인터 즉, 스트림을 생성해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;FILE *fdopen(int fd, const char *mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파일 디스크립터로부터 스트림을 생성하는 방법은 &lt;code&gt;fdopen()&lt;/code&gt; 함수를 이용하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int fileno(FILE *stream)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;반대로 스트림에서 파일 디스크립터를 추출하는 것도 가능하다. 이때는 &lt;code&gt;fileno&lt;/code&gt; 함수를 이용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;표준-입출력-버퍼-관리&#34;&gt;표준 입출력 버퍼 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 스트림에 &lt;code&gt;fprintf()&lt;/code&gt;나 &lt;code&gt;fputs()&lt;/code&gt; 같은 함수를 이용하여 쓰기 작업을 하면 &lt;code&gt;write()&lt;/code&gt; 관련 시스템 콜이 실행되어 파일 쓰기 작업이 수행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 표준 입출력 함수의 사용이 시스템 콜로 바로 이어지는 것은 아니다. 표준 결과물은 표준 입출력 버퍼에 저장되어 있다가 상황에 맞게 한 번의 시스템 콜로 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 버퍼링은 시스템 콜의 횟수를 줄일 수 있다는 장점을 제공하는 동시에 버퍼링되어 있는 시간만큼 해당 작업이 지연된다는 단점을 가져올 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 경우에 따라 버퍼에 있는 내용을 강제로 배출하는 기능이 필요한다. 이러한 기능은 &lt;code&gt;fflush()&lt;/code&gt; 함수가 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int fflush(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;또한 표준 입출력에서 사용되는 버퍼의 크기를 설정하는 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void setbuff(FILE *stream, char *buf);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;예제---표준-입출력-함수를-이용한-소켓-프로그래밍&#34;&gt;예제 - 표준 입출력 함수를 이용한 소켓 프로그래밍&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;클라이언트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nclude &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

int main(int argc, char *argv[]) {
  int connect_sd;
  struct sockaddr_in client_addr;
  int client_addr_len, read_len;
  char write_buffer[BUFSIZ];
  FILE *wfp;

  if (argc != 3) {
    printf(&amp;quot;usage: %s &amp;lt;IP Address&amp;gt; &amp;lt;Port Number&amp;gt;\n&amp;quot;, argv[0]);
    return -1;
  }

  connect_sd = socket(PF_INET, SOCK_STREAM, 0);
  printf(&amp;quot;=== client program ===\n&amp;quot;);

  memset(&amp;amp;client_addr, 0, sizeof(client_addr));
  client_addr.sin_family = AF_INET;
  client_addr.sin_addr.s_addr = inet_addr(argv[1]);
  client_addr.sin_port = htons(atoi(argv[2]));

  connect(connect_sd, (struct sockaddr *)&amp;amp;client_addr, sizeof(client_addr));
  wfp = fdopen(connect_sd, &amp;quot;w&amp;quot;);
  while (1) {
    printf(&amp;quot;send msg: &amp;quot;);
    fgets(write_buffer, BUFSIZ, stdin);
    fputs(write_buffer, wfp);
    fflush(wfp);
    if (!strcmp(write_buffer, &amp;quot;END\n&amp;quot;)) break;
  }
  fclose(wfp);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;서버&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[]) {
  int listen_sd, connect_sd;
  struct sockaddr_in server_addr, client_addr;
  int client_addr_len, read_len, str_len, state;

  char read_buffer[BUFSIZ];
  FILE *rfp;

  if (argc != 2) {
    printf(&amp;quot;usage %s [port number]\n&amp;quot;, argv[0]);
    return -1;
  }

  printf(&amp;quot;server start...\n&amp;quot;);
  listen_sd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

  memset(&amp;amp;server_addr, 0, sizeof(server_addr));

  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(atoi(argv[1]));

  bind(listen_sd, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr));
  listen(listen_sd, 5);

  client_addr_len = sizeof(client_addr);

  connect_sd = accept(listen_sd, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_len);
  fprintf(stderr, &amp;quot;a client is connected...\n&amp;quot;);

  rfp = fdopen(connect_sd, &amp;quot;r&amp;quot;);

  while (!feof(rfp)) {
    fgets(read_buffer, BUFSIZ, rfp);
    printf(&amp;quot;%s&amp;quot;, read_buffer);
  }
  fprintf(stderr, &amp;quot;the client is disconnected. \n&amp;quot;);
  fclose(rfp);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/q3lp1q6nxe1d91s/Screen%20Shot%202021-08-17%20at%203.43.38%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/r63x0947s1x2kp0/Screen%20Shot%202021-08-17%20at%203.44.34%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 메시지 큐</title>
      <link>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90.html</link>
      <pubDate>Sun, 15 Aug 2021 02:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90.html</guid>
      <description>&lt;h3 id=&#34;메시지-큐&#34;&gt;메시지 큐&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;운영체제는 &lt;code&gt;IPC&lt;/code&gt;를 위해서 메시지 큐라는 객체를 제공한다. 메시지 큐는 말 그대로 큐라는 자료 구조로 구성되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐는 운영체제가 관리하는 별도의 객체로서 따라서 프로세스 A에서 프로세스 B에게 메시지를 전달하고자 프로세스 A에서 메시지 큐에 데이터를 복사하는 과정, 프로세스 B가 메시지 큐에서 데이터를 읽어오는 과정을 거쳐서 통신이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리를 설명했을 때와 유사한 순서로 메시지 큐의 생성, 메시지 큐의 타입 설정, 데이터 읽기, 데이터 쓰기의 과정에 관여하는 함수에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 사용하기 위해서는 &lt;code&gt;mq_open()&lt;/code&gt; 함수를 통해서 기존에 존재하는 메시지 큐에 접근할 수 있는 디스크립터를 얻어오거나 새로운 메시지 큐를 생성한 후에 생성된 메시지 큐에 접근할 수 있는 디스크립터를 얻어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// oflag에 O_CREAT가 명시된 경우
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);

// oflag에 O_CREAT가 명시되지 않은 경우
mqd_t mq_open(const char *name, int oflag);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;name: 메시지 큐 객체를 지칭하기 위한 이름&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oflag: 생성되는 메시지 큐의 특성 정의(공유 메모리의 oflag와 유사함)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mode: 생성되는 메시지 큐 객체의 퍼미션&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attr: 생성되는 메시지 큐 객체의 속성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;oflag&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;는 공유 메모리와 세마포어 함수의 &lt;code&gt;open&lt;/code&gt; 함수에서 사용되는 인자와 비슷한 성격을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct mq_attr {
  long mq_flags; // 메시지 큐의 블록, 논블록 설정 여부
  long mq_maxmsg; // 메시지 큐에 저장될 수 있는 메시지의 최대 수
  long mq_msgsize; // 메시지의 최대 사이즈 (바이트)
  long mq_curmsgs; // 메시지 큐에 들어있는 메시지의 수
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mq_attr&lt;/code&gt; 구조체는 생성되는 메시지 큐의 속성을 지정하기 위해서 사용되며 다음과 같이 정의된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int mq_getattr(mqd_t mqd, struct mq_attr *attr);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mqd: 속성값을 얻어오려고 하는 메시지 큐를 지칭하는 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attr: 속성값을 저장하기 위한 &lt;code&gt;mq_attr&lt;/code&gt; 구조체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐의 속성 정보는 &lt;code&gt;mq_getattr&lt;/code&gt; 함수를 사용하여 조회할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int mq_send(mqd_t mqd, const char *ptr, size_t len, unsigned int prio);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mqd&lt;/strong&gt;: 접근할 메시지 큐를 지정하기 위한 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ptr&lt;/strong&gt;: 전송할 데이터의 시작 지점을 가리키는 포인터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송할 데이터의 길이를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;prio&lt;/strong&gt;: 메시지의 우선순위를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐에 보내야 하는 데이터를 삽입하는 함수는 &lt;code&gt;mq_send&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ssize_t mq_receive(mqd_t mqd, char *ptr, size_t len, unsigned int *prio);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mqd&lt;/strong&gt;: 접근할 메시지 큐를 지정하기 위한 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ptr&lt;/strong&gt;: 전송받는 데이터의 시작 시점을 가리키는 포인터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송받는 데이터의 길이를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;prio&lt;/strong&gt;: 메시지의 우선순위를 나타내는 매개변수&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반면 메시지 큐에서 데이터를 읽어오는 함수는 &lt;code&gt;mq_receive&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;부모와 자식 프로세스 사이에서 간단한 문자열을 전송하는 프로그램을 작성해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로그램은 자식 프로세스를 하나 생성한다.&lt;/li&gt;
&lt;li&gt;자식 프로세스는 사용자에게 문자열을 입력 받은 후에 메시지 큐를 이용하여 부모 프로세스에게 전송한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스는 화면에 전송받은 문자열을 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;mqueue.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define MQ_NAME &amp;quot;/test_mq&amp;quot;

int main(int argc, char **argv)
{
  mqd_t mqfd;
  int pid;
  unsigned int priority = 10;
  char send_buff[50];
  void *read_buff;
  int read_len;

  struct mq_attr attr;
  attr.mq_flags = 0;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = 10;

  mqfd = mq_open(MQ_NAME, O_CREAT|O_RDWR, 644, &amp;amp;attr);
  if (mqfd == (mqd_t)-1)
  {
    perror(&amp;quot;mq_open failure from main&amp;quot;);
    printf(&amp;quot;Errno = %d\n&amp;quot;,errno);
    exit(0);
  }

  pid = fork();
  if (pid == 0) {
    printf(&amp;quot;child: &amp;quot;);
    scanf(&amp;quot;%s&amp;quot;, send_buff);
    if (mq_send(mqfd, send_buff, strlen(send_buff), priority) == -1) {
      fprintf(stderr, &amp;quot;MQ SEND ERROR\n&amp;quot;);
      exit(1);
    }
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;FORK FAILURE\n&amp;quot;);
    exit(1);
  } else {
    if (mq_getattr(mqfd, &amp;amp;attr) == -1) {
      fprintf(stderr, &amp;quot;MQ_GET_ATTR ERROR \n&amp;quot;);
      exit(1);
    }
    read_buff = malloc(attr.mq_msgsize);
    read_len = mq_receive(mqfd, read_buff, attr.mq_msgsize, &amp;amp;priority);
    printf(&amp;quot;parent receives: %s\n&amp;quot;, (char*)read_buff);
  }
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/yjytov82iozfi4s/Screen%20Shot%202021-08-15%20at%208.51.54%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정상적으로 자식 프로세스에서 보낸 문자열이 부모 프로세스로 전달된 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한가지 주의할 점은 &lt;code&gt;struct mq_attr&lt;/code&gt; 구조체의 값을 설정할 때 현재 시스템에서 허용 가능한 값이 정해져있으므로 시스템에서 정한 값을 넘지 않도록 주의해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 설정값은 &lt;code&gt;/proc/sys/fs/mqueue/&lt;/code&gt; 위치에 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8xbgyr5un86s3q6/Screen%20Shot%202021-08-15%20at%208.56.06%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=kdr0923&amp;amp;logNo=50073835187&#34;&gt;네이버 블로그 - 메시지큐 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 공유 메모리, 세마포어</title>
      <link>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4.html</link>
      <pubDate>Sun, 15 Aug 2021 01:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/15/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4.html</guid>
      <description>&lt;h3 id=&#34;공유-메모리&#34;&gt;공유 메모리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/uhpa9tuknwl5qti/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리는 프로세스와 프로세스 사이의 공유할 수 있는 메모리 공간을 지정하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리를 사용하려면 3가지 과정이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;공유 메모리 객체를 만드는 과정&lt;/li&gt;
&lt;li&gt;공유 메모리 객체의 크기를 설정하는 과정&lt;/li&gt;
&lt;li&gt;공유 메모리 객체를 프로세스 메모리 영역과 맵핑하는 과정&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt; // 함수 정의
#include &amp;lt;sys/stat.h&amp;gt; // mode 매크로의 정의
#include &amp;lt;fcntl.h&amp;gt; // 0_로 시작하는 상수 매크로의 정의

int shm_open(const char *name, int oflag, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shm_open()&lt;/code&gt; 함수는 특정 이름을 갖는 공유 메모리 객체를 생성한 후에 그 객체에 접근할 수 있는 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 함수와 마찬가지로, 만약 같은 이름을 갖는 객체가 이미 존재하면 그 객체를 지시하는 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두번째 매개변수로 사용하는 &lt;code&gt;int&lt;/code&gt; 형 &lt;code&gt;oflag&lt;/code&gt; 는 &lt;code&gt;open&lt;/code&gt; 계열 함수에서 공통적으로 사용하는 인자로 객체의 읽기 쓰기 속성과 &lt;code&gt;open&lt;/code&gt;이 실행될 때의 행동들을 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;매크로 이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;O_RDWR&lt;/td&gt;
&lt;td&gt;객체를 읽기 쓰기가 가능한 상태로 설정한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_RDONLY&lt;/td&gt;
&lt;td&gt;객체를 읽기만 가능한 상태로 설정한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_CREAT&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하지 않을 경우 새로운 객체를 생성한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_EXCL&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하면 에러를 발생시킨다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O_TRUNC&lt;/td&gt;
&lt;td&gt;해당 이름의 객체가 존재하면 사이즈 0으로 만든다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;int ftruncate(int fd, off_t length);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;생성한 공유 메모리의 크기를 지정하는 과정은 &lt;code&gt;ftruncate()&lt;/code&gt; 함수를 통해서 이루어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t off_set);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;맵핑 영역의 보호 수준을 지정하는 &lt;code&gt;prot&lt;/code&gt; 매개변수의 사용을 위해서 다음과 같이 매크로 값이 정의되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;매크로 이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PROT_READ&lt;/td&gt;
&lt;td&gt;데이터의 읽기 작업이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_WRITE&lt;/td&gt;
&lt;td&gt;데이터의 쓰기 작업이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_EXEC&lt;/td&gt;
&lt;td&gt;데이터의 실행이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROT_NONE&lt;/td&gt;
&lt;td&gt;데이터의 접근이 불가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매개변수 &lt;code&gt;flag&lt;/code&gt;는 맵핑된 데이터의 처리방식에 대한 정보를 지정하며 &lt;code&gt;MAP_SHARED&lt;/code&gt; 값으로 지정하면 다른 프로세스와 맵핑된 영역을 공유하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리 영역의 맵핑을 제거하려면 &lt;code&gt;munmap&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;

int munmap(void *addr, size_t len);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt;: 맵핑을 제거할 시작 주소&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;: 제거할 사이즈&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;공유-메모리-사용-예제&#34;&gt;공유 메모리 사용 예제&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;공유 메모리 영역을 생성한 후 정수형 카운터를 관리한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스는 카운터 값을 각각 증가시킨다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스 간에 공유되는 정보를 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define SM_NAME &amp;quot;/Test&amp;quot;

int main(int argc, char *argv[]) {
  int shmfd;
  int pid;
  int status;
  int *test_value;

  shmfd = shm_open(SM_NAME, O_RDWR | O_CREAT, 0777);
  if (shmfd == -1) {
    fprintf(stderr, &amp;quot;open error\n&amp;quot;);
    exit(1);
  }

  if (ftruncate(shmfd, sizeof(int)) == -1) {
    fprintf(stderr, &amp;quot;truncate error\n&amp;quot;);
    exit(1);
  }

  test_value = mmap(0, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  close(shmfd);

  *test_value = 10;

  printf(&amp;quot;test value: %d\n&amp;quot;, *test_value);

  pid = fork();
  if (pid == 0) {
    *test_value = *test_value + 1;
    printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
    sleep(3);
    *test_value = *test_value + 1;
    printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
    exit(1);
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;fork failure\n&amp;quot;);
    exit(1);
  }
  else {
    sleep(1);
    *test_value = *test_value + 5;
    printf(&amp;quot;parent process test value: %d\n&amp;quot;, *test_value);
    wait(&amp;amp;status);
  }
  shm_unlink(SM_NAME);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/2ofu5de7n9htzw8/Screen%20Shot%202021-08-15%20at%201.31.57%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;결과를 보면, 공유메모리를 10으로 한 변수를 자식 프로세스에서 1증가시킨 후 &lt;code&gt;sleep()&lt;/code&gt; 상태로 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 후에 부모프로세스에서 공유 메모리 값을 5 증가시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서, 자식 프로세스에서 깨어나서 다시 공유 메모리 값을 증가시킨것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞의 결과에서 부모 프로세스와 자식 프로세스 사이에서 공유 메모리 값이 공유된 다는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세마포어&#34;&gt;세마포어&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리에서는 메모리 영역의 맵핑 이후에 운영체제로 데이터를 복사하기 위한 쓰기 작업, 운영체제로부터 데이터를 가져오기 위한 읽기 작업이 요구되지 않는다는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 정보의 갱신 여부를 다른 프로세스에게 알리는 작업과 공유 메모리 영역에 대한 프로세스 간의 동기화 작업은 프로그래머의 몫으로 남게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번에 프로세스가 공유하는 자원에 대한 동기화를 지원해주는 방법중에 하나인 세마포어에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;크리티컬-섹션에-대한-접근-방법&#34;&gt;크리티컬 섹션에 대한 접근 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스 A와 프로세스 B가 하나의 카운터 변수를 공유하고 있다고 가정을 해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;카운터 변수를 1 증가시키는 방법은 다음과 같은 순서로 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;현재 카운터 변수 값을 읽는다.&lt;/li&gt;
&lt;li&gt;현재 카운터 변수의 값에 1을 더한 값을 계산한다.&lt;/li&gt;
&lt;li&gt;카운터 변수의 값을 2)번 결과물로 대체한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스 A가 카운터 변수의 값을 1 증가시키는 행위를 하는 도중에 프로세스 B가 카운터 변수의 값을 증가시키는 행위를 시도하면 프로세스 B는 A가 증가시킨 수치를 반영하지 못한채로 카운터 변수의 값을 읽어 올 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 프로세스 A, B가 한번씩 호출되어 총 2의 값이 증가해야하지만, 1의 값만 증가하는 현상이 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 같이 프로세스 간에 공동으로 관리되어야 하는 자원에 대한 읽기/쓰기가 이루어지는 코드 부분을 크리티컬 섹션이라고 부른다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 예제에서는 카운터 변수의 값을 읽은 후에 1을 증가시킨 새로운 변수로 카운터 변수의 값을 변경하는 일련의 과정이 크리티컬 섹션에 대응된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/26eahnfm27z9jim/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카운터 변수값의 동기화를 위해 하나의 프로세스가 카운터 변수에 접근하여 값을 읽고 그 값을 변화시키기 전에 다른 프로세스가 해당 변수에 접근하는 것을 방지할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;세마포어 값이 양수일 때만 크리티컬 섹션에 진입할 수 있다.&lt;/li&gt;
&lt;li&gt;프로세스는 크리티컬 섹션에 진입하면서 세마포어 값을 0으로 변경한다.&lt;/li&gt;
&lt;li&gt;프로세스는 크리티컬 섹션을 빠져나오면서 세마포어 값을 증가시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;세마포어의-사용&#34;&gt;세마포어의 사용&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;세마포어를 사용하려면 객체를 세마포어 객체로 생성해야 한다. 아래 함수를 통해서 세마 포어를 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;oflag에 O_CREAT가 설정된 경우&amp;gt;
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);

&amp;lt;oflag에 OCREAT가 설정되지 않은 경우&amp;gt;
sem_t *sem_open(const char *name, int oflag);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;크리티컬 섹션에 접근하려면, 지금 크리티컬 섹션을 수행하고 있는 프로세스가 있는지를 먼저 확인해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한, 크리티컬 섹션에 진입한 프로세스는 다른 프로세스가 크리티컬 섹션에 들어오는 것을 방지하기 위해서 세마포어 값을 감소시켜야 한다. 이러한 기능을 하는 함수는 &lt;code&gt;sem_wait&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sem_wait(sem_t *sem);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sem_wait&lt;/code&gt; 함수는 세마포어의 값을 확인하고 세마포어의 값이 0인 경우 그 값이 양수가 될 때까지 프로세스를 대기 상태로 전환시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세마포어 값이 0이라는 것은 다른 프로세스가 이미 해당 자원을 사용하는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세마포어 값이 양수가 되면 비로소 &lt;code&gt;sem_wait&lt;/code&gt; 함수 호출 이후의 코드가 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;크리티컬 섹션에 진입한 프로세스는 크리티컬 섹션에 해당하는 코드를 실행한 후에 다시 다른 프로세스가 크리티컬 섹션에 진입할 수 있도록 &lt;code&gt;sem_post&lt;/code&gt; 함수를 통해서 자원을 반납해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sem_post(sem_t *sem);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;세마포어와-공유-메모리&#34;&gt;세마포어와 공유 메모리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공유 메모리로 카운터 변수를 맵핑하여 사용한다고 생각을 해보자. 공유 메모리 영역에 대한 동기화는 전적으로 프로그래머에게 위임되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 아래 예제에서는 세마포어를 사용하여 프로세스 간에 동기화된 카운터를 사용할 수 있는 프로그램을 작성해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;공유 메모리 영역을 한 후 정수형 카운터를 관리한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스는 카운터 값을 각각 증가시킨다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스 간에 공유되는 정보를 확인한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스가 공동으로 접근할 수 있는 공유 메모리의 동기화를 위해서 세마포어를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;nclude &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;semaphore.h&amp;gt;

#define SM_NAME &amp;quot;/Test&amp;quot;
#define SEM_NAME &amp;quot;/SemTest&amp;quot;

int main(int argc, char *argv[]) {
  int shmfd, pid, status, i;
  int *test_value;
  sem_t *sem;

  sem = sem_open(SEM_NAME, O_RDWR | O_CREAT, 0777, 1);
  if (sem == SEM_FAILED) {
    fprintf(stderr, &amp;quot;sem open error\n&amp;quot;);
    exit(1);
  }

  shmfd = shm_open(SM_NAME, O_RDWR | O_CREAT, 0777);
  if (shmfd == -1) {
    fprintf(stderr, &amp;quot;shm open error\n&amp;quot;);
    exit(1);
  }

  if (ftruncate(shmfd, sizeof(int)) == -1) {
    fprintf(stderr, &amp;quot;truncate error\n&amp;quot;);
    exit(1);
  }

  test_value = mmap(0, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  close(shmfd);
  *test_value = 10;
  printf(&amp;quot;test value: %d\n&amp;quot;, *test_value);

  pid = fork();
  if (pid == 0) { // child process
    for (i = 0; i &amp;lt; 10; i++) {
      sem_wait(sem);
      *test_value = *test_value + 1;
      printf(&amp;quot;child process test value: %d\n&amp;quot;, *test_value);
      sem_post(sem);
    }
    exit(1);
  } else if (pid &amp;lt; 0) {
    fprintf(stderr, &amp;quot;fork failure\n&amp;quot;);
    exit(1);
  } else {
    for (i = 0; i &amp;lt; 10; i++) {
      sem_wait(sem);
      *test_value = *test_value + 5;
      printf(&amp;quot;parent process test value: %d\n&amp;quot;, *test_value);
      sem_post(sem);
    }
    wait(&amp;amp;status);
  }
  
  shm_unlink(SM_NAME);
  sem_unlink(SEM_NAME);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/4k8sdqd9yex8y8a/Screen%20Shot%202021-08-15%20at%202.18.56%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부모 프로세스나 자식 프로세스에서 세마포어 값을 얻기 위해서 &lt;code&gt;sem_wait&lt;/code&gt;을 호출하고 세마 포어 값이 0으로 만들었다면 &lt;code&gt;sem_post&lt;/code&gt;로 얻은 세마포어 값을 증가시키기전까지는 자식 프로세스에서 접근하지 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 파이프</title>
      <link>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%ED%8C%8C%EC%9D%B4%ED%94%84.html</link>
      <pubDate>Sat, 14 Aug 2021 03:13:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%ED%8C%8C%EC%9D%B4%ED%94%84.html</guid>
      <description>&lt;h3 id=&#34;파이프&#34;&gt;파이프&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/zmenrdqn0icmmou/download.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이프는 프로세스가 파이프 객체 생성을 요청하면 커널은 프로세스가 사용할 수 있는 메모리 공간 (버퍼)를 할당하고 그 버퍼에 접근할 수 있는 두 개의 파일 디스크립터를 프로세스에게 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프 버퍼에 저장되는 데이터는 바이트 흐름으로 취급된다. 두 개의 파일 디스크립터 중 하나는 읽기 작업 전용 나머지 하나는 쓰기 작업 전용으로 사용할 수 있다. 파이프 버퍼에 저장되는 데이터는 바이트 흐름으로 취급된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 개의 파일 디스크립터 중 하나는 읽기 작업 전용 나머지 하나는 쓰기 작업 전용으로 사용할 수 있다. 두 디스크립터 사이에서의 읽기 / 쓰기 작업의 혼용은 허용되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int pipe(int pipefd[2]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인자: &lt;strong&gt;pipefd[2]&lt;/strong&gt;: 파이프 버퍼에 접근하기 위한 두 개의 파일 디스크립터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프를 생성하기 위해서는 &lt;code&gt;pipe&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 개의 디스크립터 중 &lt;code&gt;pipefd[0]&lt;/code&gt;은 읽기 영역의 끝을 가리키며 &lt;code&gt;pipefd[1]&lt;/code&gt;은 읽기 영역의 끝을 가리킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프 또한 입출력 중 한 가지 방법이다. 따라서 저수준 입출력 함수를 이용하여 읽기/쓰기 작업을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프를 단일 프로세스에서 사용할 때에는 커널에서 제공받은 저장공간일 뿐 활용도가 업다. 파이프를 프로세스 사이의 통신을 위해 사용하려면 &lt;code&gt;fork()&lt;/code&gt; 함수와 함께 사용해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모 프로세스에서 파이프를 생성하고 &lt;code&gt;fork()&lt;/code&gt;를 통해서 자식 프로세스를 생성하면 파이프에 접근할 수 있는 파일 디스크립터들이 복사된다. 따라서 부모 프로세스와 자식 프로세스 사이의 데이터 교환이 가능해지며 또한, 자식 프로세스들끼리도 파이프를 이용하여 통신하는 것이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이프는 프로세스 간 통신을 할 때 해당 파이프에 대해서 쓰기 작업을 수행하는 프로세스와 읽기 작업을 하는 프로세스를 정해서 한 방향으로 통신하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 두 프로세스 또는 그 이상의 프로세스가 &lt;code&gt;write()&lt;/code&gt; 함수를 이용하여 파이프에 데이터를 쓰는 것이 가능하지만, 그러나 파이프는 데이터를 연속된 바이트의 흐름으로 처리하기 때문에, 프로세스 별로 쓴 데이터를 구별해주지 않고 파이프 버퍼에 쌓일 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rl7x72prngofxov/images.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 그림처럼 &lt;code&gt;fork()&lt;/code&gt; 함수 이후에 사용하지 않는 프로세스 A의 &lt;code&gt;pipefd[0]&lt;/code&gt;과 프로세스 B의 &lt;code&gt;pipefd[1]&lt;/code&gt;을 &lt;code&gt;close()&lt;/code&gt; 함수를 통해서 닫아주는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이유는 파이프 통신의 종료와 연관되어 있는데, 파이프 &lt;code&gt;write()&lt;/code&gt;에 해당하는 파일 디스크립터로 &lt;code&gt;close()&lt;/code&gt; 함수를 호출하면 &lt;code&gt;read()&lt;/code&gt; 함수는 버퍼에 있는 모든 데이터를 읽고 &lt;code&gt;EOF&lt;/code&gt;를 만난다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;read()&lt;/code&gt; 함수를 호출한 프로세스는 상대방 프로세스가 파이프 연결을 끊었다는 사실을 &lt;code&gt;read()&lt;/code&gt; 함수의 반환값으로 인지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 단위로 운영되는 &amp;lsquo;열린 파일 테이블&amp;rsquo;의 엔트리는 하나의 파일 디스크립터라도 해당 엔트리를 가리키고 있다면 없어지지 않는다. 만약 프로세스 A의 &lt;code&gt;pipefd[0]&lt;/code&gt;이 열려 있더라면, 프로세스 B가 &lt;code&gt;pipefd[0]&lt;/code&gt;을 닫아도 &amp;lsquo;열린 파일 테이블의&amp;rsquo; 해당 엔트리를 사라지지 않으므로 프로세스 A는 프로세스 B가 파이프를 닫았다는 사실을 알 방법이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;부모 프로세스는 사용자에게 문자열을 입력받는다.&lt;/li&gt;
&lt;li&gt;부모 프로세스는 자식 프로세스에게 파이프를 통해서 사용자가 입력한 문자열을 전송한다.&lt;/li&gt;
&lt;li&gt;자식 프로세슨느 부모 프로세스가 전달한 문자열을 파일에 쓴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

void error_proc(const char *);

int main(int argc, char *argv[]) {
  int pipe_fd[2];
  int res;
  char buff[BUFSIZ];
  pid_t pid;
  int read_len, n_write;
  int open_fd, status;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s [file] \n&amp;quot;, argv[0]);
  }

  res = pipe(pipe_fd);
  if (res == -1) error_proc(&amp;quot;pipe&amp;quot;);

  pid = fork();
  
  if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
  if (pid == 0) { // child
    close(pipe_fd[1]);
    open_fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC);
    while (1) {
      read_len = read(pipe_fd[0], buff, BUFSIZ - 1);
      if (read_len == -1) error_proc(&amp;quot;read&amp;quot;);
      if (read_len == 0) break;
      write(open_fd, buff, read_len);
    }
    printf(&amp;quot;parent process closed the pipe. \n&amp;quot;);
    close(open_fd);
    close(pipe_fd[0]);
    return 0;
  } else { // parent
    close(pipe_fd[0]);
    while (1) {
      fgets(buff, BUFSIZ - 1, stdin);
      read_len = strlen(buff);
      if (read_len == 4 &amp;amp;&amp;amp; !strncmp(buff, &amp;quot;END&amp;quot;, 3))
        break;
      n_write = write(pipe_fd[1], buff, read_len);
      if (n_write == -1) error_proc(&amp;quot;write&amp;quot;);
      printf(&amp;quot;%d bytes are written \n&amp;quot;, n_write);
    }
    close(pipe_fd[1]);
    wait(&amp;amp;status);
    return 0;
  }
}

void error_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로세스 사이의 통신 - 시그널</title>
      <link>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EC%8B%9C%EA%B7%B8%EB%84%90.html</link>
      <pubDate>Sat, 14 Aug 2021 01:13:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/14/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EC%8B%9C%EA%B7%B8%EB%84%90.html</guid>
      <description>&lt;h3 id=&#34;프로세스-사이의-통신&#34;&gt;프로세스 사이의 통신&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;운영체제는 같은 호스트상에서 실행중인 프로세스 사이의 통신을 가능하게 하는 여러가지 방법을 제공하며, 소켓 API도 그 중에 하나일 뿐이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시그널&#34;&gt;시그널&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우리 몸에는 신체 내부 또는 외부의 자극을 받아들여 다른 부위로 전달하고 반응을 일으키는 신체기관인 신경계가 있다. 컴퓨터에서 이와 비슷한 역할을 하는 것이 바로 시그널이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 프로세스에게 전달되는 특정 정보를 포함하고 있는 신호이다. 리눅스 운영체제의 경우 여러 가지 사건들에 번호를 부여하여 관리하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 운영체제에서 프로세스로 전달할 수 있고 프로세스에서 다른 프로세스로 전달할 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널을 발생시키는 발생시키는 다양한 사건은 크게 에러 발생, 외부에서 발생한 사건, 명시적인 호출과 같이 세 가지 유형으로 분류할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;산술적인 에러, 정수 오버플로우, 정수를 0으로 나눈 경우 등과 같이 프로그램에서 발생한 에러를 운영체제에서 검출했을 경우에도 시그널이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력의 도착, 타이머의 경과, 자식 프로세스 종료와 같은 외부 사건이 발생 했을 때도 시그널은 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 명시적으로 시그널을 발생시키는 라이브러리 함수가 호출된 경우에도 시그널이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ubmet9kiegrgcpm/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시그널이 프로세스로 배달되면 프로세스는 해당 시그널을 위하여 정의된 핸들러 루틴을 실행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시그널은 무시하거나, 시그널이 발생하였을 때 처리할 수 있는 함수를 지정하여 해당 함수를 호출하거나 시그널 종료에 따라서 기본 동작을 수행하는 것이 대표적으로 정의된 루틴이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시그널의-종류&#34;&gt;시그널의 종류&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/op31x0lmokqmf3k/Screen%20Shot%202021-08-14%20at%201.26.13%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;signal.h&lt;/code&gt; 파일에는 시그널이 양의 정수 매크로로 정의되어 있다. 정의된 매크로의 값은 &lt;code&gt;kill -l&lt;/code&gt; 명령어를 통해서도 확인 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용빈도가 높은 시그널들을 다음 표에 정리해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;번호&lt;/th&gt;
&lt;th&gt;매크로이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;사용자가 발생시키는 인터럽트 (CTRL + C)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;SIGQUIT&lt;/td&gt;
&lt;td&gt;프로그램 종료와 코어 파일 작성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;SIGFPE&lt;/td&gt;
&lt;td&gt;부동소수점에러가 발생했을 때 발생하는 시스널&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;즉각적인 프로그램 종료를 위해 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;SIGALRM&lt;/td&gt;
&lt;td&gt;지정된 타이머의 경과&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;SIGTERM&lt;/td&gt;
&lt;td&gt;프로그램 종료를 위한 시그널 (kill 명령어의 DEFAULT 시그널)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;SIGHLD&lt;/td&gt;
&lt;td&gt;자식 프로세스의 종료 시에 발생하는 시그널&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;SIGSTOP&lt;/td&gt;
&lt;td&gt;프로세스를 정지시키는 시그널&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;만약 우리가 시그널로 정의 되어 있는 특정 사건의 발생 여부에 관심이 있고 그 사건이 발생할 때 마다 무언가를 하고 싶다면 어떻게 해야할까?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다음과 같은 경우에는 시그널이 발생했을 때 처리를 담당하는 핸들러 함수를 정의하고 운영체제에게 해당 사건이 발생 했을 때, 정의한 핸들러 함수를 호출해달라고 부탁하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void (*signal(int sig, void (*func) (int)))(int);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;핸들러 함수를 운영체제에 등록하는 함수는 위와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;터미널에서 &lt;code&gt;CTRL + C&lt;/code&gt; 입력을 통해서 &lt;code&gt;SIGINT&lt;/code&gt; 시그널이 발생하였을 때, 이벤트가 발생했음을 화면에 출력하는 예제 프로그램이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int global_count = 10;

void sigint_handler(int sig) {
  if (sig == SIGINT) {
    printf(&amp;quot;received SIGINT... %d lives left \n&amp;quot;, global_count--);
  }

  if (global_count &amp;lt;= 0) {
    signal(SIGINT, SIG_DFL);
  }
}

int main(int argc, char *argv[]) {
  int i = 0;
  signal(SIGINT, sigint_handler); // 터미널 창에서 CTRL + C 입력을 받으면 운영체제에게 sigint_handler 함수를 호출해 달라는 요청을 하는 과정이다.
  while (1) {
    printf(&amp;quot;%d: sleep and awake \n&amp;quot;, ++i);
    sleep(5);
  }
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/un56ovw91qk8anq/Screen%20Shot%202021-08-14%20at%201.45.16%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CTRL + C&lt;/code&gt;를 누를 때마다, 시그널 핸들러에 등록한 함수가 실행되고, 곧바로 &amp;ldquo;sleep and awake&amp;rdquo; 문자열이 출력되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이것은 시그널이 발생하면 &lt;code&gt;sleep()&lt;/code&gt; 함수의 호출을 통해서 &lt;code&gt;sleep()&lt;/code&gt; 상태에 있는 프로세스가 깨어난다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sigaction-함수&#34;&gt;SIGACTION 함수&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;다음은 &lt;code&gt;signal()&lt;/code&gt; 함수보다는 복잡하지만, 추가적인 기능을 제공하는 &lt;code&gt;sigaction()&lt;/code&gt; 함수에 대해서 이야기를 해보자&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int sigaction(int sig, const struct sigaction *act, struct sigaction * oldact);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;sig : 시그널 dml 종류를 지칭하는 시그널 번호&lt;/li&gt;
&lt;li&gt;act: 시그널 발생시 호출되는 시그널 핸들러의 포인터&lt;/li&gt;
&lt;li&gt;oldact: 이전에 등록되었던 시그널 핸들러의 포인터&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;struct sigaction {
  void (*sa_handler)(int);
  sigset_t sa_mask;
  int sa_flags;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sigaction&lt;/code&gt; 함수는 시그널 핸들러 정보를 관리하기 위해서 &lt;code&gt;sigaction&lt;/code&gt; 이라는 구조체를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예제-1&#34;&gt;예제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;터미널에서 CTRL + C 입력을 통해서 SIGINT 시그널을 발생시킨다.&lt;/li&gt;
&lt;li&gt;1초에 한번 씩 카운트를 1씩 감소시켜 카운트 값이 0이되면 프로그램을 종료한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

int main(int argc, char *argv[]) {
  int i = 5;
  struct sigaction new_action, old_action;

  new_action.sa_handler = SIG_IGN; // 핸들러로 SIG_IGN 등록
  sigemptyset(&amp;amp;new_action.sa_mask);
  new_action.sa_flags = 0;

  sigaction(SIGINT, &amp;amp;new_action, &amp;amp;old_action);

  while (1) {
    printf(&amp;quot;%d: sleep and awake \n&amp;quot;, i--);
    sleep(1);
    if (i == 0) break;
  }
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/nzeqyb1y8xish4k/Screen%20Shot%202021-08-14%20at%201.57.51%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CTRL + C를 눌러도 프로그램의 루틴이 모두 실행될 때까지 프로그램은 종료되지 않는다. &lt;code&gt;SIGINT&lt;/code&gt; 시그널을 무시하도록 시그널 핸들러를 설정했기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시그널-발생&#34;&gt;시그널 발생&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;지금까지는 시그널을 전달받았을 때, 그것을 처리하는 방법에 대해서 다뤘고, 마지막으로 시그널을 발생시키는 함수에 대해서 다뤄볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

int kill (pid_t pid, int sig);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;pid: 시그널을 전송하려고 하는 목적지 프로세스의 PID&lt;/li&gt;
&lt;li&gt;sig: 시그널의 종류 선택&lt;/li&gt;
&lt;li&gt;결과값: 성공시 0, 실패시 -1&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;kill()&lt;/code&gt; 함수의 첫번째 인자의 PID는 음수또는 0을 입력 받을 수 있는데 의미는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;음수로 입력한 경우에는 pid의 절대값이 지칭하는 프로세스가 속해있는 프로세스 그룹 전체로 시그널이 전달된다.&lt;/li&gt;
&lt;li&gt;0을 입력받는 경우 &lt;code&gt;kill&lt;/code&gt; 함수를 호출한 프로세스가 속해있는 프로세스 그룹 전체로 시그널이 전달된다.&lt;/li&gt;
&lt;li&gt;-1을 입력 받는 경우 &lt;code&gt;kill&lt;/code&gt; 함수를 호출한 프로세스가 시그널을 전송할 수 있는 권한을 가지고 있는 모든 프로세스에게 시그널이 전달된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 13 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/29cm/%EC%9C%A0%EC%A0%80-%EC%A3%BC%EB%AC%B8-%EC%B7%A8%EC%86%8C-%EA%B8%B0%EB%8A%A5-java-%EC%A0%84%ED%99%98%EA%B8%B0-d218e5ecb874&#34;&gt;유저 주문 취소 기능 Java 전환기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ui.toast.com/weekly-pick/ko_20210812&#34;&gt;React 상태 관리 라이브러리 Zustand의 코드를 파헤쳐보자&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이슈를 구현하기 전에 설계를 하는 것이 버그가 없고, 복잡한 비즈니스 로직을 분석하는데 좋은 것 같다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;플로우 차트나, 클래스 다이어그램은 너무 무거운 느낌도 있으나, 이것은 업무 복잡도에 따라서 결정하면 될 것 같고, 새로운 도메인을 만나고 공부를 해야할 때 도 모델을 그려서 서로 도메인 전문가랑 이야기를 하면 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새로운 리액트 상태 관리 라이브러리에 대해서 알게 되었다. 프로젝트에 도입하게 될 지는 모르겠지만, 리액트 상태관리가 더 쉬워졌으면 좋겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고 코딩 테스트 문제를 풀어야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그동안 미뤄두었던 시스템 프로그래밍 공부를 해야겠다. 오늘은 프로세스 사이 통신 및, 입출력과 소켓에 대해서 공부를 하면 될 것 같다. (20:00 ~ 24:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, 틈틈히 도메인 주도 개발 스터디를 위해서 책을 읽으면 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 열심히 일을 하고 꾸준히 공부하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>멀티 프로세스를 이용한 에코 및 채팅 서버</title>
      <link>https://dongwooklee96.github.io/post/2021/08/13/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EC%BD%94-%EB%B0%8F-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B2%84.html</link>
      <pubDate>Fri, 13 Aug 2021 01:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/13/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EC%BD%94-%EB%B0%8F-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B2%84.html</guid>
      <description>&lt;h3 id=&#34;멀티-프로세스-에코-서버&#34;&gt;멀티 프로세스 에코 서버&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;커널은 파일 디스크립터에 대한 정보를 파일 디스크립터 테이블에 관리한다. 파일 디스크립터 테이블은 프로세스당 하나씩 생성된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터 테이블은 프로세스당 하나씩 생성된다. 또한 커널은 시스템 상에 열려 있는 모든 열린 파일에 대한 정보를 저장하고 있으며, 시스템당 하나만 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터 테이블은 열린 파일 테이블에 대한 링크를 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 &lt;code&gt;fork()&lt;/code&gt;를 이용하여 자식 프로세스를 생성하면 커널은 자식 프로세스를 위한 파일 디스크립터 테이브을 생성하고, 이때 모든 값이 복사되기 때문에 두 파일 디스크립터 테이블은 같은 값을 가지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널의 열린 파일 테이블 입장에서보면, 하나의 열린 파일 엔트리를 가리키는 파일 디스크립터 테이블의 엔트리가 두개 가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상황에서, 하나의 프로세스가 &lt;code&gt;close()&lt;/code&gt; 함수를 실행하면 열린 파일을 가리키고 있는 파일 디스크립터 테이블의 엔트리가 존재하는 한 &lt;code&gt;close&lt;/code&gt; 함수는 열린 파일 디스크립터 테이블의 해당 엔트리만 삭제한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void error_proc();
void error_print();

int main(int argc, char* argv[]) {
  int server_sd, client_sd;
  struct sockaddr_in server_addr, client_addr;

  int client_addr_len, read_len;
  char read_buffer[BUFSIZ];
  pid_t pid;

  if (argc != 2) {
    printf(&amp;quot;usage: %s [port] \n&amp;quot;, argv[0]);
    exit(1);
  }
  printf(&amp;quot;server start...\n&amp;quot;);

  server_sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (server_sd == -1) error_proc();

  memset(&amp;amp;server_addr, 0, sizeof(server_addr));
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(atoi(argv[1]));

  if (bind(server_sd, (struct sockaddr *)&amp;amp;server_addr, sizeof(server_addr)) == -1) error_proc();

  if (listen(server_sd, 5) &amp;lt; 0) error_proc();

  client_addr_len = sizeof(client_addr);

  while(1) {
    client_sd = accept(server_sd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;client_addr_len);
    if (client_sd == -1) {
      error_print();
      continue;
    }
    printf(&amp;quot;client %s: %d is connected...\n&amp;quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    pid = fork();
    if (pid == 0) { /* child process */
      close(server_sd);
      while (1) {
        read_len = read(client_sd, read_buffer, sizeof(read_buffer) - 1);
        if (read_len == 0) break;
        read_buffer[read_len] = &#39;\0&#39;;
        printf(&amp;quot;client (%d): %s\n&amp;quot;, ntohs(client_addr.sin_port), read_buffer);
        write(client_sd, read_buffer, strlen(read_buffer));
      }
      printf(&amp;quot;client (%d) : is disconnected\n&amp;quot;, ntohs(client_addr.sin_port));
      close(client_sd);
      return 0;
    } else if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
    else {
      close(client_sd);
    }
  }
  close(server_sd);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;간단한-udp-멀티-프로세스-채팅-프로그램&#34;&gt;간단한 UDP 멀티 프로세스 채팅 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;채팅 서버의 역할은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트의 접속 처리&lt;/li&gt;
&lt;li&gt;클라이언트가 전송하는 문자열을 다른 클라이언트들에게 전송&lt;/li&gt;
&lt;li&gt;클라이언트의 접속 종료 처리&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 중에서, 클라이언트가 전송하는 문자열을 다른 클라이언트들에게 전송하는 기능은 여러 클라이언트들의 데이터를 하나의 소켓으로 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;recvfrom&lt;/code&gt; 함수를 통해서 전달받은 문자열을 &lt;code&gt;sendto&lt;/code&gt; 함수로 전송한 클라이언트를 제외한 모든 클라이언트 들에게 전송하면 작업을 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;채팅 서버&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

#define MAX_CLIENT 10

void error_proc(const char*);

int check_sock_list(struct sockaddr_in *entry, struct sockaddr_in *list, int count);

int main(int argc, char* argv[]) {
  int my_sock, read_len, n_recv, res;
  char buff[BUFSIZ];
  char name_buffer[50];
  char *str_addr;
  struct sockaddr_in src_addr, dest_addr;

  socklen_t addr_len;
  int n_client = 0, i = 0, port;
  struct sockaddr_in sockets[MAX_CLIENT];

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s port&amp;quot;, argv[0]);
    return 0;
  }

  memset(&amp;amp;sockets, 0, sizeof(sockets[0])*MAX_CLIENT);
  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);

  memset(&amp;amp;src_addr, 0, sizeof(src_addr));
  src_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  src_addr.sin_family = AF_INET;
  src_addr.sin_port = htons(atoi(argv[1]));

  res = bind(my_sock, (struct sockaddr*)&amp;amp;src_addr, sizeof(src_addr));
  if (res == -1) error_proc(&amp;quot;bind&amp;quot;);
  addr_len = sizeof(dest_addr);

  while (1) {
    n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0,
        (struct sockaddr *) &amp;amp;dest_addr, &amp;amp;addr_len);
    if (n_recv == -1) error_proc(&amp;quot;recvfrom&amp;quot;);
    res = check_sock_list(&amp;amp;dest_addr, sockets, n_client);

    if (res == n_client) {
      if (res == MAX_CLIENT) continue;
      else {
        memcpy(&amp;amp;sockets[res],
            &amp;amp;dest_addr, sizeof(dest_addr));
        n_client++;
      }
    }
    printf(&amp;quot;n_client: %d\n&amp;quot;, n_client);
    str_addr = inet_ntoa(dest_addr.sin_addr);
    sprintf(name_buffer, &amp;quot;%s: %d &amp;gt;&amp;gt; &amp;quot;, str_addr, ntohs(dest_addr.sin_port));

    for (i = 0; i &amp;lt; n_client; i++) {
      if (i == res) continue; // sender == receiver skip
      sendto(my_sock, name_buffer, strlen(name_buffer), 0, (struct sockaddr *) &amp;amp;sockets[i], addr_len);
      sendto(my_sock, buff, n_recv, 0, (struct sockaddr *) &amp;amp;sockets[i], addr_len);
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;채팅 클라이언트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void error_proc(const char*);

int main(int argc, char* argv[]) {
  int my_sock, read_len, n_sent, n_recv;
  char buff[BUFSIZ];
  char str_addr;
  struct sockaddr_in dest_addr;
  socklen_t addr_len;
  pid_t pid;

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  memset(&amp;amp;dest_addr, 0, sizeof(dest_addr));
  dest_addr.sin_addr.s_addr = inet_addr(argv[1]);
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_port = htons(atoi(argv[2]));
  addr_len = sizeof(dest_addr);

  pid = fork();
  if (pid == -1) error_proc(&amp;quot;fork&amp;quot;);
  if (pid == 0) {
    while (1) {
      n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0, (struct sockaddr*) &amp;amp;dest_addr, &amp;amp;addr_len);
      if (n_recv == -1) error_proc(&amp;quot;read&amp;quot;);
      write(1, buff, n_recv);
    }
  } else {
    while (1) {
      fgets(buff, BUFSIZ - 1, stdin);
      read_len = strlen(buff);
      if (read_len == 0) error_proc(&amp;quot;fgets&amp;quot;);
      n_sent = sendto(my_sock, buff, read_len, 0, (struct sockaddr*) &amp;amp;dest_addr, addr_len);
      if (n_sent == -1) error_proc(&amp;quot;write&amp;quot;);
      buff[read_len - 1] = &#39;\0&#39;;
      if (!strcmp(buff, &amp;quot;END&amp;quot;)) break;
    }
    kill(pid, SIGTERM);
  }
  return 0;
}

void error_proc(const char* str) {
  fprintf(stderr, &amp;quot;%s:%s \n&amp;quot;, str, strerror(errno));
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;서버 화면&lt;/strong&gt;
&lt;img src=&#34;https://dl.dropbox.com/s/fpxyeusfjxy8d2h/Screen%20Shot%202021-08-13%20at%202.47.58%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/cguiw5wx46zoxjl/Screen%20Shot%202021-08-13%20at%202.47.48%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클라이언트2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8f8w1a3j8jrpuf3/Screen%20Shot%202021-08-13%20at%202.47.53%20AM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트 간의 통신이 이루어지는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 12 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고 코딩 테스트 문제를 풀어야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운동을 하기 위해서 복싱 도장에 간다. (19:00 ~ 20:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그동안 미뤄두었던 시스템 프로그래밍 공부를 해야겠다. (22:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;운동은 건강 뿐만 아니라, 목표를 달성하는데 좋은 수단인 것 같다. 따라서 운동을 꾸준히 하기 위해서 노력하고 일과를 끝내면 운동을 하러 가자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBMS 분야의 메인 컨트리뷰터가 되기 위해서 노력하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 11 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=JYd6EHl7i-g&amp;amp;t=171s&#34;&gt;게임프로그래머 실력향상법 자료조사 ver 2.0&lt;/a&gt; 라는 영상을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트는 최소 일주일에 한번은 코드 푸시를 해야한다고 했다. 나도 이를 명심하고 꾸준하게 토이 프로젝트를 통해서 개발을 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 도메인 주도 설계 스터디에 참석하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어제 리눅스 파운데이션 멘토링 신청서를 작성하면서, 링크드인 프로필을 수정하였다. 나를 어필할 수 있는 좋은 수단인 것 같아서 꾸준히 관리하고 이를 채워나갈 학습 및 해커톤에 많이 참가해야겠다는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다이내믹 프로그래밍에 대해서 학습을 했는데, 기본적으로 재귀적으로 풀어나갈 수 있는 능력이 필요하다고 생각되었다. 재귀적으로 문제를 풀 수 있도록 많은 연습을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 멘토링 마감 기한이 얼마 남지 않아, 아마도 합격하기는 힘들 수도 있지만, 그래도 제출은 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 내가 수정하거나 기능 추가로 인해서 영향이 가는 부분을 기록을 해야할 것 같다. 나중에 이를 파악하려고 하니까 기억나지도 않고 자세하지 않은 부분이 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;책을 읽고 나서, 이를 정리해보는 것이 굉장히 중요한 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단순히 배운 지식을 나열하는 것이 아니라, 직접 모델을 설계해 볼 수 있어서 좋았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 일과가 끝난후에 간단히 운동을 하려고 했으나 하지 않았다. 차라리 점심시간에 운동을 간단하게 하는것이 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일과가 끝난 후에, 코딩 테스트 문제를 풀 것이다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도메인 주도 설계 책을 학습 (19:00 ~ 21:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도메인 주도 설계 스터디 참여  (21:00 ~ 24:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 리눅스 커널과, DBMS 분야의 메인 컨트리뷰터가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>동적 프로그래밍 문제 파악</title>
      <link>https://dongwooklee96.github.io/post/2021/08/10/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C-%ED%8C%8C%EC%95%85.html</link>
      <pubDate>Tue, 10 Aug 2021 19:15:14 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/10/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EC%A0%9C-%ED%8C%8C%EC%95%85.html</guid>
      <description>&lt;h3 id=&#34;동적-프로그래밍-문제-파악&#34;&gt;동적 프로그래밍 문제 파악&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동적 프로그래밍으로 해결하는 문제는 모든 경우의 수를 파악하여 진행하면서 지수승의 시간 복잡도를 가지는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 경우의 수를 조합하면서, 확인하는 과정을 가지는 문제는 동적 프로그래밍 접근법이 가능하다고 보면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음과 같은 키워드가 들어가면, 동적 프로그래밍 접근법을 이용하여 풀 수 있는 문제이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;shortest&amp;quot;, &amp;quot;longest&amp;quot;, &amp;quot;minimized&amp;quot;, &amp;quot;maximized&amp;quot;, 
&amp;quot;least&amp;quot;, &amp;quot;most&amp;quot;, &amp;quot;fewest&amp;quot;, &amp;quot;greatest&amp;quot;, &amp;quot;biggest&amp;quot;, &amp;quot;smallest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;단계별-동적-프로그래밍-문제-해결-방법&#34;&gt;단계별 동적 프로그래밍 문제 해결 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;전체 탐색(&lt;code&gt;Brute Force&lt;/code&gt;) 방법으로 우선 문제를 해결해본다.&lt;/li&gt;
&lt;li&gt;그 다음에 해당 풀이를 분석하여, 반복되는 작업을 정리한다, 즉 전체 탐색에서 하위 문제로 쪼개어보고 반복되는 단계가 있는지를 찾아낸다.&lt;/li&gt;
&lt;li&gt;순조롭게 진행되면 역으로 동적 방식이 용이하다고 판단할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=267996120&#34;&gt;쓰면서 익히는 알고리즘과 자료구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 10 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://lfx.linuxfoundation.org/blog/advance-your-open-source-skills-with-real-world-mentorships/?utm_campaign=LFX%20August%20Content%20Campaign%20-%20Contributors%20%26%20Maintainers&amp;amp;utm_content=175836337&amp;amp;utm_medium=social&amp;amp;utm_source=linkedin&amp;amp;hss_channel=lcp-208777&#34;&gt;Advance Your Open Source Skills with Real-World Mentorships&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mentorship.lfx.linuxfoundation.org/project/2145d0aa-4812-4c6b-9108-42d64deea738&#34;&gt;Linux kernel PCI project&lt;/a&gt; 리눅스 재단에서 리눅스 커널 관련 멘토링을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/musinsa-tech/mab-211d14d2090b&#34;&gt;MAB 알고리즘을 이용하여 효율적으로 정렬하기&lt;/a&gt; 무신사 기술 블로그를 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 컨트리뷰톤 행사에 참여하지 못하게 되었는데 이 행사를 참여하면 좋을 것 같다. 합격하기 힘들것 같기는 하더라도, 일단 지원은 해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내일은 도메인 주도 설계 스터디가 있는 날이다. 스터디를 하기 전에 미리 책을 읽어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실시간 데이터 처리와 복잡한 수식을 바탕으로 한 정렬 알고리즘을 적용하는 것이 인상깊었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 과연 나중에, 필요한 기술들을 이론을 보고 적용할 수 있을까라는 생각을 하였고 그렇게 할 수 있도록 노력해야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;책임감을 가지고, 열심히 일하자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일과가 끝난 후에, 코딩 테스트 문제를 풀 것이다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;간단히 산책을 할 것이다. (18:00 ~ 19:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 프로그래밍 공부를 할 것이다 (프로세스 관련) (21:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도메인 주도 설계 책을 간단히 읽어볼 것이다. (23:00 ~ 24:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>UDP 소켓 프로그래밍</title>
      <link>https://dongwooklee96.github.io/post/2021/08/09/udp-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</link>
      <pubDate>Mon, 09 Aug 2021 22:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/09/udp-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</guid>
      <description>&lt;h3 id=&#34;udp-소켓-프로그래밍&#34;&gt;UDP 소켓 프로그래밍&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;에서는 &lt;code&gt;TCP&lt;/code&gt;에서 제공하는 신뢰적인 정보 전달, 순차적인 정보 전달, 흐름 제어, 혼잡 제어와 같은 서비스를 제공하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대신 포트번호를 사용하여 데이터를 올바른 프로세스에게 전달해주는 서비스, 즉 전송 계층 프로토콜이 제공해주는 서비스 중 필 수 서비스만을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 위에서 나열한 서비스를 제공하기 위해서 &lt;code&gt;TCP&lt;/code&gt; 모듈 간의 정보를 공유해야하고 이를 위해 결국 네트워크 자원을 소모한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그에 비해서 &lt;code&gt;UDP&lt;/code&gt;는 카운터 파트들 사이에 정보를 공유할 필요가 없으니 그만큼 가볍다고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;는 전송 계층 프로토콜의 핵심 기능인 호스트 안에서의 프로세스 식별을 통한 데이터 배달만을 수행하는 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;TCP&lt;/code&gt; 처럼 안정적이고 순차적인 데이터 전달을 보장하지 않으며, 흐름제어와 혼잡 제어를 수행하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;헤더 구조가 단순하며, 주로 동영상 스트리밍, 인터넷 전화와 같은 실시간 응용에 많이 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 소켓을 생성하고 연결을 한 이후에 통신이 가능하다, 또한 전송되는 &lt;code&gt;TCP&lt;/code&gt; 세그먼트의 성공적인 전달 여부를 확인하기 위해서 수신자 &lt;code&gt;TCP&lt;/code&gt; 모듈은 &lt;code&gt;ACK&lt;/code&gt; 세그먼트를 추가적으로 전달한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;의 경우 전송할 데이터가 생기면 바로 상대방 &lt;code&gt;UDP&lt;/code&gt; 모듈로 전송을 시도한다. 응용 계층으로부터 의뢰받은 데이터에 &lt;code&gt;UDP&lt;/code&gt; 포트 넘버가 적혀있는 &lt;code&gt;UDP&lt;/code&gt; 헤더만을 붙인 이후에 바로 네트워크 계층에 전송 서비스를 의뢰한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-헤더&#34;&gt;UDP 헤더&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/twjz782l8j32syf/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SOURCE PORT, DESTINATION PORT:&lt;/strong&gt; 출발지 포트와, 목적지 포트인 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt; 데이터 그램의 크기를 나타낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CHECK SUM&lt;/strong&gt; 데이터 무결성 검사를 위한 체크섬&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-소켓&#34;&gt;UDP 소켓&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;는 연결지향적이지 않기 때문에, 송신자와 수신자 간의 연결과 연결 종료 절차가 없을 것이고 소켓에 수신자와 송신자 쌍에 대한 정보도 없을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 읽기 쓰기를 할 때는 상대방의 주소 정보를 항상 포함해야 될 것이다. 또한 주고 받는 데이터를 바이트 스트림으로 취급하는 &lt;strong&gt;TCP&lt;/strong&gt;와는 다르게 &lt;strong&gt;UDP&lt;/strong&gt;는 하나의 데이터그램 단위로 읽기/쓰기 작업을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UDP 소켓의 특징&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결 / 연결 종료 절차가 없음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓에 수신자, 송신자 쌍에 대한 정보를 저장하지 않음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터그램 단위로 읽기/쓰기 진행&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp-서버-클라이언트-모델&#34;&gt;UDP 서버 클라이언트 모델&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;소켓-생성&#34;&gt;소켓 생성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;전송 계층 프로토콜로 &lt;strong&gt;UDP&lt;/strong&gt;를 사용하려면, &lt;code&gt;socket&lt;/code&gt; 함수의 인자를 다음과 같이 설정해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
socket (AF_INET, SOCK_DGRAM, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;데이터-전송&#34;&gt;데이터 전송&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;소켓 전용 입출력 함수인 &lt;code&gt;sendto&lt;/code&gt;를 이용하여 &lt;strong&gt;UDP&lt;/strong&gt; 데이터그램을 전송하는 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t sendto (
    int sockfd,
    const void *buf,
    size_t len,
    int flags,
    const struct sockaddr *dest_addr,
    socklen_t addrlen
    )
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파라미터에 대한 자세한 설명은 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sockfd&lt;/strong&gt;: 소켓의 파일 디스크립터&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buf&lt;/strong&gt;: 전송할 데이어가 저장되어 있는 곳의 첫 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;len&lt;/strong&gt;: 전송할 데이터의 최대 길이&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt;: 부가적인 기능을 설정할 수 있는 플래그&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dest_addr&lt;/strong&gt;: 목적지 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addrlen&lt;/strong&gt;: 목적지 주소 공간의 크기&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sendto()&lt;/code&gt; 함수는 목적지의 주소를 인자로 받는다. 여기서 다음과 같은 의문이 생길 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;소켓의 출발지 주소는 어떻게 설정하는가?
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

void error_proc(const char*);

int main(int argc, char *argv[]) {
  int my_sock, read_len, n_sent;
  char buff[BUFSIZ];
  struct sockaddr_in dest_addr;
  socklen_t addr_len;

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);
  memset(&amp;amp;dest_addr, 0, sizeof(dest_addr));
  dest_addr.sin_addr.s_addr = inet_addr(argv[1]);
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_port = htons(atoi(argv[2]));
  addr_len = sizeof(dest_addr);

  while(1) {
    fgets(buff, BUFSIZ - 1, stdin);
    read_len = strlen(buff);
    n_sent = sendto(my_sock, buff, read_len, 0, (struct sockaddr *) &amp;amp;dest_addr,
addr_len);
    printf(&amp;quot;%d bytes were sent. \n&amp;quot;, n_sent);
  }
  return 0;
}

void error_proc(const char* str) {
  fprintf(stderr, &amp;quot;%s: %s \n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다음 예제를 실행하고 패킷을 캡처해본면 다음과 같은 사실을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;출발지 주소를 설정하지 않고 &lt;code&gt;sendto&lt;/code&gt; 함수를 호출한 경우, 소켓에 자동으로 IP 주소와 포트번호가 할당된다.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;데이터-수신&#34;&gt;데이터 수신&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

ssize_t recvfrom (
  int socketfd,
  void *buf,
  size_t len,
  int flags,
  struct sockaddr *src_addr,
  socklen_t *addrlen
)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파라미터에 대한 자세한 설명은 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sockfd&lt;/strong&gt;: 소켓의 파일 디스크립터&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buf&lt;/strong&gt;: 수신할 데이어가 저장될 곳의 첫 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;len&lt;/strong&gt;: 수신할 데이터의 최대 길이&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt;: 부가적인 기능을 설정할 수 있는 플래그&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;src_addr&lt;/strong&gt;: 출발지 주소를 저장할 구조체의 주소&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addrlen&lt;/strong&gt;: 출발지 주소 공간의 크기&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞에서 작성한 데이터 전송 프로그램과 통신이 가능한 데이터 수신 프로그램을 만들기 위해서는 수신 프로그램의 포트번호와 전송 프로그램의 목적지 포트가 일치해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 수신 측에서는 &lt;strong&gt;소켓에 주소를 설정해야한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주소의 설정을 위해서 &lt;code&gt;TCP&lt;/code&gt; 소켓과 마찬가지로 &lt;code&gt;bind&lt;/code&gt; 함수를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 함수를 이용하여 소켓에 주소 정보를 설정한 후 &lt;code&gt;recvfrom&lt;/code&gt; 함수를 호출하는 형태로 프로그램을 진행해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;전송 프로그램이 sendto 함수의 인자로 전달하는 포트번호 = 수신 프로그램이 bind 함수의 인자로 전달하는 포트번호&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;따라서 수신 프로그램은 다음의 흐름으로 진행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;소켓 생성(socket) -&amp;gt; 소켓에 주소 설정(bind) -&amp;gt; recvfrom 함수 호출(recvfrom)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;수신-프로그램-예제&#34;&gt;수신 프로그램 예제&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void error_proc(const char*);

int main(int argc, char **argv) {
  int my_sock, read_len, n_recv, res;
  char buff[BUFSIZ];

  struct sockaddr_in src_addr, dest_addr;
  socklen_t addr_len;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s port&amp;quot;, argv[0]);
    return 0;
  }

  my_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (my_sock == -1) error_proc(&amp;quot;socket&amp;quot;);

  memset(&amp;amp;src_addr, 0, sizeof(src_addr));
  src_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  src_addr.sin_family = AF_INET;
  src_addr.sin_port = htons(atoi(argv[1]));

  res = bind(my_sock, (struct sockaddr *)&amp;amp;src_addr, sizeof(src_addr));

  if (res == -1) error_proc(&amp;quot;bind&amp;quot;);

  addr_len = sizeof(dest_addr);

  while(1) {
    n_recv = recvfrom(my_sock, buff, BUFSIZ - 1, 0, (struct sockaddr *)&amp;amp;dest_addr, &amp;amp;addr_len);
  if (n_recv == -1) error_proc(&amp;quot;recv_from&amp;quot;);
  printf(&amp;quot;%d bytes were recv. \n&amp;quot;, n_recv);
  }
  return 0;
}

void error_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(1);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;전송-측-화면&#34;&gt;전송 측 화면&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/i5c8w5mne3it4ya/Screen%20Shot%202021-08-09%20at%2011.28.45%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;수신측-화면&#34;&gt;수신측 화면&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/5tviz2rngz6aj6u/Screen%20Shot%202021-08-09%20at%2011.26.43%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;다수의-클라이언트-처리&#34;&gt;다수의 클라이언트 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;recvfrom&lt;/code&gt; 함수의 특징에 대해서 좀 더 살펴보자면, &lt;code&gt;recvfrom&lt;/code&gt;함수를 호출하면 프로그램은 데이터그램이 도착할 때 까지 대기 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터그램이 도착하면 &lt;code&gt;recvfrom&lt;/code&gt; 함수는 다음 코드로 제어권을 넘기며 전달받은 데이터의 출발지 주소를 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 출발지 주소에 관계없이 자신에게 도착한 데이터그램을 가져온다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 알 수 있는 것은 &lt;code&gt;sendto&lt;/code&gt; 함수의 목적지도 한 곳으로 정해져 있는 것은 아니라는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sendto&lt;/code&gt; 함수의 목적지는 호출 시마다 바뀔 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 정리하면 &lt;code&gt;sendto&lt;/code&gt; 함수의 목적지와 &lt;code&gt;recvfrom&lt;/code&gt; 함수의 출발지는 호출 시마다 바뀔 수 있다. 이 말은 하나의 소켓으로 여러 호스트 또는 여러 프로세스와 통신할 수 있다는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;connect-함수의-역할&#34;&gt;connect 함수의 역할&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UDP 소켓은 &lt;code&gt;sendto&lt;/code&gt; 함수나 &lt;code&gt;recvfrom&lt;/code&gt; 함수를 호출했을 때만 커널과 연결되므로 함수 호출이 끝나면 소켓과 커널의 연결이 해제된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널과 소켓이 연결되고 다시 해제되는 과정에서도 무시하지 못할 만큼의 컴퓨팅 자원이 소모된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;connect 함수는 소켓의 목적지 주소를 설정하여 커널과 소켓을 연결시키는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 connect 함수를 사용하면 &lt;code&gt;read&lt;/code&gt; 함수와 &lt;code&gt;write&lt;/code&gt; 함수를 사용할 수 있다. (해당 소켓을 통해서 통신할 수 있는 목적지가 하나로 한정되기 때문에, &lt;code&gt;sendto&lt;/code&gt;, &lt;code&gt;recvfrom&lt;/code&gt;) 을 사용하지 않아도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송 시마다 커널과 소켓 사이의 연결과 연결 해제 과정이 없어서 효율이 좋아진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ICMP&lt;/code&gt; 메시지에 대한 통지를 받을 수 있다. (즉 UDP 다이어그램을 수신하는 상대방의 정상동작 여부를 파악할 수 있다.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 09 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://brunch.co.kr/@cks210/56&#34;&gt;주니어는 어디서 경력을 얻냐고요?&lt;/a&gt; 라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이력서에 자기소개서를 작성할 때, 어떠한 관점에서 작성해야하는지 알 수 있었다. 내가 회사에 어떤 기여를 할 수 있는지를 적극적으로 어필해야한다. 내가 여태까지 탈락했던 참가 신청서와 같은 경우도, 상대방이 원하는 바를 정확하게 캐치하지 못했기 때문이라고 생각한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;취업이란 나라는 상품을 소개하는 자리이고, 나를 뽑아준다면 굉장히 편해질 것이라는 것을 어필할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 슬로우 쿼리를 분석하고, 문제점을 해결 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝난 후에, 코딩 테스트 문제를 풀고 이를 제출하도록 해야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘은 기타 수업이 있는 날이다. 업무시간이 끝난 후에, 간단히 밥을 먹고 기타수업을 수강하러 가야겠다. (20:00 ~ 21:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JPA&lt;/code&gt; 강의를 수강하도록 해야겠다. 관계 설정하는 방법에 대해서 배울 것이다. 그리고 간단하게 시스템 프로그래밍 공부도 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;삶의 주인이 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 06 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어제 운동을 하려고 계획을 세웠으나, 실제로 하지 않았다. 오늘은 꼭 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아직 &lt;code&gt;JPA&lt;/code&gt;에 대해서, 익숙하지 못한 것 같다. 강의를 들으면서, &lt;code&gt;JPA&lt;/code&gt;에 대한 이해도를 높일 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어제 마이그레이션 관련 작업은 마무리를 지을 수 있었다. 오늘은 기존 요구사항대로 코딩이 되었는지 마지막으로 검토를 하고 어떻게 이관 전략을 가져가면 좋을까에 대한 고민을 해봐야 할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞으로의 커리어에 대해서 많은 고민을 하게 되는 것 같다. 과연 어떤 분야로 나아가면 좋을지 나에 대해서 생각을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;혼자 일하다보니, 협업에 대한 스킬을 키울 수 있는 기회가 많이 없어지는 것 같다. 하지만 다른 직군과 커뮤니케이션 할 기회가 많으므로 이를 잘 활용하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고, 곧바로 운동을 해야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운동 후, 씻고 간단히 식사를 하고 나서 잠시 휴식을 해야겠다. (18:00 ~ 20:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓 프로그래밍 공부 및 배운 내용을 정리 해야겠다. (20:00 ~ 22:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트 문제를 풀고, 제출해야겠다. (22:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;요즘 반복되는 일상에 조금은 지치기도 하지만, 나는 잘 할 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 05 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 전날에 잠이오지 않아서, 잠을 못잤더니 업무 끝나고 피곤하여 아무것도 하지 못했다. 재택을 하더라도 규칙적인 생활을 할 수 있도록 해야겠고 어떻게 하면 규칙적인 생활을 유지할 수 있는지 고민을 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어제 실제 환경에서 마이그레이션을 진행하다가 오류가 있어서, 하지 못하였다. 오늘은 실제 환경이여서 잘못된 데이터가 있더라도, 마이그레이션이 성공할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고, 곧바로 운동을 해야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운동 후, 씻고 간단히 식사를 하고 나서 잠시 휴식을 해야겠다. (18:00 ~ 20:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓 프로그래밍 공부 및 배운 내용을 정리 해야겠다. (20:00 ~ 22:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트 문제를 풀고, 제출해야겠다. (22:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;생산성 있게 일하기 위해서 노력하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;때로는 지치더라도 절대로 포기하지 말자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 04 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 마이그레이션 관련 코드를 완전히 끝내야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고, 곧바로 운동을 시작해야겠다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운동 후, 씻고 간단히 식사를 하고 나서 잠시 휴식을 해야겠다. (18:00 ~ 20:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘은 어제 하지 못했던 소켓 프로그래밍 공부를 해야겠다. (20:00 ~ 22:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트 문제를 풀고, 제출해야겠다. (22:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일을 하기 전에, 명상을 하는 것도 생각을 정리하는데 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP 프로토콜 및 특징</title>
      <link>https://dongwooklee96.github.io/post/2021/08/04/tcp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95.html</link>
      <pubDate>Wed, 04 Aug 2021 07:02:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/04/tcp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95.html</guid>
      <description>&lt;h3 id=&#34;tcp-소켓&#34;&gt;TCP 소켓&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전송 계층 프로토콜의 핵심 기능은 호스트 안에서의 프로세스 식별을 통한 데이터의 배달이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크를 통해 배달된 데이터가 어떤 프로세스에게 배달된 것인지를 확인한 후 적절한 프로세스에게 전달하는 것이 전송 프로토콜의 메인 임무이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 회사에는 우편 업무를 담당하는 직원 A가 있다.
- 우편물을 보내야하는 직원들은 직원 A에게 우편물 배달을 의뢰한다.
- 직원 A는  직원들이 이뢰한 우편물을 모아서, 우체국에 배달을 의뢰한다.
- 직원 A는 우체국으로부터 배달된 우편물을 해당 직원이 소속되어 있는 부서의 서류함에 넣는다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 비유에서 우편 업무 담당 직원 A가 바로 전송 계층 프로토콜에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우체국은 네트워크 계층 프로토콜에 해당하며 직원 A에게 배달을 의뢰하는 다른 직원들은 응용 계층에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;직원 역할은 크게 두 가지로 볼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다른 직원의 우편물을 수거하여 우체국에 전달 -&amp;gt; 프로세스 데이터를 IP 계층으로 전달&lt;/li&gt;
&lt;li&gt;도착한 우편물을 각 부서의 서류함으로 분배 -&amp;gt; IP 계층으로부터 받은 데이터를 프로세스에게 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우편물을 각 부서의 서류함으로 정확하게 배달하려면 우편물에 적혀있는 주소 정보를 확인해야하는데. 여기서 주소는 각 부서의 이름일 것이며 이에 해당하는 것이 포트번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;직원 A의 역할이 여기까지라고 볼 수 있고, TCP 통신에서는 다음과 같은 역할이 추가된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;우편물이 목적지까지 제대로 갔는지를 확인한다.&lt;/li&gt;
&lt;li&gt;우편물이 목적지까지 순서대로 갔는지 확인한다.&lt;/li&gt;
&lt;li&gt;목적지 우편함이 가득 차 있어서 우편물이 반송되는 것을 방지할 것.&lt;/li&gt;
&lt;li&gt;우체국이 너무 바쁘면 적절히 우편물의 양을 조절 할 것.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 작업은 혼자서 하기 힘들고 누군가의 도움이 필요하다. 바로 목적지 회사의 직원 A와 유사한 일을 수행하는 직원들이 이러한 일을 돕는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;직원 B와 협력한다면 위의 역할을 해결할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;직원 B가 A에게 우편물을 잘 받았다는 메시지를 전달할 수 있다.&lt;/li&gt;
&lt;li&gt;직원 A가 우편물에 번호를 부여한다면 직원 B는 메시지가 순차적으로 도착했는지를 판단할 수 있다.&lt;/li&gt;
&lt;li&gt;직원 B가 우편함의 여유공간을 직원 A에게 알려준다면 우편함이 가득차서 우편물이 반송되는 현상을 방지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;위의 기능들은 TCP 통신의 기능들을 비유로 설명한 것이다. TCP 통신은 다음과 같은 기능을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;신뢰성 있는 데이터의 전달 보장&lt;/li&gt;
&lt;li&gt;데이터의 순차적인 전달 보장&lt;/li&gt;
&lt;li&gt;흐름제어, 및 혼잡 제어&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정리하자면 TCP는 호스트 안에서의 프로세스 식별을 통산 데이터의 배달이라는 전송 계층 프로토콜의 기본 기능을 지원하는 프로토콜이며 부가적으로 신뢰적이고 순차적인 데이터의 전달을 보장하며 흐름제어 / 혼잡 제어를 수행하는 전송 계층 프로토콜이라고 볼 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp의-기능&#34;&gt;TCP의 기능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;호스트 안에서의 프로세스 식별을 통한 데이터의 배달&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;신뢰적이고 순차적인 데이터 전달&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흐름제어와 혼잡제어&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-헤더&#34;&gt;TCP 헤더&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전의 비유에서 직원 A와 B는 정보를 주고 받아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보를 주고 받는다는 이야기는 둘 사잉에 연결 관계가 형성되어 공유하는 정보가 있다는 의미로 해석할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보를 공유하는 가장 쉬운 방법은 우편물 봉투에 해당 내용을 적어보내는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계층별로 카운터 파트끼리 주고 받는 정보를 주고 받기 위해서 정보를 전송해야할 데이터의 앞에 붙여보낸다. 이를 프로토콜 헤더라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/9pqh7zj84onxwbn/img.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Source Port, Destionation Port&lt;/strong&gt;: TCP 세그먼트를 보내는 프로세스가 사용하는 포트번호와 TCP 세그먼트를 받는 프로세스가 사용하는 포트번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sequence Number&lt;/strong&gt;: TCP는 데이터를 바이트 스트림(바이트의 흐름)으로 처리한다. TCP 세그먼트 중 헤더 다음에 오는 데이터 부분은 바이트 스트림을 순차적으로 잘라서 구성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Acknowledgement Number&lt;/strong&gt;: 성공적인 데이터 전달 여부를 상대방에게 알리기 위해서 사용하는 번호이다. 다음에 전달 받을 데이터의 &lt;code&gt;Sequence Number&lt;/code&gt;가 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Header Length&lt;/strong&gt;: 기본적인 TCP 헤더의 길이는 20 바이트이지만 가변적인 옵션이 붙을 수 있다. 이 필드는 TCP 헤더 길이를 32비트 (4바이트) 단위로 나타낸다. 헤더의 최소 길이는 20바이트이기 때문에, 이 필드의 최소 값은 5(5 * 4 = 20) 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reserved Filed&lt;/strong&gt;: 미래에 기능이 추가되었을 때 사용할 수 있도록 예약 해둔 비트들이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP Flags&lt;/strong&gt;: TCP 세그먼트들의 기능을 표기하기 위한 8가지의 플래그이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CWR: 혼잡 제어 관련 플래그이다.&lt;/li&gt;
&lt;li&gt;ECE: 혼잡 제어 관련 플래그이다.&lt;/li&gt;
&lt;li&gt;URG: 긴급 데이터의 포함 여부를 나타낸다.&lt;/li&gt;
&lt;li&gt;ACK: Acknowledgement 필드의 유효성을 나타낸다.&lt;/li&gt;
&lt;li&gt;PHS: 긴급한 데이터 처리를 요청한다.&lt;/li&gt;
&lt;li&gt;RST: 연결을 리셋한다.&lt;/li&gt;
&lt;li&gt;SYN: 연결을 시작한다.&lt;/li&gt;
&lt;li&gt;FIN: 연결을 종료한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Window Size&lt;/strong&gt;: 수신 버퍼의 크기를 알린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tcp Checksum&lt;/strong&gt;: 세그먼트의 데이터 무결성을 검사하기 위한 필드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Urgent Pointer&lt;/strong&gt;: 긴급 데이터를 가리키는 포인터이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp의-상태&#34;&gt;TCP의 상태&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;연결&#34;&gt;연결&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 연결 지향형 프로토콜이다. 이 말은 통신을 하는 두 호스트에서 실행중인 TCP 모듈은 연결되어 있다는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 되어 있다는 것은 &lt;code&gt;TCP&lt;/code&gt; 모듈끼리 몇몇 수치들을 공유한다는 이야기일 뿐이니 연결이란 자체에 많은 의미를 부여할 필요는 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/assmg20ak7amd07/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 TCP 상태 다이어그램이다. 맨 처음 TCP 모듈은 CLOSED 상태로 존재한다. 여기서 &lt;code&gt;Passive Open(수동형 열기)&lt;/code&gt;를 하면 &lt;code&gt;LISTEN&lt;/code&gt; 상태로 전이되고, &lt;code&gt;Active Open(능동형 열기)&lt;/code&gt;를 하면 &lt;code&gt;SYN_SENT&lt;/code&gt; 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수동형 열기 : TCP 연결을 위해서 대기 상태로 돌입한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;능동형 열기: TCP 연결을 위해서 연결 요청 세그먼트(SYN 세그먼트)를 전송한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP는 양방향 통신이기 때문에 양방향 모두 연결 요청이 완료되고 나서야 비로서 &lt;code&gt;ESTABLISHED&lt;/code&gt; 상태가 된다. &lt;strong&gt;두 페어가 SYN을 보내고 해당 SYN에 대한 ACK를 수신했을 떄 비로서 연결 완료 상태가 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/a8gsowwbcu1zfgy/download.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 연결 과정은 보통 세번의 세그먼트 교환을 통해서 이루어지기 때문에 3방향 핸드 쉐이크라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;종료&#34;&gt;종료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 연결 종료를 요청하기 위해서, &lt;code&gt;FIN&lt;/code&gt; 세그먼트를 전송한다. &lt;code&gt;SYN_RCVD&lt;/code&gt;, &lt;code&gt;ESTABLISHED&lt;/code&gt; 상태에서 &lt;code&gt;FIN&lt;/code&gt; 전송을 통해 연결 종료 요청을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;호스트 A가 TCP 연결을 끊기 위해서 FIN을 전송하면 호스트 B는 FIN을 기다리게 되는 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에 돌입한다. 이 상태는 FIN을 보내기만 한 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN에 대한 ACK를 수신하게 되면 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 상태로 이동한다. 이 상태는 내 FIN이 상대방에게 도달된 상태를 말한다. 만약 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에서 &lt;code&gt;FIN+ACK&lt;/code&gt;를 수신하게 되면 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 전송하고 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태로 들어간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상태는 상대방이 자신의 &lt;code&gt;FIN&lt;/code&gt;을 받았다는 것을 확인한 상태이며, 상대방도 자신과의 연결을 끊기 원한다는 것까지 확인한 상태라고 볼 수 있다. 만약 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 상태에서 &lt;code&gt;FIN&lt;/code&gt;을 수신하게 된다면 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 전송하고 &lt;code&gt;CLOSING&lt;/code&gt; 상태로 이동한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 상태는 자신이 보낸 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;는 받지 못했지만, 상대방이 보낸 &lt;code&gt;FIN&lt;/code&gt;은 받은 상태이다. &lt;code&gt;CLOSING&lt;/code&gt; 상태에서 자신이 보낸 &lt;code&gt;FIN&lt;/code&gt;에 대한 &lt;code&gt;ACK&lt;/code&gt;를 수신하면 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태로 이동한다. 상태가 많아서 어려워 보이지만 단순하게 생각하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;연결이 끊어지는 CLOSED 상태가 되기 위해서는 양단 모두가 FIN을 수신해야하면 FIN에 대한 ACK도 수신해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-흐름-제어&#34;&gt;TCP 흐름 제어&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 수신 받은 데이터를 운영체제가 제공하는 버퍼에 순서대로 채운다. 버퍼에 있는 데이터들은 해당 포트에서 대기하고 있는 응용 프로그램들이 그것을 가져갈 때 까지 유지된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버퍼에 사용되는 메모리는 컴퓨터의 중요한 리소스 중 하나이기 때문에, 무한한 크기의 버퍼를 사용할 수는 없다. 따라서 버퍼의 크기는 유한하며 데이터가 가득 찬 경우에는 TCP는 더는 데이터를 받을 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 상황을 방지하기 위해서 TCP는 상대방의 버퍼에 공간이 있을 떄만, 데이터를 전송한다. 이러한 절차와 행동 양식을 흐름제어라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;는 흐름제어를 위해 슬라이딩 윈도우라는 개념을 사용한다. &lt;code&gt;TCP&lt;/code&gt; 헤더를 살펴보면 윈도우라는 필드가 있는데, 이 원도우 필드의 값에 따라서 보낼 수 있는 공간의 크기가 결정된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/rng7cqw2xqknkpw/TCP-sliding-window-mechanism.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;윈도우는 수신하는 TCP 쪽의 남은 버퍼를 의미하며, 스트림이 프로세스에 의해서 처리되어 버퍼가 빌 경우, 윈도우 버퍼가 이동하게 된다. 따라서 옆으로 이동한 윈도우에 의해서 아직 전송하지 못한 바이트 스트림에 대한 전송 공간이 발생하면 그때 전송을 시도한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 리스트에서 중복된 요소를 제거하는 방법들 및 성능 비교 </title>
      <link>https://dongwooklee96.github.io/post/2021/08/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90.html</link>
      <pubDate>Tue, 03 Aug 2021 20:00:13 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90.html</guid>
      <description>&lt;h3 id=&#34;리스트에서-중복된-요소를-제거하는-방법&#34;&gt;리스트에서 중복된 요소를 제거하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리스트에서 중복된 요소를 제거하는 방법에는 크게 두 가지가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 자료구조 SET을 이용하는 방법
2. 딕셔너리를 이용하는 방법
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;첫-번째-방법---set-자료구조-이용&#34;&gt;첫 번째 방법 - SET() 자료구조 이용&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;파이썬에서는 중복된 요소를 허용하지 않는 &lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#sets&#34;&gt;SET&lt;/a&gt; 이라는 자료구조가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;] 

sets &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(nums) &lt;span style=&#34;color:#75715e&#34;&gt;# 결과: {1, 2, 3, 4, 5, 7, 8,  9}&lt;/span&gt;

list(sets) &lt;span style=&#34;color:#75715e&#34;&gt;# 결과: [1, 2, 3, 4, 5, 7, 8, 9]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;중복이 제거된 집합을 생성하고나서, 이를 다시 리스트로 변환하면 중복이 제거된 리스트가 반환된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/ydzu7eos858oslr/Screen%20Shot%202021-08-03%20at%209.23.47%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공식 문서를 살펴보면, &lt;code&gt;set()&lt;/code&gt;은 순서를 보장하지 않는 컬렉션이며, 중복을 허용하지 않는다고 되어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;두-번째-방법---딕셔너리를-이용하는-방법&#34;&gt;두 번째 방법 - 딕셔너리를 이용하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;두 번째 방법은 딕셔너리의 키가 고유하다는 특성을 이용하여 중복을 제거하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]

list(set(dict&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromkeys(nums))) &lt;span style=&#34;color:#75715e&#34;&gt;# 결과: [1, 3, 5, 7, 9, 2, 4, 6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SET&lt;/code&gt;을 이용한 방법과 차이점은 중복된 요소를 제거하더라도, 순서를 유지한다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;딕셔너리 자료구조는 중복된 키 값이 입력되었을 때 값만 덮어쓰여지고 키 값은 유지하는 특성을 이용한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/8h17mdl4w4xx9tt/Screen%20Shot%202021-08-03%20at%209.46.47%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/stdtypes.html#dict.fromkeys&#34;&gt;&lt;code&gt;fromkeys()&lt;/code&gt;&lt;/a&gt; 는 반복 가능한 값을 인자로 받아, 키로 사용한다 그리고 그 키 값으로 새로운 딕셔너리 타입을 만드는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; nums1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; dict&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromkeys(nums1)
{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;사용가능한 버전에는 키만 인자로 받는 버전과, 키와 값을 둘다 받는 버전이 있는데 인자로 키만 주어질 경우 키 값만 생성되고 키에 대한 값들은 모두 &lt;code&gt;None&lt;/code&gt;으로 설정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/uje9m9lacxpkvi3/Screen%20Shot%202021-08-03%20at%209.40.13%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;딕셔너리에서 &lt;code&gt;list(d)&lt;/code&gt;를 수행하였을 때 딕셔너리에 존재하는 모든 키들이 삽입 순서대로 반환된다고 되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;따라서 리스트의 순서를 유지하고 싶으면, 딕셔너리를 이용하여 중복 요소를 제거하는 것이 좋다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능-비교&#34;&gt;성능 비교&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그렇다면 순서를 보장하지 않아도 되는 리스트에서 중복을 제거할 때 어떤 것이 더 좋을까?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 알아보기 위해서 성능을 비교해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pip install pytest-benchmark
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;우선 성능 비교를 위해서 &lt;code&gt;pytest-benchmark&lt;/code&gt; 모듈을 설치한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pytest

nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;))


&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;mark&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;benchmark(
    group&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;group-name&amp;#34;&lt;/span&gt;,
    min_rounds&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;,
    timer&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time,
    disable_gc&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;,
    warmup&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_use_dict&lt;/span&gt;(benchmark):
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func1&lt;/span&gt;():
        list(dict&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromkeys(nums))

&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;mark&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;benchmark(
    group&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;group-name&amp;#34;&lt;/span&gt;,
    min_rounds&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;,
    timer&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time,
    disable_gc&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;,
    warmup&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_use_set&lt;/span&gt;(benchmark):
    &lt;span style=&#34;color:#a6e22e&#34;&gt;@benchmark&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func2&lt;/span&gt;():
        list(set(nums))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;맨 위에서 랜덤으로 1 ~ 100 사이의 정수 리스트를 만들어 준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 코드는 &lt;code&gt;SET()&lt;/code&gt;과 딕셔너리를 이용하여, 리스트에서 중복된 요소를 제거하는 함수를 벤치마크 한 결과이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각 10,000,000 번씩 돌린 결과의 수치들을 뽑아내었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://dl.dropbox.com/s/k8bl4heg0d9vab6/Screen%20Shot%202021-08-03%20at%2011.37.18%20PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;랜덤으로 생성된 리스트의 특성에 따라서 차이가 심할 수 있으므로 평균, 표준 편차, 중앙값이 의미가 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;딕셔너리를 이용하는 것보다 &lt;code&gt;SET&lt;/code&gt;을 사용하는 것이 중복된 원소를 훨씬 빠르게 제거할 수 있다는 것을 확인할 수 있다. 다만 리스트의 순서를 유지할 필요가 없는 경우에 사용할 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.pytest.org/en/6.2.x/contents.html&#34;&gt;pytest - doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7961363/removing-duplicates-in-lists/24554087&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 03 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt; 이전에 보았던 글인데 다시 보니 새로웠다. 최근에 구글 인공지능 교육 지원이나 오픈 소스 컨트리뷰톤을 지원하였는데, 지원서를 작성하는데도 많은 도움이 되는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/musinsa-tech/map-416b5f143943&#34;&gt;무신사가 검색 품질을 관리하는 방법&lt;/a&gt; 로그 수집 및 분석을 어떻게 하는지 알 수 있는 좋은 글이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://meetup.toast.com/posts/294&#34;&gt;모킹 통합관리와 cypress의 모킹 on/off 기능&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://josephg.com/blog/crdts-go-brrr/&#34;&gt;더 빠른 CRDT를 위해 최적화하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://channel.io/ko/blog/crdt_vs_ot&#34;&gt;CRDT vs OT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://m.facebook.com/photo.php?fbid=873681873240141&amp;amp;id=100017950085523&amp;amp;set=a.119501898658146&amp;amp;comment_id=874269496514712&amp;amp;notif_t=feedback_reaction_generic&amp;amp;notif_id=1627982637945212&amp;amp;ref=m_notif&#34;&gt;켄트벡이 제안하는 TDD를 좀 더 쉽게하는 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프론트 개발을 하다 보면, 모킹 데이터를 사용할 때가 많은데, 모킹 데이터를 관리할 수 있는 좋은 방법을 제시한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨플루언스를 사용할 때, 실시간으로 데이터가 동기화되서 여러명이서 협력할 수 있는 것을 알 수 있었는데, 이러한 기술에 사용되는 알고리즘중에하나가, CRDT 또는 OT라는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;켄트벡이 제안한 TDD를 쉽게 하는 방법에 대한 글을 읽었다.&lt;/li&gt;
&lt;li&gt;방법은 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 원래 하던대로 코드를 수정한다.
2. 방금 변경한 코드로 인해서 성공하는 테스트 코드를 작성한다.
3. 변경 한 코드를 되돌린다.
4. 테스트를 다시 작성하거나, 새롭게 추가해본다.
5. 컴파일을 진행한다.
6. 테스트가 실패하는 것을 확인한다.
7. 테스트 성공을 위해서 다시 코드를 수정한다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아직은 테스트 코드를 작성하는것이 익숙하지 않은 나에게 테스트 코드를 작성하는데 좋은 방법이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 코드를 다 작성하고 나서, 테스트 코드를 막상 작성하기 귀찮을 때가 있는데, 변경한 부분에 대한 테스트를 작성하는 것이기 때문에 부담이 적어 시도할 만 하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현업에서는 파이썬 &lt;code&gt;IMPORT&lt;/code&gt; 에러 때문에 현재 고생중인데, 이것을 해결하면 바로 적용을 해볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무 집중도가 떨어질 때, 해야할 일을 놓치거나, 생산성이 떨어질 때가 있다. 이럴 때 일을 잠시 멈추고 어떤 것을 먼저 해야할지 우선 순위를 매겨보도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 할 일에 운동 계획을 빼먹지 말고, 적자. 이제 본격적으로 재택이 장기화되었는데 그럴 수록 운동의 중요성이 커지기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 업무시간에 마이그레이션 관련 작업을 마무리 할 것이다. (08:00 ~ 17:00)&lt;/li&gt;
&lt;li&gt;업무가 끝나고 코딩 테스트 문제를 풀 것이다. (17:00 ~ 18:00)&lt;/li&gt;
&lt;li&gt;코딩 테스트 문제를 제출하고 나서, 소켓 프로그래밍에 대해서 공부를 할 것이다. (20:00 ~ 22:00)&lt;/li&gt;
&lt;li&gt;토이 프로젝트를 할 것이다. (22:00 ~ 24:00) API 설계 및 여행자등록 관련된 부분을 작업할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 건강하고 자신감 있게 살자.&lt;/li&gt;
&lt;li&gt;내가 이루고 싶은 삶의 목표를 향해서 나아가자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/08/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 02 Aug 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kdy1.github.io/post/jobs/offers/2021/1/&#34;&gt;오랜만에 괜찮은 이직 제안을 받았다&lt;/a&gt; 굉장한 충격을 받았던 글이다. 유명한 오픈 소스 프로젝트를 만들고, 자신의 실력을 증명할 수 있다면, 좋은 조건으로 이직 제안이 오는 것을 확인할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 실력을 키워서 유명한 회사에서 이직 제안을 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오픈소스에 대한 나의 생각을 확장 시켜주었다. 그 전에는 참여자로서 오픈 소스에 기여하는 것을 생각했다면, 요즘에는 프로젝트 관리 및 생성자로서의 오픈 소스 대해서 생각을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 뛰어난 개발자가 되어야겠다고 생각을 했고, 우선 지금 연습해야하는 것은 아이디어를 코드로 구현하는 것과, 작은 프로그램을 많이 만들어보는 것이다. 지금은 회사에서 유지보수성 코드 및 예제 코드만 작성하고 있는데 한 단계 더 성장하려면, 작은 프로그램이라도 많이 만들어보는 습관이 중요할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아이디어를 코드로 표현하는 능력이 많이 부족하다고 느낀다. 이를 연습할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 데이터 마이그레이션 코드 작성과, 문의사항 해결을 할 것이다. (08:00 ~ 17:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사 업무가 끝나면, 바로 코딩 테스트 문제를 풀 것이다. (17:00 ~ 18:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;간단히 저녁 식사를 하고 나서, 기타 학원에 갈 것이다. (19:00 ~ 20:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집에 와서, 시스템 프로그래밍 공부를 할 것이다. (22:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 가치 있게 사용하려고 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>간단한 소켓 프로그램</title>
      <link>https://dongwooklee96.github.io/post/2021/08/02/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.html</link>
      <pubDate>Mon, 02 Aug 2021 00:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/02/%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.html</guid>
      <description>&lt;h3 id=&#34;간단한-소켓-프로그램&#34;&gt;간단한 소켓 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;서버와 클라이언트를 연결해봄으로써, 간단한 소켓 프로그래밍을 해볼 것이다.&lt;/li&gt;
&lt;li&gt;A와 B가 연결된 상태로 통신을 하려면 둘 중의 하나가 연결 요청을 해야한다. 그리고 나머지 한쪽은 상대방의 연결 요청을 처리할 준비를 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int listen(int sockfd, int backlog);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 함수는 연결 요청을 처리하기 위한 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;listen()&lt;/code&gt; 함수는 해당 소켓을 듣기 상태로 만든다. &lt;code&gt;listen&lt;/code&gt; 함수가 호출되면 해당 소켓은 상대방의 연결 요청을 받을 준비를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램의 흐름은 다음 라인으로 넘어가면 운영체제에게 해당 소켓을 통해 연결 요청이 들어올 경우, 연결 요청 정보를 저장해달라고 부탁한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;backlog&lt;/code&gt;는 저장하고 있을 연결 요청의 최대 수를 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int accept(int sockfd, struct sockaddr *addr, socket_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;accept()&lt;/code&gt; 함수가 호출되는 순간, 커널은 &lt;code&gt;listen&lt;/code&gt; 함수에 의해 생성된 대기열에 연결 요청이 있었는지를 확인한다. 연결 요청이 없으면 &lt;code&gt;accept&lt;/code&gt; 함수는 연결 요청이 발생할 때까지 프로그램의 제어권을 가진 상태로 대기한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결 요청이 있으면 가장 먼저 연결 요청을 한 프로세스와 통신하기 위한 소켓의 파일 디스크립터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주의해야할 것은 &lt;code&gt;listen&lt;/code&gt; 함수를 통해 듣기 모드에 돌입한 소켓은 &lt;strong&gt;연결 요청을 접수하는 역할을 하는 듣기 소켓이 되고 accept 함수의 결과 반환된 소켓은 실제 데이터 전송에 사용되는 연결 소켓이 된다는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 함수를 통해서, &lt;code&gt;listen()&lt;/code&gt; 함수 호출로 대기하고 있는 프로세스에 연결 요청을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/127778990-5303317c-394f-4399-ac92-2d892f045d22.gif&#34; alt=&#34;7099 epsi&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송을 위한 연결은 &lt;code&gt;connect()&lt;/code&gt; 함수의 인자로 전달된 소켓과 &lt;code&gt;accept()&lt;/code&gt; 함수 호출에 의해 듣기 소켓이 된 소켓은 연결 요청을 처리하는 일만을 담당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 완료된 이후에는 일반 파일과 같이 입출력 함수 (&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;)를 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서버-프로그램&#34;&gt;서버 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단한 예제를 통해서, 다룬 함수들의 실제 사용에 대해서 알아볼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 프로그램의 기능은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;클라이언트쪽으로부터 &amp;ldquo;How old are you?&amp;rdquo; 라는 문자열을 전송받은 후에 이것을 전송한다.
클라이언트쪽으로 &amp;ldquo;I am 20 years old&amp;rdquo; 라는 문자열을 전송한 후에 화면에 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

#define PORT 9001

int main() {
  int srv_sd, client_sd;
  struct sockaddr_in srv_addr, client_addr;
  int client_addr_len, read_len;
  char read_buff[BUFSIZ];
  char write_buff[BUFSIZ] = &amp;quot;I am 20 years old.&amp;quot;;

  srv_sd = socket(PF_INET, SOCK_STREAM, 0);

  if (srv_sd == -1) {
    printf(&amp;quot;socket creation error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;==== server program ====\n&amp;quot;);

  memset(&amp;amp;srv_addr, 0, sizeof(srv_addr));
  srv_addr.sin_family = AF_INET;
  srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  srv_addr.sin_port = htons(PORT);

  if (bind(srv_sd, (struct sockaddr *) &amp;amp;srv_addr, sizeof(srv_addr)) == -1) {
    printf(&amp;quot;bind error&amp;quot;);
    return -1;
  }

  if (listen(srv_sd, 5) == -1) {
    printf(&amp;quot;listen error&amp;quot;);
    return -1;
  }

  client_addr_len = sizeof(client_addr);
  client_sd = accept(srv_sd, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_len);

  if (client_sd == -1) {
    printf(&amp;quot;accept error&amp;quot;);
    return -1;
  }
  write(client_sd, write_buff, sizeof(write_buff));
  printf(&amp;quot;server: %s\n&amp;quot;, write_buff);

  read_len = read(client_sd, read_buff, sizeof(read_buff));
  if (read_len == -1) {
    printf(&amp;quot;read error&amp;quot;);
    return -1;
  }

  read_buff[read_len] = &#39;\0&#39;;
  printf(&amp;quot;client: %s\n&amp;quot;, read_buff);

  close(client_sd);
  close(srv_sd);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;클라이언트-프로그램&#34;&gt;클라이언트 프로그램&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;같은 호스트 안에 위치한 서버 프로그램에 &lt;code&gt;TCP 9001번 포트로 연결을 시도한다.&lt;/code&gt;
연결 후 서버 프로그램으로 &amp;lsquo;How old are you?&amp;rsquo; 라는 문자열을 전송한 후에 화면에 출력한다.
서버로부터 &amp;lsquo;I am 20 years old.&amp;rsquo; 라는 문자열을 전송 받은 후에 화면에 출력한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define PORT 9001

int main() {
  int client_sd;
  struct sockaddr_in client_addr;

  int client_addr_len, read_len;
  char write_buff[BUFSIZ] = &amp;quot;How old are you?&amp;quot;;
  char read_buff[BUFSIZ];

  client_sd = socket(PF_INET, SOCK_STREAM, 0);
  if (client_sd == -1) {
    printf(&amp;quot;socket creation error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;==== client program ====\n&amp;quot;);

  memset(&amp;amp;client_addr, 0, sizeof(client_addr));
  client_addr.sin_family = AF_INET;
  client_addr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
  client_addr.sin_port = htons(PORT);

  if (connect(client_sd, (struct sockaddr *) &amp;amp;client_addr, sizeof(client_addr)) == -1) {
    printf(&amp;quot;connection error&amp;quot;);
    close(client_sd);
    return -1;
  }

  write(client_sd, write_buff, sizeof(write_buff));
  printf(&amp;quot;client: %s\n&amp;quot;, write_buff);

  read_len = read(client_sd, read_buff, sizeof(read_buff));
  if (read_len == -1) {
    printf(&amp;quot;read error&amp;quot;);
    return -1;
  }
  read_buff[read_len] = &#39;\0&#39;;
  printf(&amp;quot;server: %s\n&amp;quot;, read_buff);
  close(client_sd);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/127781662-add25fdb-1379-4a5f-a7e4-ea5214afd686.png&#34; alt=&#34;Screen Shot 2021-08-02 at 3 32 59 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서버를 실행한 직후 &lt;code&gt;netstat&lt;/code&gt; 명령을 통해서, &lt;code&gt;listen&lt;/code&gt; 상태에 있는 연결을 조회한 결과입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버는 클라이언트의 연결 요청을 기다리는 &lt;code&gt;listen&lt;/code&gt; 상태에 머물러 있다는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소켓 객체를 관리하는 것은 커널이고, 따라서 소켓 관련 함수들은 대부분 시스템 콜과 관련이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 함수들은 경우에 따라 실패할 수 있으므로, 실패의 종류에 따라서 필요한 루틴을 실행하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스에서는 함수 호출 후에 발생한 에러를 저장하는 &lt;code&gt;errno&lt;/code&gt; 라는 전역 변수를 제공한다. &lt;code&gt;errno&lt;/code&gt;는 &lt;code&gt;errno.h&lt;/code&gt; 파일을 &lt;code&gt;include&lt;/code&gt; 해서 사용할 수 있다. 또한, 에러 종류에 대한 매크로도 &lt;code&gt;errno.h&lt;/code&gt;에 정의되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;socket&lt;/code&gt; 함수의 인자 중 프로토콜 패밀리가 잘못되면 &lt;code&gt;socket&lt;/code&gt; 함수는 &lt;code&gt;-1&lt;/code&gt;을 리턴하면 종료하고, 종료하면서 자신이 어떤 에러에 의해서 종료되었는지 &lt;code&gt;errno&lt;/code&gt; 변수에 저장하는데 그 값은 &lt;code&gt;EINVAL&lt;/code&gt;로 미리 정의되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이 경우 다른 작업을 추가할고 싶으면 코드를 다음과 같이 구성하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;client_sd = socket(PF_INET, SOCK_STREAM, 0);

if (client_sd == -1) {
  if (errno == EINVAL) {
    printf(&amp;quot;protocol family error&amp;quot;);
    return -1;
  }
  printf(&amp;quot;socket creation error&amp;quot;);
  return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;화면에 에러 메시지에 대략적인 내용을 출력하는 함수를 만들고 실패가 발생하는 모든 함수에서 에러 처리 루틴을 삽입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void perror(const char *msg);

int foo(int domain, int type, int protocol) {
  int res;
  res = socket(domain, type, protocol);
  if (res == -1) {
    perror(&amp;quot;socket&amp;quot;);
  }
  return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IP 주소 변환</title>
      <link>https://dongwooklee96.github.io/post/2021/08/01/ip-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98.html</link>
      <pubDate>Sun, 01 Aug 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/01/ip-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98.html</guid>
      <description>&lt;h3 id=&#34;주소-변환&#34;&gt;주소 변환&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그램이 사용자에게 입력받는 주소는 &lt;code&gt;Dotted-Decimal&lt;/code&gt; 형태의 문자열인 IP 주소 또는 호스트 이름일 것이다. 따라서 주소를 변환해주어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 입력한 IP 주소 문자열을 &lt;code&gt;uint32_t&lt;/code&gt; 형태로 변환시켜주는 작업이 반드시 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경우에 따라서는 &lt;code&gt;IP&lt;/code&gt; 주소를 다시 문자열 형태로 변환시키는 작업도 필요할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 주소를 변환할 수 있는 API 이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_addr(const char *cp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 주소를 네트워크 바이트 순서 &lt;code&gt;in_addr_t&lt;/code&gt;로 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_network(const char *cp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 주소를 호스트 바이트 순서 &lt;code&gt;in_addr_t&lt;/code&gt;로 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_aton(const char *cp, strcut in_addr *inp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cp 문자열 IP 네트워크 바이트 순서 &lt;code&gt;inp&lt;/code&gt;로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;char *inet_ntoa(struct in_addr in);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;네트워크 바이트 순서로 된 &lt;code&gt;in_addr&lt;/code&gt;구조체 주소에서 IP 주소 문자열 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int inet_pton(int af, const char *src, void *dst);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;af&lt;/code&gt; 인자로 3계층 프로토콜 선택 가능, &lt;code&gt;src&lt;/code&gt; 문자열 주소를 &lt;code&gt;dst&lt;/code&gt;로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;af&lt;/code&gt; 인자로 3계층 프로토콜을 선택 가능, &lt;code&gt;src&lt;/code&gt; 주소 구조체를 문자열 주소로 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ip-주소를-정수로-변환하여-출력하는-예제&#34;&gt;IP 주소를 정수로 변환하여 출력하는 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv) {
  uint32_t ip_int;
  char *ip_str = &amp;quot;127.0.0.1&amp;quot;;

  ip_int = inet_network(ip_str);

  printf(&amp;quot;string: %s, decimal: %u, hex: %x\n&amp;quot;,
    ip_str, ip_int, ip_int);

  ip_int = htonl(ip_int);
  printf(&amp;quot;after htonl - decimal: %u, hex: %x \n&amp;quot;,
    ip_int, ip_int);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;inet_network&lt;/code&gt; 함수를 이용하여 문자열로 된 &lt;code&gt;IP&lt;/code&gt; 주소를 &lt;code&gt;uint32_t&lt;/code&gt; 타입 변수에 호스트 바이트 순서로 저장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;htonl&lt;/code&gt; 함수를 이용하여 호스트 바이트 순서로 되어 있는 주소를 네트워크 바이트 순서로 변경한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주소-변환-함수-예제&#34;&gt;주소 변환 함수 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

int print_addr(struct sockaddr_in *);

int main(char argc, char* argv[]) {

  char *sample_ip = &amp;quot;127.0.0.1&amp;quot;;

  int port = 9002;

  struct sockaddr_in sock_addr1, sock_addr2, sock_addr3;

  sock_addr1.sin_family = AF_INET;
  sock_addr1.sin_addr.s_addr = inet_addr(sample_ip);
  sock_addr1.sin_port = htons(port);

  sock_addr2.sin_family = AF_INET;
  inet_aton(sample_ip, &amp;amp;(sock_addr2.sin_addr));
  sock_addr2.sin_port = htons(port);

  sock_addr2.sin_family = AF_INET;
  inet_aton(sample_ip, &amp;amp;(sock_addr2.sin_addr));
  sock_addr2.sin_port = htons(port);

  sock_addr3.sin_family = AF_INET;
  inet_pton(AF_INET, sample_ip, &amp;amp;(sock_addr3.sin_addr));
  sock_addr3.sin_port = htons(port);

  print_addr(&amp;amp;sock_addr1);
  print_addr(&amp;amp;sock_addr2);
  print_addr(&amp;amp;sock_addr3);

  printf(&amp;quot;===== ntoa =====\n&amp;quot;);
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr1.sin_addr));
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr2.sin_addr));
  printf(&amp;quot;IP: %s \n&amp;quot;, inet_ntoa(sock_addr3.sin_addr));
  return 0;
}

int print_addr(struct sockaddr_in *address) {
  int port;
  char txt[INET_ADDRSTRLEN];
  port = ntohs(address-&amp;gt;sin_port);
  inet_ntop(AF_INET, &amp;amp;(((struct sockaddr_in *) address) -&amp;gt; sin_addr), txt, sizeof(struct sockaddr_in));
  printf(&amp;quot;ip: %s, port: %d \n&amp;quot;, txt, address-&amp;gt;sin_port);
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;호스트-이름과-ip-주소&#34;&gt;호스트 이름과 IP 주소&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실제로 우리가 작성하는 프로그램은 &lt;code&gt;IP&lt;/code&gt; 주소 문자열보다 호스트 이름을 인자로 받을 확률이 높다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;호스트 이름 문자열을 &lt;code&gt;IP&lt;/code&gt; 주소로 변환하는 과정은 단순 변환이 아니다. 네임 서버에 해당 내용을 조회하고 그 결과값을 알려주는 과정이 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
struct hosten *gethostbyname(const char *name);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;호스트 이름을 네임서버에 조회하여 성공하면 네임 서버는 여러 가지 정보를 제공한다. 이 정보를 저장하기 위해서는 &lt;code&gt;hostent&lt;/code&gt; 라는 구조체가 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct hostent {
  char *h_name; // 호스트의 공식 이름
  char **h_aliases; // 가명 리스트 (마지막 인자는 NULL)
  int h_addrtype; // 호스트 주소 타입 (IPv4, IPv6)
  int h_length; // 주소의 길이
  char **h_addr_list; // 주소 리스트 (마지막 인자는 NULL)
}
#define h_addr h_addr_list[0]; // 주소 중 첫 번째 엔트리
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;여러가지 정보 중에 우리가 관심 있는 것은 IP 주소이다. IP 주소는 &lt;code&gt;gethostbyname&lt;/code&gt; 하뭇의 실행 결과 얻을 수 있는 &lt;code&gt;hostent&lt;/code&gt; 구조체의 멤버 변수 중에서 주소 리스트인 &lt;code&gt;h_addr_list&lt;/code&gt;를 통해서 얻어올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;호스트-이름으로-ip-주소를-조회하는-예제&#34;&gt;호스트 이름으로 &lt;code&gt;IP&lt;/code&gt; 주소를 조회하는 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

void err_proc(const char *);

int main(int argc, char *argv[]) {
  struct hostent *ent;
  struct in_addr **res;
  int i = 0;

  if (argc != 2) {
    fprintf(stderr, &amp;quot;usage: %s &amp;lt;hostname&amp;gt; \n&amp;quot;, argv[0]);
    return -1;
  }

  ent = gethostbyname(argv[1]);
  if (ent == NULL) err_proc(&amp;quot;gethostbyname&amp;quot;);

  res = (struct in_addr **) ent-&amp;gt;h_addr_list;
  printf(&amp;quot;hostname: %s \n&amp;quot;, ent-&amp;gt;h_name);
  while(res[i] != NULL) {
    printf(&amp;quot;%s&amp;quot;, inet_ntoa(*res[i]));
    i++;
  }
  printf(&amp;quot;\n&amp;quot;);
}

void err_proc(const char *str) {
  fprintf(stderr, &amp;quot;%s: %s\n&amp;quot;, str, strerror(errno));
  exit(errno);
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;예제 프로그램은 프로그램 실행시에 호스트 이름을 입력 인자로 받는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램 실행 시 입력받은 호스트 이름 문자열을 이용하여 &lt;code&gt;gethostbyname&lt;/code&gt; 함수를 실행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GREP 명령어 만들기 및 정규표현식</title>
      <link>https://dongwooklee96.github.io/post/2021/08/01/grep-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</link>
      <pubDate>Sun, 01 Aug 2021 21:46:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/08/01/grep-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</guid>
      <description>&lt;h3 id=&#34;grep-명령어-만들기-및-정규-표현식&#34;&gt;GREP 명령어 만들기 및 정규 표현식&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libc&lt;/code&gt;에서 제공하는 정규 표현식 API는 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;

int recomp(regex_t *reg, const char *pattern, int flags);
void regfree(regex_t *reg);
int regexec(const regex_t *reg, const char *string, size_t nmatch, regmatch_t pmatch[], int flags);
size_t regerror(int errcode, const regex_t *reg, char *msgbuf, size_t msgbuf_size);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;는 두번째 인자로 넘어온 정규 표현식 문자열을 전용 데이터 형식 &lt;code&gt;regex_t&lt;/code&gt;로 변환한다. 변환한 결과는 첫번째 인자 &lt;code&gt;reg&lt;/code&gt;에 기록된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫번째 인자 &lt;code&gt;reg&lt;/code&gt;의 메모리 영역은 호출하기 전에 할당하여 그 포인터를 전달해야 하는데, 그 외에도 &lt;code&gt;regcomp()&lt;/code&gt;가 독자적으로 메모리를 확보하게 된다. 그것을 해제하는 &lt;code&gt;API&lt;/code&gt;가 바로 &lt;code&gt;regfree()&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;와 &lt;code&gt;regfree()&lt;/code&gt;는 &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt; 처럼 늘 쌍으로 사용되는 함수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;regcomp()&lt;/code&gt;는 성공하면 0을 반환하고 실패하면, 에러 코드를 반환하는데, 이 에러 코드를 에러 메시지로 변환하는 함수가 &lt;code&gt;regerror()&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;grep-소스-코드&#34;&gt;grep 소스 코드&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;regex.h&amp;gt;

static void do_grep(regex_t *pat, FILE *f);

int main(int argc, char *argv[]) {
  regex_t pat;
  int err;
  int i;

  if (argc &amp;lt; 2) {
    fputs(&amp;quot;no pattern\n&amp;quot;, stderr);
    exit(1);
  }
  err = regcomp(&amp;amp;pat, argv[1], REG_EXTENDED | REG_NOSUB | REG_NEWLINE);
  if (err != 0) {
    char buf[1024];
    puts(buf);
    exit(1);
  }
  if (argc == 2) {
    do_grep(&amp;amp;pat, stdin);
  } else {
    for (i = 2; i &amp;lt; argc; i++) {
      FILE *f;

      f = fopen(argv[i], &amp;quot;r&amp;quot;);
      if (!f) {
        perror(argv[i]);
        exit(1);
      }
      do_grep(&amp;amp;pat, f);
      fclose(f);
    }
  }
  regfree(&amp;amp;pat);
  exit(0);
}

static void do_grep(regex_t *pat, FILE *src) {
  char buf[4096];

  while (fgets(buf, sizeof buf, src)) {
    if (regexec(pat, buf, 0, NULL, 0) == 0) {
      fputs(buf, stdout);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;한글-문자열-처리와-국제화&#34;&gt;한글 문자열 처리와 국제화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 &lt;code&gt;grep&lt;/code&gt; 명령어를 한글로 된 텍스트 파일에 적용할 수가 없다. 이유는 한글 문자열을 고려하지 않았기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C언어에서 문자는 사실 숫자이며, 문자열은 숫자의 배열이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;유니코드&#34;&gt;유니코드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;유니코드는 기존의 수많은 언어의 문자 코드를 대부분 포함해 문자 코드가 난립하는 상황을 해결하기 위해서 고안되었다. 그러나, 현실은 유니코드에 포함되지 않은 문자도 존재하며 특히 한자와 관련된 골치아픈 문제들이 남아있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래도 기존의 문자 코드를 여러개 사용하는 것보다는 훨씬 낫고, 달리 대체할 것이 없어 현재는 유니코드가 사실상 표준이 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문자-코드의-구체적인-의미&#34;&gt;문자 코드의 구체적인 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;문자 코드&amp;rsquo; 라는 모호한 개념은 구체적으로 다음과 같이 두 가지로 분해할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;부호화 문자집합&lt;/li&gt;
&lt;li&gt;인코딩&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;부호화-문자-집합&#34;&gt;부호화 문자 집합&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;문자집합 또는 문자 셋은 글자들의 집합이며, 집합 안의 문자들에 음수가 아닌 정수들을 배정한 것을 &lt;strong&gt;부호화된 문자 집합(coded character set)&lt;/strong&gt; 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인코딩&#34;&gt;인코딩&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;부호화 문자 집합에 속하는 각 문자는 하나의 숫자와 대응된다. 그 번호를 실제 바이트 열로 적용할 때의 계산식이 인코딩이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인코딩은 크게 두 가지 종류가 있는데 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;모든 문자에 대해서 같은 바이트 수를 사용하는 인코딩&lt;/li&gt;
&lt;li&gt;문자의 종류에 따라 사용하는 바이트 수를 바꾸는 인코딩&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;전자를 &lt;strong&gt;와이드 문자&lt;/strong&gt;, 후자를 &lt;strong&gt;멀티 바이트 문자&lt;/strong&gt;라고 한다. 둘 다 실제로 사용되고 있는데, 문자열의 저장 및 전송은 멀티 파이트 문자를 사용하고, 프로세스 내에서 데이터를 처리할 때는 와이드 문자도 자주 사용된다. 와이드 문자가 처리하기 쉽기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문자열-처리-방법&#34;&gt;문자열 처리 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞으로 유니코드가 우세할 것은 틀림이 없다. 그리고 특히 데이터 저장 및 전송에 사용되는 인코딩은 &lt;code&gt;UTF-8&lt;/code&gt;로 결정되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 지금까지 작성된 유니코등 이외의 데이터를 어떻게 처리할 것인가 하는 문제가 있는데 아래 방법중에 하나를 선택해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;프로그램에서 사용할 문자 코드를 미리 정한다 (혹은 사용자가 정하도록 한다)&lt;/li&gt;
&lt;li&gt;문자 코드를 추출한다.&lt;/li&gt;
&lt;li&gt;문자열을 주고 받을 때, 문자 코드의 이름도 넘기도록 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 번째 방법은 정해진 문자 코드를 사용하기로 사용자와 합의하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 방법은 유니코드가 등장하기 전까지는 효과적일지 몰라도, 유니코드가 포함되면서 실패할 확률이 늘었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세번재 방법은 문자 코드의 이름을 명시적으로 전달하는 것도 좋은 방법이지만, 이름을 잘못 전달하거나 모르는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결로넉으로 완벽한 대처는 존재하기 힘들고, 가장 합리적인 방법은 사용할 문자 코드를 미리 정하고, 그 이외의 문자 코드는 이름을 넘겨줘서 처리할 수 있도록 대응하는 방법일 것이다.&lt;/p&gt;
&lt;h3 id=&#34;국제화와-다중언어화&#34;&gt;국제화와 다중언어화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지금까지 설명한 것은 하나의 프로그램에서 여러 언어를 처리할 수 있도록 하기 위한 개념들이었고, 이를 다중 언어화라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 비슷한 개념으로 프로그램으 여러 요소를 지역의 관습에 맞추는 작업도 한다. 이것을 지역화(&lt;code&gt;localiszation&lt;/code&gt;)라고 한다. 예를 들어서, 메시지를 사용자가 원하는 언어로 표시하거나 날짜와 시간을 지역의 관습에 맞춰서 표시하는 경우이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 실행시에 해당 지역을 전환할 수 있게 하는 것을 국제화(&lt;code&gt;internationalization&lt;/code&gt;)라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 언어에선 국제화의 기본 구조는 &lt;code&gt;로케일(locale)&lt;/code&gt; 이다. 국가, 언어, 문자의 조합이 로케일이며, 예를 들면 한글 &lt;code&gt;UTF-8&lt;/code&gt;의 경우 &lt;code&gt;ko_KR.UTF-8&lt;/code&gt; 로케일을 사용한다. &lt;code&gt;ko&lt;/code&gt;가 한글, &lt;code&gt;KR&lt;/code&gt;이 한국이라는 지역, &lt;code&gt;UTF-8&lt;/code&gt;이 유니코드를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다중언어-처리와-국제화를-위한-라이브러리&#34;&gt;다중언어 처리와 국제화를 위한 라이브러리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;국제화와 다중 언어 문자열 처리에 사용할 수 있는 라이브러리 몇 가지를 소개한다.&lt;/p&gt;
&lt;h4 id=&#34;libc-로케일-매커니즘&#34;&gt;&lt;code&gt;libc&lt;/code&gt; 로케일 매커니즘&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setlocale()&lt;/code&gt;이 로케일의 기본 API이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;libc-와이드-문자-관련-루틴wchar&#34;&gt;&lt;code&gt;libc&lt;/code&gt; 와이드 문자 관련 루틴(wchar)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libc&lt;/code&gt; 에서는 ANSI &lt;code&gt;C&lt;/code&gt;로 규정되어 있는, 와이드 문자용 &lt;code&gt;API&lt;/code&gt;가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;iconv&#34;&gt;&lt;code&gt;iconv&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iconv&lt;/code&gt;문자 코드 간 상호 변환을 위해 사용하는 라이브러리이다. 예를 들면, &lt;code&gt;EUC-KR&lt;/code&gt;과 &lt;code&gt;UTF-8&lt;/code&gt;등의 변화를 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcreperl-compatible-regular-expression&#34;&gt;&lt;code&gt;PCRE(Perl Compatible Regular Expression)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PCRE(Perl Compatible Regular Expression)&lt;/code&gt;는 &lt;code&gt;UTF-8&lt;/code&gt;에 대응하는 정규 표현 라이브러리이다. 이장에서 소개한 &lt;code&gt;libc&lt;/code&gt; 정규 표현에 더하여 &lt;code&gt;Perl5&lt;/code&gt; 확장 정규 표현에도 대응한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 30 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://devocean.sk.com/blog/techBoardDetail.do?ID=163249&#34;&gt;JHipster 프레임워크 기초&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://devocean.sk.com/blog/techBoardDetail.do?ID=163263&#34;&gt;JHipster 데이터 모델링 하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데보션이라는 SKT에서 운영하는 기술 블로그 같은 개발자 커뮤니티 사이트를 알게 되었는데 굉장히 유용한 글들이 많은 것 같다. 특히 스프링 클라우드를 익히는데 많은 도움이 될 것이라고 생각이 든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스에 대한 강의도 굉장히 많았는데, 이를 공부하는데 많은 도움이 될 것이라고 생각한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무를 끝내고, 코딩 테스트 문제를 풀 것이다. (17:30 ~ 18:30)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 프로그래밍 공부 및 소켓 프로그래밍을 공부할 것이다. (19:30 ~ 20:30)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이 프로젝트를 웹 API 디자인이라는 책을 읽으면서 다시 설계를 해볼 것이다. (22:00 ~ 24:00)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>소켓 구조체 및 빅엔디안, 리틀엔디안</title>
      <link>https://dongwooklee96.github.io/post/2021/07/30/%EC%86%8C%EC%BC%93-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%B0%8F-%EB%B9%85%EC%97%94%EB%94%94%EC%95%88-%EB%A6%AC%ED%8B%80%EC%97%94%EB%94%94%EC%95%88.html</link>
      <pubDate>Fri, 30 Jul 2021 02:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/30/%EC%86%8C%EC%BC%93-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%B0%8F-%EB%B9%85%EC%97%94%EB%94%94%EC%95%88-%EB%A6%AC%ED%8B%80%EC%97%94%EB%94%94%EC%95%88.html</guid>
      <description>&lt;h3 id=&#34;소켓-자료-구조&#34;&gt;소켓 자료 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터 네트워크를 이용하여 통신을 하기 위해서는 다음과 같은 사항들이 결정되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 전송 계층 프로토콜
- 네트워크 계층 프로토콜
- Source 호스트의 IP 주소
- Destination 호스트의 IP 주소
- Source 프로세스의 포트번호
- Destination 프로세스의 포트번호
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이중에서 프로토콜들은 &lt;code&gt;socket&lt;/code&gt; 함수의 인자로 결정할 수 있는 부분이다.&lt;/li&gt;
&lt;li&gt;소켓에서는 주소를 다음과 같은 구조체를 이용하여 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr {
  uint8_t sa_len; // 주소 길이
  sa_familiy_t sa_family; // 주소 패밀리
  char sa_data[14]; // 주소 값
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;네트워크 계층 프로토콜로 &lt;code&gt;IPv4&lt;/code&gt;를 사용한다면 아래 구조체를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr_in {
  uint8_t sin_len; // 주소 길이
  sa_familiy_t sin_family; // 주소 패밀리
  in_port_t sin_port; // 포트번호

  struct in_addr sin_addr; // IPv4 주소값
  char sin_zero[8]; // 사용되지 않는 값 (sockaddr 과 길이를 맞추기 위함)
}

struct in_addr {
  uint32_t s_addr; // IP 주소
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;주소를-소켓에-적용시키는-방법&#34;&gt;주소를 소켓에 적용시키는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;소켓을 생성한 후 &lt;code&gt;bind()&lt;/code&gt; 함수를 호출하면 소켓에 &lt;code&gt;IP&lt;/code&gt; 주소와 포트번호 정보가 연결된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt; 함수는 두 번째 인자로 &lt;code&gt;sockaddr&lt;/code&gt; 구조체의 포인터를 사용하기 때문에 &lt;code&gt;sock_addr_in&lt;/code&gt; 구조체를 바로 사용할 수 없고 캐스팅을 해야한다.&lt;/li&gt;
&lt;li&gt;프로토콜 주소의 확장성을 위해서 다양한 주소 체계를 처리할 수 있도록 제작된 형태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빅엔디안과-리틀-엔디안&#34;&gt;빅엔디안과 리틀 엔디안&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터에서 데이터를 바이트 단위로 다룬다. 데이터를 바이트 단위로 다루는 것은 대부분의 컴퓨터에서 공통적인 일이지만, 여러 바이트로 구성된 데이터를 메모리에 저장하는 방식은 컴퓨터 구조에 따라서 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 아래와 같은 연속된 바이트로 구성된 데이터가 있다고 가정하자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| 0x |  12 | 34 | 56 | 78 | 9a | bc | de | f0 |
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;빅엔디안(Big-Endian)&lt;/strong&gt; : 상위 바이트 값이 메모리의 작은 주소에 저장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;리틀 엔디안(Little-Endian)&lt;/strong&gt; : 하위 바이트 값이 메모리의 작은 주소에 저장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 차이 때문에 컴퓨터에서 사용하던 데이터를 네트워크로 그대로 전송하면 컴퓨터마다 해독이 가능할 수도 있고, 불가능할 수 도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크로 흘러가는 데이터는 빅엔디안 방식을 사용하기로 약속하고 이를 네트워크 바이트 순서라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인텔 계열 컴퓨터는 리틀 엔디안으로 사용하기 때문에, 네트워크로 데이터를 전송하기 전에 빅엔디안으로 적절하게 변경해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 함수들은, 두 바이트 오더 간에 변환을 해주는 함수이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;가 뜻하는 것은 호스트이며 &lt;code&gt;n&lt;/code&gt;이 뜻하는 것은 네트워크이다. 데이터의 길이에 알맞게 사용을 하면 된다.&lt;/li&gt;
&lt;li&gt;만약 이미 네트워크 바이트 오더를 사용하는 컴퓨터라면 &lt;code&gt;htons&lt;/code&gt;와 &lt;code&gt;htonl&lt;/code&gt; 함수를 사용해도 값이 변경되지는 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr_in srv_addr;
int port = 9001;

srv_addr.sin_port = htons(port);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;앞의 함수를 사용하여 포트번호를 지정하는 예제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 28 Jul 2021 07:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 밤늦게 도커 허브에 이미지를 자동으로 업로드하는 기능을 구현하였는데, 잘되어서 다행이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 자기전에 글또에 어떤 글을 투고하면 좋을까 고민을 하였는데 &lt;code&gt;API&lt;/code&gt;에 대한 글을 작성하면 좋을 것 같다는 생각을 했다. 특히 &lt;code&gt;HATEOAS&lt;/code&gt;에 대해서 어떻게 하면 이 기능을 잘 활용할지 그리고 사다드림의 &lt;code&gt;API&lt;/code&gt; 설계가 어떻게 이루어졌는지를 책과 함께 실제 &lt;code&gt;API&lt;/code&gt;를 설계하면 나의 이야기가 잘 녹아들 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;점심 식사후에 취침을 하는데, 별로 졸리지도 않은데 오후 업무를 위해서 가끔 취침할 때가 있었다. 하지만, 정말로 피곤하지 않다면 자지 않는 편이 나은 것 같다. 일어나고 나서 한동안 찌뿌둥해서 업무 효율이 나오지 않기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 점심을 먹기 전에, 간단한 운동을 한 후(12:15 ~ 12:45)에, 씻고 식사를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무를 마치고, 코딩 테스트 문제를 풀고 나서, 제출한다. (18:00 ~ 19:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사다드림 &lt;code&gt;API&lt;/code&gt; 설계를 시작한다. &lt;code&gt;API&lt;/code&gt; 설계를 하면서 배운점을 글로 기록한다. (19:00 ~ 21:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 프로그래밍 공부 및 네트워크 프로그래밍 공부를 한다. (21:00 ~ 23:00)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이 프로젝트 (사다드림)의 AWS 배포 자동화를 구축한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;행복은 나중에 오지 않는다. 현재를 즐기고 충실하게 살아가면서 행복을 느끼는데 집중을 하자.&lt;/li&gt;
&lt;li&gt;시간을 가치있게 사용하자. 모든 사람에게 공평하게 주어지는 것이 바로 시간이다. 이러한 시간을 낭비하도록 하지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 27 Jul 2021 07:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/0881672&#34;&gt;nGrinder에 적용한 HttpCore 5와 HttpCore 5 살펴보기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;글또에 작성할 기술 블로그를 어떻게 작성하면 좋을지에 대한 좋은 자료가 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자꾸 글또에 투고할 글을 작성하는 것을 미루고 있는데, 토이 프로젝트에서 배포 자동화를 했던 경험을 적으면 좋을 것 같다는 생각을 했다. 아직 완전하지는 않은데, 배포 작동화를 하려면, AWS 코드 디플로이를 이용한 배포 자동화까지해야겠다는 생각을 했다. 오늘은 꼭 코드 디플로이를 이용한 배포자동화까지 할 예정이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;요즘 재귀 문제를 풀고 있는데, 아직도 많이 어려운 편이다. 나누어서 작업을 하는 것은 그나마 잘 따라가지만, 함수를 종료 조건까지 호출하고 끝났을 때의 처리를 생각하는 것이 약한 것 같다. 그래도 흥미를 느끼고 공부를 하니까 재미가 있는 것 같다. 무슨 일이든 꾸준히 하는 것이 중욯나 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=258021255&#34;&gt;자바 개발자를 위한 97가지 제안&lt;/a&gt; 요즘 심심할 때마다 이 책을 읽고 있는데, 여기서 더 나은 소프트웨어를 더 빨리 전달하기 위한 원칙이라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 전달 이란 코드를 작성하고 디버깅하는 것 이상의 책임을 갖는 것을 의미한다. 코드를 작성하는 것 보다 소프트웨어를 출시 하는 것에 주의를 더 기울이려면 작성한 변경 내역을 프로덕션 환경에 적용하기 위한 전반적인 절차를 이해해야 한다. 그 이후에는 알 두 가지 핵심 사항에 집중해야한다.

  1. 실제 구현에 앞서 모호한 요구사항을 명확하게 이해하려 하지 않고 자의적인 해석으로 업무를 수행하는 등 절차를 무시하지 않는다.
  2. 여러분이 작성하는 코드가 요구 사항에 부합하는지 확인하는 자동화된 테스트를 작성하고 실행하는 등 절차를 더 빠르게 수행하기 위해서 노력한다.

2. 더 나은 소프트웨어란 &#39;올바른 기능을 구현하는 것과&#39;, &#39;올바르게 기능으 구현하는&#39; 두 가지 개념을 짧게 표현한 것이다.

첫 번째는 항상 요구 사항과 수용 조건을 만족하는 코드를 작성한다는 것이다.
두 번째는 다른 프로그래머도 버그를 성공적으로 수정하거나 새로운 기능을 추가할 수 있도록 이해하기 쉬운 코드를 작성하는 것이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 업무가 끝나고, 잠을 자느라 전체적인 일정이 늦어졌다. 물론 코딩 테스틑 문제는 풀었지만 이후에 소켓 프로그램 및 시스템 프로그래밍을 진행하지 못했다. 내일은 업무 시간을 좀 더 집중할 수 있도록 노력하고 버그를 무조건 해결하고 끝내야겠다. 그리고 나서 마이그레이션을 어떻게 할지 정하고 제대로 코딩을 할 수 있도록 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;업무를 마치고 나서, 간단한 휴식후 코딩 테스트 문제를 푼다. (17:30 ~ 18:30)&lt;/li&gt;
&lt;li&gt;시스템 프로그래밍 및 소켓 프로그래밍 공부를 한다. (19:30 ~ 21:00)&lt;/li&gt;
&lt;li&gt;글또에 투고할 기술 글을 작성한다. (21:00 ~ 23:00)&lt;/li&gt;
&lt;li&gt;취침 준비 및 간단한 독서후 취침을 한다. (23:00 ~ 24:00)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루도, 열심히 시간을 모두 활용하면서 살아가자!&lt;/li&gt;
&lt;li&gt;항상 자신감 있는 자세로 임하고, 어떤 문제든 시간만 있으면 해결 할 수 있다는 마음으로 임한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>HEAD 명령어 만들기</title>
      <link>https://dongwooklee96.github.io/post/2021/07/27/head-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</link>
      <pubDate>Tue, 27 Jul 2021 00:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/27/head-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HEAD 명령어를 만들어보자. &lt;code&gt;head&lt;/code&gt; 명령어는 파일의 처음 몇 줄만을 출력해주는 명령어이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래는 &lt;code&gt;head&lt;/code&gt; 명령어를 실행하는 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ head -n 5 file.c

cat file.c | head -n 5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위처럼 파일의 이름을 실행인자로 전달하면, 그 파일의 처음 몇 줄만을 출력한다. 또한 인자로 파일 이름을 지정하지 않은 경우에는 표준 입력에서 읽어서 출력하는데, 이와 같은 동작이 리눅스에서는 일반적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;headc&#34;&gt;&lt;code&gt;head.c&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 명령어는 비교적 간단한 프로그램이지만, 그렇다고 만만하지는 않다. 따라서 일부 기능만 포함된 버전을 만들고 조금씩 기능을 추가하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 단계적으로 기능을 추가해나가는 것이 일반적으로 프로그램을 만들 때 좋은 접근 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 초보자들은 처음부터 모든 기능을 다 구현하려다 보면 뒤죽박죽이 될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 처음에는 아주 쉬운 기능을 확실히 돌아가게 만들고 나서, 조금씩 기능을 덧붙여 나가는 것이 확실한 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

static void do_cat(const char *path);
static void die(const char *s);

int main(int argc, char *argv[]) {
  int i;
  if (argc &amp;lt; 2) {
    fprintf(stdout, &amp;quot;%s: file name not given\n&amp;quot;, argv[0]);
    exit(1);
  }
  for (i = 1; i &amp;lt; argc; i++) {
    do_cat(argv[i]);
  }
  exit(0);
}

#define BUFFER_SIZE 2048

static void do_cat(const char *path)
{
  int fd;
  unsigned char buf[BUFFER_SIZE];
  int n;

  fd = open(path, O_RDONLY);
  if (fd &amp;lt; 0) die(path);

  for (;;) {
    n = read(fd, buf, sizeof buf);
    if (n &amp;lt; 0) die(path);
    if (n == 0) die(path);
    if (write(STDOUT_FILENO, buf, n) &amp;lt; 0) die(path);
  }
  if (close(fd) &amp;lt; 0) die(path);
}

static void die(const char *s)
{
  perror(s);
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 26 Jul 2021 07:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;업무를 마치고 나서, 간단한 휴식후 코딩 테스트 문제를 푼다. (17:30 ~ 18:30)&lt;/li&gt;
&lt;li&gt;기타 수업을 참석한다. (19:30 ~ 21:00)&lt;/li&gt;
&lt;li&gt;집에 도착해서, 간단한 운동을 한다. (21:00:22:00)&lt;/li&gt;
&lt;li&gt;취침 준비 및 간단한 독서후 취침을 한다. (23:00 ~ 24:00)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루도, 열심히 시간을 모두 활용하면서 살아가자!&lt;/li&gt;
&lt;li&gt;항상 자신감 있는 자세로 임하고, 어떤 문제든 시간만 있으면 해결 할 수 있다는 마음으로 임한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>소켓 프로그래밍이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/07/25/%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Sun, 25 Jul 2021 18:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/25/%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;소켓-프로그래밍-입문&#34;&gt;소켓 프로그래밍 입문&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우리 주변에서 발견할 수 있는 대부분의 프로그래밍은 누군가로부터 정보를 전달 받거나, 누군가에게 정보를 전달하는 작업의 연속이다. 이러한 입력과 출력 작업이 없는 프로그램은 거의 없기 때문에, 모든 프로그래머가 입출력 작업에 노출되어 있다고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입출력의 대상은 화면, 키보드, 파일, 데이터베이스, 다른 프로그램등 정말로 다양하다. 이중에 컴퓨터 네트워크를 대상으로 하는 입출력 행위를 다루는 프로그래밍을 네트워크 프로그래밍 또는 소켓 프로그래밍이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소켓은 네트워크 대상 입출력을 위한 응용 프로그래밍 인터페이스 (API의) 이름이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 프로그래밍의 정의&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;소켓 API를 이용하여 컴퓨터 네트워크를 사용하는 프로그램을 작성하는 것
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;프로세스 - 소켓 - 컴퓨터 네트워크 - 소켓 - 프로세스로 이어지는 연결 구조에서, 복잡한 컴퓨터 네트워크에서 데이터가 어떻게 전달되는가는 프로그래머의 1차 관심사가 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;소켓과-입출력&#34;&gt;소켓과 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;프로세스의 입장에서, 소켓에 관계된 작업은 다른 프로세스로부터 데이터를 받는 작업과 다른 프로세스에게 데이터를 주는 작업이라고 볼 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래밍을 처음 배울 때 대부분의 책들이 &lt;code&gt;Hello World!&lt;/code&gt; 라는 문자열을 출력하는 프로그램을 작성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 프로그램은 출력 대상이 터미널 화면인 출력 프로그램이다. 입출력의 대상이 될 수 있는 대상은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;표준 입출력, 파일, 장치, 터미널, 소켓&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;간단한-소켓-프로그래밍&#34;&gt;간단한 소켓 프로그래밍&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;

int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;domain&lt;/code&gt; : 소켓 통신을 위한 프로토콜 패밀리를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;: 소켓의 종류를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protocol&lt;/code&gt;: 소켓에서 사용할 포로토콜을 지정한다.&lt;/li&gt;
&lt;li&gt;반환값은 성공시에는 파일의 디스크립터를 반환하고 실패시에는 -1을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
  int sd1, fd1, sd2, fd2;
  sd1 = socket(PF_INET, SOCK_STREAM, 0);
  fd1 = open(&amp;quot;test&amp;quot;, O_RDONLY);
  sd2 = socket(PF_INET, SOCK_STREAM, 0);
  fd2 = open(&amp;quot;test2&amp;quot;, O_RDONLY | O_CREAT);
  printf(&amp;quot;sd1: %d, fd1: %d, sd2: %d, fd2: %d\n&amp;quot;, sd1, fd1, sd2, fd2);
  close(sd1);
  close(fd1);
  close(sd2);
  close(fd2);
  return 0;
}

// result: sd1: 3, fd1: 4, sd2: 5, fd2: 6
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;결과를 통해서 소켓에도 파일과 같은 디스크립터가 할당된 다는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;통신-프로토콜&#34;&gt;통신 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞서 소개한 &lt;code&gt;socket&lt;/code&gt; 함수는 3개의 인자를 받아서 소켓을 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 인자들 (도메인, 소켓타입, 프로토콜)을 이해하려면 컴퓨터 네트워크 통신 프로토콜에 대해서 알아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 소켓 프로그램인 웹 서버를 기준으로 통신 프로토콜에 대해서 알아보도록 하자. 웹서버에 접속하는것은 아래의 세부작업으로 구성되어 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 우리가 알고 있는 접속 주소를 네트워크 장비들이 이해할 수 있는 주소로 변환하는 작업
2. 교환할 데이터를 패킷으로 만드는 작업
3. 패킷이 이동하는 길의 이정표를 만드는 작업
4. 패킷의 목적지와 이정표를 확인하여 올바른 경로로 패킷을 전달하는 작업
5. 패킷이 목적지까지 제대로 도착했는지를 확인하는 작업
6. 네트워크가 혼잡할 때, 네트워크로 전송하는 패킷의 흐름을 조절하는 작업
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이러한 작업을 수행하기 위해서 네트워크 장비들이 따라야하는 절차와 약속을 정의하고 있는 것이 바로 통신 프로토콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인터넷-프로토콜&#34;&gt;인터넷 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IP는 인터넷 계층 프로토콜로써 컴퓨터 네트워크의 핵심 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP가 컴퓨터 네트워크의 핵심 프로토콜인 이유는 &lt;strong&gt;호스트와 라우터가 사용할 수 있는 통일된 규격의 주소, 즉 IP 주소를 제공하기 때문이다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;택배를 보낸다고 하더라도, 주소가 있어야 정상적으로 목적으로 배송을 할 수 있을 것이다. 또한 통일된 규격인 주소이여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 각각의 호스트들은 통신 기술과는 별개로 인식할 수 있는 주소가 있고 어려움 없이 데이터를 주고 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;전송-계층-프로토콜&#34;&gt;전송 계층 프로토콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크의 궁극적인 목적은 다른 호스트상에서 실행되고 있는 프로세스 간의 통신이다. 프로세스는 프로세스 아이디(&lt;code&gt;PID&lt;/code&gt;)로 식별이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 말해서, 프로세스를 특정하려면, &lt;code&gt;PID&lt;/code&gt; 가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;원거리 호스트에서 실행중인 프로그램의 PID를 통신할 때마다 알아야 하는가?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞에서 설명한 IP 주소 덕분에 호스트까지 데이터를 전달하는 것은 가능하지만, 호스트에 데이터가 도착하고 그 데이터가 어떤 프로세스에 전달되어야 하는지를 알려면 &lt;code&gt;PID&lt;/code&gt;로 판별을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 다른 호스트에서 실행되고 있는 &lt;code&gt;PID&lt;/code&gt;를 알아내는 것은 쉽지 않으므로, 그 대신에 도착한 패킷에 있는 정보를 이용하여 해당 프로세스까지 전달해주는 수단이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 일을 전송 계층 프로토콜인 &lt;code&gt;TCP&lt;/code&gt;, &lt;code&gt;UDP&lt;/code&gt;에 의해서 수행된다. &lt;strong&gt;전송 계층에서는 프로세스를 식별하기 위해서 포트라는 주소를 제공한다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 간에 통신할 포트 번호를 미리 약속한다면 &lt;code&gt;PID&lt;/code&gt;를 몰라도 통신하는 것이 가능하기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전송 계층 프로토콜은 통신을 원하는 프로세스들과 직접적인 연관이 있는 것으로, 네트워크 중간에서 패킷을 포워딩하는 라우터에서는 작동하지 않는다. 통신의 시작점과 목적지에서만 역할을 하기 때문에 &lt;code&gt;END-TO-END&lt;/code&gt; 프로토콜이라고 불린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=47823267&#34;&gt;네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 25 Jul 2021 18:11:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오랜만에 주간 회고를 시작해본다.&lt;/li&gt;
&lt;li&gt;이번주에는 글또 오리엔테이션 및 다짐글을 작성하였다.&lt;/li&gt;
&lt;li&gt;글또 사람들과 만나서 진행하는, 공개 소프트웨어 개발자 대회에 참여하게 되었다. 나름 백엔드 파트장이 되었는데, 책임감을 가지고 열심히 임해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기타를 배우고 있었는데, 실력이 정체된 것 같은 느낌을 받았다. 악보를 집으로 가져와 연습을 하니, 확실히 전보다는 더 좋아진 느낌이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자 커리어에 대해서, 혼란을 가졌던 한 주이기도 하다. 계속 웹 서버 개발자 및 파이썬 개발을 할 것인지 아니면 다른 길을 알아봐야하는지 생각을 좀 더 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번주에 젯브래인 에듀케이션 구독이 끝나서, 갱신하기 위해서 많은 지출을 하였다. 많은 돈을 쓴 만큼 개발을 더 열심히 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아쉽게도 영어로 작성된 JVM 관련된 글을 번역해도 된다는 허락을 받지 못했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 관련 에세이를 시간이 없다는 핑계로 미뤄두고 있었는데, 책상앞에 꺼내두니까 스마트폰 대신해서 짬짬히 읽고 읽는것이 가능해졌다. 따라서 휴대폰을 사용하는 시간을 줄이고, 평소에 읽고 싶었지만 시간이 없어서 미뤄두었던 책들을 꺼내두어서 천천히 읽어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;당연히 돌아가겠지라고 생각하는 것을 로컬에서 조차 테스트 해보지 않고 마무리 하려고 하는 안좋은 버릇이 나와서
반복하지 않도록 노력하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JPA&lt;/code&gt;를 사용할 때, 팁이나 스프링을 사용할 때 알아야할 팁과 관련된 문서를 인터넷에서 찾을 수 있었다. 특히 도메인 프로젝트 구조 같은 경우에는 현재 프로젝트에 적용해보려고 하였으나, 일단은 프로젝트 규모가 좀 더 커질 때까지 기다려보도록 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공개 소프트웨어 개발자 대회 관련된 토의를 할 때, 내가 생각하고 있는 것을 남에게 설명하는 능력이 부족하다는 것을 다시 한번 깨달았다. 그리고 전에 면접 연습을 할 때 내가 공부한 내용을 발표 형식으로 하여 혼자 발표하면 어떨까라고 생각을 해봤던 것이 생각이 났다. 글또에서 작성할 글을 미리 강의 형태로 만들어 놓고 이를 글로 풀어쓰는 것도 재미있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공개 개발자 대회에서 우선적으로 해야할 것은 기능 요구사항을 먼저 리스트업하는 것 부터 시작을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 어떻게 하면 효율적으로 사용할 수 있을까, 고민을 하고 스마트폰을 이용하는 시간을 최대한 줄어야겠다. 그리고 그 시간을 책으로 대체할 수 있는 방법을 연구해야겠다.&lt;/li&gt;
&lt;li&gt;저녁에 늦게 자고나서, 다음날 늦게 일어나는 것이 시간을 굉장히 낭비한다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-해야할-일&#34;&gt;Todo (해야할 일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 프로그래밍을 공부할 것이다.&lt;/li&gt;
&lt;li&gt;사다드림 프로젝트에서, 테스트 코드 관련된 부분을 손보고, 전에 작성하였던 자바독을 옮기는 작업을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스마트폰을 보는 시간을 줄이고, 그 시간에 개발과 관련된 에세이를 읽자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>스트림과 관련 라이브러리 함수</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%95%A8%EC%88%98.html</link>
      <pubDate>Sat, 24 Jul 2021 16:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%95%A8%EC%88%98.html</guid>
      <description>&lt;h1 id=&#34;스트림-관련-라이브러리-함수&#34;&gt;스트림 관련 라이브러리 함수&lt;/h1&gt;
&lt;h3 id=&#34;stdio&#34;&gt;&lt;code&gt;stdio&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜만을 이용해서, 프로그램을 작성할 수 있지만, 시스템 콜만을 사용하여 더욱 복잡한 입출력 기능을 구현하려 한다면 다음과 같은 문제에 봉착하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫째, 시스템 콜은 바이트 단위로만 읽고 쓸 수 있다. 우리에게 더 익숙한 단위, 예를 들면 문자 단위나 줄 단위로 문자열을 처리할 수 있다면 더욱 편리할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째로 성능의 문제가 발생한다. 예를 들어서 10 바이트나 20바이트 단위로 &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 호출을 반복한다면 아무리 최신 컴퓨터로도 시간이 오래 걸릴 수 밖에 없다. 스트림에 연결된 장치에 따라서 다르지만, 대체로 &lt;code&gt;1KB&lt;/code&gt; 단위로 시스템 콜을 해야 효율적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 문제를 피해서 편리하게 사용할 수 있게 만들어진 것이 바로 표준 입출력 라이브러리(standard I/O library)이다. 줄여서 &lt;code&gt;stdio&lt;/code&gt; 라고 한다. &lt;code&gt;stdio&lt;/code&gt;는 &lt;code&gt;libc&lt;/code&gt;의 큰 비중을 차지하는 만큼 중요한 라이브러리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;버퍼링&#34;&gt;버퍼링&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stdio&lt;/code&gt;는 커널 수준의 스트림을 쉽게 사용할 수 있는 인터페이스를 제공한다. 예를 들어 바이트 단위로 읽고 쓰는 함수나, 줄 단위로 읽고 쓰는 함수를 제공한다. 또한 숫자나 문자열을 포맷에 맞게 출력하는 함수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜 &lt;code&gt;read()&lt;/code&gt;는 스트림에서 우리가 지정한 &lt;code&gt;buffer&lt;/code&gt;에 지정한 크기만큼 읽어 들이는 반면에, &lt;code&gt;stdio&lt;/code&gt;는 독자적인 버퍼를 사용한다. 여기서 버퍼란 일시적으로 데이터를 저장하는 장소를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 시스템 콜 &lt;code&gt;read()&lt;/code&gt;를 사용하여, 적당한 크기의 데이터를 버퍼에 읽어들이고, 프로그램에서 요구하는 만큼을 다시 반환해준다. 예를 들어 1바이트를 읽어 달라는 요청을 받으면 버퍼에서 1바이트만 다시 반환해준다. 이렇게 버퍼를 이용하여 데이터를 주고 받는 것을 버퍼링이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜로 1바이트를 연속해서 요청하면 속도가 안나는 반면에, &lt;code&gt;stdio&lt;/code&gt;를 사용한다면 성능의 저하 없이 바이트 단위로 읽는 것이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;버퍼링-모드&#34;&gt;버퍼링 모드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 쓸 때도 읽을 때와 마찬가지로 버퍼를 사용한다. 바이트 단위 또는 줄 단위의 데이터를 전달 받아 버퍼가 꽉 차면 시스템 콜 &lt;code&gt;write()&lt;/code&gt;를 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;예외&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그러나 몇가지 중요한 예외가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 스트림이 단말에 연결된 경우에는 버퍼가 가득찰 때까지 기다리지 않고
개행 (\n)을 만나는 시점에서 write()를 실행한다. 이유는, 반대편에 모니터와
같은 단말이 있다면 사람이 출력을 보고 있을 가능성이 높기 때문이다.
버퍼가 가득차기 까지는 오랜 시간이 걸릴 수도 있기 때문에 적절한 순간에
바로 출력해주는 것이 프로그램의 응답이 빨라지고 사용자의 사용성도 좋아진다.

2. 스트림이 비버퍼링 모드(unbuffered mode)로 되어 있는 경우이다. 비버퍼링 모드로 설정된 
stdio 스트림에 데이터를 쓰면 버퍼링 없이 즉시 write()가 수행된다. setvbuf()로 설정할 수 있다.

3. 표준 예외 출력에 해당하는 stderr에 대한 출력이다. stderr은 예외적으로 처음부터
비버퍼링 모드다. 그 이유는 표준 에러 출력의 경우 에러 메시지나 디버깅 정보를 출력하는데 사용되기 때문에 발생한 시점에서 바로 출력하는 것이 바람직하기 때문이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;file-타입&#34;&gt;FILE 타입&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시스템 콜 레벨에서는 스트림을 지정하기 위해 파일 디스크립터라는 것을 사용했었다. 한편, stdio에서는 비슷한 역할을 하기 위해 &lt;code&gt;FILE&lt;/code&gt; 타입에 대한 포인터를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FILE&lt;/code&gt; 타입은 &lt;code&gt;typedef&lt;/code&gt;으로 정의되어 있어, 그 안에는 파일 디스크립터와 앞서 설명한 &lt;code&gt;stdio&lt;/code&gt; 버퍼의 내부 정보를 포함하고 있다. 라이브러리를 사용하는 입장에서는 &lt;code&gt;FILE&lt;/code&gt; 타입의 내부 구조를 몰라도 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdio의-표준-입출력&#34;&gt;stdio의 표준 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜을 사용할 때, 표준 입출력 스트림을 지정하기 위해 예약된 정수가 있었는데, &lt;code&gt;stdio&lt;/code&gt;에도 이에 대응하여, &lt;code&gt;FILE*&lt;/code&gt; 타입의 변수가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;파일 디스크립터&lt;/th&gt;
&lt;th&gt;정식 명칭&lt;/th&gt;
&lt;th&gt;stdio 변수명&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;STDIN_FILENO&lt;/td&gt;
&lt;td&gt;stdin&lt;/td&gt;
&lt;td&gt;표준 입력&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;STDOUT_FILENO&lt;/td&gt;
&lt;td&gt;stdout&lt;/td&gt;
&lt;td&gt;표준 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;STDERR_FILENO&lt;/td&gt;
&lt;td&gt;stderr&lt;/td&gt;
&lt;td&gt;표준 에러 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;fopen3&#34;&gt;&lt;code&gt;fopen(3)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;표준 입출력 이외의 스트림에 대한 &lt;code&gt;FILE&lt;/code&gt;을 여는 것도 물론 가능하다. 이때는 &lt;code&gt;fopen()&lt;/code&gt; 이라는 &lt;code&gt;API&lt;/code&gt;를 사용한다. 이것은 시스템 콜 &lt;code&gt;open()&lt;/code&gt;에 대응된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

FILE *fopen(const char *path, const char *mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fopen()&lt;/code&gt;은 첫 번째 인자 &lt;code&gt;path&lt;/code&gt;로 지정한 파일에 대한 스트림을 만들고 그것을 관리하는 &lt;code&gt;FILE&lt;/code&gt; 포인터를 반환한다. 만약 실패한 경우 &lt;code&gt;NULL&lt;/code&gt;을 리턴하고, 원인을 나타내는 상수를 &lt;code&gt;errno&lt;/code&gt;에 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 두 번째 인자인 &lt;code&gt;mode&lt;/code&gt;에는 다음과 같은 옵션을 지정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fclose3&#34;&gt;`fclose(3)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜 &lt;code&gt;open()&lt;/code&gt;에 대응하는 API가 &lt;code&gt;fopen()&lt;/code&gt;이라면 &lt;code&gt;close()&lt;/code&gt;에 대응하는 API는 &lt;code&gt;fclose()&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int fclose(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;문자열-입출력&#34;&gt;문자열 입출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일은 바이트의 연속이다. 그런데 그 바이트의 연속을 문자의 연속으로 본다면 파일은 곧 줄의 연속이라고 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 시스템에서는 &amp;lsquo;줄&amp;rsquo;은 &lt;code&gt;&#39;\n&#39;&lt;/code&gt;를 기준으로 줄이 나뉜다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 파일의 마지막이나 스트림으로부터의 입력이 끝나는 지점에 &lt;code&gt;&#39;\n&#39;&lt;/code&gt;이 없어도 하나의 줄로 간주한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 24 Jul 2021 06:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JPA&lt;/code&gt; 강의를 들었다.&lt;/li&gt;
&lt;li&gt;시스템 프로그래밍 공부를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JPA&lt;/code&gt;를 사용하니 정말로 편하고 좋았지만, 내부 동작 원리를 제대로 이해하고 사용해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;아직은 파일 시스템에 대해서 긴가민가하는 상태이기는 하지만, 곧 좋아질 것이라고 믿는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스트림과 관련된 라이브러리 함수를 배우게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 역시도, 개발을 하다 보니 새벽에 잠들어버렸다. 다음날 늦게 일어났는데 이는 시간을 효율적으로 사용하지 못하는 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트를 위해서, JPA 강의를 수강한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 프로그래밍 공부를 주로 할 것이다. 오늘은 스트림 뿐만 아니라, 소켓 프로그래밍에 대해서도 병행하여 공부를 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글또에서 작성할 주제를 선정해야한다. 오늘 스프링이나 자바 공부를 하면서 어떤 주제의 글을 작성할지 생각을 해야겠다. 되도록이면 새로운 주제에 대한 포스팅 보다는 토이 프로젝트나, 공개 개발자 대회 구현을 위해서 필요한 기술 위주로 포스팅을 하는 것도 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루도 자신감 있게 하루를 보낼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CAT 명령어 만들기 및 기타 시스템 콜</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/cat-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</link>
      <pubDate>Sat, 24 Jul 2021 05:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/cat-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%B0%8F-%EA%B8%B0%ED%83%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</guid>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

static void do_cat(const char *path);
static void die(const char *s);

int main(int argc, char *argv[]) {
  int i;
  if (argc &amp;lt; 2) {
    fprintf(stderr, &amp;quot;%s: file name not given\n&amp;quot;, argv[0]);
    exit(1);
  }
  for (i = 1; i &amp;lt; argc; i++) {
    do_cat(argv[i]);
  }
  exit(0);
}

#define BUFFER_SIZE 2048

static void do_cat(const char *path)
{
  int fd;
  unsigned char buf[BUFFER_SIZE];
  int n;

  fd = open(path, O_RDONLY);
  if (fd &amp;lt; 0) die(path);

  for (;;) {
    n = read(fd, buf, sizeof buf);
    if (n &amp;lt; 0) die(path);
    if (n == 0) die(path);
    if (write(STDOUT_FILENO, buf, n) &amp;lt; 0) die(path);
  }
  if (close(fd) &amp;lt; 0) die(path);
}

static void die(const char *s)
{
  perror(s);
  exit(1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;파일-오프셋&#34;&gt;파일 오프셋&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파일 디스크립터에 대해서 &lt;code&gt;read()&lt;/code&gt; 시스템 콜을 반복해서 호출하면 파일의 마지막에 도달하게 되는데 이것은 스트림이 마지막으로 읽은 파일의 위치를 기억하고 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉, 스트림은 파일의 특정 위치에 연결되어 있다. 이렇게 스트림이 연결되어 있는 위치를 &lt;strong&gt;파일 오프셋&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일 오프셋은 스트림의 속성으로 시스템 콜을 사용해서 조작할 수 있다. 파일 오프셋을 조작하는 대표적인 시스템 콜이 &lt;code&gt;lseek()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lseek2&#34;&gt;&lt;code&gt;lseek(2)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
off_t lseek(int fd, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lseek()&lt;/code&gt;는 파일 디스크립터 내부의 파일 오프셋을 지정한 위치로 이동한다. 옮겨갈 위치를 지정하는 방식은 아래와 같고, 그것을 &lt;code&gt;whence&lt;/code&gt;라는 인자에 저장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;제목&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_SET&lt;/td&gt;
&lt;td&gt;파일의 처음을 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_CUR&lt;/td&gt;
&lt;td&gt;현재 위치 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEEK_END&lt;/td&gt;
&lt;td&gt;파일의 마지막을 기준으로 오프셋 계산 및 이동&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;스트림의 반대편에 있는 실체에 따라서 &lt;code&gt;lseek()&lt;/code&gt;를 사용할 수 없는 경우도 있다. 예를 들어서 단말이나 프로세스에 연결된 스트림에 대해서는 &lt;code&gt;lseek()&lt;/code&gt;를 실행하면 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dup2-dup22&#34;&gt;dup(2), dup2(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int dup(int oldfd);
int dup2(int oldfd, int newfd);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dup()&lt;/code&gt;, &lt;code&gt;dup2()&lt;/code&gt;는 인자로 지정한 파일 디스크립터 &lt;code&gt;oldfd&lt;/code&gt;를 복제하는 시스템 콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ioctl2&#34;&gt;ioctl(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/ioctl.h&amp;gt;

int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ioctl()&lt;/code&gt;은 스트림이 연결된 디바이스에 특화된 작업을 모두 포함하는 시스템 콜이다. 예를 들어서 아래와 같은 작업을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;DVD 드라이브 여닫기, 음악 CD 재생
프린터 구동이나 일시정지
SCSI 디바이스 하드웨어 옵션 설정
단말 통신 속도 설정
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;자세한 내용은 메뉴얼에서 확인할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man ioctl_list
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;fcntl2&#34;&gt;fcntl(2)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ioctl()&lt;/code&gt;의 기능 중에서 파일 디스크립터 관련 작업을 분리하려고 만들어 진 것이 &lt;code&gt;fnctl&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcnt.h&amp;gt;

int fcntl(int fd, int cmd, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;두번째 인자 &lt;code&gt;cmd&lt;/code&gt;에 실제로 수행하는 작업을 지정하고 지정한 작업에 따라서, 세번째 이후의 인자가 결정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스트림과 관련된 시스템 콜</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</link>
      <pubDate>Sat, 24 Jul 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</guid>
      <description>&lt;h3 id=&#34;스트림과-관련된-시스템-콜&#34;&gt;스트림과 관련된 시스템 콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에서 바이트 열을 읽는 &lt;code&gt;read&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;스트림에서 바이트 열을 쓰는 &lt;code&gt;write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;새로운 스트림을 생성하는 &lt;code&gt;open&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;사용 완료한 스트림을 닫는 &lt;code&gt;close&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-디스크립터&#34;&gt;파일 디스크립터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스에서 파일을 읽거나, 쓸 때 혹은 다른 프로세스와 데이터를 주고 받을 때 스트림을 사용한다고 했다. 그렇다면, 우리가 만든 프로그램에서 스트림을 사용하려면 어떻게 해야할까?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 위해서 &lt;strong&gt;파일 리스크립터(file desriptor)&lt;/strong&gt; 라는 것을 사용하는데, 커널이 스트림을 열 때 부여하는 번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널이 만들어준 스트림의 번호(파일 디스크립터)를 알아야 스트림을 본격적으로 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력-표준-출력-표준-에러-출력&#34;&gt;표준 입력, 표준 출력, 표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보통 셸을 통해서 프로세스가 생성되는 경우, 세 개의 스트림이 기본으로 생성되며, 이에 대한 파일 디스크립터 값이 미리 할당된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 새 개의 스트림이란 &lt;strong&gt;표준 입력(standard input)&lt;/strong&gt;, &lt;strong&gt;표준 출력(standard output)&lt;/strong&gt;, &lt;strong&gt;표준 에러 출력(standard error output)&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이들 스트림은 각각 파일 디스크립터 0번, 1번, 2번에 할당된다. 이 값에 대한 매크로도 준비되어 있는데 각각 &lt;code&gt;STDIN_FILENO&lt;/code&gt;, &lt;code&gt;STDOUT_FILENO&lt;/code&gt;, &lt;code&gt;STDERR_FILENO&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력과-표준-출력&#34;&gt;표준 입력과 표준 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 입력과 표준 출력을 잘 활용하면 리눅스 명령어를 조합하여 고도의 작업을 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 명령어를 파이프로 연결하여 데이터를 처리하는 것이 가능한 것도 각 명령어가 표준 입력에서 데이터를 읽어들이고, 처리 결과를 표준 출력에 쓰게 되어 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우의 &amp;lsquo;표준&amp;rsquo;은 &amp;lsquo;디폴트&amp;rsquo;에 가까운 의미이다. 표준 입력은 프로그램의 디폴트 입력 소스이며, 표준 출력은 디폴트 출력지라는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러개의 리눅스 명령어를 조합할 수 있는 것도 각 리눅스 명령어가 표준 입력에서 데이터를 읽고, 표준 출력에 쓰는 약속을 했기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-에러-출력&#34;&gt;표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 에러 출력은, 에러 메시지를 출력하기 위해서 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 표준 출력은 파이프라인을 통해서 다른 프로그램의 표준 입력에 연결된다. 따라서 에러 메시지를 표준 출력으로 내보내면 사람이 에러 발생을 알기 어렵게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 여분의 스트림을 준비해서 일반 메시지는 파이프라인을 통해 표준 출력으로 내보내고, 에러 메시지는 표준 에러 출력으로 출력하도록 한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;파일 디스크립터&lt;/th&gt;
&lt;th&gt;매크로&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준입력, 기본 입력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 출력, 기본 출력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 에러 출력, 별도 메시지 출력용&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;스트림-읽기-및-쓰기&#34;&gt;스트림 읽기 및 쓰기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 데이터를 읽고 쓰기 위해서 &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 라는 시스템 콜을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 바이트 열을 읽기 위해서 사용하는 시스템 콜이 &lt;code&gt;read()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;read2&#34;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t read(int fd, void *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 파일 디스크립터 번호인 &lt;code&gt;fd&lt;/code&gt;에 해당하는 스트림에서 바이트 열을 읽는 시스템 콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt;로 바이트 수를 읽어서 &lt;code&gt;buf&lt;/code&gt;에 기록한다. &lt;code&gt;buf&lt;/code&gt;의 크기는 &lt;code&gt;bufsize&lt;/code&gt;로 할당하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 읽기 작업이 완료되면 읽어들인 바이트 수를 반환한다. 그리고 파일의 끝에 도달한 경우에는 0을 반환하고, 중간에 에러가 발생한 경우에는 -1을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt; 바이트 수 보다 적은 바이트를 읽는 경우도 많으므로 반환값을 체크하도록 코딩해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C언어 문자열에는 임의의 바이트 열을 저장할 수 있지만, 일반적으로 문자열의
끝에는 &#39;\0&#39;을 넣는 것이 관례이다. API 중에도 문자열의 끝에 &#39;\0&#39;이 있다고
전체하는 것과 그렇지 않은 것이 있어서 사용에 주의 해야한다. 
예를 들어, 문자열의 끝에 &#39;\0&#39;이 있다고 전제하는 API에 &#39;\0&#39;로 끝나지 
않는 문자열을 전달하면 문제가 될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read&lt;/code&gt;의 경우에는 읽어들인 데이터의 끝에 &lt;code&gt;\0&lt;/code&gt;가 있다고 전제하지 않는 &lt;code&gt;API&lt;/code&gt;이다. 따라서 &lt;code&gt;read(2)&lt;/code&gt;를 통해서 읽어 들인 문자열의 끝에 &lt;code&gt;\0&lt;/code&gt;이 있다고 생각하고 코드를 작성해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;printf()&lt;/code&gt;의 경우에는 문자열의 끝에 &amp;lsquo;\0&amp;rsquo;이 들어가 있다고 전제하는 &lt;code&gt;API&lt;/code&gt; 이므로, &lt;code&gt;read(2)&lt;/code&gt;로 읽은 문자열을 그대로 &lt;code&gt;printf()&lt;/code&gt;로 전달하면 안된다. 이는 보안상의 취약점이 될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;write2&#34;&gt;&lt;code&gt;write(2)&lt;/code&gt;&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에 바이트 열을 쓸 때는 시스템 콜 &lt;code&gt;write()&lt;/code&gt;를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t write(int fd, const *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;는 인자로 지정한 &lt;code&gt;bufsize&lt;/code&gt; 바이트만큼, &lt;code&gt;buf&lt;/code&gt;의 내용을 &lt;code&gt;fd&lt;/code&gt;로 지정한 파일 디스크립터의 스트림에 쓴다. 반환값의 데이터 타입인 &lt;code&gt;ssize_t&lt;/code&gt;는 부호 있는 정수를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정상적으로 쓴 바이트 수를 반환하고 에러가 발생한 경우에는 &lt;code&gt;-1&lt;/code&gt;를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;가 &lt;code&gt;bufsize&lt;/code&gt;로 지정한 바이트 수만큼 쓸 수 없는 상황은 비교적 드물지만, 발생한 여지는 충분히 있다. 정확한 처리가 필요한 경우에는 반환값을 체크하도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스트림이란&#34;&gt;스트림이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림은 파일 디스크립터로 표현되고, &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 읽고 쓸 수 있다. 예를 들면, 파일을 &lt;code&gt;open()&lt;/code&gt;하면 &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 파일의 내용을 읽거나 쓸 수 있는데, 이것이 바로 스트림이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은 맥락에서 파이프라인이나, 소켓도 스트림으로 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-열기&#34;&gt;파일 열기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;프로세스가 만들어 질 때부터 사용할 수 있는 스트림으로는 표준 입력, 표준 출력, 표준 에러 출력이 있다. 이번에는 이 이외의 스트림을 만드는 방법에 대해서 알아보자.&lt;/p&gt;
&lt;h4 id=&#34;open2&#34;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;파일을 읽고 쓰는 스트림을 만들려면 시스템 콜 &lt;code&gt;open()&lt;/code&gt;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt;은 첫 번째 인자 &lt;code&gt;path&lt;/code&gt;로 지정한 경로의 파일에 대한 스트림을 만들고, 그 스트림을 가리키는 파일 디스크립터를 반환한다. 이러한 과정을 흔히 파일을 연다라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 인자인 &lt;code&gt;flags&lt;/code&gt;에서는 파일을 어떤 모드로 열 것인지 비트 연산자를 사용하여 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;파일을 열 때 사용할 수 있는 &lt;code&gt;flag(1)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;flag&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;쓰기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDWR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽고 쓰기&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;close2&#34;&gt;&lt;code&gt;close(2)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;사용이 끝난 스트림은 &lt;code&gt;close()&lt;/code&gt;로 닫는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int close(int fd);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;close&lt;/code&gt;는 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt;에 연결된 스트림을 해제한다. 이러한 처리를 파일을 닫는다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오류 없이 닫히면 &lt;code&gt;0&lt;/code&gt;, 에러가 발생하면 &lt;code&gt;-1&lt;/code&gt;를 반환한다. 일반적으로 &lt;code&gt;close()&lt;/code&gt;함수를 호출하는 코드는 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;if (close(fd) &amp;lt; 0) {
  /* 에러 처리 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료되면 사용하던 모든 스트림을 커널이 파기 하기 때문에, &lt;code&gt;close()&lt;/code&gt;를 하지 않아도 시스템에 이상이 생기지 않을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 사용이 완료된 스트림은 반드시 종료시켜주는 것이 좋다. 프로세스가 동시에 사용할 수 있는 스트림의 개수에 제한이 있기도 하고, 스트림의 반대편에 프로세스가 &lt;code&gt;close()&lt;/code&gt; 할 대까지 기다리고 있을 수도 있다. 모든 리소스는 사용이 완료되었을 때 닫아주는 것이 바람직하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 23 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zuminternet.github.io/zum-front-investing-clone/&#34;&gt;INVESTING.COM 클론 코딩(feat. Vue JS SSR, CANVAS API)&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://devkingdom.tistory.com/&#34;&gt;IT 알려주는 은행원&lt;/a&gt; 스프링에 대한 굉장히 좋은 글을 읽을 수 있었다. 토이프로젝트를 할 때 많은 도움이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126722627-0cb2a6d4-6195-4261-b01a-bd14eadb13a3.png&#34; alt=&#34;Screen Shot 2021-07-23 at 8 49 11 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;공개 개발자, 대회에 참여할 때 참고할 좋은 자료가 될 것 같다. 특히 기능적 요구사항과, 기술적인 요구사항을 간단하게 리스트업 하는게 좋았는데 토이 프로젝트도 당장 기능적인 요구사항을 리스트업하고 정리하는 시간을 가지는 것이 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어제 무리하지 않으려고, 비교적 일찍 잠자리에 들었는데 그나마 몸이 가벼워진 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 공개 개발자 대회 아이디어 도출 회의를 했었는데, 꽤 괜찮은 아이디어가 나온 것 같아서 기분이 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스마트폰을 침실과 분리하니, 수면의 질이 올라간 느낌이다. 분리하려고 노력을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내일이면 주말인데, 주말에도 일일 회고를 작성하고 오늘의 할일을 적어야겠다. 오늘의 할일을 적으니, 시간을 좀 더 활용하는 느낌이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어제 하루종일 컨디션이 별로라서, 시스템 프로그래밍 공부를 하지 못했다. 따라서 오늘은 꼭 하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 오늘은 인프런에서 &lt;code&gt;JPA&lt;/code&gt; 강좌를 시청해야겠다는 생각을 했다. 이번 주말에, API 및 기능적 요구사항을 다시 한 번 정리하고 진도를 나가야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이 프로젝트를 코드로 구현하는 것도 좋지만, 매일 기능 요구사항 및 어떻게 구현하면 좋을지 생각해보는 것도 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어제 컨디션이 좋지 못해서, 코드에 실수가 많이 발생했을 것 같다. 따라서, 오늘 다시 한 번 확인을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 점심(12:15 ~ 13:30)에는 간단한 운동 및 식사를 해야겠다.&lt;/li&gt;
&lt;li&gt;업무가 끝난 후에, (17:00 ~ 17:30) 잠시 휴식한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트 문제를 풀고 이를 제출한다. (17:30 ~ 18:30)&lt;/li&gt;
&lt;li&gt;간단하게 저녁 식사를 마친 뒤에, 복싱 도장에 가서 복싱을 할 예정이다. (19:30 ~ )&lt;/li&gt;
&lt;li&gt;복싱을 마친 뒤에, 시스템 프로그래밍 공부를 간단히 할 예정이다. (22:00 ~ 23:00)&lt;/li&gt;
&lt;li&gt;오늘 코드 포스 DIV.3 대회가 있어서 대회에 참여할 예정이다. (23:35 ~ )&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루도 책임감 있게 일할 것이다.&lt;/li&gt;
&lt;li&gt;항상 자신감 있고, 활기찬 생활을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 22 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://brunch.co.kr/@jowlee/148&#34;&gt;최상위 1%가 의외로 공통으로 가지고 있는 습관 ?&lt;/a&gt; 라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나도 어떤 것을 설명할 때, 애들도 이해할 수 있을 정도로 쉽게 풀어서 남에게 설명하는 연습을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전에 기술 주제에 대해서, 발표를 하면서 공부하기로 하였는데 어느 순간 잊어버린 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;점심(12:15 ~ 13:30)에 부족한 잠을 보충해야할 것 같다.&lt;/li&gt;
&lt;li&gt;업무가 끝난 후에, (17:00 ~ 17:30) 잠시 휴식한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트 문제를 풀고 이를 제출한다. (17:30 ~ 18:30)&lt;/li&gt;
&lt;li&gt;시스템 프로그래밍에 대해서 공부를 한다.(20:00 ~ 21:00) 스트림 관련 시스템 콜을 공부할 예정이며 5,6 장을 공부할 것이다.&lt;/li&gt;
&lt;li&gt;오늘, 공개 개발자 대회에서 어떤 것을 만들지에 대한 회의를 진행한다. (22:00 ~ 23:00)&lt;/li&gt;
&lt;li&gt;토이 프로젝트를 진행하기 위해서 인프런에서 &lt;code&gt;JPA&lt;/code&gt; 강좌를 시청한다.
(23:00 ~ 24:00)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루도 활기차게 보내자.&lt;/li&gt;
&lt;li&gt;항상 자신감 있고 당당하게 시간을 보내자.&lt;/li&gt;
&lt;li&gt;매일 조금씩이라도 토이프로젝트를 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>커맨드라인 인자</title>
      <link>https://dongwooklee96.github.io/post/2021/07/22/%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%EC%9D%B8%EC%9E%90.html</link>
      <pubDate>Thu, 22 Jul 2021 00:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/22/%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%EC%9D%B8%EC%9E%90.html</guid>
      <description>&lt;h3 id=&#34;커맨드-라인-인자&#34;&gt;커맨드 라인 인자&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char* argv[]) {
  int i;
  printf(&amp;quot;argc=[%d]\n&amp;quot;, argc);
  for (i = 0; i &amp;lt; argc; i++) {
    printf(&amp;quot;argv[%d]=%s\n&amp;quot;, i, argv[i]);
  }
  exit(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;는 실행 인자에 대한 정보를 담고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argc&lt;/code&gt;는 실행 인자의 개수를 담고 있고, &lt;code&gt;argv&lt;/code&gt;는 실행 인자의 내용을 문자열 배열 형태로 담고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argv[0]&lt;/code&gt;에는 실행할 때 입력한 명령어가 들어가는데, 예를 들어서 &lt;code&gt;./hello&lt;/code&gt; 라는 명령어를 실행하면 &lt;code&gt;argv[0]&lt;/code&gt;에 &lt;code&gt;./hello\0&lt;/code&gt;이라는 값이 들어간다. 따라서 &lt;code&gt;argc&lt;/code&gt;는 언제나 1 이상이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126514030-9633c6d5-1a59-40ab-a450-ead604263969.png&#34; alt=&#34;Screen Shot 2021-07-22 at 12 16 25 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로그램을 실행할 때의 이름이 &lt;code&gt;argv[0]&lt;/code&gt;에 항상 들어있는 것과, 실행 인자를 늘리면 &lt;code&gt;argc&lt;/code&gt;도 증가하는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126514473-f311278c-30db-4700-82d4-81f2caf18a28.png&#34; alt=&#34;Screen Shot 2021-07-22 at 12 18 59 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추가적으로, 실행인자를 &amp;ldquo;&amp;ldquo;로 묶어서, 감싼 부분을 하나의 실행 인자로 묶어 주는 효과를 낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; 같은 와일드 카드(&lt;code&gt;glob&lt;/code&gt;) 패턴을 이용하여 파일 이름의 집합을 인자로 넘겨줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;glob&lt;/code&gt; 패턴을 문자 그대로 사용하고 싶은 경우에는 위와 같이 큰 따옴표로 주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 21 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://shipilev.net/jvm/anatomy-quarks/&#34;&gt;JVM Anatomy Quarks&lt;/a&gt; 라는 시리즈를 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;을 공부하는데 많은 도움이 될 것 같다. 추가로 원 저자에게 허락을 맡으면, 번역글을 작성하는 것도 좋을 것이다. 글또에 이 번역글을 제출해도 재미있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;도커 파일 구성 및, 자바 웹 애플리케이션을 도커 이미지화하는 방법에 대해서 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쉽게 배포를 할 수 있을 것 같고, 더 나아가서는 쿠버네티스를 이용해보는 것도 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어제 저녁에 무리해서 토이 프로젝트를 했더니, 오늘 아침에 조금 힘들었다. 따라서 점심에 밥도 안먹고 잠자느라 바뻤다. 하지만 오히려 저녁에 더 쌩쌩해진 것 같다. 좋은 패턴은 아니므로 빨리 고치자 오늘 저녁에는 무조건 일찍 잠자리에 들도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래도 이제, 거의 다 마무리 되는 것 같아서 기쁘다. 자잘한 버그가 있기는 한데, 이것은 마음을 가다듬으면서 잘못된 부분을 찾아가야할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오전 일과가 끝나면 잠깐 쉬다가 운동을 시작한다. (12:30 ~ 13:00)까지, 그리고 점심을 먹는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고(17:00), 한시간 정도 쉬다가 (18:00) 부터 코딩 테스트 문제를 풀고 제출한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(19:00) 저녁 식사를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(19:30) 복싱 도장으로 가서 복싱을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(10:00) 시스템 프로그래밍 공부를 한다. 이전에 공부하던 책 &amp;ldquo;리눅스 시스템 네트워크 프로그래밍은&amp;rdquo; 레퍼런스 형태로 사용하고 우선은 &amp;ldquo;모두를 위한 리눅스 프로그래밍&amp;rdquo; 이라는 책부터 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(12:00) 토이프로젝트에서 자바독을 명시한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 집중도 있게 일할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;많은 일도 하나씩 해결하다 보면, 끝나있을 것이다. 따라서 긍정적인 마인드로 공부를 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다시 공부를 시작할 마음이 생긴것 같고, 재미있을 것이다. 따라서 조급해하지 말고 즐기면서 공부를 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 문서를 처음부터 끝까지 읽으려고 하지말고, 머리에 들어오지 않는 내용이거나 지금 당장 필요하지 않은 내용이면 잠시 미루고 필요하거나 이해가 되려고 할 때 공부를 하는 것도 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도큐먼트를 필요한 부분만 읽는 것도 중요하지만, 너무 흘려 읽지 않고 필요한 부분은 집중해서 읽는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 20 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘도, 역시 코딩 테스트 문제를 풀고 출석 체크를 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글또에서 만난 사람들이랑 공개 소프트웨어 개발자 대회에 참여하게 되었다. 좋은 경험이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요즘 내가 개발적으로 나아가고 싶은 분야가 뭔지 정확히 모르겠어서 조금은 혼란스럽다. 시스템 개발을 정말로 하고 싶은 건지, 진지하게 생각하는 시간을 가지고 커리어를 어떤 방향으로 쌓아야하는지 고민하는 시간을 가져봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 고민을 글또에 올려서, 다같이 고민하는 시간을 가져도 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같이 공부하던 코딩 스터디 팀원이 나가게 되어서 굉장히 아쉬웠다. 끝까지 함께할 수 있었으면 좋았을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 점심시간에 운동을 하고 씻을 수 있어서 굉장히 개운하고 기분이 좋았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내일 젯브레인 구독이 끝나는 날이다. 새롭게 등록을 해야하는데 이번달은 지출이 굉장히 많아지는 것 같다. 저축을 하나도 하지 못했다. 다음달에는 사소한 지출을 최대한 줄이도록해야겠다. 짠돌이가 되어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝나고 알고리즘을 풀기전에, 피곤하여 잠깐 잠이 들었다. 이렇게 잠깐 자는 잠이 새벽까지 잠들지 못해서 다음날 아침이 피곤해지고, 업무가 끝난후에 무기력해지는 것 같다. 오늘 저녁에는 늦게 자지 않도록 주의해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;피곤해서 잠을 자느라 복싱 도장에 가지 못했다. 확실히 재택 근무를 하다 보니, 복싱 도장에 가는 빈도가 줄어든 것 같다. 최소한 격주로는 갈 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 아침에, 업무를 하다가 &lt;code&gt;12:15&lt;/code&gt;분에 &lt;code&gt;12:45&lt;/code&gt;분까지 운동을 하고 씻고 나서 밥을 먹을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무가 끝난 후에는, 조금 쉬다가 알고리즘 문제를 풀 것이다. 그리고 밥을 먹을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;19 시쯤 운동복을 챙겨서 복싱 도장으로 운동을 하러 갈 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집에 도착해서는, 리눅스 시스템 네트워크 프로그래밍 책 파일 처리 관련된 부분을 읽을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서, 토이프로젝트에서 도커 파일을 작성하고 배포 파이프라인을 구축할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루 책임감을 가지고 열심히 일을 하자!&lt;/li&gt;
&lt;li&gt;오늘 하루 시간을 헛투로 사용하지 말자.&lt;/li&gt;
&lt;li&gt;자신감 있고, 내가 계획한 일들을 이루려고 노력을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>프로그래밍을 학습하는 좋은 접근 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/07/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94-%EC%A2%8B%EC%9D%80-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Tue, 20 Jul 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%99%EC%8A%B5%ED%95%98%EB%8A%94-%EC%A2%8B%EC%9D%80-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=91501933&#34;&gt;자바 웹 프로그래밍 Next Step&lt;/a&gt; 이라는 책을 읽다가 &lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=31679090&#34;&gt;코딩을 지탱하는 기술&lt;/a&gt;이라는 책에서 좋은 글귀를 발견했다고 인용하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;책의 목차를 살펴보니, 읽어보는 것도 나쁘지 않겠다. 이 책에서 말하는 프로그래밍 학습 방법은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;첫번째 단계, 필요한 부분부터 흡수한다&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;책이나 자료 전체가 동일한 정도로 중요하다고 말할 수 없다. 목적이 명확하고, 목적 달성을 위해서
어디를 읽어야 할지 알고 있다면 다른 페이지는 신경쓰지 말고 바로 그곳을 읽도록 한다.
전체 모두 읽지 않은 것이 깨름칙한가? 하지만 좌절하고 전혀 읽지 않은 것보다는 낫다.
&#39;전부 읽지 않으면&#39;이라는 완벽주의가 배우고자 하는 동기를 짓누르고 있다면, 버려 버리는 것이 낫다.
동기는 매우 중요하다. 이 전략을 사용하기 위해서는 읽고 싶은 부분이 어디인지 대략적으로 전체적인
구조를 파악하고 있어야 한다. 만약 그게 어려우면 다음 전략인 
&#39;대략적인 부분을 잡아서 조금씩 상세화한다.&#39;를 시험해보도록 하자.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;두 번째 단계, 대략적인 부분을 잡아서 조금씩 상세화 한다&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;책이나 문서에는 목차가 있다. 목차를 보면 전체 구조를 대략적으로 알 수 있다.
그리고나서 본문을 속독으로 읽어나간다.
자세히 보지 않고 우선은 소제목이나 강조 부분, 그림과 그림 제목 등을 본다.
소스 코드를 읽을 때는 우선 디렉토리 구조와 파일 명을 본다. 그리고 파일을 속독으로 읽고
거기서 정의하고 있는 함수나 클래스 이름, 자주 호출되는 함수명 등을 본다. 이 방법들에는
&#39;우선 대략적인 구조를 잡고, 조금씩 상세한 정보로 접근한다&#39;는 공통점이 있다. 이것이 기본 원칙이다.
소스코드에는 다른 방식의 독해 방법이 있다. 디버거의 과정을 사용해서, 실행되는 순서나 호출 계층으로
읽는 방법이다. 이 경우도 동일하게 우선은 대략적인 처리 흐름을 따라가고, 조금씩 깊이를 더해서 함수 
안의 처리를 따라가는 것이 중요하다. 이 방법으로 읽이도 정보가 한쪽 귀로 들어와서 한쪽 귀로 나가버리는 
느낌을 받는 경우가 있다면, 마지막 방법인 &#39;끝에서부터 차례대로 배껴간다&#39;를 시도해보자.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;세 번째 단계, 끝에서부터 차례대로 배껴간다&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;명확히 &#39;하고 싶은 것&#39;, &#39;조사하고 싶은 것이 없이 &#39;대충 읽으면&#39; 읽은 내용이 뇌를 그냥 스쳐 지나갈 뿐이다.
이런 상태에서 어떻게 배울까를 고민한다고 해도, 판단을 위한 지식 자체가 없기 때문에 무의미하다.
그래서 지식의 밑바탕을 만들기 위해서 교과서를 그대로 배껴 쓴다. 이것이 &#39;베끼기&#39;라 불리는 기술이다.
지식이 없는 상태에서 고민하는 것은 무익하기 때문에 우선 아무것도 생각하지 않고 지식을 복사하는 것이다.
이 이상의 방법은 없다. 저자는 시간을 정해서 &#39;25분간 어디까지 베낄 수 있는지&#39; 도전하는 것을 좋아한다.
분량으로 나눈 것도 좋은 방법이다. 중요한 것은 간격을 적절히 해서 목표를 이루었다는 만족감을 얻을 수 있도록
하는 것이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=91501933&#34;&gt;자바 웹 프로그래밍 Next Step&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=31679090&#34;&gt;코딩을 지탱하는 기술&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 19 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dongwooklee96/spring-guide&#34;&gt;https://github.com/cheese10yun/spring-guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cheese10yun/spring-jpa-best-practices&#34;&gt;spring-jpa-best-practices&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cheese10yun/github-project-management&#34;&gt;github-project-management&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 토이프로젝트를 진행할 때 참고하면 좋은 자료들이 위에 나와있었다. 또한 토이프로젝트 뿐만 아니라, 자바 관련한 면접 문제를 대비할 때도 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 걱정하던 문제가 생각보다 쉽게 풀려서 기분이 좋았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기타를 배우고 있는데, 실력이 조금 정체된 것 같다. 문제는 연습량이 부족해서 그런것 같은데, 악보를 집에 두고 연습을 계속해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;긍정적인 마인드로, 개발을 하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt; 토큰이 만료되지 않게 설정하고, 디버거로 실제로 &lt;code&gt;expired&lt;/code&gt; 가 없어지는 것까지는 확인했는데 실제로 동작하는지 확인은 하지 않았다. 따라서, 다음부터는 꼭 확인을 하는 습관을 들이자! 실제 반영까지 되었는데, 동작하지 않는다는 것을 알면 낭패고, 동료들에게 신뢰를 잃을 수도 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표 및 마감기한 섹션을 오늘 할일을 기록하는 칸으로 두는 것이 좋겠다. 실제 목표 및 마감기한을 리마인드하는 목적으로 만들었지만, 구글 캘린더를 이용하고 있어 실제로 사용되지는 않기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo-오늘-할일&#34;&gt;Todo (오늘 할일)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일에 책임감을 가지고 열심히 일을 할 것이다.&lt;/li&gt;
&lt;li&gt;나는 항상 생산자적 마인드를 가지고 살아갈 것이다.&lt;/li&gt;
&lt;li&gt;나는 블로그에 내가 배운 내용을 글로 잘 풀어서 적을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>글또 6기 다짐글</title>
      <link>https://dongwooklee96.github.io/post/2021/07/18/%EA%B8%80%EB%98%90-6%EA%B8%B0-%EB%8B%A4%EC%A7%90%EA%B8%80.html</link>
      <pubDate>Sun, 18 Jul 2021 22:44:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/18/%EA%B8%80%EB%98%90-6%EA%B8%B0-%EB%8B%A4%EC%A7%90%EA%B8%80.html</guid>
      <description>&lt;h3 id=&#34;글또-다짐글&#34;&gt;글또 다짐글&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;글을 잘 쓰고 싶다는 마음에 글또 지원하였는데, 매우 다행이게도 합격메일을 받을 수 있었다. 글또 활동을 시작하기 전에 다짐글을 작성하면 좋다고 하여 다짐글을 작성해본다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126069699-da4df488-a27e-4706-a4f7-523aa3918170.png&#34; alt=&#34;합격메일&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;글또를-통해서-내가-기대하는-것&#34;&gt;글또를 통해서 내가 기대하는 것&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;우선 내가 글또를 통해서 어떤 것을 이루기 위해서 지원을 했는지 되집어서 생각을 해보자.
내가 글또를 통해서 이루고자 하는 바는 정리해보자면 아래와 같을 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 블로그 글을 작성하는 모임을 통해서, 강제성을 가지고 꾸준하게 글을 작성해보고 싶다.
2. 피드백을 통해서 단순한 정리글이 아닌, 다른 사람들에게 유용한 글을 작성해보고 싶다.
3. 다른 사람들은 글을 어떻게 어떤 생각으로 작성하는지 조금더 가까히서 보고 싶다. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;한마디로 다른 사람들과 함께 내 자신을 성장시키고 싶다는 말로 요약할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;조금씩 회고나 배운것을 작성하고 있기는 하지만, 아쉬운 점이 있기는 했다. 짧은 시간에 작성하다보니 완성도 있는 글을 작성하기 힘들고, 단순히 인터넷에서 리서치한 내용을 요약하거나 번역하는 식의 글 밖에 작성하지 못하는 것이다.&lt;/p&gt;
&lt;p&gt;가끔 정보를 얻고자 인터넷을 검색할 때 우와라는 감탄사가 나오도록 글을 작성한 블로그가 있다. 되돌아서 생각을 해보니 대부분 이러한 글들은, 개발을 하면서 겪은 자신의 경험담을 글에 잘 녹여냈거나, 단순히 문서에 있는 내용을 요약하거나 나열한 것이 아니라, 직접 사용하면서 얻은 깨달음을 녹여낸 글이였다.&lt;/p&gt;
&lt;p&gt;그렇다면 나는 어떻게 하면 이러한 글을 작성할 수 있을까 생각을 해보았는데, 우선 하나의 글을 작성하는데 오랜 시간을 보내면서 다듬는것부터 시작을 해야겠다. 이전에는 글을 쓰면 당일날에 무조건 끝낸다는 생각을 가지고 글을 작성했다면, 글또를 시작하면서는 하나의 글을 오랜시간동안, 계속 다듬어가면서 작성해보는 것이다.&lt;/p&gt;
&lt;p&gt;글또 6기를 시작하면서 하나의 목표를 둔다면 이것을 목표로 삼고 싶다. 하나의 글을 매일 조금씩 다듬어 가는 것이다. 그 이유는 좋은 글을 작성하기 위한 첫걸음이라고 생각하기 때문이다. 좋은 글을 작성하기 위해서라면 우선적으로 절대적인 시간을 많이 투자해야한다. 글또에서 글을 작성하는 주기는 2주이므로, 내가 다짐한 내용을 지키려면 최소한 일주일 전에는 글을 작성하기 시작해야한다는 것이다.&lt;/p&gt;
&lt;h3 id=&#34;나의-다짐&#34;&gt;나의 다짐&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;* 한편의 글을 작성할 때, 최소 일주일의 기간동안 작성한다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 단 한가지의 목표를 글또를 하는 동안 꼭 지킬것이다!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>글또 OT</title>
      <link>https://dongwooklee96.github.io/post/2021/07/18/%EA%B8%80%EB%98%90-ot.html</link>
      <pubDate>Sun, 18 Jul 2021 21:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/18/%EA%B8%80%EB%98%90-ot.html</guid>
      <description>&lt;p&gt;일요일 저녁, 드디어 기다리던 글또 OT를 진행하였다. 아래 내용은 글또 &lt;code&gt;OT&lt;/code&gt; 글또의 규칙과 주의사항을 정리한 글이다.&lt;/p&gt;
&lt;h3 id=&#34;글을-제출하는-방법&#34;&gt;글을 제출하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126066643-1fd562e8-fa3d-4942-bf24-6c79ff2d64fe.png&#34; alt=&#34;Screen Shot 2021-07-18 at 9 15 10 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;글을 작성하고 나서, 자신이 속한 채널에 블로그 &lt;code&gt;URL&lt;/code&gt;을 제출하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 작성할 때는 꼭 제출이라는 슬랙 이모지를 제출해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불가피하게 제출하지 못하는 경우에는, 패쓰권을 사용하겠다는 메세지와 함께 패쓰 이모지를 사용하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;패쓰는 연속해서 2번 이상 사용할 수 없고, 마감 시간전에 패쓰를 사용해야 반영이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;슬랙-봇&#34;&gt;슬랙 봇&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126068245-3906798c-759b-4dce-b1e8-26abdc53c5ff.png&#34; alt=&#34;슬랙봇&#34;&gt;&lt;/p&gt;
&lt;p&gt;글또 슬랙 채팅방에서는 슬랙봇이 있는데 궁금한 정보를 물어보지 않고 봇에게 물어보면 답변을 해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$글또마감일
$글또규칙
$피드백규칙
$글또캘린더
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 슬랙에서 입력하면, 편하게 원하는 정보를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;과거-참여하셨던-분들의-팁&#34;&gt;과거 참여하셨던 분들의 팁!&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;끝까지 완주하기 위해서는 가볍게 시작하는 마음으로 해야 끝까지 갈 수 있다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글을 목적과 컨셉과 상관없이 글을 읽는 사람이, 읽기 편해야하고, 도움이 되면 좋고, 또한 배울 수 있는 글이면 좋다고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글의 퀄리티는 피드백이 답이다. 물론 혼자도 고민해봐야겠지만, 우선 글쓰는것이 힘들다면 피드백을 동료들에게 맡기는 것도 좋은 방법이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 피드백은 글을 쓰는 데드라인 전에 작성하는 것이 다른 사람들에게 퀄리티 있는 피드백을 줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람들이 왜 이글을 찾는지, &lt;code&gt;Search Console&lt;/code&gt;에 등록하고 검색어를 통해서 확인한다면 어떤 글이 사람들에게 더 반응이 있는지를 찾을 수 있다. -&amp;gt; 이 부분은 고려하지 못했는데 사람들이 어떤 것을 원하고 귀기울이는지를 찾는 좋은 연습이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;검색 엔진에 잘 걸리도록 콘텐츠 구조를 구성하는 것이 1순위이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보통 처음글은, 글또 다짐글, 마지막글은 중간 회고글 혹은 연말 회고, 연초 다짐글로 작성이 된다. 아래는 글을 목적에 따른 분류이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 내가 알고 있는 부분을 정리한다.
2. 어려운 개념 정리 글이 검색해도 잘 없는데 이를 번역이라도 해서 익혀보자.
3. 작업하다가 삽질해서 내 것이 된 지식을 정리하자.
4. 공부하자! 내 스타일로 메모
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;예치금을 받으려고, 남에게 잘 보이려고 하지 말고 나에게 집중하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 글을 왜 쓰려고 했는가?, 무엇을 위해 글을 쓰기 시작했는가? 이를 되돌아 보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;큰 문제를 조금씩 잘라서 접근하듯이, 하루에 30분 1시간씩 투자해서 조금씩 작성해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글 작성이 끝나고 미리미리 피드백을 해두는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 과거부터 참여하셨던 분들의 블로그이다. 글을 작성하면서 어떻게 작성하셨는지 살펴보면 좋을 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://feel5ny.github.io/&#34;&gt;필오의 개발일지&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://lsjsj92.tistory.com/category/IT%20Infra%28Engineer%29&#34;&gt;꿈 많은 사람의 이야기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;취업-컨설팅-및-출판사-연결&#34;&gt;취업 컨설팅 및 출판사 연결&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이건 추가적으로, 요청을 주시면 취업 컨설팅 및 출판사 연결을 해주신다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;취업 컨설팅은 주로 학생들 위주로 진행이 될 것 같다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨설팅은 아래와 같은 관점으로 긴호흡으로 이루어진다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 나는 어떤 사람인지?
2. 내가 왜 이 일을 하고 싶은지?
3. 내가 이 일을 하기 위해서 이후 어떤 것을 바라고 있는지?
4. 내가 가고 싶은 회사는 어디인지?
5. 다른 사람들은 어떠한 생각과 어떠한 관점으로 회사를 원하는지?
6. 이력서를 어떻게 써야하는지?
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/1XqURd94fxVQnhENycBOznUW13cd-1zdFZxAz95jHgRI/edit#slide=id.p1&#34;&gt;글또 6기 오리엔테이션&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 16 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/humanscape-tech/iac-infrastructure-as-code-with-terraform-1fb0c6486fbc&#34;&gt;IaC(Infrastructure as Code) with Terraform&lt;/a&gt; 라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.skyer9.pe.kr/wordpress/?p=2184&#34;&gt;application.yml 예제&lt;/a&gt; 라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AWS&lt;/code&gt; 인스턴스 생성과 관련된 작업을, 코드로 관리하면 훨씬 편할 것 같다.&lt;/li&gt;
&lt;li&gt;마음에 드는 설정을 참조하여 설정하면 많은 도움이 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/epXqrRJQnko&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 영상을 보면서 전에 내가 더 이상 소비자가 아니라, 생산자가 되기 위한 마음가짐과 기술을 익히자고 말했던 것이 기억났다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부자들은 다른 사람들에게 무엇인가를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지금 나만 보더라도, 다른 사람들에게 유익한 어떤 것을 제공하지 않고 일단은 소비를 하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 다른 사람들에게 어떤 가치를 전달할 수 있는 사람이 되기위한 기술을 배우고 소비자 마인드가 아니라 생산자 마인드로 거듭나야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 업무를 할 때 밖에서 입는 옷이 아니라 집에서 입는 옷을 입었는데 집중력이 흐트러진 느낌이었다. 따라서 재택을 할 때 근무할 때처럼 복장을 갖춰서 입어야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 하루, 시간이 아깝지 않게 보내자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 자신감 있고, 자신에게 부끄럽지 않도록 행동하는 사람이 되자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;금요일 밤에는 평소에 하고 싶었던 여가 활동을 하는 것도 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 15 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.thestartupbible.com/2021/07/ignorance-is-big-bliss.html?utm_source=feedburner&amp;amp;utm_medium=feed&amp;amp;utm_campaign=Feed%3A+baenefit%2FslXh+%28baenefit.com%29&amp;amp;url=http%3A%2F%2Ffeedproxy.google.com%2F%7Er%2Fbaenefit%2FslXh%2F%7E3%2FEjCOUoaHuqg%2Fignorance-is-big-bliss.html&#34;&gt;모르는게 약이다&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dropbox.github.io/dbx-career-framework/overview.html&#34;&gt;드롭박스의 커리어 프레임워크&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 사업을 할 때, 그 사업 또는 시장에 대해서 아무것도 모를 수가 있는데, 지금의 전문가들도 처음 시작할 때는 아무것도 모르는 상태에서 시작하는 사람들이 많다. 오히려 모르는 것이 더 도움이 될 수 있고 모르는 상태에서 기존의 문제 해결에 집중할 수 있다. 따라서 용기를 가지자. 모르는게 때로는 약이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;드롭박스의 커리 프레임워크를 참조하면서 내가 개발자로서 부족한 점을 파악하는데 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 하루도 활기차고 재미있게 보내자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간을 잘 활용하자. 그리고 운동을 틈틈히 하자, 오늘은 점심을 먹고나서 운동을 하고 간단히 씻는 것을 꼭 완수하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;미리 하루 계획을 세우고, 내가 이루고 싶은 계획을 세우자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>정규표현식</title>
      <link>https://dongwooklee96.github.io/post/2021/07/14/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</link>
      <pubDate>Wed, 14 Jul 2021 21:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/14/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;기본적인 정규 표현식 문법을 익히고 나서, 나중에 사용하거나 이와 관련된 코드를 볼 일이 있을 때 기억이 나도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;정규-표현-regular-expression&#34;&gt;정규 표현 (Regular Expression)&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정규 표현식은 일련의 문자열 패턴을 정형화된 방법을 통해서 찾을 수 있도록 도와주는 문법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다양한 언어의 정규 표현 실행을 위한 함수는 서로 다르지만, 정규 표현 자체는 개발 언어에서 동일하게 적용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;반복자-repeaters---&#34;&gt;반복자 (Repeaters): &lt;code&gt;*, +, {}&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 키워드는 문자열이 얼마나 많이 반복되는지 지정해 줄 때 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정규 표현에 &lt;code&gt;*&lt;/code&gt;를 사용하면 어떤 문자가 0번 혹은 그 이상 나올 수 있다는 것을 표현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;a * b&#39; 이면 &#39;a&#39; 와 &#39;b&#39; 사이에 0번 혹은 그 이상 출현할 수 있다는 것을 의미한다.
예를 들면, &#39;b&#39;, &#39;ab&#39;, &#39;aab&#39;, &#39;aaab&#39;, &#39;aa......b&#39;가 올 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; (더하기)는 &lt;code&gt;*&lt;/code&gt;와 거의 비슷하지만, &lt;code&gt;*&lt;/code&gt;와 다른점은 최소 1번은 나온다는 의미를 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;a + b&#39;이면 &#39;ab&#39;, &#39;aaab&#39;, &#39;aa.....b&#39;는 될 수 있지만, &#39;b&#39;는 될 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;(중괄호)는 중괄호에 숫자를 포함하여 문자열 패턴의 반복 횟수를 설정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;`a{3}b` 이면, &#39;aaab&#39;만 된다.
&#39;a{3}b&#39; 이면, &#39;aaab&#39;, &#39;aaaab&#39;, &#39;aaa...b&#39;와 같이 최소 3이상 a가 나올 수 있다는 의미이다.
&#39;a{3, 4}b&#39;이면 &#39;aaab&#39;, &#39;aaaab&#39;가 된다. 3 ~ 4의 &#39;a&#39; 길이를 설정한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;와일드-카드-wild-card-&#34;&gt;와일드 카드 (Wild Card): &lt;code&gt;.&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 패턴에 대해서는 정규 표현식으로 만들기 어려운 경우가 있다. 이때 편리하게 사용하는 것이 와일드 카드인 &lt;code&gt;.&lt;/code&gt; (점) 키워드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 키워드는 해당 자리에 어떤 문자든 가능하다는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;.&#39;이면 하나의 어떤 문자로든 매칭될 수 있다.
&#39;.*&#39; 이면, 다양한 (모든) 길이의 문자열을 찾는다.
&#39;a.b&#39;이면, &#39;aab&#39;, &#39;abc&#39;, ..., &#39;a b&#39;, &#39;a/b&#39; 등과 같은 모든 문자가 대응될 수 있다. 즉 a로 시작하여 b로 끝나는 길이 3의 모든 문자열로 정의 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;선택-문자-optional-character-&#34;&gt;선택 문자 (Optional Character) &lt;code&gt;?&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;color&amp;rsquo;, &amp;lsquo;colour&amp;rsquo;과 같이 동일한 의미를 가지는 단어가 다른 스펠링으로 쓰이는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 경우 &lt;code&gt;?&lt;/code&gt; 키워드를 통해서 &amp;lsquo;u&amp;rsquo; 문자를 0 혹은 1개가 있을 수 있다는 것을 나타낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;탈자-부호-caret-&#34;&gt;탈자 부호 (Caret): &lt;code&gt;^&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시작 문자를 지정할 수 있다. 특정 문자 혹은 특정 문자열을 시작으로 하는 문자열 패턴을 만들기 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;^a.*&#39; 이면 &#39;a&#39;로 시작하는 모든 문자열을 뜻한다.
&#39;a{2}.*2&#39;이면 &#39;aa&#39;로 시작하는 모든 문자열이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;달러-문자dollar-&#34;&gt;달러 문자(Dollar): &lt;code&gt;$&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 과는 정 반대로 마지막 문자 혹은 문자열을 지정한다. 특정 문자 혹은 문자열이 마지막에 지녀야하는 문자열 패턴을 만들 때 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;.*b$&#39; 이면 마지막 문자 혹은 문자열을 지정한다. 특정 문자 혹은 문자열이 마지막에 지녀야 하는 문자열 패턴을 만들 때 사용한다.
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&#39;.b$&#39;이면, &#39;b&#39;로 끝나는 모든 문자열
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;문자-클래스-charactert-classes-&#34;&gt;문자 클래스 (Charactert classes): &lt;code&gt;[]&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;[cnf]이면 &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;혹은 f가 될 수 있다,&lt;/li&gt;
&lt;li&gt;[^cdf] 이면 &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;, f를 제외한 나머지 문자열&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;그룹-문자-grouping-character-&#34;&gt;그룹 문자 (Grouping character): &lt;code&gt;()&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;특정 문자의 조합 패턴을 검색하는 경우에 사용된다.&lt;/li&gt;
&lt;li&gt;중괄호를 이용하여, 그룹화를 하고, 이 그룹을 위에 언급한 키워드와 조합하여 사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;`(ab)+` 이면 &#39;ab&#39;, &#39;abab&#39;, &#39;ababab...&#39;가 가능하다.
&#39;^(th).*&#39;이면 &#39;th&#39;로 시작하는 모든 문자와 매칭이 가능하다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;수직선-vertical-bar-or-opertation-&#34;&gt;수직선 (Vertical Bar, OR Opertation): &lt;code&gt;|&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;수직선은 비트 연산의 OR 연산과 비슷한 역할을 한다.&lt;/li&gt;
&lt;li&gt;함께 사용된 패턴 중 하나를 선택 및 찾기를 가능하게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;th&#39;(is|e|at) 이면 &#39;this&#39;, &#39;the&#39;, &#39;that&#39;이 매칭이 될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;역슬레시-back-slash-espace-charater-&#34;&gt;역슬레시 (Back-slash, Espace charater): &lt;code&gt;\&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, 키워드 중 하나인 &lt;code&gt;*&lt;/code&gt;를 문자로 찾고 싶을 경우가 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞서 소개한 모든 키워드 문자가 대상이 될 수 있는데, 해당 키워드를 문자 그대로 찾기 위한 방법으로 역슬래시를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;[0-9]\*[0-9]\+[0-9]&#39; 이면, &#39;1 * 2 + 3 = 7&#39;과 같은 문자열이 있다면, &#39;1 * 2 + 3&#39;을 추출할 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;느낀점&#34;&gt;느낀점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;평소에 &lt;code&gt;VIM&lt;/code&gt;을 쓴것이 정규 표현식을 외우는데 많은 도움이 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=267996120&#34;&gt;쓰면서 익히는 알고리즘과 자료구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 13 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://meetup.toast.com/posts/291&#34;&gt;우리의 Thread는 왜 이렇게 부자가 되었을까?&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4597&#34;&gt;스타트업에서 데이터 팀 만들기&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자바8과 자바11의 &lt;code&gt;Thread Executor&lt;/code&gt; 동작 방식이 다르다는 것을 알 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt;에서 장애가 발생하였을 때, 어떻게 해결하는지 대략적으로 알 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 작성하면서, 문서에서 읽었거나, 알고 있는 것이 실제로 동작하는지 테스트 하는 것을 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버전마다 비슷하게 동작할 것이라고 생각하지만, 때로는 다르게 동작할 때가 있다. 따라서 이러한 부분에 주의를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장애는 언제든지 발생할 수 있으므로, 이를 어떻게 하면 원인을 빠르고 정확하게 알아 낼 수 있도록 실력을 키워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재택 근무는 처음이었는데, 예상과는 다르게 매우 집중력 있고 좋은 경험이었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;요즘 코로나때문에 운동을 다시 중지하였는데, 개인적으로도 운동을 계속해서, 나태해지지 않도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 항상 긍정적이고 밝을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나는 항상 긍정적이고 발전할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나는 작은일에도 최선을 다하고 때로는 힘들어도, 조금만 더라는 생각과 나는 할 수 있다라는 생각을 통해서 이를 극복한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 12 Jul 2021 08:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mygumi.tistory.com/396?url=https://mygumi.tistory.com/396h&#34;&gt;Redux 를 걷어낸 이유&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.edgedb.com/&#34;&gt;EdgeDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리덕스와 SWR의 차이에 대해서 대략적으로 알 수 있었다. 이는 토이프로젝트에 어떤 기술을 도입할지 결정하는데 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, 상태 관리를 위해서라면 리덕스를 도입하는 것보다 &lt;code&gt;RECOIL&lt;/code&gt;이라는 상태 관리 라이브러리를 사용하는 것이 더 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EDGEQL&lt;/code&gt; 이라는 매우 혁신적인 쿼리 언어를 발견하였다. 아직 실무에 적용하기는 힘들 것 같지만, 유심히 살펴보는게 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;처음에는 재택이 사무실 근무보다 효율이 않좋을 것이라고 생각을 하였는데 생각보다 효율이 좋아서 놀랐다. 장단점이 있겠지만 아직까지는 장점이 훨씬 더 많은 느낌이다. 조금만 더 재택을 해보면서 재택의 효과를 확인해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;뭔가를 직접 해보기 전에, 판단하는 일을 이번 계기로 하지 않아야겠다. 직접 하면 분명히 다르기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요즘 매일 코딩 테스트 문제를 해결하는 시간대가 늦어지고 있는데, 이는 하기 싫은 다음이 약간이라도 섞여있어서 그런 것 같다. 이를 반성하고 예전처럼 다시 재미있게 코딩 테스트 문제를 풀 수 있으면 좋겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매일 되고 싶은 모습을 상상하고, 자기 선언을 하자고 말했지만, 막상 실천하지 못하는 것 같다. 따라서 내일 아침에는 아에 일정으로 잡고 나서, 내가 되고 싶은 모습을 상상하고 자기선언을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;난 일에 책임감을 가지고, 막히는 일이 있더라도, 끝가지 해낼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 자신감을 가지고, 내가 목표한 바가 모두 잘될 것이라는 확신을 갖는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 09 Jul 2021 08:34:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jybaek.tistory.com/924?url=https://jybaek.tistory.com/924&#34;&gt;성장에 대한 짧은 단상&lt;/a&gt; 이라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우물안의 개구리가 되지 말고, 넓은 시야를 가져야겠다고 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에서 새로운 기술을 도입할 때는 다음과 같은 사항을 고려해봐야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 도입의 명분이 있는지?
2. 새로운 기술을 사용함으로써 실질적인 이득을 지표로 설명 / 설득 가능한지?
3. 비즈니스 구조에 적합한 기술인지?
4. 유지보수 비용은 괜찮은지?
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 08 Jul 2021 08:34:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://techneedle.com/archives/41962&#34;&gt;27년 동안 제프 베조스가 전한 최고의 교훈 5가지&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://hamait.tistory.com/1137?url=https://hamait.tistory.com/1137&#34;&gt;코딩을 잘 한다는 것, 코더가 되지 말라는 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서, 이사님이랑 같이 코딩을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Tr0cUGXDVis&amp;amp;t=4s&#34;&gt;오타를 줄이면 버그도 줄어든다&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hWwJF-fU2Lg&#34;&gt;프로그래머라면 검증한다&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PuSAVazO1JM&#34;&gt;성공한 사람이 죽어도 지키는 단 한가지&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;반복해서 고치고, 고민하는 끈기가 있어야한다는 말이 인상 깊었다. 예전에 작성한 코드를 삭제하지 말고, 나중에 다시 보았을 때 고칠점이 보이면 꾸준하게 고치라는 글을 본 기억이 있다. 이와 상통하는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 다른 사람이 설명하고 있는 내용을 집중하는데 어려움을 느끼고 있다고 생각을 하였고, 조인에 대해서 완전히 이해하지 못하고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 회사에서 일을 할 때 덤벙거리면서 실수를 할 때가 있는데, 가끔 이럴 수도 있다고 생각하고 넘어가려고 했던 것 같다. 따라서 나의 이러한 자세를 반성하게 되었다. 또한 다음부터 주의해야겠다는 마음을 가지는 것보다는 일처리가 제대로 되었는지를 확인하는 프로세스를 가져야겠다고 생각을 했다. 오탈자를 살펴보는 일도, 두세번을 반복해도 찾지 못하는 경우가 있다고 했다. 따라서 처음일을 하고 나서, 바로 제출하는 것이 아니라, 시간을 두고 기다렸다가 한 번 더 확인하는 것이다. 물론 시간은 더 소모되겠지만, 나는 일단 시간을 줄이는 것보다 어떤일을 제대로 하는 연습을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그래머라면 어떤 것을 검증할 수 있어야한다는 말에 공감했다. 예를 들어서, 버그가 발생하거나, 시스템에서 어떻게 동작하는지 궁금할 때가 있는데 이를 어떻게 검증할 수 있을 지도 감이 오지 않을 때가 있다. 따라서 검증할 수 있는것이 실력이라고 생각을 하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;검증을 잘하는 프로그래머라면, 테스트 코드를 작성하지 않더라도, 좋은 코드를 만들 수 있고 오히려 검증을 잘 못하는 프로그래머라면, 테스트 코드를 작성하더라도, 별로 중요하지 않은 이상한 테스트코드를 짠다는 것이다. 나도 별로 중요하지도 않은 테스트 코드를 작성하느라 시간을 낭비하는 프로그래머가 아니라, 진짜로 검증해야하고, 좋은 테스트를 작성할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 위험을 감수하라
-&amp;gt; 열정을 따르기 위해서라면 기꺼히 위험을 감수하라.
-&amp;gt; 80세가 되었을 때 이 결정을 후회할지를 생각하면서 결정하라.
2. 빠른 결정을 내려라.
-&amp;gt; 혁신적인 비즈니스를 유지하기 위한 핵심이 &#39;높은 퀄리티의, 빠른 결정&#39;이다.
-&amp;gt; 대부분의 결정은 변경 가능하고, 되돌릴 수 있다. 따라서 결정은 신속하게 내려야 한다.
-&amp;gt; 되돌릴 수 있는 결정을 심사숙고하는데 너무 많은 시간을 소비하면 위험에 처한다.
3. 천직을 찾아라.
4. 방황의 비효율성을 수용하라.
-&amp;gt; 성공을 위해서라면 건강한 비효율성은 동반된다.
-&amp;gt; 성공은 발명, 발사, 재창조, 재도전, 다시 시작, 반복 또 반복을 통해서 온다. 성공을 향한 길은 항상 직선이 아니다.
5. 개성을 잃지마라.
-&amp;gt; 세상은 당신이 일반적인 사람이 되기를 원하지만, 그렇게 하지 마라. 개성을 유지하려면 지속적인 노력이 필요하지만, 개성을 유지하는 것은 그만한 가치가 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;1. 무엇을 원하는지, 무엇이 되고 싶은지를 결정하라.
2. 명확한 목표를 세우고, 꼭 된다는 생각 될 수 있다는 확신을 가진다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;목표를 이룰 만한 잠재력이 충분하다는 확신이 필요하다.&lt;/li&gt;
&lt;li&gt;나의 인생 목표가 반드시 이뤄질 것이라는 확신이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;조인에 대해서, 알고 있다고 생각을 했는데, 완전히 이해하고 있지 못했다. 따라서, 조인을 하면 어떻게 되는지 남에게 설명할 수 있을 정도로 이해를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확신을 강화하는 방법을 매일 아침에 실천을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 명확한 인생목표를 정확하게 글로 적고, 그것이 결국 이뤄질 것이라는 확신으로 묵상한다. 그리고 목표를 이룬 다음 하고 싶은 것을 하며 사는 자신의 모습을 상상해본다.
2. 인생 목표에 도달함으로써, 얻을 수 있는 이득에 대해서 목록을 만들어본다. 그리고 그것을 날마다 여러 번 마음에 떠올리고 새김으로써, 마음을 &#39;성공 의식&#39;으로 가득 채운다. 이것은 자기 암시와 같은 것으로 어떤 일이 닥쳐도 우리를 흔들리지 않게 해준다.
3. 부정적인 마음가짐은 신념의 능력을 파괴하므로 마음가짐에 모든 것이 달려 있음을 명심하고 마음을 장악한다. 한순간이라도 부정적으로 되지 않ㄷ록 조심하고 또 조심한다.
4. 자신의 명확한 목표에 공감하고 도움이 되는 사람들과만 교류하고, 조금이라도 부정적인 마인드가 있는 사람과는 관계를 멀리한다. 언제 어디서나 긍정의 에너지를 얻으려 애써야 한다.
5. 인생 목표의 도달을 향해 적어도 하루에 한 번 명확한 실천을 하려고 노력한다. 실천하지 않는 신념은 우리를 흔들리게 하고 그런 것이 쌓이면 결국 모든 계획을 물거품이 되게 한다는 것을 항상 명심한다.
6. 자수성가한 사람들을 골라서 자신의 모범으로 삼고 그런 사람들을 따라 잡는 것을 넘어 능가하겠다고 결심한다. 모법으로 삼을 만한 사람이 있다는 것은 우리 마음을 다잡는데 큰 도움이 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어제 자신감 있고, 당당한 사람이 되려면, 일처리를 제대로 하고 꼼꼼하게 확인하는 습관이 동반되어야한다는 것을 깨달았다. 따라서, 오늘 항상 어떤일을 할 때 꼼꼼하게 확인하는 습관을 가지기 위해서 노력을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음 맡은 일이라면 잘하기 위해서 3번정도 확인한다, 그리고 이미 해보았던 일이라도, 한 번하고 나서 끝내지 말고, 다시 한번 확인하는 습관을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 07 Jul 2021 08:34:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://corecursive.com/066-sqlite-with-richard-hipp/&#34;&gt;The Untold Story of SQLite&lt;/a&gt; 라는 글을 흥미롭게 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나중에 원문으로도 읽어보고 싶다는 마음이 들었다. 또한 재미있는 개발 팟캐스트 사이트도 찾을 수 있었다. &lt;a href=&#34;https://corecursive.com/&#34;&gt;CoRecursive&lt;/a&gt; 좋은 프로그램을 만든 개발자의 이야기를 들어볼 수 있는 팟캐스트이다. 단점으로는 모두 영어라서, 영어 실력이 좋아야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떤 것에 얽메이지 않으려면, 직접 개발을 해야한다는 이야기가 굉장히 인상 깊었다. 요즘에는 다른 개발자가 만든 라이브러리를 이요하는 경우가 굉장히 많지만, 나중에 직접 개발하지 않아서 생기는 문제가 발생한다. 나도 내가 필요한 프로그램이 존재하지 않을 때 직접 만들 수 있는 용기를 가지고, 실력을 갖출수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항상 밝고, 재미있는 사람이 되도록 노력하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 일처리를 꼼꼼하게 하는 사람이 되도록 노력하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자신감이 있고, 생각하는 사람이 되자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 06 Jul 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 체육관에 가서, 복싱을 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;배열에 있는 모든 요소의 조합을 찾는 문제를 풀었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;힘을 빼고, 주먹을 뻗었더니, 자세가 훨씬 괜찮아 졌다는 말을 들었다. 이제는 안정적으로 오랜 시간 주먹을 뻗을 수 있는 체력을 기르기 위해서 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아직 재귀에 대해서, 완전히 이해하지 못한 것 같고, 제대로 활용하지 못하는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모든 조합&lt;/strong&gt;을 찾는 일은 재귀를 이용하여 풀 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서 정수를 이진수 문자열로 반환해주는 내장 함수 &lt;code&gt;bin()&lt;/code&gt;에 대해서 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;말할 때, 발음이 뭉개져서 발음을 하는 경향이 있다. 따라서 또박또박하게 크게 말하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내일부터는 이메일 확인하기 전에, 자리에 앉아서 오늘 어떤 마인드로 생활할 것인지를 먼저 노트에 적고나서 아침 일과를 시작하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;무언가에 대해서 두려움을 느낀다면 그것을 잘 모르기 때문이다. 따라서 내가 무언가를 두려워한다면 그것을 알기 위해서 노력하고 피하지 말고 정면으로 맞서자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 긍정적인 마음을 가지고, 나는 다른 사람들이 하기 싫어하거나 꺼리는 일을 기꺼히 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;힘들거나 끝나지 않을 것 같은 일도 언젠가는 끝날 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 05 Jul 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 조금 일이 하기 힘들었지만, 그래도 도중에 무한 긍정의 힘으로 이겨낸 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서 작업을 어떻게 하면, 재미있게 할 수 있을까? 핑계일 수도 있지만, 잘 만들어진 시스템을 문서화한다면, 재미있게 할 수 있을 것 같지만, 엉망진창인 프로젝트를 문서화하려고 시도하는 것은 매우 괴로운 일인 것 같다. 깨진 유리창 이론처럼 뭔가 하나가 망가지기 시작한다면, 일에 정성이 가지 않는 것 같다. 이렇게 되지 않도록 작은 것부터 제대로 하는 습관을 가져야할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쿠버네티스에서, 인그레스를 이용하여 마이크로서비스 운영을 실습하엿다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;피곤하다고, 너무 티를 낸 것 같은데, 혼자 일하더라도 항상 긍정적인 마인드로 일을 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 항상 당당할 것이다.&lt;/li&gt;
&lt;li&gt;나는 항상 열심히 최선을 다해서 일을 할 것이다.&lt;/li&gt;
&lt;li&gt;나는 남들이 하기 싫어하는 일을 잘 해낼 자신이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (2) - 프로세스 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</link>
      <pubDate>Sun, 04 Jul 2021 01:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</guid>
      <description>&lt;h3 id=&#34;posix_spawn-계열-함수&#34;&gt;posix_spawn 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn(pid_t *restrict pid, const char *restrict path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);

int posix_spawnp(pid_t *restrict pid, const char *restrict file, cosnt posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞서 언급했듯이 &lt;code&gt;fork-exec&lt;/code&gt;는 부모 프로세스의 자원을 선택적으로 복제할 수 없으므로, 성능상의 문제와 추가적인 코딩이 복잡해지는 문제가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, &lt;code&gt;posix_spawn&lt;/code&gt; 계열에서는 부모 프로세스의 자원을 선택적으로 복제하거나, 다룰 수 있는 통합 인터페이스가 제안되었는데 이를 가능하게 하는 것이 바로 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수 부분에 &lt;code&gt;NULL&lt;/code&gt;을 지정하면, &lt;code&gt;fork-exec&lt;/code&gt;와 동일한 작동, 즉 부모 프로세스의 자원을 모두 복제한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawn&lt;/code&gt;도 기본적으로는 부모 프로세스가 열었던 파일은 모두 상속 받는다. 만약 추가로 열어야하는 파일이 있거나, 기존에 열은 파일을 닫아야 할 필요가 있는 경우에는 &lt;code&gt;file_actions&lt;/code&gt; 매개변수를 이용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawn_file_actions_t-구조체-조작&#34;&gt;posix_spawn_file_actions_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_destroy(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict file_actions, int fildes, const char *restrict path, int oflag, mode_t mode);
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes);
int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;spawn.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
	int ret_err = 0;
	pid_t pid_child;
	char buf_err[64];
	posix_spawn_file_actions_t posix_faction; /* file action struct */
	char *argv_child[] = { &amp;quot;forkexec_child&amp;quot;, NULL };
	printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());

	if((ret_err = posix_spawn_file_actions_init(&amp;amp;posix_faction)) != 0) { /* init */
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_init :%s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	if ((ret_err = posix_spawn_file_actions_addopen(&amp;amp;posix_faction, 3,
					&amp;quot;pspawn.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0664 )) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_addopen: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	ret_err = posix_spawn(&amp;amp;pid_child,
			argv_child[0],
			&amp;amp;posix_faction,
			NULL,
			argv_child,
			NULL);

	if ((ret_err = posix_spawn_file_actions_destroy(&amp;amp;posix_faction)) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_destory: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	printf(&amp;quot;Parent[%d]: Wait for child(%d)\n&amp;quot;, getpid(), (int)pid_child);
	(void)wait(NULL);
	printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;메모리를 해제하는 부분을 유의해서 보자, 예제에서는 한번 실행되고 곧바로 종료되기 때문에, 해제하지 않아도 메모리 누수를 신경 쓸 필요가 없지만, 연속적으로 실행되는 실무 프로그램에서는 민감한 문제이므로, 꼭 메모리 해제에 신경을 써야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawnattr_t-구조체-조작&#34;&gt;posix_spawnattr_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawnattr_init(posix_spawnattr_t *attr);
int posix_spawnattr_destroy(posix_spawnattr_t *attr);

int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt; 구조체는 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt;로 초기화를 한 뒤에 사용해야만 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 사용이 끝난 구조체는 &lt;code&gt;posix_spawnattr_destroy()&lt;/code&gt;로 메모리를 해제해야 누수가 발생하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 메모리를 해제한 후에, 다시 사용할 필요가 있다면, 다시 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt; 로 초기화를 한 후에 사용하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt;에는 &lt;code&gt;EUID&lt;/code&gt;, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러를 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이중에서 &lt;code&gt;EUID&lt;/code&gt; 설정을 제외한 나머지 기능들은 해당 속성의 &lt;code&gt;on/off&lt;/code&gt;를 의미하는 플래그를 설정하고 개별적으로 속성을 등록하는 함수를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (1) - 프로세스 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</link>
      <pubDate>Sat, 03 Jul 2021 11:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</guid>
      <description>&lt;h3 id=&#34;프로세스&#34;&gt;프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전통적인 프로세스를 복제하는 방법은 &lt;code&gt;fork&lt;/code&gt;를 사용하는 방법이다. 이때 복제할 프로세스를 부모 프로세스라고 하고, 새롭게 복제된 프로세스를 자식 프로세스라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스를 복제하는 이유는 멀티 태스킹을 위해서이다. 싱글 스레드에서, 3개의 태스크, &lt;code&gt;A, B, C&lt;/code&gt;를 실행하는 구조를 멀티 프로세스 구조로 바꾸면 3개의 복제된 자식 프로세스에 일임하는 형식으로 분리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복제된 프로세스는 부모 프로세스와 독립적으로 작동하기 때문에, 복수개의 CPU가 설치된 경우에는 매우 뛰어난 응답성과 성능을 보여줄 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 복제된 프로세스 사이에 데이터를 주고 받는 구조이고, 데이터 통신 처리에 비용이 크다면 오히려 성능 하락이 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 복제가 많이 쓰이는 경우로, 셸(&lt;code&gt;SHELL&lt;/code&gt;)이 있다. 셸에서 &lt;code&gt;ls&lt;/code&gt; 명령을 실행한다고 가정할 때, 셸은 명령어를 받아들인 후에, &lt;code&gt;fork&lt;/code&gt;를 하여 자식 프로세스를 만든다. 그 후에 바로 &lt;code&gt;exec&lt;/code&gt;를 호출하여 &lt;code&gt;bin/ls&lt;/code&gt; 프로그램 이미지로 교체하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;확장된-프로세스-실행-방법&#34;&gt;확장된 프로세스 실행 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 프로세스 실행 방법이 있는데, 이 방법은 기존의 &lt;code&gt;fork-exec&lt;/code&gt;를 대체할 수 있는 기능으로서 더 가볍고 빠른 실행을 위해서 제안되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 &lt;code&gt;fork-exec&lt;/code&gt; 구조에서는 &lt;code&gt;fork&lt;/code&gt;에서 부모 프로세스를 복제할 때, 모든 정적 정보를 복제한다. 예를 들어서 부모 프로세스의 힙 메모리, 정적 메모리, IPC 자원 ID, 열린 파일, 시그널 마스크 등이 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 &lt;code&gt;fork&lt;/code&gt;를 하고 나서, 곧바로 &lt;code&gt;exec&lt;/code&gt;를 호출하는 경우에는 대부분 부모 프로세스의 열린 파일이나, &lt;code&gt;IPC&lt;/code&gt; 자원을 사용하지 않는 경우가 많다. 따라서 사용하지 않는 자원을 복제하는 오버헤드가 존재한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 한두 개의 프로세스가 저런 오버헤드를 가진다고 해도 시스템에 큰 문제가 없지만, 대형 시스템에서 엄청난 수의 프로세스가 실행되거나, 실시간 처리가 중요한 서비스라면 더더욱 큰 문제가 될 수 있다. 따라서 &lt;code&gt;posix_spawn&lt;/code&gt;에서는 부모 프로세스의 자원 중 6가지(&lt;code&gt;열린 파일, 프로세스 그룹 ID, 유저 및 그룹 ID, 시그널 마스크, 스케줄링&lt;/code&gt;)의 자원을 선택적으로 복제 및 관리할 수 있도록 디자인 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fork&#34;&gt;fork()&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; 호출이 성공하면 프로세스가 복제되어 2개가 되고, 리턴값으로 정수인 &lt;code&gt;pid_t&lt;/code&gt; 타입을 리턴한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 리턴 값은 3가지의 반환 형태를 가지며 각각에 따라서 처리 방법을 다르게 코딩해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0 -&amp;gt; 자식 프로세스에게 리턴되는 값
양수 -&amp;gt; 부모 프로세스에게 리턴되며, 자식 프로세스의 PID를 의미한다.
-1 -&amp;gt; 에러, 복제 실패
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 다음과 같이 0인 경우에는, 자식 프로세스가 실행할 부분을 코딩하고 양수인 부분은 부모 프로세스가 실행할 부분으로 코딩한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 &lt;code&gt;fork()&lt;/code&gt;를 사용하면 하나의 소스코드에 부모와 자식 프로세스의 코드가 같이 들어가게 된다. 그리고 부모 프로세스에는 자식 프로세스의 종료를 기다리기 위해서 &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;waitpid&lt;/code&gt;를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;switch (ret = fork()) {
  case 0:
    do_child(); /* 자식 프로세스인 경우에 실행될 코드 */
    break;
  case -1: /* 에러가 난 경우 */
    do_errorcatc();
    break;
  default: /* 양수는 부모 프로세스이며 ret에 자식 프로세스의 PID가 저장됨 */
    do_parent();
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 위와 같이 부모 프로세스가 실행할 부분과, 자식 프로세스가 실행할 부분을 나누어서 코딩할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의할 점은 &lt;code&gt;fork()&lt;/code&gt; 를통해서 자식 프로세스가 분기하는 구조를 제대로 만들지 않으면 이상한 현상이 발생할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int main() {
  int i = 0;
  pid_t ret;

  for (i = 0; i &amp;lt; 3; i++) {
    ret = fork();
    printf(&amp;quot;[%d] PID(%d) PPID(%d)\n&amp;quot;, i, getpid(), getppid());
#ifndef OMIT_SWITCH
    switch (ret) {
      case 0:
        pause();
        return 0;
      case -1:
        break;
      default:
        break;
    }
#endif
  }
  wait(NULL);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 코드를 보면, 전처리기 분기문 처리가 되어있어, &lt;code&gt;OMIT_SWITCH&lt;/code&gt; 매크로가 정의되어 있지 않는다면, 같이 빌드되는 부분이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DOMIT_SWITCH _Wall -o fork_omit_swich fork_process.c 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위와 같이 매크로를 같이 빌드하면, 전처리기 분기문 처리가 빌드되지 않는다. 그리고 나서 프로그램을 실행하면 다음과 같은 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/124343414-2d213e80-dc06-11eb-93b1-7e6ba63954b7.png&#34; alt=&#34;result&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;총 7개의 프로세스가 실행되는 것을 확인할 수 있는데, 부모 프로세스에서 총 3개의 자식 프로세스를 생성하고, 또한 그 자식 프로세스들이 자식 프로세스를 생성하는 구조로 이루어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;exec3-계열-함수&#34;&gt;exec(3) 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열 함수는 현재 실행중인 프로세스의 이미지를 새로운 프로세스 이미지로 대체한다. 즉 쉽게 이야기하면 현재 프로세스에 실행중인 프로그램 파일을 로딩한다는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 이미지가 대체되면 프로세스의 실행코드는 교체되지만, 기본적인 &lt;code&gt;PID&lt;/code&gt;, &lt;code&gt;PPID&lt;/code&gt;, 파일 기술자등 프로세스의 정보는 유지된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열의 첫 번째 인수는 실행되어야 하는 프로그램 파일로서절대 경로나 상대 경로를 사용할 수 있다. 만일 경로가 생략되고 파일 명만 넣으면 &lt;code&gt;execl, execle, execv, execve&lt;/code&gt;는 현재 작업 디렉터리에서 실행되어야 하는 프로그램 파일을 찾고, &lt;code&gt;execlp, exevcp&lt;/code&gt;는 환경 변수에 등록된 디렉터리를 검색하여 실행되어야 하는 프로그램 파일을 찾는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;execl&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;arg&lt;/code&gt; 라는 이름을 쓰고, &lt;code&gt;execv&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;argv&lt;/code&gt;를 사용하는 것을 알 수 있다. 이들의 차이는 execl&lt;code&gt;계열은 실행할 파일의 인수 목록을 리스트로 받기 때문에 가변 인수 리스트를 가진다. 따라서 인수 리스트의 마지막을 알아내기 위해서 맨 끝은&lt;/code&gt;NULL`로 끝내야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;execl 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
execlp(&amp;quot;ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;execv 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execv(&amp;quot;/bin/ls&amp;quot;, argv_exec);

char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execvp(&amp;quot;ls&amp;quot;, argv_exec);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;이 경우에는 기존의 환경변수는 모두 초기화되고 새로 넣은 환경 변수 벡터가 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
  if (execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL) == -1) {
    perror(&amp;quot;excel&amp;quot;);
  }
  printf(&amp;quot;+ arfter execl\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 예제는 작동에는 문제가 없지만, 설계상의 의문이 있는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;왜냐하면, &lt;code&gt;execl&lt;/code&gt; 실행되면서 &lt;code&gt;ls&lt;/code&gt;로 프로세스 이미지를 교체하기 때문에 이후 &lt;code&gt;+ after execl&lt;/code&gt; 메시지는 화면에 출력될 일이 없기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상속되지-않는-파일-기술자&#34;&gt;상속되지 않는 파일 기술자&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로는 &lt;code&gt;exec&lt;/code&gt;는 부모 프로세스의 파일 기술자를 복제한다.&lt;/li&gt;
&lt;li&gt;하지만, 부모 프로세스가 &lt;code&gt;fork&lt;/code&gt;를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플레그를 지정하면 &lt;code&gt;exec&lt;/code&gt;가 실행될 때 해당 파일 기술자는 닫히게 된다. 이를 &lt;code&gt;close-on-exec&lt;/code&gt;라고 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;forkexec_parent.c&lt;/em&gt;*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
  pid_t pid_child;
  printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());
  int fd = open(&amp;quot;forkexec.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0644);

  if (fd == -1) {
    perror(&amp;quot;FAIL: open&amp;quot;);
    exit(EXIT_FAILURE);
  }

  dprintf(fd, &amp;quot;Parent[%d]: Open log file(fd=%d)\n&amp;quot;, getpid(), fd);

#ifdef APPLY_FD_CLOEXEC
  int ret_fcntl;
  if ((ret_fcntl = fcntl(fd, F_SETFD, FD_CLOEXEC)) == -1) {
    perror(&amp;quot;FAIL: fcntl(F_SETFD, FD_CLOEXEC)&amp;quot;);
    exit(EXIT_FAILURE);
  }
#endif

  /* fork-exec code */
  char *argv_exec[] = {&amp;quot;fork_exec_child&amp;quot;, (char*) NULL};

  switch ((pid_child = fork())) {
    case 0: /* child process */
      execv(argv_exec[0], argv_exec);
      break;
    case -1: /* error */
      perror(&amp;quot;FAIL: FORK&amp;quot;);
      break;
    default: /* parent process */
      wait(NULL);
      break;
  }
  printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;forkexec_child.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Start\n&amp;quot;, getpid());
  dprintf(3, &amp;quot;Child[%d]: fd(3): Test fd.\n&amp;quot;, getpid());
  close(3);
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음은 부모 프로세스에서, 파일을 생성하고 기록하고 있다. 그리고 나서, 자식 프로세스에서 파일 디스크립터를 받고 종료하는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;생성된 파일을 살펴보면 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Parent[5935]: Open log file(fd=3)
Child[5936]: fd(3): Test fd.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;하지만, 부모 프로세스를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그를 지정하면, 해당 파일 기술자는 닫히게 된다. 따라서 이를 위해서 &lt;code&gt;APPLY_FD_CLOEXEC&lt;/code&gt; 매크로를 정의하고 빌드를 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DAPPLY_FD_CLOEXEC -o forkexec_parent_fdcloexec forkexec_parent.c
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Parent[6014]: Open log file(fd=3)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매크로를 정의하고 나서는, 부모 프로세스가 자식 프로세스에게 파일 기술자를 상속하지 않으므로, &lt;code&gt;forkexec.log&lt;/code&gt; 파일에 자식 프로세스에는 기록되지 않았음을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론적으로는 &lt;code&gt;fork-exec&lt;/code&gt;를 이용할 때, 자식 프로세스가 사용하지 않는 파일이 복제되는 오버헤드를 피하고 싶다면 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그 사용을 고려하는 것이 좋다. 하지만 더 근본적인 방법으로는 &lt;code&gt;fork-exec&lt;/code&gt; 대신에 &lt;code&gt;posix_spawn&lt;/code&gt;을 사용하는 것이 더 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;system-함수&#34;&gt;system 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system&lt;/code&gt; 함수는 셸을 실행시켜서 명령어를 실행하는 기능으로서, &lt;code&gt;fork-exec&lt;/code&gt;를 간단하게 구현한 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 중요한 차이가 있는데, &lt;code&gt;system&lt;/code&gt;은 실행 명령어가 작동되는 동안에 부모 프로세스가 잠시 정지되고, 자식 프로세스의 정지, 종료 상태를 통보해주는 &lt;code&gt;SIGCHILD&lt;/code&gt;도 블록되고 종료 시그널인 &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGQUIT&lt;/code&gt; 시ㅋ그널도 무시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 중요 시그널이 블록킹 되어, 종종 부모 프로세스가 무한 대기 상태에 빠지는 경우가 발생할 수 있으므로, 정말로 간단한 경우가 아니라면 &lt;code&gt;fork-exec&lt;/code&gt;로 구현하는 것을 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (0) - 서문</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</link>
      <pubDate>Sat, 03 Jul 2021 11:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</guid>
      <description>&lt;h3 id=&#34;서문&#34;&gt;서문&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;책의 서문에서는 코딩이란 예술의 경지이기 때문에 반복해서 사용함으로써 익숙해지고, 좋은 경험을 토대로 새로운 것을 깨닫게 해준다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 수 많은 이론을 머리에 채워넣었다고 하더라도, 절대적으로 코딩을 해본 경험이 적다면, 반쪽 짜리 프로그래머가 될 수 밖에 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이론만 배우고 끝나는 것이 아니라, 실제로 코딩을 하면서 손에 익을 때까지 코딩을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;리눅스의-표준-및-역사&#34;&gt;리눅스의 표준 및 역사&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리눅스가 표준 안을 가지기 전까지, 많은 파생된 버전이 있었다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에일리어싱과-restric-포인터&#34;&gt;에일리어싱과 RESTRIC 포인터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 어떤 한 공간에 대해 복수개의 접근 경로가 있는 경우를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 C언어에서, 중요한 역할을 담당하고 있으며, 가독성 향상이나, 형변환을 위해서 사용되지만 때때로, 최적화를 방해하거나, 문제를 일으킬 소지가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몇몇 함수들은 인수로 받아들이는 주소가 에일리어싱 되었을 때 오류를 방지하기 위해 미리 검사하는 행위 때문에 성능 저하가 발생하기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 함수 인수가 다른 곳에서 참조하지 않음을 보장해준다면 내부적으로 병렬처리를 하거나, 에일리어싱에 대한 검사를 하지 않아도 되므로 상당히 효율적으로 함수를 설계할 수 있고 이를 위해서 &lt;code&gt;restrict&lt;/code&gt; 포인터가 도입되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;restrict&lt;/code&gt; 포인터는 &lt;code&gt;restrict&lt;/code&gt; 포인터가 가리키는 객체를 다른 공간에서 에일리어싱 하지 않도록 강제를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void *memcpy(void *dest, const void *src, size_t n);
void *memcpy(void *restrict s1, const void *restrict s2, size_t n);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서, 상위에 있는 &lt;code&gt;memcpy&lt;/code&gt; 함수는 과거에 사용되던 함수의 원형이고, 아래쪽 &lt;code&gt;memcpy&lt;/code&gt;는 C99 이후에, 적용되는 함수의 원형이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새롭게 적용된 &lt;code&gt;memcpy&lt;/code&gt; 에서는 사용자가 &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;의 접근이 비순차, 비동기적으로 진행되거나 병렬처리 될 수도 있음을 암시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int *p_num, *p_alias;
p_num = (int *) malloc(sizeof(int) * 100);
p_alias = p_num + 20; /* 에일리어싱 되었음 */
memcpy(p_num, p_alias, sizeof(int) * 50);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서 &lt;code&gt;p_num&lt;/code&gt;, &lt;code&gt;p_alias&lt;/code&gt;는 에일리어싱 되었으므로, &lt;code&gt;restict&lt;/code&gt; 포인터 룰을 위반한 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 사이드 이펙트의 발생 가능성이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 02 Jul 2021 23:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 아침에는 깜빡하고, 아침마다 자기 선언하는 것을 하지 못했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;확실히 일을 하기 전에, 자기 선언을 하면서 오늘 어떻게 살아야겠다고 마음을 다잡고 일을 할 때랑 그냥 바로 업무를 시작할 때랑 집중도에 차이가 있는 것 같았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;요즘에 시간이 날때 마다, 자기 암시를 하고 있는데, 효과가 있는 것 같다. 책임감 있고, 자신감 있는 사람이 되자고 했는데, 실제로 맡은 일에 책임감을 가지고 일하게 된 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트 문제를 이번 한주도 한번도 빼먹지 않고, 계속해서 스터디에 참여하였다. 물론 바뻐서, 조금만 고민한 후에, 해답을 보면서 코딩한 것도 있지만, 일단은 알고리즘 문제에 재미를 느끼고, 생각하는 습관을 기르는 것에 의미를 두자&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;엄청나게 많아 보이고, 이것을 언제 다할까라는 생각했던 일도, 멀리 보지 않고 그냥 하나씩 처리하다보면 끝이보인다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 서두르지 말고, 모든 것이 결국에는 다 잘될것이라는 생각을 가지고, 일이나 공부를 해야겠다. 길게 보는 것이 중요하기는 하지만 때로는 바로 앞만 보면서 최선을 다하는 것도 좋은 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주말에 공부할 계획을 세울 때, 너무 여러가지 목표를 잡는 경우가 있다. 하지만 많은 것을 하려고 욕심을 부리게 되니, 무리를 하거나 이해되지 않았음에도 불구하고, 대충 넘어가려고 할 때도 많다. 따라서 이제부터는 일단 하나의 일만 계획하고 그것을 하지 않을 때는 그냥 쉬다가, 계속 하나의 계획한 일만 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에 도착하면, 이메일이랑, 블로그를 확인하는 것처럼, 자기 암시와 하루를 시작하기 전에 어떤 점을 주의할 지 그리고 어떻게 살아야할지 미리 선언하는 것을 루틴으로 만들어야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내일은 스터디 카페에가서, 리눅스 시스템 프로그래밍을 공부할 것이다. 책도 리눅스 시스템 네트워크 프로그래밍이라는 책 하나만 가져갈 계획이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 항상 최선을 다할 것이다.&lt;/li&gt;
&lt;li&gt;나는 책임감을 가지고, 다른 사람들에게 자신감 있는 모습으로 보일 것이다.&lt;/li&gt;
&lt;li&gt;어려운 일도 곧잘 해낼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/07/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 01 Jul 2021 08:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=R6-sw81dBXU&#34;&gt;뭘 하든 하루의 20~40%는 사라집니다 (2부)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=1zBpozANCR0&#34;&gt;..누구든 1000% 바꿀 뇌 개조법.. (공유 금지)&lt;/a&gt;
영상을 출근길에 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=lnyeY5yz8Bg&#34;&gt;성공한 사람들이 말하는 공통된 점&lt;/a&gt; 이라는 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.opsnow.com/66&#34;&gt;배치 개선 기록 1&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.opsnow.com/67&#34;&gt;배치 개선 기록 2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 기술 블로그를 읽으면서 업무를 어떻게 처리하는지 알 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://meetup.toast.com/posts/286&#34;&gt;Github Actions으로 배포 자동화하기&lt;/a&gt;를 읽으면서 현재 기술 블로그부터 깃허브 액션을 설정함으로써 배포를 자동화하는 프로세스를 만들어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;평소에 집중하는 훈련을 해야겠다고 생각했다. 일을 하다가, 머리가 복잡해져서 쉬고 싶을 때는, 핸드폰을 보는 것이 아니라, 내 호흡을 알아차리거나 정말로 아무것도 하지 않는 것이 휴식하는데 도움이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 유튜버가 성공하는 사람들이 하는 이야기를 들었는데 공통점은 어떤 목표를 정하고 이를 계속 적고, 말하고 생각하고, 실제 이룬 것처럼 상상한다는 것이다. 나도 비슷한 영상을 시청하였고, 오늘도 역시 시청하였다. 따라서 나도 목표를 정하고, 직접 글로 적고 실제로 이룬것 같은 상상을 매일 아침에 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내가 되고 싶거나, 이루고 싶은 것이 있지만, 잠깐 떠오른 생각뿐이지 이를 직접적으로 이루려고, 매일 떠올리거나, 노력을 한 적은 별로 없는 것 같다. 따라서 이제부터는 나의 진짜 목표가 무엇인지 어떤 사람이 되고 싶은지를 생각하면서 상상할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스를 개선하는 업무가 주어졌을 때 설계 및 작업 순서를 이렇게 수행하고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 상황 파악
2. 업무 프로세스 분석 -&amp;gt; 흐름도를 그려가면서, 이해가 되지 않는 것은 정리하고 흐름도를 
그렸을 때 작업이 중복되거나 꼭 필요한 것인지 의문이 드는 것들을 정리한다.
3. 인터뷰 -&amp;gt; 업무를 잘 알고 있는 시니어 개발자분께 인터뷰 일정을 잡고, 꼭 필요한 것인지, 왜 여기서 해야하는지? 그리고 과거에는 필요했지만 현재에는 필요하지 않은 부분을 질문한다.
4. 작업 프로세스 개선 -&amp;gt; 실제로 개선을 다양한 방법으로 진행하고, 전후를 비교하면서 어떤 부분이 개선 되었는지, 그리고 오류는 없는지를 체크한다.
5. 마지막으로 어려웠던 점들을 정리한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;충동적으로 어떤 생각이 떠올라서, 하는 행동들이 있는데, 이러한 행동을 줄이고 만약 생각이 났다고 하더라도 참는 법을 배워야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나는 한가지 일에 집중할 것이고, 집중하기 위해서 방해되는 것들은, 의도적으로 차단한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나는 끈기를 가지고, 포기를 하지 않을 것이다. 때로는 힘들면 쉬겠지만, 나는 반드시 해낼 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 30 Jun 2021 08:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;재귀에 대해서 학습하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 업무를 할 때 어떻게 하면 하나에 집중하여 일을 할 수 있을까에 대해서 고민을 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;역시 재귀는 코드나 설명을 들었을 때는 쉽게 이해를 할 수 있지만, 직접 설계를 할 때 어려운 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 재귀적인 코드를 보는 것은 매우 재미있고, 쉽게 작성할 수 있다는 것을 깨달을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자주 보는 창들의 위치를 고정을 해놓으면 화면을 이동하는데 드는 비용을 줄일 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사내 메신저로 슬랙을 사용하는데, 알림이 올때마다 확인을 하면 집중이 깨지는 것 같다. 따라서 미안하기는 하지만 슬랙 메시지를 시간을 정해놓고 일정 주기에 따라서 확인을 하는 것이 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;재귀적인 코드를 직접 작성해보고 어떻게 설계하는지 대략적으로 살펴볼 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 복싱장에서, 너무 힘이 들어가 있다는 말을 들었다. 잽을 날릴 때 최대한 힘을 들이지 않도록 노력하고 제자리에서 뛸때고, 최대한 힘을 빼고 뛰도록 의식적으로 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;잽잽을 날릴 때, 손이 완전히 펴지지 않은 상태에서 또다시 잽을 날린다는 피드백을 받았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아직도 한번에 여러가지 일과 금방 집중이 딴데로 새서, 어떤 일을 하다가 어느순간 다른 일을 하게 될 때가 있다. 이러한 점을 주의하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스마트폰을 최대한 멀리하고, 주의를 뺏기지 않도록 방해하는 요소들을 제거한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지의 일을 동시에 조금씩 하지말고, 한번에 하나의 일을 집중해서 처리하는 연습을 하자&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 본격적으로 시작하기 전에, 마음을 가다듬고, 집중력을 가지자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기왕하는 일 즐겁게하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;밀도 있는 집중력이 중요한 것 같다. 따라서 집중력이 흐트러졌다고 생각하고, 쉽게 돌아오지 않는다면 쉬면서 명상을 하는 것도 좋은 방법이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 29 Jun 2021 21:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사 업무를 할 때, 집중할 수 없었다. 하나의 일을 처리하다가 다른 업무가 계속 생겼기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떻게 하면, 멀티태스킹이 아니라, 하나의 일에만 집중해서 할 수 있을지를 생각해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무 뿐만 아니라, 일상 생활에서 어떤 작업을 하고 있을 때 갑자기 어떤 생각이 떠오르곤 한다. 이럴때 그 생각에 따라서 바로 행동하곤 하는데, 이러한 것들을 주의해야겠다. 어떤 일을 하고 있으면 특별한 이유가 없는한, 그 일을 끝마치고 다른 일을 하도록 하는 습관을 들여야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서 &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;deque&lt;/code&gt;는 내부적으로 구현이 다르다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리스트는 연속적인 메모리 블록을 할당하여 공간을 하나씩 채워가는 형태이고, &lt;code&gt;deque&lt;/code&gt;는 이중 연결 리스트로 데이터 연결을 지원한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 리스트에서는 요소에 바로 접근이 가능하지만, 데큐는 연결리스트 구조이기 때문에, 앞에서부터 접근한다 따라서 조금 느리다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리스트는 할당한 공간이 채워지면 확장하는 작업이 필요하지만, 데큐는 계속 데이터를 추가할 수 있다. 따라서, 이러한 자료구조의 특징을 잘 이해하고 사용하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재귀에 대해서 배웠고, 재귀 알고리즘이 정상적인 수행 및 완료되기 위해서 아래의 3가지 조건을 만족해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 베이스(BASE) 케이스가 반드시 정의되어야 한다.
베이스 케이스는 재귀 호출을 마무리 할 수 있는 조건이다.
앞서 살펴본 예제의 베이스 케이스는 배열 요소 개수가 1인 경우로, 재귀 호출을 하지 않고 마무리 한다.
2. 지속적으로 재귀 인자가 변경되어야 하고 변경되는 인자는 베이스 케이스로 수렴해야한다. 재귀 호출에 전달되는 인자는 맨 앞 요소가 빠진 상태로 전달되고 이를 통해서 배열의 요소의 개수가 베이스 케이스로 다가가는 모양새가 된다.
3. 재귀 알고리즘이은 자기 자신을 호출하는 과정이 필요하다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;재귀를 통해서, 모든 부분 집합을 찾는 방법에 대해서 배우게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 사용하고 있는, 언어의 자료구조의 특성을 이해하고 코딩을 할 필요가 있다. 리스트와 데큐의 내부 구현이 다르다는 것을 최근에 알게 된 것을 반성하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포기하지 말고, 당장은 막막해 보여도 조금씩 처리하다보면은 언젠가 일은 끝난다는 것을 명심하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공부나, 목표했던 것도 쉽게 포기하지말고, 때로는 바로 앞만 보자. 그냥 하루하루 열심히 하다보면은 내가 원하는 곳에 도달할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 28 Jun 2021 21:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스에 대해서 학습을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 업무를 진행할 때, 문제를 해결할 수 있는 다양한 옵션을 생각해보고, 하나씩 적용해보니까 문제를 쉽게 해결할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://youtube.com/watch?v=DVcljdUvQQk&amp;amp;feature=share&#34;&gt;이것만 멈춰도 모든 성과가 즉시 2배 올라갑니다..&lt;/a&gt; 라는 영상을 퇴근길에 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩테스트 문제를 풀때, 다양한 해결법을 생각해보려고 노력한 것이 많은 도움이 된 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무를 할때나, 어떤 공부를 할 때 집중을 하지 못하고 여러가지 일을 할 때가 있다. 뭔가를 동시에 하고 싶은 충동이 들더라도, 하나씩 처리하는 연습을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파드, 서비스, 리플리카, 디폴로이먼트 &lt;code&gt;YAML&lt;/code&gt; 파일을 이용하여 설정하고 실습을 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리플리카셋과, 디플로이를 이용하여, 원하는 개수만큼 파드를 설정하는 것이 재미있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아침에 일어났을 떄, 휴대폰을 1시간동안 보지 않는것만으로도 성공하는 것이라도 했다. 나도 취침 한시간 전이나, 아침에 일어나서 핸드폰을 보는 것보다는 오늘 무엇을 할지, 무엇을 하지 말아야할지에 대해서 생각을 해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요즘에, 토이 프로젝트에 소흘해진 것 같은데 정신을 차리고 이어서 토이프로젝트를 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주말에 시간을 아깝게 사용하는 것 같다. 따라서, 미루는 습관을 없애기 위해서 무조건 일어나자 마자 씻고 집을 나가도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;투두 리스트도 중요하지만, 오늘 무엇을 하지 말지 정하는 것도 중요하다. 해야하지 말아야할 행동들을 정리하고 이를 지키도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>C 포인터 이해와 활용 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/26/c-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%9D%B4%ED%95%B4%EC%99%80-%ED%99%9C%EC%9A%A9-2.html</link>
      <pubDate>Sat, 26 Jun 2021 23:27:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/26/c-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%9D%B4%ED%95%B4%EC%99%80-%ED%99%9C%EC%9A%A9-2.html</guid>
      <description>&lt;h2 id=&#34;chap-02-동적-메모리-관리&#34;&gt;CHAP 02. 동적 메모리 관리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터에서 강력한 기능의 대부분은 동적으로 할당된 메모리를 추적할 수 있는 포인터의 능력에서 기인한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 프로그램은 런타임 시스템안에서 실행된다. 런타임 시스템은 일반적으로 운영체제에서 제공되는 환경이며, 많은 프로그램 기능들과 함께, 스택과 힙을 지원한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동적-메모리-할당&#34;&gt;동적 메모리 할당&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc&lt;/code&gt; 류의 함수로 메모리를 할당한다.&lt;/li&gt;
&lt;li&gt;애플리케이션에서 할당된 메모리를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free&lt;/code&gt; 함수를 이용해 할당된 메모리를 해제한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 단계는 매우 일반적인 동적 메모리 할당 순서이다. 다음 예제에선 &lt;code&gt;malloc&lt;/code&gt; 함수를 사용하여 정수를 저장할 메모리를 할당한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *pi = (int*)malloc(sizeof(int));
*pi = 5;
printf(&amp;quot;*pi: %d\n&amp;quot;, *pi);
free(pi);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt; 함수의 유일한 인자에는 할당할 바이트 수를 저장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리 할당에 성공하면 이 함수는 힙으로부터 할당된 메모리에 대한 포인터를 반환하고, 실패하면 널 포인터를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;할당할 바이트 수를 지정할 때, &lt;code&gt;sizeof&lt;/code&gt; 연산자를 사용하면 애플리케이션의 이식성을 높일 수 있고, 시스템에 할당할 정확한 바이트 수를 결정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리가 해제 되는 즉시 해당 메모리에 다시 접근해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해제된 메모리에 대한 접근은 뜻하지 않게 발생하는데 일반적으로 해제된 포인터에는 항상 &lt;code&gt;NULL&lt;/code&gt;을 할당하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리가 할당되면 추가적인 정보가 힙 관리자에 의해 관리되는 데이터 구조의 일부로 저장된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메모리-누수&#34;&gt;메모리 누수&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메모리 누수는 할당된 메모리가 더는 사용되지 않지만, 해제되지 않을 때 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리의 주소를 잃어버리는 경우와 &lt;code&gt;free&lt;/code&gt; 함수가 호출되어야 하는 상황에 호출되지 않을 경우 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리 누수의 문제점은 해당 메모리가 반환되지 않고, 다시 사용될 수 없다는 것이다. 그 결과로 힙 관리자가 사용할 수 있는 메모리의 양이 감소하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;char *chunk;

while (1) {
  chunk = (char*)malloc(10000000);
  printf(&amp;quot;Allocating\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;만약 메모리를 반복적으로 사용하고 누수가 발생하면, 추가적인 메모리가 필요할 때, &lt;code&gt;malloc&lt;/code&gt; 함수가 OOM(Out of Memory) 오류로 인해서 추가 메모리를 할당할 수 없어 프로그램이 종료된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메모리-주소-손실&#34;&gt;메모리 주소 손실&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;int *pi = (int*) malloc(sizeof(int));

*pi = 5;

pi = (int*) malloc(sizeof(int));
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pi&lt;/code&gt; 포인터는 해제되지 않고 새로운 메모리 주소로 재할당 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;char *name = (char*) malloc(strlen(&amp;quot;Susan&amp;quot;) + 1);
strcpy(name, &amp;quot;Susan&amp;quot;);

while (*name != 0) {
  printf(&amp;quot;c&amp;quot;, *name);
  name++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 예제는 &lt;code&gt;name&lt;/code&gt; 변수의 루프를 하나씩 증가시키고 마지막에 NULL을 가리키고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;할당된 메모리의 시작 주소를 잃어버린 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;malloc&lt;/td&gt;
&lt;td&gt;힙에서 메모리 할당&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;realloc&lt;/td&gt;
&lt;td&gt;기존 할당된 메모리의 크기 변경&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;calloc&lt;/td&gt;
&lt;td&gt;힙에서 메모리 할당 그리고 0으로 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;free&lt;/td&gt;
&lt;td&gt;할당된 메모리를 힙으로 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;정적-포인터-및-전역-포인터에-malloc-사용하기&#34;&gt;정적 포인터 및 전역 포인터에 &lt;code&gt;malloc&lt;/code&gt; 사용하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정적 변수나 전역 변수는 선언시 초기화를 위해 함수 호출을 사용할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래 코드는 정적 변수를 선언하고, &lt;code&gt;malloc&lt;/code&gt; 함수를 사용하여 초기화를 시도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;static int *pi = (int*)malloc(sizeof(int));
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;따라서 위의 코드는 컴파일 시에 오류가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;static int *pi;
pi = malloc(sizeof(int));
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 선언과 초기화를 분리함으로써, 오류를 피할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컴파일러 관점에서 초기화 연산자 (=)의 사용과 할당 연산자의 사용은 차이가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;힙-메모리와-시스템-메모리&#34;&gt;힙 메모리와 시스템 메모리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;힙은 일반적으로 운영체제의 기능을 이용해 메모리를 관리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;힙의 크기는 프로그램이 실행될 때 고정된 크기로 정해지거나, 실행 도중에 크기를 늘리도록 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, &lt;code&gt;free&lt;/code&gt; 함수가 호출되었다고 해도, 힙 관리자가 반드시 해제된 메모리를 운영체제로 반환하는 것은 아니고, 애플리케이션에서 해당 메모리를 다시 사용할 수 있게 할 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 프로그램이 메모리를 할당한 후에, 다시 해제한다고 해도 일반적으로 운영체제 측면에서는 해제된 메모리가 애플리케이션의 메모리 사용량에 반영되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;댕글링-포인터-다루기&#34;&gt;댕글링 포인터 다루기&lt;/h3&gt;
&lt;p&gt;포인터가 원인인 문제들의 디버깅은 때로 해결하기 어려울 때가 있다. 댕글링 포인터 문제를 처리하기 위한 몇 가지 접근 방법이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;메모리 해제 후 포인터를 NULL로 설정하라. NULL로 설정한 포인터를 그 이후에 사용하면, 애플리케이션이 종료될 것이다. 그러나 해당 포인터에 대한 다수의 복사본이 존재할 경우에는 문제는 여전히 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;free&lt;/code&gt; 함수를 대체할 새로운 함수를 작성하라.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몇몇 런타임 시스템이나 디버깅 시스템은 해제된 메모리를 특별한 값으로 덮어쓴다. 예외가 발생하지 않은 상황이라도, 프로그래머는 예상치 못한 곳에 이러한 값이 포함된 것을 보고 프로그램이 해제된 메모리에 접근한 것을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;댕글링 포인터와 다른 문제들을 발견하기 위한 서드 파티 도구들을 활용하라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;동적-메모리-할당-기술&#34;&gt;동적 메모리 할당 기술&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;힙 관리자의 메모리 할당과 해제의 구현은 컴파일러마다 다를 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 힙 관리자들은 메모리를 할당하기 위해서, 힙 또는 데이터 세그먼트를 사용하며, 이 방식은 메모리 단편화나 프로그램 스택과 충돌이 일어나기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=33784887&#34;&gt;C 포인터의 이해와 활용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C 포인터 이해와 활용 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/26/c-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%9D%B4%ED%95%B4%EC%99%80-%ED%99%9C%EC%9A%A9-1.html</link>
      <pubDate>Sat, 26 Jun 2021 13:27:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/26/c-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%9D%B4%ED%95%B4%EC%99%80-%ED%99%9C%EC%9A%A9-1.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123501837-a78c1480-d682-11eb-892e-eb7378e1ef67.jpg&#34; alt=&#34;8994506799_1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포인터에 대해서 복습하고 모르던 내용을 다시 되집어 보기 위해서 다음 책을 읽고 정리한 내용이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시작하기&#34;&gt;시작하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터를 얼마나 확실하게 이해하고 효율적으로 사용하는 가로 초보와 전문 C 프로그래머를 구분할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사실 포인터의 기본적인 개념은 매우 간닪다. 포인터는 메모리 위치의 주소를 저장하는 변수일 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;포인터와-메모리&#34;&gt;포인터와 메모리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;컴파일된 C 프로그램은 다음 세가지 종류의 메모리를 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정적(Static) / 전역(Global)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정적으로 선언된 변수들은 정적/전역 메모리에 할당된다. 또한 전역 변수들 또한 같은 메모리 공간에 할당된다.
정적/전역 변수들은 프로그램이 시작될 때 할다오디며, 프로그램이 종료될 때까지 메모리 공간에 남아 있다. 모든 함수에서 접근할 수 있는 전역 변수와는 달리 &lt;strong&gt;정적 변수의 접근 범위는 해당 변수를 선언한 함수로 제한된다&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자동 (Automatic) / 로컬 (Local)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자동 변수는 함수 안에서 선언되고 함수가 호출될 때 생성된다. 자동 변수의 접근 범위는 선언된 함수로 제한되며, 함수가 호출되는 동안에만 존재한다. 일반적으로 블록문 안에서 선언된 변수의 범위는 해당 블록으로 제한한다. 이들은 종종 자동 변수라고 언급된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동적 (Dynamic)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;동적 (Dynamic) 메모리는 힙(Heap) 메모리 영역에 할당되고 필요한 경우에 해제된다. 포인터를 사용하여 할당된 메모리 영역을 참조하며, 포인터에 의해 접근이 제한 된다. 메모리를 해제하지 않는 한 메모리레 존재한다.&lt;/p&gt;
&lt;h4 id=&#34;포인터를-잘-알아야하는-이유&#34;&gt;포인터를 잘 알아야하는 이유&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;빠르고 효율적인 코드 작성&lt;/li&gt;
&lt;li&gt;다양한 문제에 대한 효과적인 해결 방법 제공&lt;/li&gt;
&lt;li&gt;동적 메모리 할당 지원&lt;/li&gt;
&lt;li&gt;작고 간결한 표현의 사용&lt;/li&gt;
&lt;li&gt;큰 오버헤드 없이 데이터 구조를 포인터로 전달&lt;/li&gt;
&lt;li&gt;함수의 매개 변수로 전달된 데이터 보호&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;포인터를 잘 사용하면 강력한 도구이지만, 포인터를 이용할 때는 다음과 같은 다양한 문제가 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열이나 데이터 구조의 경계를 넘는 접근&lt;/li&gt;
&lt;li&gt;소멸한 자동/로컬 변수의 참조&lt;/li&gt;
&lt;li&gt;할당 해제된 힙 메모리의 참조&lt;/li&gt;
&lt;li&gt;아직 할당되지 않은 포인터에 대한 역참조&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;포인터-선언하기&#34;&gt;포인터 선언하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;포인터 변수는 데이터 타입과 별표 그리고 변수 이름을 순서대로 나열하여 선언한다. 아래 예제 에서는 정수 변수와 정수 포인터 변수를 선언하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int num;
int *pi;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;주소-연산자&#34;&gt;주소 연산자&lt;/h4&gt;
&lt;p&gt;주소 연산자(&amp;amp;)는 변수의 주소를 반환하다. 아래와 같이 주소 연산자를 사용하여 &lt;code&gt;pi&lt;/code&gt; 포인터를 &lt;code&gt;num&lt;/code&gt; 변수의 주소로 초기화 할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;num = 0
pi = &amp;amp;num;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;가상-메모리와-포인터&#34;&gt;가상 메모리와 포인터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주소 출력을 좀 더 복잡하게 하기 위해서 가상 운영체제에서 표시되는 포인터의 주소가 실제 물리 메모리 주소가 될 가능성은 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 운영체제는 프로그램이 머신의 물리 주소 공간을 나눠 사용할 수 있게 하며, 프로그램은 페이지/프레임 단위로 물리 주소 공간을 나눠 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션의 페이지는 잠재적으로 연속적이지 않은 메모리 공간에 할당되거나 동시에 메모리상에 존재 하지 않을 수 도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영체제는 페이지에 의해 메모리를 유지할 필요가 있을 때 보조 기억장치에 기록하고 필요한 시점에 다시 읽어들이며 이전과는 다른 메모리 공간에 할당된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영체제에서 실행되는 각각의 프로그램들은 머신의 전체 물리 메모리 공간에 접근할 수 있다고 가정되지만, 실제로는 그렇지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각의 프로그램에서 사용하는 주소는 실제 물리 메모리 주소와는 다른 가상 주소이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영체제는 필요한 시점에 이 가상 주소를 실제 물리 메모리 주소로 변환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 페이지에 있는 코드와 데이터는 프로그램이 실행될 때 메모리의 서로 다른 물리 위치에 존재할 수 있다. 애플리케이션의 가상 주소는 실행중에 변경되지 않으며, 포인턴의 내용을 출력할 때 우리가 보게 되는 주소이다 또한 가상 주소는 실제 주소로 운영체제에 의해서 투명하게 변환된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간접지정-연산자로-포인터-역참조하기&#34;&gt;간접지정 연산자로 포인터 역참조하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;간접 지정 연산자 (&lt;code&gt;*&lt;/code&gt;)는 포인터 변수가 가리키는 위치의 값을반환하며 참조 연산자로 포인터 값의 역참조를 하는 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int num = 5;
int *pi = &amp;amp;num;


printf(&amp;quot;%d\n&amp;quot;, *pi); // 5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고 또한 좌변값(left-value)에 의해서 참조 연산자의 결과를 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좌변값은 할당 연산자의 좌측에 위치한 피연산자를 말한다. 모든 좌변값은 값이 할당될 수 있도록 변경 가능한 값이어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;*pi = 200;
printf(&amp;quot;%d\n&amp;quot;, num);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;함수-포인터&#34;&gt;함수 포인터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;포인터는 함수를 가리키도록 선언할 수 있으며 함수 포인터 선언은 일반적인 포인터 표기법에 비해서 다소 복잡하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void (*foo)();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;null의-개념&#34;&gt;NULL의 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;널은 흥미로운 주제이다. 하지만 종종 널이 가진 다양한 개념들이 잘못 이해되거나 혼란을 일으킨다. 널은 다음과 같은 개념들을 포함한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 널 개념
- 널 포인터 상수
- NULL 매크로
- NUL 아스키 문자
- 널 문자열
- 널 문장
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터에서 NULL이 할당되면 해당 포인터는 아무것도 가리키지 않음을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;널 개념은 포인터가 다른 포인터와 다른 포인터와 특별한 값을 가질 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;널이 할당된 포인터는 메모리의 어떤 영역도 가리키지 않으며 두 개의 널 포인터는 항상 서로 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적이지는 않지만, 문자 포인터나 정수 포인터와 같이 포인터 타입을 위한 널 포인터 타입이 있는 경우도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실제 널의 개념은 널 포인터 상수에 의해 지원되는 추상적인 개념이다. 널 포인터 상수는 0이거나 0이 아닐 수 있으며, C 개발자는 널 상수의 실제 내부적인 표현에 대해서 신경쓰지 않아도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NULL 매크로는 상수 정수 0을 &lt;code&gt;void&lt;/code&gt; 포인터로 캐스팅 한 것이다. 많은 라이브러리에서 다음과 같이 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#define NULL ((void*) 0)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NULL 포인터는 연결 리스트에서 종종 리스트의 끝을 표시하기 위해 사용되는 것 처럼, 많은 데이터 구조의 표현에서 매우 유용하게 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;포인터 변수 &lt;code&gt;pi&lt;/code&gt;에 널 값을 할당하기 위해서는 다음과 같이 NULL 타입을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pi = NULL;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;널 포인터와 초기화되지 않은 포인터는 명백히 다르다. NULL을 포함한 포인터가 메모리상의 어떤 위치도 참조하지 않지만, 초기화되지 않은 포인터는 어떤 값이라도 포함될 수 있으며 참조될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;포인터는 논리식에서 단독으로 피연산자로 사용될 수 있다. 예를 들어서, 아래 코드처럼 포인터가 NULL로 설정되었는지 테스트 할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (pi) {
  // 널이 아닌 경우
} else {
  // 널인 경우
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;널 포인터가 포함한 주소는 유효한 주소가 아니므로 절대로 역참조 해서는 안되며, 널 포인터에 대한 역참조는 프로그램에 대한 비정상 종료를 초래한다.&lt;/p&gt;
&lt;h3 id=&#34;void-포인터&#34;&gt;void 포인터&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; 포인터는 어떤 타입의 데이터도 참조할 수 있는 범용 포인터이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void *pv;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;void&lt;/code&gt; 포인터 선어에는 두 가지 흥미로운 것이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; 포인터는 &lt;code&gt;char&lt;/code&gt; 포인터와 같은 표현과 메모리 정렬 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; 포인터는 다른 포인터와 절대 같지 않다. 하지만 NULL 값이 할당된 두 개의 &lt;code&gt;void&lt;/code&gt; 포인터는 서로 같다. &lt;code&gt;void&lt;/code&gt; 포인터의 실제 동작은 시스템에 따라서 서로 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int num;
int *pi = &amp;amp;num;
printf(&amp;quot;Value of pi: %p\n&amp;quot;, pi); // Value of pi: 0x7ffee6dfd9cc
void* pv = pi;
pi = (int*) pv;
printf(&amp;quot;Value of pi: %p\n&amp;quot;, pi); // Value of pi: 0x7ffee6dfd9cc
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;void 포인터 사용시 주의가 필요하다.
임의의 포인터를 void 포인터로 캐싱팅 한 후에, 기존 타입이 아닌 전혀 다른 타입의 포인터로 캐스팅하더라도 이를 막을 방법이 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;size_t size = sizeof(void*); // valid
size_t size = sizeof(void); // invalid
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;전역-포인터와-정적-포인터&#34;&gt;전역 포인터와 정적 포인터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;포인터가 전역 또는 정적으로 선언되면, 해당 포인터는 프로그램 시작 시에 &lt;code&gt;NULL&lt;/code&gt;로 초기화 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int *globalpi;

void foo() {
  static int *staticpi;
}

int main() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;포인터의-크기와-데이터-타입&#34;&gt;포인터의 크기와 데이터 타입&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터의 크기는 애플리케이션의 호환성과 다른 환경으로의 이식 가능성을 고민할 때 문제가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;포인터의 크기는 사용하는 장비와 컴파일러에 따라서 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메모리-모델&#34;&gt;메모리 모델&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;64&lt;/code&gt;비트 컴퓨터의 도입으로 C 기본 데이터 타입의 메모리 크기 차이가 더 확실해졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컴퓨터와 컴파일러들은 C 기본 데이터 타입의 메모리 할당을 위해서 저마다 다른 옵션의 메모리 모델을 가지고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;I In L Ln LL LLn P Pn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123513904-c3b3a400-d6ca-11eb-8d44-66838289b5f0.png&#34; alt=&#34;Screen Shot 2021-06-26 at 10 06 25 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;사전-정의된-포인터-관련-데이터-타입&#34;&gt;사전 정의된 포인터 관련 데이터 타입&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터를 다룰 때, 네 가지의 사전 정의된 데이터 타입이 종종 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size_t&lt;/code&gt;, &lt;code&gt;ptrdiff_t&lt;/code&gt;, &lt;code&gt;intptr_t&lt;/code&gt;, &lt;code&gt;uintptr_t&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;size_t-타입의-이해&#34;&gt;&lt;code&gt;size_t&lt;/code&gt; 타입의 이해&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size_t&lt;/code&gt; 타입은 C 언어에서 임의의 객체가 가질 수 있는 최대 크기를 나타낸다. 크기를 표현하는 데 음수의 사용은 의미가 없기 때문에, &lt;code&gt;size_t&lt;/code&gt;는 부호 없는 정수를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size_t&lt;/code&gt; 타입을 쓰는 이유는 시스템에서 주소 지정이 가능한 메모리 영역과 일치하는 크기를 선언하는 이식 가능한 방법을 제공하기 위해서이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;문자의 수나 배열 인덱스와 같은 크기 변수를 선언할 때는
size_t 타입을 사용하는 것이 좋다.
size_t 타입은 반복문이나 카운터나 배열의 참조 그리고 때로는 포인터 연산에서 사용될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;intptr_t-uintptr_t-사용하기&#34;&gt;&lt;code&gt;intptr_t&lt;/code&gt;, &lt;code&gt;uintptr_t&lt;/code&gt; 사용하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;intptr_t&lt;/code&gt;, &lt;code&gt;uintptr_t&lt;/code&gt; 타입은 포인터의 주소를 저장하는데 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 두 타입은 다른 환경으로 이식이 가능하고, 안전한 포인터 선언 방법을 제공하며, 시스템 내부에서 사용하는 포인터와 같은 크기다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;포인터를 정수 표현으로 변환할 때 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상수와-포인터&#34;&gt;상수와 포인터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt; 에서 포인터와 &lt;code&gt;const&lt;/code&gt; 키워드를 함게 사용하면 매우 강력한 기능이 제공된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 키워드와 포인터의 사용은 몇몇 상황에 전혀 새로운 방식의 데이터 보호 방법을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;상수에-대한-포인터&#34;&gt;상수에 대한 포인터&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터는 상수를 가리키도록 정의될 수 있다. 이 말은 곧 포인터가 참조하는 값을 수정하는 데 사용될 수 없음을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음 예제에서 상수 정수를 선언한다. 다음으로 정수에 대한 포인터와 상수 정수에 대한 포인터를 선언하고 각각의 정수로 초기화 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int num = 0;
const int limit = 500;
int *pi;
const int *pci;

pi = &amp;amp;num;
pci = &amp;amp;limit;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;상수 포인터에 대한 역참조는 단지 정수의 값을 읽기만 한다면 문제가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;%d\n&amp;quot;, *pci);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포인터가 참조하는 값을 변경하기 위해서 상수 포인터를 역참조할 수는 없다. 그러나 포인터 값 자체는 상수가 아니므로 포인터 자체의 값은 변경할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉, 포인터는 다른 상수 정수나 정수를 사용하기 위해서 변경될 수 있다. 상숭 포인터 값 자체의 변경은 전혀 문제가 되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상수 포인터 선언은 단지 포인터를 통해 참조된 값의 변경만을 제한한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pci = &amp;amp;num;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;상수 정수를 가리키는 &lt;code&gt;pci&lt;/code&gt; 포인터 변수의 선언은 다음을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pci&lt;/code&gt;는 다른 상수 정수를 가리키도록 할당될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pci&lt;/code&gt;는 다른 비상수 정수를 가리키도록 할당될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pci&lt;/code&gt;는 가리키는 정수의 값을 읽기 위해 역참조 될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pci&lt;/code&gt;는 가리키는 정수의 값을 변경하기 위해 역참조 될 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비상수를-가리키는-상수-포인터&#34;&gt;비상수를 가리키는 상수 포인터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비상수를 가리키는 상수 포인터 역시 선언할 수 있으며, 이 선언의 의미는 포인터 자체의 값, 즉 가리키는 대상은 변경할 수 없지만 포인터가 가리키는 곳의 값은 변경할 수 있음을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int num;
int *const cpi = &amp;amp;num;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위 선언은 다음을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cpi&lt;/code&gt; 변수는 비상수 변수로 초기화 되어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpi&lt;/code&gt; 변수는 변경될 수 없다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpi&lt;/code&gt; 포인터 변수가 가리키는 변수의 값은 변경할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상수를-가리키는-상수-포인터&#34;&gt;상수를 가리키는 상수 포인터&lt;/h3&gt;
&lt;p&gt;상수를 가리키는 상수 포인터는 거의 사용되지 않는다. 포인터 값은 변경될 수 없으며, 포인터가 가리키는 값 역시 포인터를 통해 변경될 수 없다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int* const cpic = &amp;amp;limit;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;다중-수준-상수-포인터&#34;&gt;다중 수준 상수 포인터&lt;/h3&gt;
&lt;p&gt;상수 포인터는 다중 수준의 간접 지정이 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int * const cpci = &amp;amp;limit;
const int * const * pcpci;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;포인터의 종류&lt;/th&gt;
&lt;th&gt;포인터 데이터 변경&lt;/th&gt;
&lt;th&gt;포인터 대상 데이터 변경&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;비상수를 가리키는 포인터&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;상수를 가리키는 포인터&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;비상수를 가리키는 상수 포인터&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;상수를 가리키는 상수 포인터&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=33784887&#34;&gt;C 포인터의 이해와 활용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 25 Jun 2021 08:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 출근길에 &lt;a href=&#34;https://www.youtube.com/watch?v=_VGM6NSses4&amp;amp;t=8s&#34;&gt;잠재의식 시각화 훈련(Visualization) , 심상화, 잠재의식, 끌어당김의법칙, 명상 | 동기부여학과&lt;/a&gt; 영상을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://awesome-devblog.netlify.app/api/korean/people/feeds/view?url=https://zinee-world.tistory.com/600&#34;&gt;리더의 역할과 스킬&lt;/a&gt; 이라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;잠재의식에 대한 영상을 보면서, 나는 후에 어떤 사람이 되고 싶은지에 대해서 생각을 해보았다. 처음에는 단순히 돈을 많이 벌고 부유한 삶이 떠올랐지만, 내가 성취하고 싶은 것이 정확히 떠오르지 않았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 리더의 위치에 올라갈 일이 있을텐데 그때는 내가 일을 잘하는 것도 중요하지만, 팀원들이 몰입해서 일을 할 수 있는 환경을 제공해주는 것이 나의 역할이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떻게 하면 나말고 다른 사람들이 몰입해서 일을 할 수 있게 하는지를 생각해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내가 뭘 목표로 하는지, 그리고 인생에서 무엇을 할지 진지하게 생각을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 내 자신을 안다고 생각했는데 아무것도 모르고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 어떤 사람인지를 먼저 알자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>데드락이란? (DeadLock) (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/24/%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80-deadlock-draft.html</link>
      <pubDate>Thu, 24 Jun 2021 11:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/24/%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80-deadlock-draft.html</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123192882-b8038a00-d4de-11eb-91a0-5e434f43c548.png&#34; alt=&#34;ScreenShot 2021-06-24 at 11 23 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전달된 에러를 추적하다가, 아래와 같은 데드락 에러를 만나게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;InternalError: 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;정확한 문제 해결을 위해서 이번 기회에 데드락에 대해서 한번 더 정리를 해보고, 마리아 데이터베이스에서는 어떠한 경우에 데드락이 발생할 수 있는지를 알아보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데드락이란-무엇인가&#34;&gt;데드락이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123194903-31e94280-d4e2-11eb-8d24-336d333a18c3.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;교착상태 (&lt;code&gt;deadlock&lt;/code&gt;)이란 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 데이터베이스에서 발생하는 데드락은 &lt;code&gt;DBMS&lt;/code&gt;가 감지하여 실행되는 트랙잭션들 사이에 발생하는 데드락으로 각각의 트랜잭션이 사용하는 데이터들 사이의 데드락을 감지하여 알려준다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;innodb에서-deadlock-확인하기&#34;&gt;InnoDB에서 DeadLock 확인하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InnoDB&lt;/code&gt;는 트랜잭션을 실행시 데드락이 발생하게 되면 그것을 감지하고, 하나의 트랜잭션을 롤백하여 데드락을 해소하고, 그 정보를 로그로 남긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;SHOW ENGINE INNODB STATUS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123194595-bc7d7200-d4e1-11eb-9ceb-57e78504e5f6.png&#34; alt=&#34;Screen Shot 2021-06-24 at 11 45 24 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 구문을 통해서 정보를 얻을 수 있지만 비교적 최신 기록만 남아있다. 따라서 장애가 발생하였을 때 바로 확인해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지 항목이 있는데, 항목의 자세한 값은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/123203522-78926900-d4f1-11eb-99ae-2096e41fe46e.png&#34; alt=&#34;Screen Shot 2021-06-24 at 1 38 09 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mysqldba.tistory.com/54&#34;&gt;InnoDB에서 Deadlock 발생 내역 분석하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/show-engine-innodb-status/&#34;&gt;SHOW ENGINE INNODB STATUS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html&#34;&gt;Deadlocks in InnoDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/set-transaction/&#34;&gt;SET TRANSACTION&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html&#34;&gt;How to Minimize and Handle Deadlocks&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jeong-pro.tistory.com/94&#34;&gt;Exclusive Lock과 Shared Lock의 차이&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jsonobject.tistory.com/427#recentComments&#34;&gt;트랜잭션과 격리레벨&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 24 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 역시, 코딩 테스트 스터디를 완료하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모두들 열심히 참여해주어서 나도, 실망시키지 않기 위해서 끝까지 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실제 코딩과는 다른면이 많지만, 코딩에 대한 기본기를 키워주는 것 같다.&lt;/li&gt;
&lt;li&gt;매일 두뇌 훈련과 내가 생각한 아이디어를 어떻게 코드로 옮길 수 있을지에 대한 훈련이 되는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 23 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 문제를 풀고, 스터디 방에 올렸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;버스에서 미리 문제를 정하고, 하루종일 생각한 다음에, 안풀리는 문제는 집에서 와서 해답지를 보는 형식으로 문제를 푸니까, 더욱 재미 있었다. 그리고, 시간에 대한 스트레스가 없어서 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 22 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/zigbang/react-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-1b2e6a771cb9&#34;&gt;React 상태 관리 도구 살펴보기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4479&#34;&gt;아마존의 도큐먼트 문서 작성&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 문제를 푸는 인프런 스터디에 참여하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;토이 프로젝트나, 회의를 할 때, 도큐먼트를 기반으로 회의를 하면 효율적이게 회의를 할 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문서를 작성하는데 많은 시간이 들기는 하지만, 회의를 하면서 해결책을 생각해야한다는 부담감을 줄일 수 있다는 점에서 장점이 될 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 문제가 생긴 원인을 분석할 때, 본질적인 원인을 보기보다는 현상에 집중하는 경향이 있었다. 이러한 점을 고치도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인프런 스터디 참여를 하고나니, 힘들어도 계속할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 21 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/deliverytechkorea/%EC%84%9C%EB%A1%9C%EA%B0%80-%EC%84%9C%EB%A1%9C%EC%9D%98-%EC%9E%90%EB%9E%91%EC%9D%B4-%EB%90%98%EB%8A%94-data-platform-squad%EC%9D%B4%EC%95%BC%EA%B8%B0-38d23fca57c6&#34;&gt;서로가 서로의 자랑이 되는 Data Platform Squad 이야기&lt;/a&gt; 를 읽어보면서, 고객이 어떤 요구를 할 떄 근본적인 이유를 파악하는 것이 중요하다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tech.kakaoenterprise.com/110&#34;&gt;개발자들을 위한 테크니컬 라이팅 10계명&lt;/a&gt;를 읽음으로써, 문서화를 할 때 참고해볼 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.kingbbode.com/52?url=https://blog.kingbbode.com/52&#34;&gt;테스트를 작성하는 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://databasearchitects.blogspot.com/2021/06/what-every-programmer-should-know-about.html&#34;&gt;Database Architects &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 간단하게 캠핑을 하였는데, 내가 스스로 결정하고 그 결정이 만족스러웠을 때 나는 높은 만족감을 가지고 행복했다는 것을 알게 되었다. 따라서 앞으로 내가 스스로 결정하고 결과를 얻을 수 있는 일을 해야겠다는 생각을 하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작게나마, 내가 스스로 기획하고 실행하는 일을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팔릴 제품이고, 상품에 경쟁력이 있다면, 네이버 카페를 개설해도 팔리지만 대부분이 앱이나, 웹 페이지를 만드는데 많은 시간과 자원을 투자한다는 말을 카페에서 듣게 되었다. 따라서, 웹 애플리케이션이나, 제품을 먼저 만들기 보다는 이것이 정말로 사용자에게 가치가 있는지를 먼저 생각하고 실행하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;친구가, 같은 말을 하더라도, 조금 더 정감이 가게 사람들에게 말하는 것을 보았는데, 나도 이런점을 배워야 겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;말만 하는 것이 아닌 적극적으로 행동하는 사람이 되어야 겠다. 하지만 행동을 하기 전에는 내가 무었때문에 이것을 하려는지 명확한 목표가 있어야 할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;업무를 요청하는 &amp;lsquo;근본적인 이유&amp;rsquo;를 파악할 수 있도록 노력해야겠다. 그리고 고객이 요청하는 일이 정말로, 해결책이 아니라 우리가 고객이 원하는 목적을 찾을 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사람들과 많은 대화를 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 18 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좋은 분들을 만나 좋은 이야기를 들을 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://livenow14.tistory.com/60?url=https://livenow14.tistory.com/60&#34;&gt;Spring 쓰레드 관점에서 본 Spring MVC HTTP 요청과정&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://livenow14.tistory.com/60?url=https://livenow14.tistory.com/60&#34;&gt;서블릿 Filter를 사용해보자&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://rafaelquintanilha.com/how-to-become-a-bad-developer/&#34;&gt;나쁜 개발자가 되는법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.timescale.com/blog/how-and-why-to-become-a-postgresql-contributor/&#34;&gt;How (and why) to become a PostgreSQL contributor&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해커톤에 굉장히 많이 참가한 분을 알게 되었는데, 나도 이러한 모습을 본받아야 겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;잘 하려면 그만큼 실수를 많이 해봐야하고, 많은 시도를 해야한다고 생각했는데 이러한 연습을 하기에는 해커톤이 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 스프링의 전반적인 요청 처리에 대해서 알게 되었으며, &lt;code&gt;Filter&lt;/code&gt;에 대해서 알게 되었다. 나도 이분처럼 정리를 잘 하고, 유용한 지식을 작성해서 공유하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좀 더 적극적인 자세를 가지고, 도움을 받고 싶거나, 조언을 듣고 싶은 분에게 연락을 해야겠다. 그리고 나도 뛰어난 개발자가 되어서 다른 사람들에게 도움을 줄 수 있는 사람이 되어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떠한 개념을 코드로 &amp;ldquo;표현&amp;quot;할 수 있는 능력이 중요하다고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;학부에서 배울 수 있는 시스템 프로그래밍 지식들을 다시 리마인드 하고, 많은 코드를 작성하면서 리눅스 환경에 더더욱 익숙해져야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 네트워크 및 동시성 프로그래밍에 대해서는 개념만 알고 실제로 코드를 작성해본 경험이 별로 없는데, 이러한 공부를 많이 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞으로 터미널에서 많은 작업을 하게될 것 같은데 리눅스 생태계 및 도구를 많이 학습해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기초적인 자료 구조 및 알고리즘에 대한 학습을 다시 해보고 내가 개념을 이해하고 이를 코드로 표현할 수 있는가에 대해서 많은 연습을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람들은 긍정문보다 부정문에 집중하는 경향이 있기 때문에, 좋은 개발자가 되기 위한 반대 예시이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나쁜 개발자가 되는법&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 자신이 작성한 코드에 버그가 있다고 가정하지 말라
2. 생각하지 않고 코드 작성 
3. 명확하지 않은 지시 
4. 더 많은 코드 작성을 즐기기
5. 인간이 아닌 기계를 위한 코드를 작성하기
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POSTGRESQL&lt;/code&gt;에 기여하는 좋은 방법과 리소스에 대해서, 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 성능 분석 툴, 빌드 도구, 그리고 테스팅을 위한 펄, C언어를 배우라고 알려주었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 전반적인 지식과, 커널에 대해서 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스프링 부트 강의 섹션 5까지 학습하기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내 자신을 믿고, 앞으로 나가자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 16 Jun 2021 09:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://spoqa.github.io/2012/12/18/semantic-versioning.html&#34;&gt;Semantic Versioning 소개&lt;/a&gt; 라는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zinee-world.tistory.com/594?url=https://zinee-world.tistory.com/594&#34;&gt;팀장일기 1on1 (원온원, 일대일 미팅)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zzsza.github.io/data/2021/06/13/data-event-log-definition/&#34;&gt;데이터 로그 설계, 데이터 로깅, 이벤트 로그 설계, 데이터 QA의 모든 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대략적으로만 버전닝을 한다는 것만 알았지, 표준 명칭이 있는지는 처음 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 15 Jun 2021 09:17:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4442&#34;&gt;항상 그만두기&lt;/a&gt; 라는 글을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;회사에서 어떻게 생활해야하는지 막연했었는데, 조금의 힌트가 되어 주었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;직장에서 생활하는 좋은 철학은 언제라도 떠날 수 있도록 행동을 하는 것이다. 이것은 항상 퇴사 생각을 하는 것이 아니라, 자신을 대체가능하도록 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조금은 폐쇄적인 나의 단점을 상쇄 시켜줄 수 있는 좋은 기회가 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나중에 이 솔루션을 맡는 사람이 한명 더 늘어때를 대비하고 실제로 들어왔을 때 일을 알려주기 위한 좋은 방법인 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시니어 개발자가 되기 위해서 배워야 할 점 같다. 이러한 점들이 나의 책임을 미룬다고 생각할 수도 있지만, 위임할 줄을 알아야 할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 지식을 문서화 하라.
-&amp;gt; 후임자가 당신이 필요하지 않도록 문서, 버그, 코드 주석등 어디에든 답을 적어라. 
2. 장기 계획을 문서화하라.
-&amp;gt; 당신이 뭔가를 실시간으로 알려주지 않더라도, 이 계획을 보고 프로젝트에 앞으로 어떤 일이 생길지를 알 수 있도록 하라
3. 미팅을 문서화하라.
-&amp;gt; 당신이 참여하는 모든 미팅을 팀내에 공유하고, 누가 참석했는지, 어떤 논의가 있었고, 어떻게 결론을 내었는지를 적어라.
4. 다른 사람들을 회의에 초대하라.
-&amp;gt; 1대1 미팅이 아니고, 당신이 혼자 미팅에 참가중이라면 다른 사람들을 더 초대하라.
-&amp;gt; 다른 관점도 중요하지만, 당신이 유일한 컨텍포인트가 되는 것을 피하는 것이다.
5. 주변 사람들을 훈련시켜라
-&amp;gt; 목표는 그들이 독립적이 되도록 하는 것이다.
-&amp;gt; 그들이 계획과 기술을 숙지하게 하고, 문서를 활용할 수 있도록 하라.
6. 후임자를 찾고 교육 시켜라.
-&amp;gt; 당신의 역할을 바꾸려면 교체할 수 있어야 한다. 당신을 대체할 사람을 찾고 적극적/지속적으로 코치하세요.
7. 사람들에게 권한을 주어라.
-&amp;gt; 그들이 옳은 일을 하게 믿어주어야 한다.
-&amp;gt; 당신이 리더십 위치에 있다면, 다른 사람들이 당신에게 허락을 요청하도록 만들지 말라.
-&amp;gt; 그들이 스스로 선택하게 하고, 올바른 데이터를 기반으로 선택하도록 가이드하라.
8. 당신이 PoC(Point of Contact)가 되지 마세요.
-&amp;gt; 다른 사람을 포함시킬 수 있는 메일링 리스트를 만들거나 다른 종류의 커뮤니케이션 채널을 만들고 이를 확장하라.
9. 위임하세요 (Delegate)
-&amp;gt; 다른 사람에게 권한을 주고, 그룹과 미팅에 포함시키고, 지식을 문서화 했다면, 당신의 일을 수행할 준비가 된 것이다.
-&amp;gt; 그들이 성장할 수 있는 일들을 위임하고, 당신만이 할 수 있는 일에 집중하세요.
10. 항상 배우세요.
-&amp;gt; 관심 있는 분야에서, 지식을 키우고 재미있게 유지하세요.
-&amp;gt; 그 분야가 당신이 가고자 하는 미래와 일치하면 보너스이다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 - 게터와 세터 메서드 대신에 일반 속성을 사용하자.</title>
      <link>https://dongwooklee96.github.io/post/2021/06/14/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B2%8C%ED%84%B0%EC%99%80-%EC%84%B8%ED%84%B0-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8C%80%EC%8B%A0%EC%97%90-%EC%9D%BC%EB%B0%98-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90..html</link>
      <pubDate>Mon, 14 Jun 2021 14:50:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/14/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B2%8C%ED%84%B0%EC%99%80-%EC%84%B8%ED%84%B0-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8C%80%EC%8B%A0%EC%97%90-%EC%9D%BC%EB%B0%98-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90..html</guid>
      <description>&lt;h2 id=&#34;batter-way-29-게터와-세터-메서드-대신에-일반-속성을-사용하자&#34;&gt;BATTER WAY 29. 게터와 세터 메서드 대신에, 일반 속성을 사용하자.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;다른 언어를 사용하다가, 파이썬으로 넘어온 프로그래머들은 자연스럽게 클래스에 게터(&lt;code&gt;getter&lt;/code&gt;)와 세터(&lt;code&gt;setter&lt;/code&gt;) 메서드를 명시적으로 구현하려고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OldResistor&lt;/span&gt;(object):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, ohms):
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ohms

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_ohms&lt;/span&gt;(self):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms

  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;set_ohms&lt;/span&gt;(self, ohms):
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ohms


r0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; OldResistor(&lt;span style=&#34;color:#ae81ff&#34;&gt;50e3&lt;/span&gt;)
print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Before: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;r0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_ohms()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# Before: 50000.0&lt;/span&gt;

r0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_ohms(&lt;span style=&#34;color:#ae81ff&#34;&gt;10e3&lt;/span&gt;)
print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Before: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;r0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_ohms()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# After: 10000.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;r0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_ohms(r0&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_ohms() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5e3&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;사용하는 법은 간단하지만, 파이썬 스럽지 않은 코딩 방법이다.&lt;/li&gt;
&lt;li&gt;겟터와 셋터는 값을 증가시키고 그 값을 바로 반영하기 불편하다.&lt;/li&gt;
&lt;li&gt;파이썬은 명시적인 게터와 세터를 구현할 일이 거의 없다. 대신 공개 속성부터 구현하기 시작해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Register&lt;/span&gt;(object):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, ohms):
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ohms
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;voltage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;


r1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Register(&lt;span style=&#34;color:#ae81ff&#34;&gt;50e3&lt;/span&gt;)
r1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10e3&lt;/span&gt;

r1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ohms &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5e3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 속성을 설정할 때, 특별한 동작이 일어나야 한다면 &lt;code&gt;@property&lt;/code&gt; 데코레이터와 이에 대응하는 &lt;code&gt;setter&lt;/code&gt; 속성을 사용하는 방법으로 바꿀 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서는 &lt;code&gt;Registor&lt;/code&gt;의 새 서브 클래스를 정의하여, &lt;code&gt;voltage&lt;/code&gt; 프로퍼티를 할당하면, &lt;code&gt;current&lt;/code&gt; 값이 바뀌도록 해본다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제대로 동작하려면, 세터와 게터의 이름이 의도한 프로퍼티의 이름과 같아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;VoltageResistance&lt;/span&gt;(Register):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, ohms):
    super()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;__init__(ohms)
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_voltage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

  &lt;span style=&#34;color:#a6e22e&#34;&gt;@property&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;voltage&lt;/span&gt;(self):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_voltage

  &lt;span style=&#34;color:#a6e22e&#34;&gt;@voltage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setter
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;voltage&lt;/span&gt;(self, voltage):
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_voltage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; voltage
    self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_voltage &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ohms

r2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; VoltageResistance(&lt;span style=&#34;color:#ae81ff&#34;&gt;1e3&lt;/span&gt;)
print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Before: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 0&lt;/span&gt;
r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;voltage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;After: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;r2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 0.01&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;프로퍼티에 &lt;code&gt;setter&lt;/code&gt;를 설정하면, 클래스에 전달된 값들의 타입을 체크하고 값을 검증할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BoundedResistence&lt;/span&gt;(Register):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, ohms):
    super()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;__init__(ohms)

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@property&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ohms&lt;/span&gt;(self):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@ohms&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setter
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ohms&lt;/span&gt;(self, ohms):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ohms &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ValueError&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;ohms&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; ohms must be &amp;gt; 0&amp;#34;&lt;/span&gt;)


r3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BoundedResistence(&lt;span style=&#34;color:#ae81ff&#34;&gt;1e3&lt;/span&gt;)
r3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;프로퍼티에 &lt;code&gt;setter&lt;/code&gt;를 설정하면, 클래스에 전달된 값들의 타입을 체크하고 값을 검증할 수 있다.&lt;/li&gt;
&lt;li&gt;다음은 모든 저항값이 0옴보다 큼을 보장하는 클래스를 정의한 것이다.&lt;/li&gt;
&lt;li&gt;만약 &lt;code&gt;ohms&lt;/code&gt; 속성값이 0이거나, 0보다 작으면 예외가 발생하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FixedResistence&lt;/span&gt;(Register):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, ohms):
    super()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;__init__(ohms)

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@property&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ohms&lt;/span&gt;(self):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms

    &lt;span style=&#34;color:#a6e22e&#34;&gt;@ohms&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setter
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ohms&lt;/span&gt;(self, ohms):
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; hasattr(self, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_ohms&amp;#39;&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ValueError&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Can&amp;#39;t set attribute&amp;#34;&lt;/span&gt;)
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_ohms &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ohms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;부모 클래스의 속성을 불변(Immutable)로 만드는데도 @property를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-정리&#34;&gt;핵심 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단한 공개 속성을 사용하여 새 클래스 인터페이스를 정의하고, 세터와 게터 메서드는 사용하지 말자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;객체의 속성에 접근할 때 특별한 동작을 정의하려면 &lt;code&gt;@property&lt;/code&gt;를 사용하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@property&lt;/code&gt; 메서드에서 최소 놀람 규칙을 따르고 이상한 부작용을 피하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@property&lt;/code&gt; 메서드가 빠르게 동작하도록 만들자. 느리거나 복잡한 작업은 일반 메서드로 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=254321728&#34;&gt;파이썬 코딩의 기술&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/14/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 14 Jun 2021 00:17:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/14/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=J-sL0d_cTCg&amp;amp;list=WL&amp;amp;index=18&amp;amp;t=40s&#34;&gt;10 Tips to Grow as a Software Developer&lt;/a&gt; 라는 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집에와서, 간단히 코딩 테스트 문제를 풀었는데, 굉장히 재미있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오랜만에 찬물로 샤워를 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;퇴근하는 길에, 개발자 초식 시리즈 영상을 시청하였다. &lt;a href=&#34;https://www.youtube.com/watch?v=ZNDDy77WInY&#34;&gt;프로그래밍 초식 : 사소한 개선 - for문 분리&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=fnH_SR3n9Ew&#34;&gt;프로그램 초식(취향?): 쿼리에서 로직 빼기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발자로 성장하기 위한 좋은 팁들을 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 개발을 할 때, 테스트 코드를 간단하게 나마 작성해야겠다는 마음을 먹었다. 개발을 모두 다하고 나서, 구조를 개선했을 때 다시 테스트를 해야하고, 또 제대로 동작하는지 확인하는데 시간이 오래걸리기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음에는 고통스러웠으나, 샤워를 하고나서 몸이 훨씬 가벼웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단위 테스트가, 가장 비용이 적지만, 일단 솔루션의 의존성 분리가 제대로 되어있지 않은 탓에 쉽게 할 수는 없을 것 같다. 따라서 일단은 &lt;code&gt;E2E&lt;/code&gt; 테스트가 최선이라는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쉽게 재미를 붙일 수 없는 분야일 수록, 적절한 난이도와 흥미를 이끄는 것이 좋다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 사이드 프로젝트를 시작해라, 하루에 조금씩이라도 하는 것이 좋다.
2. 다른 개발자의 코드를 읽어라, 프레임워크의 코드나, 언어 라이브러리 코드를 읽는 것이 좋다.
3. 오픈 소스 프로젝트에 기여하라
4. 어떤 주제에 대해서 배울 때, 적어도 3가지 책(다른 저자)을 통해서 배워라
5. 자신이 주로 사용하고 있는 언어와 다른 새로운 프로그래밍 언어를 학습하라.
6. 주로 사용하는 언어와 관련된 도구나 라이브러리 생태계에 대해서 학습하라.
7. 주로 사용하는 운영체제를 변경하라.
8. 도큐먼트를 많이 읽고, 작성하라.
9. 해커톤에 참가하거나, 프로그래밍 컨테스트에 참가하라.
10. 개발자 네트워크에 참여하고 활동하라.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;한동안, 찬물로 샤워를 해야겠다. 머리도 맑아지고 개운해지는 느낌이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿼리에 로직을 넣는 습관을 가지고 있는데 이를 고쳐야겠다는 생각을 했다. 비즈니스 로직과 데이터베이스가 해야하는 역할을 명확히 구분해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;은탄환은 없다. 상황에 따라서, 최선을 선택하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한동안 찬물로 샤워하면서 정신을 맑게 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 12 Jun 2021 09:17:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트 문제를 풀어보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 내 블로그에 방문을 해주고, 메일까지 보내주신 분이 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제 해결 프로세스 대로, 해결해나가다 보니까, 굉장히 재미있었을 뿐만 아니라, 생각을 더 많이 하게 된 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 문제들을 틈틈히 풀어보면서, 나에게 부족한 문제 분석 능력 및 해결 능력을 키우기 위해서 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 작성한 글을 보고 메일을 보내주셔서 정말로 감사함을 느낌과 동시에 앞으로 글을 더욱 잘 작성해야겠다는 생각을 했다. 처음에는 내가 배운것을 정리하기 위한 목적이었다면, 이제는 다른 사람들이 내가 작성한 글을 통해서 도움을 줄 수 있도록 작성해야겠다는 마음이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아직 나는 &lt;code&gt;OOP&lt;/code&gt;에 대한 지식이 부족하다는 것을 느끼고, 내가 맡은 솔루션의 소스 코드를 더욱 가독성 있고 유지 보수 하기 편리하게 바꾸려면 객체지향적인 설계를 하기 위해서 더 많은 것을 배워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 정말하고 싶고, 되고 싶은 것이 무엇인지 진지하게 고민을 해봐야할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;업무를 진행할 때도, 알고리즘 문제를 풀듯이 문제의 제약 사항, 그리고 아이디어, 구현 및 테스트를 하면서 업무를 진행하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 문제를 해결하면서, 다시 한번 기본적인 자료 구조 및 알고리즘(&lt;code&gt;Sorting&lt;/code&gt;, &lt;code&gt;Search&lt;/code&gt;, &lt;code&gt;Optimize&lt;/code&gt;)에 대해서 공부할 필요를 느꼈다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 문제를 해결하면서, 문제 분석력과 해결 능력을 기를 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OOP&lt;/code&gt;의 핵심 설계원칙과 이를 적용해봄과 동시에 전반적인 소프트웨어 개발 펀더멘탈 (&lt;strong&gt;설계&lt;/strong&gt;, 개발, &lt;strong&gt;테스팅&lt;/strong&gt;, &lt;strong&gt;자동화&lt;/strong&gt;, 문서화) 및 &lt;strong&gt;소통능력&lt;/strong&gt;을 기르기 위해서 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 개발에 대해서, 관심이 있지만, 개발 실력을 키우기 위해서 노력은 하지 않았던 것 같다. 지금부터라도, &lt;code&gt;Multi-Thread&lt;/code&gt;, &lt;code&gt;IPC(Inter-Porcess-Communication)&lt;/code&gt;, &lt;code&gt;Network Programming&lt;/code&gt;에 대해서 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 11 Jun 2021 09:17:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/musinsa-tech/sre-fe8c7edfb772&#34;&gt;늘어나는 개발 프로젝트, 빌드환경을 어떻게 모니터링 할까?&lt;/a&gt; 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.promedius.ai/brain-mri-generation/&#34;&gt;T1, T2, FLAIR-Stacked Brain MRI Generation using StyleGAN2&lt;/a&gt; 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;빌드 자동화 및 모니터링을 구축할 때 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인공지능을 이용하여, 의료쪽에 많은 도움일 줄 수 있고 앞으로 유망한 분야가 될 것이라는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 10 Jun 2021 09:19:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://meetup.toast.com/posts/274&#34;&gt;mongoDB Story 1: mongoDB 정의와 NoSQL&lt;/a&gt; 라는 글을 읽어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이프로젝트를 할 때, 대량의 검색할 일이 있을 때 사용하면 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 08 Jun 2021 09:19:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.naver.com/collabee/222388121279&#34;&gt;업무 피드백의 기술&lt;/a&gt; 라는 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 체육관에서 인사를 하는데, 인사를 할 때 내 자신이 자신감 없게 인사를 하고 항상 힘없게 인사를 하는 것 같은 느낌을 받았다. 따라서, 내일부터는 목소리도 크게하고 자신감 있게 행동하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나중에 동료들과 함께 일할 때 좋은 피드백을 줄 수 있음으로 기분 나쁘지 않게 서로 발전하는 관계가 될 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사에서 인사를 하거나, 어떤 행동을 할 때 항상 자신감 있게 행동을 하자. 하나라도 제대로 하려면 이런 기본적인 것부터 똑바로 하는 습관을 기르자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/121103446-ed4f7d00-c83a-11eb-906d-e4fbfe528ee7.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;좋은 피드백을 주기 위해서 먼저 문제를 납득시키고, 원인을 설명한 다음에, 누군가의 탓이 아닌 객관적인 현상으로 설명하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;지금 우리 배가 가라앉고 있어요.(문제) 오른쪽 귀퉁이에 난 구멍때문인데(객관적인 원인) 00씨가 가지고 있는 목공 기술을 발휘(능력)하면 구멍을 메우고 정상 운영(이점)이 될 것 같아요.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;덜 가르치고, 많은 피드백을 주는 것이 성장을 위해서 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좋은 피드백을 주기 위한 관점으로는 &amp;ldquo;상대가 성취하고자 하는 목표가 무엇인지&amp;rdquo;, &amp;ldquo;목표를 향해 얼마나 잘 나아가고 있는지&amp;rdquo;, &amp;ldquo;다음 단계는 어떤 방향으로 나아가야하는지&amp;quot;와 같은 질문에 답이 되는 관점에서 전달을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &amp;ldquo;목표 지향적&amp;rdquo;, &amp;ldquo;실체가 있고 명료하며&amp;rdquo;, &amp;ldquo;실행 가능하면서&amp;rdquo;, &amp;ldquo;이해하기 쉽고&amp;rdquo;, &amp;ldquo;적시적이며&amp;rdquo;, &amp;ldquo;지속적이면서도&amp;rdquo;, &amp;ldquo;일관적인&amp;rdquo; 내용이여야 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아침에 회사에 출근해서 동료들에게 인사를 하거나, 체육관에 들려서 인사를 할 때 밝고 힘있게 인사를 하자. 나도 남들에게 힘을 주는 존재가 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 항상 자신감 있고, 힘있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>프로그래머처럼 생각하라 정리 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-2.html</link>
      <pubDate>Sun, 06 Jun 2021 14:44:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-2.html</guid>
      <description>&lt;h3 id=&#34;프로그래머는-단순하게-생각한다&#34;&gt;프로그래머는 단순하게 생각한다&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래머는 &lt;strong&gt;항상 목적을 달성하기 위한 최단 경로를 모색한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;쓸모없는 것을 생략하고, 사물을 단순하게 생각한다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 단순하게 생각하기 위해서, 모델을 사용하여 생각한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사물을 단순하게 표현하기 위해서는 복잡한 사물로부터, 본질은 남겨둔 채 쓸모없는 부분을 제거해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델-작성법&#34;&gt;모델 작성법&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;사물을-단순화-한다&#34;&gt;사물을 단순화 한다.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120914101-ca0bbd00-c6d6-11eb-8ace-0bd78c36f759.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가능한 한 불필요한 부분을 제거하고, 사물의 본질을 돋보이도록 해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;피카소의 그림에서 알 수 있듯이 처음부터, 단순화된 황소를 그리려고 한 것이 아니라, 여러 번 스케치를 해봄으로써 황소의 어떤 부분이 본질인지를 찾아내려고 노력하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 만들때도, 이와 같은 현상이 일어난다. &lt;strong&gt;생각하기 위해서 모델을 만들고, 모델을 만듦으로써 더 깊이 있게 생각할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;머리속에서 생각만 하는것만으로는 막다른 길에서 움직이지 못하는 경우가 많다. 이때 생각하고 있는 것을 바깥으로 꺼내서 표현해봄으로써 새로운 아이디어를 얻을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;맨 처음부터 훌륭한 모델을 만들자는 것이 아니라, 우선은 머리속에서 생각하고 있는 것을 머리 바깥으로 끄집어내서 모델 형태로 표현하고, 그 모델을 살펴보면서 다시 생각해보는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델의-기본-구조란&#34;&gt;모델의 기본 구조란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델은 &amp;lsquo;요소와 요소 사이의 관계&amp;rsquo;를 나타낸 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사람들은 흔히 &amp;lsquo;이해하려면 분해해보라&amp;rsquo;고 한다. 복잡한 사물을 있는 그대로 이해하는 것이 힘들기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 작성할 때 중요한 점은 &lt;strong&gt;목적과 관점을 명확하게 하는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은 대상으로 하더라도, 목적이 다르면 관점이 달라져서 사물을 바라보는 형식이 서로 다르게 되기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 사물에 관한 모델은 유일 무이하게 단 한 개만 존재하는 것이 아니라, 목적과 관점에 따라서 다양하게 만들어질 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요소를-추출하여-작성한다&#34;&gt;요소를 추출하여 작성한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;복잡한 사물은 여러 개의 요소로 구성되어 있다. &lt;strong&gt;모델링에서 가장 바람직한 방법은 각 요소를 모두 찾아내서 열거하는 작업 부터 시작해보는 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발상을 위한 사고법에서는 &amp;lsquo;발산&amp;rsquo;과 &amp;lsquo;수렴&amp;rsquo;의 사고과정을 반복한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델의 상세한 내용을 작성하는 경우, 깊이 있게 숙고 하고, 다시 폭넓게 생각하면서 이번 작업의 목적에 부합하지 않는 요소들을 제거하여 대담하게 수렴시켜 나가는 과정을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 작업의 초기에서는 무엇이든지 머리속에서 생각나는 것을 끄집어내서 표현해보도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;중요한-것을-요소로-만든다&#34;&gt;중요한 것을 요소로 만든다&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그러나 정말로 무엇이든지 생각나는 모든 것을 끄집어내서 표현하면 다 좋다는 의미는 아니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;복잡한 사물을 구성하는 &amp;lsquo;중요한 요소들&amp;rsquo;을 모두 열거해 보는 것&lt;/strong&gt;이 이 단계에서 해야할 작업이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;요소는-명사로-작성한다&#34;&gt;요소는 명사로 작성한다&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델이라는 것은 사물을 단순하게 표현한 것이므로 때에 따라서는 모호함이 표함되어 있어서 그 의미를 전달하기 어려운 경우도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;요소를 명사로 한다&amp;rsquo;라는 점을 주의해서 모델링하면 자신의 의도와 모델의 표현을 서로 일치하게 만들 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;관계를-명확하게-한다&#34;&gt;관계를 명확하게 한다&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요소를 추출하여, 열거한 후에는 각 요소 사이의 관계를 찾아내도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러고 나서 요소를 사각형으로 표현하고 관계를 연결선으로 나타낸다. 이러한 작업만으로 복잡한 사항을 정리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배치를-조정한다&#34;&gt;배치를 조정한다.&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;모델링 작업에서 무엇을 요소로 추출할 것인가 그리고 요소들 사이의 관계를 어떻게 표현할 것인가가 가장 중요하지만, 이와 거의 같은 수준으로 중요한 작업이 바로 모델의 전체 모습(어떻게 알기 쉽게 표현할 것인가의 문제) 즉 배치문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델을-사용하면-얻게-되는-장점&#34;&gt;모델을 사용하면 얻게 되는 장점&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;1. 도식화의 이점을 누릴 수 있다.
2. 전체 모습을 파악할 수 있다.
3. 논리적으로 생각할 수 있다.
4. 발상을 넓힐 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;빈약한-모델에서-발견할-수-있는-네-가지-공통점&#34;&gt;빈약한 모델에서 발견할 수 있는 네 가지 공통점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모델을 작성한다는 것은 처음에는 간단한 듯하지만 뜻밖에 깊이가 있는 작업으로 익숙해지지 않으면 좀처럼 좋은 모델을 만들어낼 수 없는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈약한 모델의 공통점은 아래와 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 목적과 관점이 정해져있지 않거나, 명확하지 않다.
2. 요소가 망라되어 있지 않거나, 불필요한 요소를 포함하고 있다.
3. 요소의 추상화 수준이 너무 높거나 너무 낮다.
4. 요소들 사이의 관계를 잘 표현하고 있지 못한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;자신의-입장을-확인한다&#34;&gt;자신의 입장을 확인한다.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모델링 대상에 대해서, 자신이 어떤 위치에 있는지를 의식할 수 있다면, 자연스럽게 자신이 그 대상물의 어떤 측면에 초점을 맞춰야할 것인지 (또는 맞추고 싶은지)가 명확해진다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델링은 무엇때문에 하는가? 라는 질문에 대해서 한마디로 대답해보는 것도 목적과 관점을 명확하게 하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목적과 관점은 모델을 만들어가면서 결정해간다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음부터 모델을 만드는 목적과 관점이 명확하게 결정된 경우는 그리 많지 않다. 따라서, 목적을 처음부터 명확하게 한마디로 대답할 수 없더라도 괜찮다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 모델을 만들면서 목적과 관점에 대해서 다시 생각해보고 모델을 만들고.. 이러한 과정을 반복하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;필요한-요소들을-부족함-없이-망라하기-위한-기법&#34;&gt;필요한 요소들을 부족함 없이 망라하기 위한 기법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;요소를 일단 삭제해보고, 그래도 모델을 이해할 수 있는지 아닌지를 확인해보는 것이다&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;요소가 부족한 경우에는, 모델의 만든 후에 위화감 또는 불안정감이 있는지를 확인하고, 시행착오를 거쳐가면서 모델을 수정해나간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;관계를-적절하게-표현하기-위한-요령&#34;&gt;관계를 적절하게 표현하기 위한 요령&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;관계에 빠진 점이 없는지를 확인한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문장으로 성립되는지를 확인한다. &lt;strong&gt;요소와 요소 사이의 관계가 정말로 성립하는지 논리적으로 생각해봄으로써 관계의 적절성을 확인할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;나무에서 떨어진다&amp;rsquo;와 같은 동사구를 명사화하여 요소로 추출하는 것이 때로는 더 좋은 모델을 만드는데 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://book.interpark.com/product/BookDisplay.do?_method=detail&amp;amp;sc.prdNo=266905788&amp;amp;gclid=Cj0KCQjwweyFBhDvARIsAA67M71SioU7M-0HZlQ00iMvRZJ8237_ixAt3Bos56hRrRlURVnzfdlnweQaAhAEEALw_wcB&#34;&gt;프로그래머처럼 생각하라&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로그래머처럼 생각하라 정리 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-1.html</link>
      <pubDate>Sun, 06 Jun 2021 14:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%B2%98%EB%9F%BC-%EC%83%9D%EA%B0%81%ED%95%98%EB%9D%BC-%EC%A0%95%EB%A6%AC-1.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120913629-646a0180-c6d3-11eb-89f0-b623930b731f.jpg&#34; alt=&#34;266905788g&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주말에 오래전에 사놓고 읽지 않은 책을 읽고 정리를 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;객체지향 사고를 할 때 도움이 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 사물을 깊게 이해하고 싶다.
2. 어떤 사물이나 개념을 상대방이 알기 쉽게 전달하고 싶다.
3. 새롭고 혁신적인 발상을 하고 싶다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 능력을 가지고 싶다면 방법은 하나이다. &amp;lsquo;단순하게 생각하기&amp;rsquo;를 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;단순하게 생각하기&amp;rsquo; 이것이 무엇인지 알기 힘들다면, 답은 프로그래머들의 사고 방식에서 찾아 볼 수 있고 이를 활용하면 위의 세가지 문제를 해결할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프로그래머는-사물을-단순하게-생각한다&#34;&gt;프로그래머는 사물을 단순하게 생각한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그래머들은, 보통 번잡하고 귀찮은 것을 싫어 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획성 없이 프로그램을 만들다 보면, 최종 단계에서 무엇인가 맞지 않게 되어서, 결국 쓸데 없는 작업이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 능숙한 프로그래머들은 여러 부품을 만들고, 어떻게 배치할지를 미리 생각하면서 작업한다. 이럴때 사용하는 것이 바로 모델이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 생각을 토대로, 모델의 핵심을 추출하여 일반적으로 사용할 수 있도록 만든 최강 단순 사고법이 바로 &lt;strong&gt;모델 기반 사고법&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델이란-무엇인가&#34;&gt;모델이란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;모델이란 &amp;lsquo;사물을 단순하게 표현한 것&amp;rsquo;이라고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120913795-beb79200-c6d4-11eb-842f-68abd4ce850c.JPG&#34; alt=&#34;IMG_5740&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;지극히 단순하게 사물을 표현하는 방법으로, 사각형(요소)과 연결선(관계)을 사용하여 모델을 표현&lt;/strong&gt; 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모델을 사용하여, 복잡한 사물들을 어느 정도 단순하고, 이해하기 쉽게 표현하고 있음을 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모델을-사용하여-발상한다&#34;&gt;모델을 사용하여 발상한다.&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;사물을 정리하여 이해하거나 알기 쉽게 전달하기 위한 목적으로만 모델을 사용하는 것은 아니다, 발상하기 위해서도 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://book.interpark.com/product/BookDisplay.do?_method=detail&amp;amp;sc.prdNo=266905788&amp;amp;gclid=Cj0KCQjwweyFBhDvARIsAA67M71SioU7M-0HZlQ00iMvRZJ8237_ixAt3Bos56hRrRlURVnzfdlnweQaAhAEEALw_wcB&#34;&gt;프로그래머처럼 생각하라&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 05 Jun 2021 15:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 풀 때, 사용할 수 있는 &lt;a href=&#34;https://www.hiredintech.com/classrooms/algorithm-design/lesson/78&#34;&gt;알고리즘 캠퍼스&lt;/a&gt; 에 대해서 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120892380-f973e880-c648-11eb-9a4c-6735ad459e88.png&#34; alt=&#34;algorithm&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그냥 무작정 문제를 푸는 것보다, 알고리즘 캠퍼스에 내용을 채워가면서, 문제를 풀면 좀 더 효율적으로 문제를 해결 할 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테이블의 레이아웃을 변경하여, 마크 다운 형식으로 기록하기 편하게 변경해야할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;주어진 정수형 배열에서 2개의 숫자를 선택하여 더한 값이 특정 목표값을 만들 때, 그 선택한 2개의 정수가 있는 배열의 인덱스를 반환하는 프로그램을 작성하라. 입력 값으로 주어지는 배열에는 정확히 하나의 정답이 존재하며, 같은 요소의 값을 중복해서 사용할 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;예를 들어서, 다음과 같은 문제가 있다고 가정을 했을 때 알고리즘 캠퍼스를 이용하면 다음과 같은 풀이가 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;제한-사항-constraints&#34;&gt;제한 사항 (Constraints)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;우선문제를 분석하고 제공하는 제한 사항을 기록하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 정수형 배열
2. 두 수의 합이 정수형을 초과할 수 있는가?
  - 문제에 언급이 없다.
3. 두 수의 합이 배열 내에 무조건 존재하는가?
  - 무조건 정확히 하나의 해결책이 존재한다.
4. 중복된 요소의 값을 2번 이상 사용하여, 결과값을 만들어서는 안된다.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;아이디어-ideas&#34;&gt;아이디어 (Ideas)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;아이디어는 여러 가지가 가능하다. 이를 통해서 시간 . 공간 복잡도를 구성해보고, 해당 아이디어를 코딩해봐야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;아이디어 (Brute-force)
1. 배열의 모든 요소의 조합을 찾는다.
  - 루프는 i = 0 ~ n, j = i + 1 ~ n으로 2중 루프를 구성한다.
  - 1번째 루프 (n번), 2번째 루푸는 (n - 1)을 기준으로 n * (n - 1)로 계산하자.
2. 해당 조합으로 목표값과 비교하여 같다면 해당 로프를 종료하고 각 가진 인덱스를 반환한다.

시간 복잡도: O(n^2)
공간 복잡도: O(1)
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;아이디어 (Hash Tables)
1. 해시 테이블을 구성한다.
  - 키 값으로는 배열의 요소, 값으로는 요소의 인덱스로 구성
2. 각 요소를 순회하면서,
  - 목표값 - 현재 요소 = 다른 요소
  - 해시 테이블에서 다른 요소의 값을 찾는다.
  - 만약 다른 요소가 해시 테이블에 있다면, 현재 요소의 인덱스와 해시 테이블의 값(인덱스)를 반환한다.
  - 다른 요소가 없다면, 현재 요소를 해시 테이블의 키 값으로 넣고 인덱스를 해시 테이블의 값 항목으로 추가한다.


시간 복잡도: O(N) 한번의 순회로 원하는 값을 찾을 수 있다.
공간 복잡도: O(N) 해시테이블의 생성하여 최대로 모든 요소 (N)을 담아야 한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;코드code&#34;&gt;코드(code)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;글로 써놓은 아이디어를 코드로, 표현해보자. 사실 아이디어를 구체적으로 설계한다면 코드는 단지 표현하는 수단중 하나일 뿐이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;테스트test-cases&#34;&gt;테스트(Test Cases)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;제한 사항에서 살펴본 내용과 함께 테스트 케이스를 만들어 본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 04 Jun 2021 15:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 &lt;a href=&#34;https://www.codewars.com/dashboard&#34;&gt;codewars&lt;/a&gt; 라는 사이트를 알게 되었다. 다양한 언어를를 지원한다는 점이 큰 장점이며, 추천 시스템을 통해서 다른 사람들의 풀이를 볼 수 있는 것도 좋았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/query-cache/&#34;&gt;Query Cache&lt;/a&gt; 라는 문서를 읽어보면서 쿼리 캐시에 대하여 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;평소에 배우고 싶었던 언어를 이용하여, 프로그래밍 문제를 풀어보면서 새로운 언어를 익혀보는 것도 재미있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시를 시스템 변수를 통해서, 확인해보고 실제 작동하는지 확인하는 과정이 재미있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쿼리 캐시의 다양한 옵션 값을 통해서, 사용하려는 애플리케이션에 따라서, 다르게 적용해줘야하는 점을 알게 되었고, 이 값을 크게 해주었을 때랑, 적게 해주었을 때의 상황에 대해서 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;집중력을 키우기 위해서 노력해야겠고, 실수를 하지 않기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인프런 (리액트) 강의 수강하기 : 이번주 일요일까지&amp;hellip;&lt;/li&gt;
&lt;li&gt;인프런 (스프링) 강의 수강하기 : 이번주까지&amp;hellip;&lt;/li&gt;
&lt;li&gt;머리자르기 : 이번주 토요일&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 많이 풀어보면서, 사고력을 기를 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>쿼리 캐시란? (MARIADB)</title>
      <link>https://dongwooklee96.github.io/post/2021/06/04/%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C%EB%9E%80-mariadb.html</link>
      <pubDate>Fri, 04 Jun 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/04/%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C%EB%9E%80-mariadb.html</guid>
      <description>&lt;h3 id=&#34;쿼리-캐시&#34;&gt;쿼리 캐시&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시란, &lt;code&gt;SELECT&lt;/code&gt; 쿼리문을 이용하여 조회한 값을 저장하고 있다가, 같은 쿼리 문을 요청하였을 때 미리 캐싱된 값을 반환하는 &lt;code&gt;DBMS&lt;/code&gt; 기능이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 웹사이트와 같이 쓰기 (&lt;code&gt;WRITE&lt;/code&gt;)보다, 읽는 (&lt;code&gt;READ&lt;/code&gt;) 횟수가 많은 환경에서 유용하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 멀티 코어 시스템 및 처리량이 높은 환경에서는 확장성이 좋지 않으므로 기본적으로 사용되지 않도록 설정된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쿼리-캐시-기능을-사용하기&#34;&gt;쿼리 캐시 기능을 사용하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시 기능을 사용할 수 있는지 확인하려면, 기본적으로 &lt;code&gt;have_query_cache&lt;/code&gt; 설정이 되어 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정이 되어있는지 확인하고 싶다면, 아래와 같은 쿼리 문을 입력한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;HAVE_QUERY_CACHE&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;조회 결과 &lt;code&gt;YES&lt;/code&gt;로 나온다면, 쿼리 캐시 기능을 사용할 수 있다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;QUERY_CACHE_TYPE&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;그 다음에는 현재 시스템에서 쿼리 캐시 기능을 사용하고 있는지를 조회해 볼 것이다. 위의 쿼리 결과가 &lt;code&gt;ON&lt;/code&gt;으로 나온다면 이미 쿼리 캐시 기능을 적용하고 있다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쿼리-캐시가-되지-않는-경우&#34;&gt;쿼리 캐시가 되지 않는 경우&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;아래와 같은 함수를 사용하면, 기본적으로 쿼리가 캐싱되지 않는다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;BENCHMARK()
CONNECTION_ID()
CONVERT_TZ()
CURDATE()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_DATE&lt;/span&gt;()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIME&lt;/span&gt;()
&lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt;()
CURTIME()
&lt;span style=&#34;color:#66d9ef&#34;&gt;DATABASE&lt;/span&gt;()
ENCRYPT() (one &lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt;)
FOUND_ROWS()
GET_LOCK()
LAST_INSERT_ID()
LOAD_FILE()
MASTER_POS_WAIT()
NOW()
RAND()
RELEASE_LOCK()
SLEEP()
SYSDATE()
UNIX_TIMESTAMP()
(&lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;parameters&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;USER&lt;/span&gt;()
UUID()
UUID_SHORT()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;또한 쿼리에 아래와 같은 구문이 있을 경우 쿼리가 캐싱되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; SQL_NO_CACHE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; OUTFILE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; DUMPFILE ...
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;UPDATE&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; autoincrement_column &lt;span style=&#34;color:#66d9ef&#34;&gt;IS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; ... &lt;span style=&#34;color:#66d9ef&#34;&gt;LOCK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SHARE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;MODE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;쿼리-캐시-크기를-제한하기&#34;&gt;쿼리 캐시 크기를 제한하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120759865-6f475980-c54e-11eb-8b81-ad5975fa0449.png&#34; alt=&#34;Screen Shot 2021-06-04 at 4 03 22 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿼리 캐시 크기를 제한하기 전에, 우선 쿼리 캐시 크기 설정을 살펴보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 설정을 통해서 &lt;code&gt;query_cache_size&lt;/code&gt; 값을 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿼리의 빈도수가 적고, 데이터가 많이 조회되는 쿼리가 있을 것이다. 이런 경우에는 캐싱을 할 필요가 없으므로, &lt;code&gt;query_cache_limit&lt;/code&gt; 옵션으로 크기를 설정해서 특정 결과값의 용량이 설정해놓은 값이 넘으면 캐싱하지 않도록 설정을 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;캐시-설정-및-의미&#34;&gt;캐시 설정 및 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;SHOW STATUS LIKE &#39;Qcache%&#39;;
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks      | 1158     |
| Qcache_free_memory      | 3760784  |
| Qcache_hits             | 31943398 |
| Qcache_inserts          | 42998029 |
| Qcache_lowmem_prunes    | 34695322 |
| Qcache_not_cached       | 652482   |
| Qcache_queries_in_cache | 4628     |
| Qcache_total_blocks     | 11123    |
+-------------------------+----------+
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 쿼리를 입력하면, 쿼리 캐싱과 관련된 설정 값들이 나오게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;중요한 옵션값만 확인하자면, &lt;code&gt;Qcache_inserts&lt;/code&gt;는 현재, 캐싱된 쿼리의 값을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_hits&lt;/code&gt;는 쿼리를 캐싱하여, 캐싱된 값을 반환한 값을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_lowmem_prunes&lt;/code&gt;는 메모리 값이 부족하여, 캐시에서 이전에 있던 값을 제거한 값이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Qcache_lowmem_prunes&lt;/code&gt; 값을 줄이려면 앞서 말했던, &lt;code&gt;query_cache_limit&lt;/code&gt; 값을 적절히 설정해주면 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그 밖에도,  &lt;code&gt;query_cache_wlock_invalidate&lt;/code&gt; 옵션을 끄면,  &lt;code&gt;WRITE&lt;/code&gt; 락이 걸려있더라도, 캐싱된 값을 반환하게 하여, 경합 상태에서도 기다리지 않고 값을 읽을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;캐시된 쿼리를 잘 이용하면, 성능을 높일 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실제 &lt;code&gt;SQL&lt;/code&gt;문은 대소문자를 구분하지 않지만, 캐싱된 쿼리 값을 반환받기 위해서는 대소문자까지 같아야 하므로, 팀 내에서 쿼리문을 통일성 있게 작성하는 노력을 해야할 것이다.그 밖에도 동일한 쿼리라는 것을 인식하려면 여러 값들이 일정해야한다. 이는 아래 내용을 참조하도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/120763124-e16d6d80-c551-11eb-9914-0df5d697cc98.png&#34; alt=&#34;Screen Shot 2021-06-04 at 4 28 16 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿼리 캐시 값의 크기를 크게 늘리면, 읽기 속도는 빨라지겠지만, 락 경합 때문에 쓰기 속도는 느려질 수 있다. 최적값을 찾아서 적용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/query-cache/&#34;&gt;Query Cache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 03 Jun 2021 07:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kwiki.devserum.com/ko/articles/tech-articles/2021-05-31-518-consecutive-days-algorithm-challenge&#34;&gt;518일동안 단 하루도 빠지지 않고 알고리즘을 풀었다.&lt;/a&gt; 라느 글을 읽어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이 글을 읽으면서, 나도 블로그 글을 이렇게 작성해야겠다는 생각을 하였고, 나도 꾸준하게 코딩 테스트 문제를 풀어야 겠다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 02 Jun 2021 07:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=II5uUQ7sARE&amp;amp;t=2124s&#34;&gt;스타트업을 만나다&lt;/a&gt; 영상을 시청하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이력서를 작성할 때는 경력 사항 및 교육이나, 활동들이 있는데, 이러한 활동을 통해서 어떤 성과가 있었는지, 그리고 어떤점을 느꼈는지를 작성하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제를 해결하기 위해서는 개념이 제대로 잡혀야 한다. 사실, 문제를 어떻게 해결하는 것보다는 문제가 무엇인지 명확히 정의하는것이 어려울 때가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이력서를 작성할 때, 읽는 사람을 배려하는 것은 코드를 작성할 때도, 다른 사람들을 배려해서 코드를 작성하는 것과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(시작은 단순하되, 점점 확장되는) 문제를 어떻게 해결할 수 있는 능력을 기르자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디버깅이나 문제 파악을 해야하는 상황이 있고, 문제를 접근하는 나름의 방법을 제시할 수 있는지, 자신만의 기술 성장 로드맵이 있고, 왜 그렇게 하고 싶은지를 설명할 수 있는가? 를 생각해보고 이러한 능력을 어떻게 하면 키울 수 있는지를 고민해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 - 키워드 인수로 선택적인 동작을 제어하자</title>
      <link>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%9D%B8%EC%88%98%EB%A1%9C-%EC%84%A0%ED%83%9D%EC%A0%81%EC%9D%B8-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%A0%9C%EC%96%B4%ED%95%98%EC%9E%90.html</link>
      <pubDate>Tue, 01 Jun 2021 16:17:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%9D%B8%EC%88%98%EB%A1%9C-%EC%84%A0%ED%83%9D%EC%A0%81%EC%9D%B8-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%A0%9C%EC%96%B4%ED%95%98%EC%9E%90.html</guid>
      <description>&lt;h2 id=&#34;better-way-19-키워드-인수로-선택적인-동작을-제공하자&#34;&gt;BETTER WAY 19. 키워드 인수로 선택적인 동작을 제공하자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이썬은 대부분의 다른 언어와 같이 함수를 호출할 때, 인수를 위치로 전달 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서는 위치 인수를 모두 키워드로 전달하는 것도 지원한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reminder&lt;/span&gt;(number, divisor):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; divisor

reminder(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)
reminder(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, divisor&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)
reminder(number&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, divisor&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)
reminder(divisor&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, number&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;키워드 인수는 코드를 처음보는 사람이 함수 호출을 더 명확하게 이해할 수 있도록 도와준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;키워드 인수는 함수를 정의할 때, 기본값을 설정할 수 있다. 이렇게 하면 반복적인 코드가 줄어들고, 코드가 깔끔해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flow_rate&lt;/span&gt;(weight_diff, time_diff, period&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (weight_diff &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; time_diff) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; period

flow_per_second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flow_rate(weight_diff, time_diff)
flow_per_hour &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flow_rate(weight_diff, period&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3600&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;키워드 인수는 기존의 코드와 호환성을 유지하면서 함수의 파라미터를 확장할 수 있는 강력한 수단이 된다. 코드의 수정 없이 추가적인 기능을 제공할 수 있으며, 버그가 생길 가능성을 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-정리&#34;&gt;핵심 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함수의 인수를 위치나 키워드로 저장할 수 있다.&lt;/li&gt;
&lt;li&gt;위치 인수만으로는 이해하기 어려울 때, 키워드 인수를 사용하면, 각 인수를 사용하는 목적이 명확해진다.&lt;/li&gt;
&lt;li&gt;키워드 인수에, 기본값을 지정하면, 함수에 새로운 동작을 쉽게 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;선택적인 키워드 인수는 항상 위치가 아닌 키워드로 넘겨야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=254321728&#34;&gt;파이썬 코딩의 기술&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/06/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 01 Jun 2021 15:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이제 회사에서 객체지향적으로 코드를 바꿀 수 있는 기회가 온 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=_JAqbUVbBVs&amp;amp;list=WL&amp;amp;index=8&amp;amp;t=513s&#34;&gt;초기 스타트업으 위한 사업 계획서 작성팁&lt;/a&gt; 이라는 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드의 구조를 본격적으로 리펙토링 할 기회가 많아질 것인데, 관심사의 분리와 각 객체들의 역할이 무엇인지 그리고, 어떻게 하면 객체지향적으로 코드를 작성할 수 있는지 고민을 해보고, 책을 통해서 배워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스타트업이 망하는 가장 큰 이유는 서비스를 원하는 시장의 수요가 작기 때문이라는 것이라고 소개를 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h4 id=&#34;인그레스-ingress가-하는-역할&#34;&gt;인그레스 (INGRESS)가 하는 역할&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;외부접속 가능한 &lt;code&gt;URL&lt;/code&gt; 경로에 따른 교통정리를 해주는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 출시하려고 하는 제품이나 서비스가, 어떤 문제로 시작되었는지, 그리고 해결할 가치가 있는 문제인지, 그리고 누구의 문제인지를 이것을 기술로 해결할 수 있는지를 충분히 고민을 해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;차별성 및 혁신성은 문제의 정의 및 해결 방법이 기존과 어떻게 다른지를 명확히 설명할 수 있으면 그것이 바로 차별성 및 혁신성이다. 이걸 이루기 위해서는 이미 시장에 진출한 경쟁자를 면밀하게 분석해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, 산업에 있는 경쟁사의 한계점을 우리가 차별성 있는 방법으로 해결 할 수 있다는 설명이 바로 차별성 및 혁신성이다. 다른 경쟁사들이 가지고 있지 않은 단 하나의 강점을 말할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시장 규모에 대해서, 이야기를 할 때, 그 근거를 기사화된 자료 및 다른 사람이 연구한 자료에서 가지고 오는 경우가 있는데, 예측되는 성장 가능성을 제시한 것이지 구체적인 시장 크기라고 보기는 힘들다. 따라서, 구체적인 해당 모델에 부합하는 숫자로 말할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반드시 숫자와, 데이터베이스로 정량적으로 산업을 설명할 수 있어야 한다. 인터뷰나, 프로토타입이나 베타 서비스가 가능한 상태에서 순환 시뮬레이션들을 프로젝션을 돌려서 수집된 숫자들이 그 근거로 해서, 만들어진 데이터베이스가 얻어지는 것이 가장 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;고객 유지 단계 주요 지표&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- DAU(Daily Active User)
- WAU(Weekly Active User)
- MAU(Monthly Active User)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작은 일에도 최선을 다하자.&lt;/li&gt;
&lt;li&gt;침착하게, 작은 부분을 천천히 정복하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;좋은 서비스가 많다는 것을 느끼고, 스타트업에 대해서 관심을 가지게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 - 가변 위치 인수로 깔끔하게 보이게 하자</title>
      <link>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B0%80%EB%B3%80-%EC%9C%84%EC%B9%98-%EC%9D%B8%EC%88%98%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%98%EA%B2%8C-%EB%B3%B4%EC%9D%B4%EA%B2%8C-%ED%95%98%EC%9E%90.html</link>
      <pubDate>Tue, 01 Jun 2021 14:50:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B0%80%EB%B3%80-%EC%9C%84%EC%B9%98-%EC%9D%B8%EC%88%98%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%98%EA%B2%8C-%EB%B3%B4%EC%9D%B4%EA%B2%8C-%ED%95%98%EC%9E%90.html</guid>
      <description>&lt;h2 id=&#34;batter-way-18-가변-위치-인수로-깔끔하게-보이게-하자&#34;&gt;BATTER WAY 18. 가변 위치 인수로 깔끔하게 보이게 하자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;파이썬으로 코딩하다가, 가변적으로 인수를 받을 때가 있다.&lt;/li&gt;
&lt;li&gt;이러한 경우에 사용하면 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(message, values):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; values:
  print(message)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
    values_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(str(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; values)
    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (message, values_str))

log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;My number are&amp;#39;&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hi there&amp;#39;&lt;/span&gt;, [])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서는 로그로 남길 값이 없을 때, 빈 리스트로 넘겨주고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬에서는 &lt;code&gt;*&lt;/code&gt; 기호를 마지막 위치의 파라미터 이름 앞에 붙이면, 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;맨 앞에 나오는 인수는 필수적이지만, &lt;code&gt;*&lt;/code&gt; 가 붙은 인수는 가변적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수 본문은 수정할 필요가 없고, 단지 호출하는 쪽만 수정하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(message, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;values):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; values:
  print(message)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
    values_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(str(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; values)
    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (message, values_str))

log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;My number are&amp;#39;&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hi there&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;인자가 필요하지 않을 때에는, 사용하지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;가변-개수의-인수를-받는-방법의-문제점&#34;&gt;가변 개수의 인수를 받는 방법의 문제점&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 가변 인수가 함수에 전달되기에 앞서, 항상 튜플로 변환된다는 점이다.

-&amp;gt; 함수를 호출하는 쪽에서 제네레이터를 사용하면, 결과로 만들어 지는 튜플의 개수가 많은 경우, 메모리를 많이 차지하여 프로그램이 죽을 수 있다.

2. 추후에 호출 코드를 변경하지 않고서는 새로운 위치에 인수를 추가할 수 없다는 점이다.

-&amp;gt; 새로운 위치에 인수를 추가할 경우, 호출하는 코드를 변경해줘야한다. 그렇지 않으면 버그가 발생한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;핵심-정리&#34;&gt;핵심 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt; 문에서 &lt;code&gt;*args&lt;/code&gt;를 사용하면, 함수에서 가변 개수의 위치 인수를 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 연산자를 사용하면, 시퀀스에 들어 있는 아이템을 함수의 위치 인수로 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제네레이터와 &lt;code&gt;*&lt;/code&gt; 연산자를 함께 사용하면, 프로그램이 메모리 부족으로 망가질 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*args&lt;/code&gt;를 받는 함수에 새 위치 파라미터를 추가하면 정말 찾기 어려운 버그가 생길 수 도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=254321728&#34;&gt;파이썬 코딩의 기술&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 - 키워드 전용 인수로 명료성을 강요하자</title>
      <link>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%84%EC%9A%A9-%EC%9D%B8%EC%88%98%EB%A1%9C-%EB%AA%85%EB%A3%8C%EC%84%B1%EC%9D%84-%EA%B0%95%EC%9A%94%ED%95%98%EC%9E%90.html</link>
      <pubDate>Tue, 01 Jun 2021 14:50:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/06/01/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%84%EC%9A%A9-%EC%9D%B8%EC%88%98%EB%A1%9C-%EB%AA%85%EB%A3%8C%EC%84%B1%EC%9D%84-%EA%B0%95%EC%9A%94%ED%95%98%EC%9E%90.html</guid>
      <description>&lt;h2 id=&#34;batter-way-21-키워드-전용-인수로-명료성을-강요하자&#34;&gt;BATTER WAY 21. 키워드 전용 인수로 명료성을 강요하자.&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;safe_division&lt;/span&gt;(number, divisor, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;,
    ignore_overflow&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;, ignore_zero_division&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; divisor
  &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OverflowError&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ignore_overflow:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ZeroDivisionError&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ignore_zero_division:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;함수는 아래와 같은 방법으로 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; safe_division(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;)
print(result)

result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; safe_division(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
print(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;문제는 두 인수의 위치를 혼동하기 쉽기 때문에 찾기 어려운 버그가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;따라서, 키워드 인수를 이용하여 매우 주의 깊고 항상 예외를 발생하도록 만들어 줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;ult &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; safe_division(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, ignore_overflow&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
print(result)


result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; safe_division(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, ignore_zero_division&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
print(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;호출하는 쪽에서, 특정 키워드 인수로 특정 연산에는 기본 값을 덮어쓰고 무시할 플래그를 지정할 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 이러한 키워드 인수는 선택적인 동작이라서 함수를 호출하는 쪽에 키워드 인수로 의도를 명확하게 드러내라고 강요할 방법이 없다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 복잡한 함수를 작성할 때에는 호출하는 쪽에서 의도를 명확히 드러내도록 요구하는 것이 낫다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파이썬3 에서는 키워드 전용 인수로 함수를 정의해서 의도를 명확히 드러내도록 요구할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;safe_division&lt;/span&gt;(number, divisor, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;,
    ignore_overflow&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;, ignore_zero_division&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;):
  &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; divisor
  &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OverflowError&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ignore_overflow:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ZeroDivisionError&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ignore_zero_division:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;키워드 인수가 아닌, 위치 인수를 사용하는 함수 호출은 더 이상 동작하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; safe_division(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 에러 발생&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;키워드 인수와 그 기본 값은 의도한 대로 동작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python3&#34; data-lang=&#34;python3&#34;&gt;safe_devision(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, ignore_zero_division&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 정상 동작&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;핵심-정리&#34;&gt;핵심 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;키워드 인수는 함수 호출의 의도를 더 명확하게 해준다.&lt;/li&gt;
&lt;li&gt;특히 불 플래그를 여러 개 받는 함수처럼 헷갈리기 쉬운 함수를 호출할 때, 키워드 인수를 넘기게 하려면 키워드 전용 인수를 사용하자.&lt;/li&gt;
&lt;li&gt;파이썬 3는 함수의 키워드 전용 인수를 명시적으로 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=254321728&#34;&gt;파이썬 코딩의 기술&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 31 May 2021 15:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 너무 피곤했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일요일날 밤에는 늦게까지 깨어있지 말고, 일찍 자서 에너지를 비축해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몸이 피곤하니, 소스 코드 분석이 제대로 되지 않았고, 집중력도 많이 떨어졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전략적으로 체력을 사용해야겠다. 주말동안 편하게 있었으므로, 다시 월요일부터 회사에서 적응하려면 체력을 비축해두어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;몸이 피곤하지 않게, 체력 관리를 잘 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내일은, &lt;code&gt;AWS&lt;/code&gt;를 통한 배포 실습을 할 예정이기 때문에 &lt;code&gt;AWS&lt;/code&gt; 계정을 새롭게 만들어야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;때로는 천천히 꾸준히 나아가자. 짧은 기간에 무리해서 많은 것을 하는 것보다 매일 조금씩 하는 것이 좋을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/30/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 30 May 2021 15:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/30/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.outsider.ne.kr/699#google_vignette&#34;&gt;TTY 멀티플랙서 tmux&lt;/a&gt; 라는 글을 읽고 사용을 해보았다.&lt;/li&gt;
&lt;li&gt;친구랑 같이 코딩 테스트 문제를 짝코딩 방식으로 풀어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TMUX&lt;/code&gt;를 이용하여 터미널 창을 분할해서 사용하니, 더 유용하게 사용할 수 있었다. 그전에는 그냥 터미널 창을 하나 새로 켜서 사용했다면 하나의 터미널 창을 분할 해서 사용하니 더 편한 것 같다. 점점 익숙해져야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;혼자 공부할 때는 재미가 없었던 코딩 테스트가 같이 한 문제를 가지고 고민을 하면서 풀다 보니, 해결 방법도 명확하고 재미도 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트가 면접을 보기 위한 과정이라고 생각을 하지 말고 논리력을 기를 수 있고 구현 능력을 키울 수 있는 기회라고 생각을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주말에 조금 시간을 낭비하는 경향이 있는데, 이러한 오전 시간에 내가 평소에 공부하고 싶거나 부족한 점을 채우면 자기 발전에 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다음주 목요일까지, 인프런 리액트 강의 및 스프링 강의를 목표한 범위를 배우고 기록할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;감정적으로 살지 말고, 이성적으로 꾸준하게 나아가자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 28 May 2021 18:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.percona.com/sites/default/files/ple19-slides/day1-pm/tracing-and-profiling-mysql.pdf&#34;&gt;Tracing and Profiling MySQL&lt;/a&gt; &lt;code&gt;MySQL&lt;/code&gt;을 트레이싱 하는, 발표 자료를 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt;에서 트레이싱을 어떻게 하는지 알 수 있었다.&lt;/li&gt;
&lt;li&gt;트레이싱을 통해서 내가 관심을 가지고 있는 애플리케이션의 내부 동작 원리 및 구현에 대해서 많이 알 수 있다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 27 May 2021 18:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tech.kakao.com/2021/05/24/jyami/&#34;&gt;카카오 백엔드 개발자 이야기&lt;/a&gt; 라는 글을 읽어보게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.naver.com/chandong83/222357950193&#34;&gt;나는 정부과제로 창업한다&lt;/a&gt;다음과 같은 글을 읽어보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추천하는 책을 꼭 읽어봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정부과제는 어떤 식으로 이루어지는지 궁금했었는데 참고할 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 26 May 2021 18:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 인프런에서 퍼블리싱 강의를 들었다.&lt;/li&gt;
&lt;li&gt;오늘 인프런에서 스프링부트에 대한 강의를 들었다.&lt;/li&gt;
&lt;li&gt;요즘 회사에서 개발을 하면서, 시야가 점점 좁아지는 느낌을 받았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;둘다 기초부터 시작하지만, 이번 기회에 기초를 튼튼하게 해야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;탄탄한 &lt;code&gt;API&lt;/code&gt;를 만들기 위해서 노력을 해야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;배우면서 실제 프로젝트를 발전 시키고 싶다. 설계라도 해야할텐데, 우선 배울 것이 너무 많기는 하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이슈를 진행하면서 막연하게 접근하기 보다는, 내가 현재 모르는 것이 뭔지 정리를 하면서 하나씩 알아가면서 이슈에 접근을 해야할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;급할 수록 돌아가자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;화면 명세서 및 프로토타입을 계속 만들어봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나의 좋은 모습을 끊임없이 상상하고, 되기 위해서 노력하자!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나를 믿어주는 고마운 사람들에게 보답을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무조건 내가 기획한 토이 프로젝트 사이트를 만들것이다!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 25 May 2021 18:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=yVtn0q4tbcE&#34;&gt;억만장자 알고리즘&lt;/a&gt; 이라는 유튜브 동영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 개발을 했을 때, 굉장히 단순한 것임에도 불구하고 헤메였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발이나 개발 공부를 할 때 접목하면 좋은 방법을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몸이 안좋거나 피곤하다는 핑계를 대고 싶지만, 잘 안풀리다보면 내 스스로 급해지고 빨리 해결하고 싶다는 마음에 시야가 좁아지는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좋은 습관을 만들기 위한 프로세스는 4가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;인지하기&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;원하기&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;실행하기&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;좋아하기&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤일을 계획할 때, 이것을 언제, 어디서, 어떻게를 적자. 그러면, 그것을 성공할 확률이 더 높아진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 일을 하기 위해서 필요한 것을 동기가 아니라, 구체적인 계획이다. 구체적인 계획이 있을 때, 그것을 실행할 확률이 더 높았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ingress&lt;/code&gt;는 조금 더 티테일하게 관리하기 위한 것이다, 마이크로서비스 아키텍처에서 각 서비스별로 분기를 시켜주는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;중요한 프로젝트나, 할일이 있을 때, 6개월 뒤에 실패하는 것을 상상한다. 그리고 나서 왜 실패했을까, 그리고 무슨 역경이 있었을까? 그렇게 생각을 하고 이를 보완하기 위한 방법들을 생각하고 적용하면 그것을 성공할 확률이 높아진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행하기의 중요성은 프로젝트를 할 때 매우 중요하다. 최선의 코드를 위해서 하루종일 고민하는 것보다. 코드를 많이 작성해보면서, 우선 계속 나은 방향으로 개선해나가는 방법을 사용하자. 처음에는 무조건 질보다 양이고, 계속해서 양을 채워나가다 보면, 어느순간 질이 올라갈 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;몸이 아무리 피곤하더라도, 급할 수록 돌아가자라는 말을 새기자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 위한 사용자 스토리 맵을 만들고, 화면 설계를 해야할 때가 왔다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;급할 수록 돌아가자.&lt;/li&gt;
&lt;li&gt;내가 진행하고 있는 프로젝트나 개발이 망했을 것이라고 가정하고 이유를 생각해보자. 그리고 그것을 절대로 망하지 않도록 현재의 문제점을 차근차근 고치자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/23/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 23 May 2021 18:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/23/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이번주에 개발 규칙을 정해서, 이를 적용하며 개발을 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mailchi.mp/fae3ac97e435/20210509?fbclid=IwAR0FyYQVsjqOi62nZwlHppkB0wwtg5vVcC946SMBH47HFR910X8S_O2GEHA&#34;&gt;이직후, 적응하고 성과를 내기까지 어떤 노력을 해야하는가?&lt;/a&gt; 라는 주제의 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://us7.campaign-archive.com/?u=1a48fb6bb0906b04f7fc87435&amp;amp;id=e3ef5b8fd8&#34;&gt;개발/공부_우선순위를_명확히하는것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번주에 드디어 튜닝 워크샵 강의를 끝마쳤다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동작하게 만들고, 이것을 옳게 만들고, 그리고 더 낫게 만드는 개발 방법은 나를 조금 더 꼼꼼하고 그리고, 내가 작성한 코드가 과연 최선인지에 대한 생각을 하게 만든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;필자는 두 가지 노력을 하였다고 했는데, 시스템을 이해하려는 노력과 동료들과 신뢰를 쌓기 위한 노력으 했다고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 회사에서 일하면서 궁금했던 점과 고민했던 부분을 명확히 정리해주어서 좋았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스에 기여하려는 프로젝트에 이러한 방법을 사용하면 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일의 우선 순위를 잘 정하지 못하는 나에게, 좋은 글이었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아직 데이터베이스에 대해서 많은 것을 배워야겠다는 생각을 하였고, 개발을 하면서 틈틈히 실행 계획 분석 및 트레이스 분석을 하면서 경험을 쌓아야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h4 id=&#34;문서-읽기-및-시스템의-변천사-확인하기&#34;&gt;문서 읽기 및 시스템의 변천사 확인하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;시스템을 이해하려는 노력에는 기술적인 영역 뿐만 아니라, 팀이 하고 있는 일, 팀이 일을 하는 방법을 익히는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사에 누적된 문서들을 읽는 것은, 프로덕트 혹은 현재 팀이 하고 있는 업무의 배경을 알려줄 뿐만 아니라, 시스템의 현재와 변천사를 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 할 때, &amp;lsquo;왜&amp;rsquo; 해야하는지에 대해서 아는 것은 매우 중요하다. 따라서 우리팀이 어떤 문제를 해결해왔고, 또 앞으로 어떤 문제를 해결하려고 노력하는지 아는 것은 매우 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;코드의-흐름-이해&#34;&gt;코드의 흐름 이해&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;만약 &lt;code&gt;API&lt;/code&gt; 서버를 담당하게 된다면, 현재 서버에서 특정 API에 대한 요청을 받고 처리를 완료하는 일련의 과정을 따라가 보면서, 요청을 받을 때 공통으로 처리하는 로직은 무엇인지, 비즈니스 로직 및 패턴은 어떻게 구성되어 있는지 확인하면 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;이슈-티켓-및-풀-리퀘스트-확인하기&#34;&gt;이슈 티켓 및 풀 리퀘스트 확인하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;팀이 문제를 어떻게 해결하고 있는지, 그리고 동료들의 피드백을 살펴봄으로써, 팀이 코드를 리뷰할 때, 집중하는 부분과, 개발 문화의 일부분을 직접 확인할 수 있는 단계이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;동료들과-신뢰를-쌓기-위한-노력&#34;&gt;동료들과 신뢰를 쌓기 위한 노력&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여태까지 시스템을 이해하려는 노력을 하면서, 정리했던 것과 궁금한 내용을 동료들에게 공유한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유를 받는 사람이 이해하는데 어려움이 없어야하고, 본인만의 충분한 이해와 문맥을 만든 후에 질문을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;일의-우선-순위-정하기&#34;&gt;일의 우선 순위 정하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;해야할 일, 혹은 해야한다고 느끼는 일, 공부 목록을 작성한다. 그리고 그 옆에 가시적인 제약 사항을 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;분산 시스템 사례 연구 : 프로젝트 시작일 3월 1일
알고리즘 공부 : 인터뷰 날짜 3월 15일
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;그리고 나서, 기대하는 결과를 적어본다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;분산 시스템 사례 연구: 프로젝트 시작일 3월 1일: 유사한 문제를 겪고 있는 회사의 해결 전략 최소 1개 도출
알고리즘 공부: 인터뷰 날짜 3월 15일: dynamic programming 문제 최소 20개 해결
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;그리고 나서, 내가 할애할 수 있는 시간을 추정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;분산 시스템 사례 연구: 프로젝트 시작일 3월 1일: 유사한 문제를 겪고 있는 회사의 해결 전략 최소 1개 도출: 하루 1시간 x 20일 = 20시간
알고리즘 공부: 인터뷰 날짜 3월 11일: dynamic programming 문제 최소 20개 해결: 하루 1.5시간 x 30일 = 45시간

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이렇게 나열하다 보면, 내가 가진 제약 사항 및, 대안 등을 고려하여 나름의 우선 순위를 정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 내 목록에서 버릴 것을 과감히 선택하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;5월 23일까지, &lt;code&gt;Slack&lt;/code&gt; 클론 코딩 섹션 0까지 듣겠다! (완료!)&lt;/li&gt;
&lt;li&gt;5월 27일까지, &lt;code&gt;Slack&lt;/code&gt; 클론 코딩 섹션 1까지 듣겠다!, 목표하는 바 : 리액트에서 로그인 및 로그아웃 기능을 구현해보면서, 권한 관리에 학습할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단순히 기능을 동작하게 만드는 프로그래머가 아닌, 그것을 올게 그리고 더 낫게 만들수 있는 개발자가 된다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 22 May 2021 22:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/119228447-0d4e2380-bb4e-11eb-8ad9-3a8642ac32db.jpeg&#34; alt=&#34;unnamed&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발 유튜버의 회고 양식을 보았다.&lt;/li&gt;
&lt;li&gt;오라클 성능 고도화 강의가 끝났다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;배울점이 많이 있었다. 모르는 점과 목표와 마감기한을 적는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 아직 모르는 것이 많이 있고, 이를 채워나가기 위해서 많은 노력을 해야겠다는 것을 알게되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;특히 나는, 목표를 세우고 이를 실행하는 능력을 보완해야겠다는 생각을 하였는데 회고에서 매일 되새김질 하면 우선 순위와 목표를 향해서 방향성 있게 공부를 할 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt;의 락에 대해서 알게 되었고, 내가 모르는 내용도 많이 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;낙관적 동시성 제어 및 비관적 동시성 제어에 대해서 배우게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;완전히 이해하지는 못했지만 병렬 쿼리가 있다는 것도 알게 되었고, 실행 계획을 살펴보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 강사님이 하시말이 이제부터 시작이라고 했다. 아무리 이론 및 문제를 많이 풀어도 실전에서 실행 계획을 많이 보고 트레이싱도 해봐야지 실력이 는다고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실제 개발을 하면서 트레이싱 및 실행 계획을 많이 봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goal-and-duedate-목표-및-마감기한&#34;&gt;Goal and DueDate (목표 및 마감기한)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;5월 23일까지, &lt;code&gt;Slack&lt;/code&gt; 클론 코딩 섹션 0까지 듣겠다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;무조건 쿼리를 실행하거나, 만들때, 실행 계획을 확인할 것이다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 21 May 2021 10:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CLION&lt;/code&gt;에서 도커에 붙어서 작업하는 것은 성공하였다. 하지만 내가 기여하고 싶은 프로젝트의 도커에는 성공하지 못했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 복잡한 쿼리문을 만났는데, 해결할 수가 없었다. 따라서 이 부분을 많이 고민해야할 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오픈소스 커뮤니티에 질문을 통하여 답변을 받는 것도 괜찮을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;생각처럼 쉽게 풀리지 않아서 막막한 기분이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 문제를 통해서, 이런 막막한 기분에 익숙해지는 것도 좋은 방법이라는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;바보 같은 질문은 없다고 했다. 물론 모든 경우에 가져다 붙일 수 있는 것은 아니지만, 노력을 해보았고, 잘 안되었다면 도움을 받는 것도 괜찮을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 쉽게 되지는 않겠지만 마음에 여유를 좀 가져보는 것도 괜찮을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;집에서도 개발을 편하게 할 수 있도록 셋팅을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사에서 안풀리던 문제의 해결 방법이 집에서 떠오를 때가 있는데, 그때 작업하면 좋을 것 같다는 생각이 들고, 만약 급한 일이 생겨서 집에서 바로 업무를 해야하는 상황이 올 수도 있게 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;안풀리는 문제를 만났다고 해서, 답답해하지 말고 기회라고 생각하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 20 May 2021 10:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 도커 컨테이너에, &lt;code&gt;CLION&lt;/code&gt;을 붙여서 작업하는 방법을 찾았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추후에 &lt;code&gt;DBMS&lt;/code&gt;를 개발하고 싶다고 하니까, 그러한 분야는 천재들만 할 수 있다는 이야기를 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나를 위한 작은 강의를 만들어보면 재미있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;터미널 기반으로 작업하는 것보다는 생산성이 증진될 것 같다. 게다가 디버깅을 명령어 기반으로 하지 않을 수 있다는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;절대 그렇지 않다는 것을 나로서 증명하고 싶다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나중에 &lt;code&gt;DBMS&lt;/code&gt;를 개발하는 개발자가 되기 위해서 노력을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나를 위한 강의를 만들어 보면 재미있을 것 같다는 생각이 들었다. 예를 들어서, 오픈소스 활동을 하면서 내가 모르는 주제를 가지고 짧막하게 5분짜리 동영상을 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;꾸준하게, 장기적인 마인드로 조바심을 내지 않고 차근차근 오픈 소스 개발을 향해서 달려가자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이 프로젝트에 속도가 붙는 느낌이다. 기왕하는거 제대로 해보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이제는 자투리 시간을 최대한 활용해야겠다는 생각 뿐이다. 버스에서 남는 시간을 최대한 활용하여, 내가 이루고 싶은 목표들을 모두 이루자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;퍼블리싱 실력을 늘려서 내가 원하는 페이지를 쉽게 만들어서 공유를 할 수 있었으면 좋겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 19 May 2021 10:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인프런에서, 내가 배워야할 지식들과 강의들의 목록을 살펴보고, 장바구니에 담으면서 필요한 지식들에 대해서, 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 개념을 배우기 위해서 가장 좋은 방법은 비슷한 프로그램을 직접 만들어보는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 의식적인 연습이 필요하다. 회사에서 일을 할 때 의식적으로 코딩을 하는지 아니면 무의식적으로 기존의 방식대로 하는지 생각을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;퍼블리싱에 대해서, 공부를 해야겠다. 졸업 작품을 하거나, 토이프로젝트를 구성할 때 항상 퍼블리싱에 자신감이 없어서 완성작이 안나오는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 서비스에 어느정도 익숙해졌다면, 플러터를 이용하여, 웹앱을 만드는 것도 좋을 것이다. 그리고 디자인 및 &lt;code&gt;UX&lt;/code&gt;에도 꾸준하게 관심을 가지도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;튜닝의 기본은 트레이스 분석이다, 튜닝은 우선 원인 파악을 해야하고, 패턴은 그 후에 나오는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;패턴을 외워서 하는 튜닝 방식은 잘못되었다. 데이터 분포 및 실행 계획 그리고 트레이스 분석을 통해서 튜닝을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;튜닝을 하려면 쿼리 변환을 무조건 잘 알아야하고, 공부를 많이 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 나에게 어떤 서비스를 만들수 있다는 자신감이 있으려면, 퍼블리싱 실력을 키워야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내가 생각하고, 디자인 한것을 그대로 코딩하고 배포를 하려면, 일단 퍼블리싱에 대한 이해가 이루어져야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;길게 보았을 때, 웹 디자인 및 퍼블리싱에 시간을 투자하는 것이 아깝지 않을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 진정한 풀스택 개발자로서, 작은 규모의 웹 서비스는 혼자서 설계하고 만들어볼 수 있는 능력을 갖출 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 18 May 2021 00:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make it work, make it right, make it fast&lt;/code&gt; 방식대로 업무를 했다.&lt;/li&gt;
&lt;li&gt;쿠버네티스를 이용하여, 실습을 하면서 약간 배웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;확실히 이전보다 안정적이고, 최적화 및 이것이 옳은 방향인지 한 번더 확인할 수 있는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그전에는 구현을 하고, 문제가 없다면 바로 다른 문제로 넘어갔다면 일단 동작하게 하고, 이것을 어떻게 하면 더 잘할 것인지를 고민하는 과정에서 실력이 증진되고 생각할 거리가 많아 진 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 개념을 배우고, 내가 이것을 제대로 이해했는지 확인하는 방법중에 하나는 이것을 상상해보는 것이다. 머리속으로 상상이 된다면 제대로 이해한 것이고 상상이되지 않는다면 이해하지 못한것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;올바른 코딩 프로세스 및 습관이 장기적으로 실력을 많이 증진시킬 수 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커와, 쿠버네티스는 컨테이너를 매니지먼트하는 도구이다. 규모의 차이가 있을 뿐이다. 그리고 도커 자체가 컨테이너 환경이 아니라, 컨테이너는 실제로 리눅스에서 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커와 쿠버네티스 모두, 내부적으로 &lt;code&gt;iptables&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스는 &lt;code&gt;POD&lt;/code&gt; 묶음들의 &lt;code&gt;IP&lt;/code&gt;를 대표한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각의 &lt;code&gt;POD&lt;/code&gt;의 &lt;code&gt;IP ADDRESS&lt;/code&gt;가 없는 것은 아니지만, 클러스터 IP (내부에서 사요하는 가상 IP)를 통하여 &lt;code&gt;POD&lt;/code&gt; 묶음에 접근한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클러스터 IP가 가상 IP이기 때문에, &lt;code&gt;NODE PORT&lt;/code&gt;를 통하여 외부에서 연결이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어디까지, 고민해야하는지 기준이 모호한 면이 있는데 이는 계속 경험을 생각을 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 정한 개발 프로세스대로, 개발을 할 것이고, 좀 더 체계적으로 개발을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 17 May 2021 09:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 몸이 안좋아서 오전 반차를 내었다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.shiren.dev/2021-05-17/?fbclid=IwAR1ssMEKLbGnNZSS4yMTwyj7Wa5uEtenE4GxPVWNBO61lWhokrYE_cePIUE&#34;&gt;개발을 잘하는 습관&lt;/a&gt; 이라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;도커에 대해서 배웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;건강을 중요하게 생각해야겠다, 쓸데 없는데 반차를 낭비하니까 아까웠다.&lt;/li&gt;
&lt;li&gt;오늘 일을 하는데, 일감이 이해되지 않는 것이 있었다.&lt;/li&gt;
&lt;li&gt;나도 일을 하면서 나만의 최적화된 루틴을 만들어야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컨테이너는 독립된 리눅스 환경을 보장하는 프로세스이다.&lt;/li&gt;
&lt;li&gt;이는 기존의 리눅스의 기능인 &lt;code&gt;namespace&lt;/code&gt;와 &lt;code&gt;cgroup&lt;/code&gt;을 이용하여 독립된 환경을 보장한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nampspace&lt;/code&gt;는 무엇을 볼 수 있는지를 제한하고, &lt;code&gt;cgroup&lt;/code&gt;은 하드웨어 자원을 얼마나 사용 가능한지를 나타낸다.&lt;/li&gt;
&lt;li&gt;도커를 자세히 알수록 많은 것을 할 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup&lt;/code&gt;에 대한 설정은 부모 프로세스를 물려받게 된다.&lt;/li&gt;
&lt;li&gt;“make it work, make it right, make it fast” 루틴&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 일단 동작하게 만든다.
-&amp;gt; 필요한 것을 공부하면서, 일단 지금 내가 해결하려는 요구사항이 충족될 수 있도록 하는 것이다. 코드 가독성에 대해서 너무 신경을 쓰지 않아도 된다. 내용에 따라서 다를 수도 있지만, TDD가 적용된다면, 의미가 있는 테스트 케이스가 만들어져야 하며, 테스트 케이스가 유용하다는 것은 모듈의 책임과 역할을 다할 수 있도록 모듈의 인터페이스가 설계가 되었고 어느정도 완성이 되었다는 뜻이다.

2. 옳게 만든다.
-&amp;gt; 첫 번째 단계에서 학습하면서 만든 코드는 엉망 진창일 수 있다. 현재 알려진 가장 나은 방법을 이용하여 실용적인 코드로 변경하는 과정이다. 리펙토링은 만들어진 테스트 케이스와, 인터페이스를 믿고, 내부 코드에 완전히 집중하는 시간이다.

3. 더 낫게 만든다.
-&amp;gt; 옳은 것과 나은 것은 다르며, 퍼포먼스 측면의 병목을 찾거나, 리소스를 덜 사용하는 방법을 찾는 것이다. 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;몸이 피곤하다는 이유로, 분석해보려고 하지 않았다. 따라서, 이를 적극적으로 분석해보려는 자세가 필요할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 &lt;code&gt;make it work, make it right, make it fast&lt;/code&gt;를 사용하여, 어느 지점에서 멈추는 개발자가 아니라, 최선을 향한 개발자가 되도록 노력을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전에는 기능 개발만 끝내고, 다 끝냈다고 말했다면 이제는 위의 단계를 따라서 어떻게 하면 더 낫게 만들 수 있는지를 생각하고 기록 및 공유를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단순히 동작하는 것에서 그치는 것이 아니라, 더 낫게 만들고 그것을 올게 만드는 프로그래머가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/16/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 16 May 2021 15:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/16/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 &lt;code&gt;fortune&lt;/code&gt; 명령어를 이용하여, 터미널이 켜질 때마다, 명언이 나오도록 설정하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이슈를 처리할 때, 잘못된 방향으로 가서 시간을 너무 많이 소모했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커의 내부 과정에 대해서 학습하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;캘린더에 기록하는 것 보다 효율적이고 더 많이 접하게 될 것이다. 개발을 하면서 하루에 한 번 오는 알림보다 터미널에서 작업하는 시간이 더 길것이기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사의 소스코드를 구조 개선할 때, 필요한 디자인 패턴을 찾아보고 이를 적용해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현을 하다가, 뭔가 이상하다고 생각이 들 때 계속 같은 방향으로 구현을 하는 것 보다는 잠시 내려놓고 다른 방법은어떨까라는 생각을 해보는 것이 장기적으로 많은 시간을 아낄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;간단한 알고리즘 문제를 매일 저녁 풀고 있는데, 재미도 있고 보람도 있는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사실 도커가 리눅스의 프로세스라는 사실을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 및 인프라적인 지식이 개발을 하는데 많은 도움이 되는 것 같다. 따라서 프로그래밍 뿐만 아니라 인프라적인 지식도 많이 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;안풀리는 문제를 억지로 잡고 있지 말고 되돌아볼 필요가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 구현보다는 설계에 많은 고민과 시간을 사용해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩을 하다가, 뭔가 잘 안풀린다 싶으면 되돌아가서 생각을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;평일에 틈틈히 발표 연습을 하고 콘텐츠를 만드는 연습을 해야겠다. 발표 자료를 만들 때, 마크다운 기반의 프레젠테이션을 만드는 도구가 생산성을 많이 올려줄 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/fortune-cmd/&#34;&gt;fortune 명령어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 15 May 2021 09:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/svrRov-SDNI&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 개발자의 공부 방법이라는 세미나 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 &lt;a href=&#34;https://festa.io/events/1557&#34;&gt;스타트업을 만나다&lt;/a&gt; 라는 세미나를 참석하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 쿼리 튜닝 워크샵 수업을 들으러 갔다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;되게 인상 깊었던 것은, 자신이 배운 개념을 남들에게 알기 쉽게 다시 나만의 방식으로 다른 사람들에게 설명을 해주는 것이다. 그리고 자신은 이런 기준이 제대로 알고 있는지를 설명하는 기준이라고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 어떤 개념을 알고 있다고 생각을 했는데, 사실은 제대로 알지 못하는 경우가 많았다. 하지만 제대로 이해하고 있는 개념들은 비유를 통해서 재밌게 설명할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;의식적인 연습의 7가지 원칙
1. 효과적인 훈련 기법이 수립되어 있는 기술 연마
2. 개인의 컴포트 존을 넘어간 지점에서 실행, 자신의 현재 능력을 살작 넘어가는 작업을 지속적으로 시도
3. 명확하고 구체적인 목표를 가지고 진행
4. 신중하고 계획적이다 즉, 자신이 온전히 집중하고 &#39;의식적&#39;으로 행동할 것을 요구
5. 피드백과 피드백에 따른 행동 변경을 수반
6. 효과적인 심적 표상을 만들어 내는 한편으로 심적 표상에 의존
7. 기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써, 발전시키고 수정하는 과정을 수반
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;무언가를 배울 때는 집중과 피드백 그리고 교정을 하는 것이 중요하다는 것을 배우게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자 이력서에 대한 좋은 조언을 얻을 수 있었고, 스타트업에서 일하게 된 계기와 경험을 많이 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 어떤 프로젝트나 경험을 하면서 어떤 것을 배웠는지 그리고 어떤 것을 느꼈는지를 평소에 기록으로 남겨야 겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿼리 튜닝을 할 때는 패턴을 외우지 말고, 데이터 분포 그리고 실행 계획에 의해서 판단을 해야한다는 것을 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 개발을 꾸준히 하는 방법에는, 평소에 관심 있는 프로젝트를 개발하는 방법도 있지만, 회사에서 현재 사용하고 있는 기술들에 있는 버그나 기능 개선을 고치는 방법도 있다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그냥 소스 코드를 수정하는데 그것이 자신의 코드이냐, 남의 코드이냐라는 차이라고 했을 때 굉장히 멋있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 교육 받았던 내용들 및 느낀점을 기록으로 남겨 놓는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발적인 실력을 많이 키워야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt;의 내부 원리에 대해서 제대로 파악하고 있지 못하다는 생각을 하였고 이를 채워나가기 위해서 노력을 많이 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 느끼는 것이지만, 쉬운 쿼리라고 하더라도 평소에 실행 계획을 많이 보고 힌트를 통해서 많이 조작해보려고 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이력서에 단순히 경험들을 나열하는 것이 아니라, 내가 구체적으로 어떤 활동을 했는지, 그리고 느낀점 및 배운점을 적는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DBMS&lt;/code&gt;에 대해서 개념을 확실하게 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;내가 제대로 배웠는지 확인하고 싶다면, 초등학생도 설명을 들으면 이해할 수 있게 설명하고 있는지 스스로 질문하고 남들에게 설명을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 13 May 2021 09:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인프런에서 강의를 만드는 팁에 대한 글을 읽어 보았다. &lt;a href=&#34;https://www.inflearn.com/pages/weekly-inflearn-28?utm_source=pinpoint&amp;amp;utm_medium=email&amp;amp;utm_campaign=weekly-inflearn&amp;amp;utm_content=28&#34;&gt;나의 첫 강의 만들기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드에 대한 좋은 글을 읽었다. &lt;a href=&#34;https://medium.com/watcha/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%AF%BF%EC%96%B4%EB%8F%84-%EB%90%A0%EA%B9%8C-3da3f337f136&#34;&gt;테스트 코드를 믿어도 될까 ?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 강의를 만들어 보면 어떨까라는 생각을 하였다. 우선 회사 회고를 할 때 발표 자료를 녹화하면서 녹화 및 발표 연습을 하면 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아키텍처를 설계할 때, 중요한 것은 원칙을 따르는 것이 아니라 무엇이 어디에, 왜 있어야하는지를 설명할 수 있는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현실의 문제는 흑백 문제와 같이 항상 맞고 틀린 경우는 없다. 따라서 결정한 방향의 이유가 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 12 May 2021 09:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;를 효율적으로 사용하는 방법에 대한 글을 읽었다. &lt;a href=&#34;https://blog.linewalks.com/archives/7428&#34;&gt;SQLAlchemy 2.0 Style 소개&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구글 엔지니어들이 어떤 문화와, 프로세스 도구를 이용해서 개발을 하는가에 대한 책을 다운 받았고, 블로그 요약을 보았다. &lt;a href=&#34;http://docs.likejazz.com/software-engineering-at-google/&#34;&gt;https://abseil.io/resources/swe-book&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 칠판 도구, 프로그램을 알게 되었다. &lt;a href=&#34;https://excalidraw.com/&#34;&gt;프로젝트를 하거나 문제를 풀 때 유용할 것 같다.&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마크다운 기반 발표 자료를 만드는 프로젝트를 알게 되었다. (Slidev)(&lt;a href=&#34;https://sli.dev/themes/use.html&#34;&gt;https://sli.dev/themes/use.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQLAlchemy 2.0 스타일로, 천천히 변경을 해야겠고, 리포지토리 형태를 변경해야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 동시에, 현재 프로젝트에서 사용하면 좋을 디자인 패턴을 소개하고 이를 적용하는 방안을 발표하는 자료를 만들어야겠다. &lt;a href=&#34;https://medium.com/zigbang/%EC%A7%81%EB%B0%A9%EC%97%90%EC%84%A0-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-a359044f5565&#34;&gt;직방에선 디자인-패턴을어떻게 이용하는가&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 11 May 2021 23:27:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서, 일이 굉장히 잘 풀렸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커의 내부 원리에 대해서, 공부하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스의 아키텍처에 대해서 공부하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;미리 풀리퀘를 날리고, 거기에 구현할 계획을 세우고 체크 박스로 하나씩 요구사항을 체크하면서 개발을 하다보니, 실수도 적어지고 내가 무엇을 해야할지 빠르게 파악할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 어떻게 구현할지에 대한 계획에 대한 고민을 좀 더 체계적으로 해야하는 필요성을 느낄 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여태까지, 도커의 명령어만 사용하면서 아키텍처에 대해서는 제대로 이해하지 못하고 있었다는 사실을 깨닫게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117834051-d0fb0780-b2b1-11eb-99b0-015dc1f2bc18.png&#34; alt=&#34;1_c3AiZFHuib7FUGyINzkEag&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리눅스가 하는 일을 보면, 크게 두 가지가 있는데 하나는 애플리케이션 자원 관리(&lt;code&gt;PID&lt;/code&gt;, &lt;code&gt;ROOT&lt;/code&gt;, &lt;code&gt;PORT&lt;/code&gt;)이고, 다른 하나는 하드웨어 자원 관리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 독립된 리눅스 환경을 보장 받는 컨테이너라는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스는 커널안에 있는 자원을 &lt;code&gt;namespace&lt;/code&gt; 라는 기능을 통해서 애플리케이션 자원을 독립화 시킬 수 있으며, 하드웨어 자원은 &lt;code&gt;cgroup&lt;/code&gt;을 이용하여 독립화 시킨다. 따라서 도커는 리눅스의 이 두 기능을 이용하여 독립된 컨테이너 환경을 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117834866-7ada9400-b2b2-11eb-977b-780c586a69b0.png&#34; alt=&#34;도커네트워크&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker0&lt;/code&gt;가 내부적으로 브릿지 역할을 한다. 그리고 컨테이너간의 통신은 가상 네트워크 인터페이스인 &lt;code&gt;veth&lt;/code&gt;를 통해서 이루어 지고, 내부적으로는 두 개의 &lt;code&gt;namespace&lt;/code&gt;를 이어주는 것이라고 보면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너 각각의 &lt;code&gt;eth0&lt;/code&gt; 인터페이스를 통해서 통신을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 하나의 컨테이너와 다른 컨테이너가 통신을 할 때, &lt;code&gt;docker0&lt;/code&gt;를 통하게 되어 다른 컨테이너로 통신이 이루어지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117835910-356a9680-b2b3-11eb-8d99-c960496207f4.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;는 쿠버네티스 안에서, 모든 로깅에 정보를 기록한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API server&lt;/code&gt;는 컨테이너를 늘리는 명령어를 비롯한 모든 명령어들을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스케줄러는 여러 서버가 있을 때, 어떤 노드에 명령어를 실행할지를 정해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POD&lt;/code&gt;은 논리적으로 애플리케이션의 묶음이고, 기본적으로 여러개의 &lt;code&gt;POD&lt;/code&gt;이 하나의 애플리케이션을 구성하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;집중하다 보면, 너무 오래 앉아있는데 일어날때마다 어지럽게 된다. 따라서, 일정 시간마다 일어나서 체력 분배를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 및 클라우드에 대한 지식 및 데브옵스 지식을 배우는 것이 전체적인 개발 스킬을 늘려줄 수 있을 것이다. 열심히 공부하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 10 May 2021 22:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117670538-f3721f80-b1e2-11eb-808b-a0ad9ba19199.jpeg&#34; alt=&#34;Unknown&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사에서 업무를 하는데, 굉장히 생산성이 안좋았다.&lt;/li&gt;
&lt;li&gt;복싱을 하니까, 굉장히 기분이 상쾌해졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;딱히 집중을 못한 것도 아닌데, 굉장히 많은 시간을 들였음에도 생산성이 높지 못했다.&lt;/li&gt;
&lt;li&gt;어느정도 코딩하기 전에 설계를 했지만, 분석하는데 많은 시간을 들이지 않아서 결국에는 다른 방식으로 구현을 바꾸느라 굉장히 많은 시간을 소모했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩하기 전에, 계획하는 습관을 들이는 이유가 구현을 하다가, 잘못된 것을 깨닫고 다시 되돌아가지 않기 위해서 하는 것이다. 많은 시간을 소모함으로써, 이를 깨닫게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 코딩하기 전에, 분석을 충분히 하고 고민을 해봐야하는 부분이 있었음에도 불구하고 코딩을 하고 있지 않는다는 불안감에 대충 어떤 방향으로 코딩을 할 것이라는 것만 적고 바로 생각이 떠오른 대로 구현을 하였다. 하지만 오늘 많은 비용을 치렀고, 뭔가 잘못되고 있다는 생각이 들때, 붙잡고 있지 말고 이것이 옳은 길이가 한번 더 생각을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주말에는 늦잠을 자거나 피곤하다는 핑계로 운동을 하지 않는데 아침에 일찍 일어나거나 저녁에 꼭 운동을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복싱 도장에서는 유산소 운동을 위주로 하는데, 주말에 근력 운동 위주로 밸런스를 맞춰야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 실력이나, 구현 능력이 부족하다고 느껴질 때가 있다. 따라서 매일 한 문제씩 알고리즘 사이트에서 문제를 풀어보는 것도 재미있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞으로 코딩을 하기 전에 계획을 할 때, 시간을 정해놓고 (예: 5분) 충분히 생각을 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발을 하다가, 뭔가가 잘못되었다는 것을 느끼면 당장 코딩을 중단하고 생각을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/09/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 09 May 2021 19:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/09/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이력서를 한달마다 작성하면 좋다는 글을 보고 이력서를 작성해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클린 아키텍처 파이썬이라는 책을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://taetaetae.github.io/2019/01/10/spring-redirect-oom/&#34;&gt;Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기&lt;/a&gt; 라는 블로그 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트를 진행할 때, 자가 진단할 수 있는 항목에 대한 영상을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 발표 영상을 보고, 다시 오픈소스 기여에 대한 열정이 타올랐다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생각보다 이력서를 작성하기 쉽지 않았고, 미리 준비를 하는게 정말로 다행이라는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;파이썬을 어떻게 해야지 제대로 사용할 수 있는지 감을 잡은 것 같다.&lt;/li&gt;
&lt;li&gt;성능 분석은 블로그에 나온 대로 정도는 해야지 제대로 한것이라는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;플라스크에서, 레이어드 아키텍처로 프로젝트를 구성하는 방법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추상화를 할 때, 웹 프레임워크는 웹을 통해서 프로그램을 이용할 수 있게 해주는 것이며 분리가 잘 되어 있다면, CLI를 통해서 비즈니스 로직의 변경없이 프로그램을 사용할 수 있도록 설계해야한다는 것을 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 역시, 관계형 데이터베이스 뿐만 아니라, NoSQL도 빠르게 바꿔서 설계해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드의 문제점을 재현해보고 직접 눈으로 확인하면서 해결하는 모습이 인상 깊었다. nGrinder로 부하를 주고, Pinpoint로 모니터링을 하고 힙 덤프를 통해서 실제로 JVM에서 FULL GC가 몇 번 일어나는지 측정까지 하고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트를 진행할 때, 아래 항목에 유의해서 개발을 계속해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;프로젝트를 자가 진단해볼 수 있는 주요 항목이다.
실제 서비스를 공개적으로 배포하고 운영해보는 경험을 해보았다.
유저의 피드백에 따라서, 성능 및 사용성을 개선해보고 신규 기능들을 추가해보았다.
발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리 해 보았다.
코드를 지속적으로 리펙토링하고 디자인 패턴을 적용해 보았다.
위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민해보았다.
반복되는 수정이과 배포에 수반되는 작업을 자동화해보았다.
언어나 프레임워크의 기능만으로 구현할 수 없는 것들을 직접 구현해보았다.
내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선해보았다.
코드나 제품의 퀄리티를 유지하기 위한 분석 툴이나 테스틑 툴을 도입해보았다.
타인과의 협업을 효율적으로 하기 위한 고민을 해보았다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;학부때 배웠던 개념이라고 하더라도, 많이 잊어버린 기초 지식들이 많았고 이를 일하면서 틈틈히 채워나가야 하는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실무와 연결시켜서 지식을 배우니까 좀 더 기억에 오래 남을 수 있었던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전산 컴퓨터 기초 지식을 다시 복습해보면서, 내가 어떤 부분이 부족한지 꾸준히 파악하고 채워나갈 수 있도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번주에는 주로, 나를 되돌아보는 계기가 된 것 같다. 나의 부족한 점을 채우기 위해서 많은 노력을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;engineer-skills핵심-역량&#34;&gt;Engineer Skills(핵심 역량)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이력서를 작성하면서 나를 제대로 파악하고 어떻게 나를 표현할 수 있을지 고민을 해봐야 겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;project-perfomance-프로젝트-주요-성과&#34;&gt;Project Perfomance (프로젝트 주요 성과)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번주에는 딱히 프로젝트에서 주요한 성과를 이룬게 없는 느낌이다. 다음주에 노력하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;li&gt;Engineer Skills (핵심 역량) 엔지니어를 평가하는 4가지 항목을 참고하여, 나의 핵심 역량을 작성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;올바른 프로젝트 방향성을 가지고 개발을 하고 있는가?&lt;/li&gt;
&lt;li&gt;엔지니어링 관점에서 좋은 개발을 하고 있는가?&lt;/li&gt;
&lt;li&gt;프로젝트의 방향성을 제시할 수 있는가?&lt;/li&gt;
&lt;li&gt;같이 일하면서, 더 큰일을 할 수 있는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Project Perfomance (프로젝트 주요 성과) 내가 회사에서 한 주간 어떤 성과를 내었는지를 평가하는 항목이다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>이력서를 작성할 때의 팁</title>
      <link>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81.html</link>
      <pubDate>Sun, 09 May 2021 18:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81.html</guid>
      <description>&lt;h2 id=&#34;이력서를-작성하게-된-이유&#34;&gt;이력서를 작성하게 된 이유&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;일반적으로 이력서는 이직할 때, 작성하지만 나는 평소에 미리미리 준비하고 싶었다.
이력서를 작성하다 보니, 매우 형편없는 것 같아서 인터넷을 찾아보았는데 아주 좋은 글들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 글을 읽어보고 나서 내 이력서의 문제점이 자세히 보이기 시작했다.&lt;/p&gt;
&lt;p&gt;틈틈히 완성도 있는 이력서를 완성시키고 무엇보다 지금부터 이력서에 내용을 적을 활동을 해야겠다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 08 May 2021 15:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 오라클 성능 고도화 SQLP 강의를 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;REDO, UNDO 로그에 대해서 배울 수 있어서 좋았다.&lt;/li&gt;
&lt;li&gt;실행 계획을 확인하는 것이 아직은 많이 어색했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;앞으로 개발을 하면서, 항상 실행 계획을 확인하는 습관을 들이고, 눈에 익숙해져야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 대해서, 나름 관심이 있다고 생각했는데 아무것도 모르고 있다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;인덱스에 대한 더 깊은 이해가 필요한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 작성한 쿼리와 인덱스가 머리속에 그림이 그려질 때까지 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>오라클 성능 고도화 강의 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1.html</link>
      <pubDate>Sat, 08 May 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1.html</guid>
      <description>&lt;h3 id=&#34;오라클-성능-고도화-강의&#34;&gt;오라클 성능 고도화 강의&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117525284-6ec5ac80-affc-11eb-8e4f-f245c5ef8828.jpeg&#34; alt=&#34;IMG_5C71B9160877-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에, 한번 튜닝 수업을 들은 적이 있었지만, 아직 경험이 부족한 상태에서 들어서 그런지 이해가 가지 않는 부분이 많았다. 실무를 조금 해보면서, 어느정도 쿼리에 익숙해진 상태에서 강의를 들으면 어떨까라는 생각이 들어서 강의를 수강하게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;sqlp-시험에-실패하는-이유&#34;&gt;SQLP 시험에 실패하는 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SQLP 시험에 실패하는 이유는 주로 글로만 학습해서 그렇다.&lt;/li&gt;
&lt;li&gt;SQLP 시험 설계는 실무 전문가임을 인정해주는 자격증이다.&lt;/li&gt;
&lt;li&gt;따라서 책으로만 학습해서 통과는 어렵고, 실무와 경험을 같이 쌓아야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-방법&#34;&gt;SQLP 시험에 합격하기 위한 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;정확히 알아야한다.&lt;/li&gt;
&lt;li&gt;상황에 따라서 답이 달라짐을 알아야한다. (DBMS 버전, 데이터 량, 데이터 분포 등등&amp;hellip;)&lt;/li&gt;
&lt;li&gt;집합적 사고를 할 줄 알아야한다. 이러한 능력은 실무에서 반복을 통해서 체화된다.&lt;/li&gt;
&lt;li&gt;모델링에 대한 이해가 같이 이루어져야한다. 따라서 모델링도 어느정도는 같이 공부를 해야한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-전략&#34;&gt;SQLP 시험에 합격하기 위한 전략&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;무조건 서술형을 다 맞춰야지 합격이 가능하다. 점수 분포가 서술형에 많은 점수가 있기 때문에 서술형을 다 맞지 않으면 합격이 힘들어진다.&lt;/li&gt;
&lt;li&gt;서술형을 먼저 풀고, 객관식을 풀고 객관식 중에서 쉬운 문제를 먼저 풀고 어려운 문제는 나중에 푼다.&lt;/li&gt;
&lt;li&gt;서술형을 답안을 작성할 때, 정확한 진단을 하고 핵심만 간결하게 그리고 절대로 길게 작성하면 안된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;chap-01-데이터베이스-아키텍처-sql-처리-과정-및-io&#34;&gt;CHAP 01. 데이터베이스 아키텍처, SQL 처리 과정 및 IO&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일단 오라클 아키텍처에 대해서, 제대로 알지 못해서 많이 당황스러웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REDO로그 및 UNDO 로그에 대해서 자세히 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버퍼 캐시 및, 버퍼 캐시 탐색 과정, 그리고 버퍼 캐시 히트율을 계산하는 방법에 대해서, 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시퀀셜 액세스와 랜덤 액세스의 원리 및 &lt;code&gt;Single Block IO&lt;/code&gt;와 &lt;code&gt;Multi Block IO&lt;/code&gt;의 차이에 대해서도 남에게 설명할 수 있을 정도로 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오라클 힌트에 대해서 자세히 공부하고 힌트가 적용되지 않는 경우에 내부적으로 쿼리가 변환되는 경우가 있는데, 이러한 경우에 대해서도 들어본 기억은 있는데 확실하게 개념이 잡혀있지는 않았다. 따라서 힌트 관련해서 많은 것을 배워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc-milti-version-concurrency-control&#34;&gt;MVCC (Milti Version Concurrency Control)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dirty Read : 다른 트랜잭션이 변경중인 데이터를 읽었는데, 그 트랜잭션이 최종 롤백 됨으로써 비일관성 상태에 놓이는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-Repetable Read : 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 값을 수정 또는 삭제 함으로써 읽은 값들이 서로 달라지는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phantom Read : 한 트랜잭션 내에서, 일정 범위의 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가함으로 인해 첫 번째 읽을 때 없던 데이터가 생기는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션이 실행 될 때, &lt;code&gt;UNDO&lt;/code&gt; 세그 먼트 헤더에 위치한 트랜잭션 테이블에서 슬롯을 할당 받는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 &lt;code&gt;UNDOO&lt;/code&gt; 레코드에는 &lt;code&gt;ITL SLOT&lt;/code&gt;이 있고, 블록에 속한 레코드 갱신을 위해서, &lt;code&gt;ITL&lt;/code&gt; 슬롯을 먼저 확보한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋이 이루어지면, 블록 클린아웃을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 클린 아웃 되지 않은 블록에 작업을 하게 되면, &lt;code&gt;SNAP SHOT TOO OLD&lt;/code&gt;가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 07 May 2021 09:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117382076-917e9500-af18-11eb-8194-2a583ab6cfa4.png&#34; alt=&#34;Screen Shot 2021-05-07 at 9 41 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큐브리드 세미나 발표에 댓글을 달았는데, 유용한 링크를 주었다. &lt;a href=&#34;https://www.cubrid.com/blog/3831726&#34;&gt;CUBRID의 개발 문화: CUBRID DBMS는 어떻게 개발되고 있을까?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.cubrid.org/dev-guide/&#34;&gt;CUBRID Developer Guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨트리뷰터에게 관심을 가져주어서 너무 좋았다. 포기하지 말고 틈틈히 소통하여, 개발을 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 하면서, 잘 모르는 부분을 그냥 넘어가는 경우가 있다. 따라서, 이 점을 유의해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 06 May 2021 08:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/PJGsPohDuoA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;포트폴리오를 작성할 때, 중점적으로 생각할 점에 대한 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 자가 진단해볼 수 있는 주요 항목이다.
&lt;ul&gt;
&lt;li&gt;실제 서비스를 공개적으로 배포하고 운영해보는 경험을 해보았다.&lt;/li&gt;
&lt;li&gt;유저의 피드백에 따라서, 성능 및 사용성을 개선해보고 신규 기능들을 추가해보았다.&lt;/li&gt;
&lt;li&gt;발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리 해 보았다.&lt;/li&gt;
&lt;li&gt;코드를 지속적으로 리펙토링하고 디자인 패턴을 적용해 보았다.&lt;/li&gt;
&lt;li&gt;위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민해보았다.&lt;/li&gt;
&lt;li&gt;반복되는 수정이과 배포에 수반되는 작업을 자동화해보았다.&lt;/li&gt;
&lt;li&gt;언어나 프레임워크의 기능만으로 구현할 수 없는 것들을 직접 구현해보았다.&lt;/li&gt;
&lt;li&gt;내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선해보았다.&lt;/li&gt;
&lt;li&gt;코드나 제품의 퀄리티를 유지하기 위한 분석 툴이나 테스틑 툴을 도입해보았다.&lt;/li&gt;
&lt;li&gt;타인과의 협업을 효율적으로 하기 위한 고민을 해보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>오픈 소스 분석 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Wed, 05 May 2021 17:30:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;h2 id=&#34;오픈-소스-분석-방법&#34;&gt;오픈 소스 분석 방법&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;머리속 한켠에는 오픈 소스 활동을 다시 하고 싶다는 생각을 가지고 있지만, 바쁘다는 핑계로 미뤄왔다. 우연히 어떤 블로그에서 &lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/#open-source%EB%9E%80&#34;&gt;오픈 소스 분석 방법&lt;/a&gt; 이라는 글을 읽고나서, 오픈 소스 개발을 하고 싶다는 생각이 들었다. 또한 오픈 소스 활동은 시간이 날때 하는 것이 아니라, 평소에 시간을 쪼개가면서, 짜투리 시간을 만들어야 가능하다는 것을 느끼게 되었다. 다음은 오픈 소스 분석하는데 좋은 팁이다.&lt;/p&gt;
&lt;h3 id=&#34;공식-문서를-통해-파악하기&#34;&gt;공식 문서를 통해 파악하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드를 분석하기 전에, 먼저 해당 솔루션에 대한 지식을 먼저 익혀야 한다. 하둡을 분석하려면, 코드를 보기 전에, 먼저 구글에서 발표한 논문을 읽어봐야 하고, &lt;code&gt;HBase&lt;/code&gt;를 분석하려면 먼저 &lt;code&gt;BigTable&lt;/code&gt; 논문을 읽어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스를 분석하기 전에, 공식 문서를 통해서 사용법을 익히면 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 나도 공감하는 내용이다. 오픈 소스라는 것이 평소에 많이 사용해보고 어떤 기능이 있는지 파악을 해야한다. 또한 이러한 기능이 생기게 된 이유 및 내부 동작 원리를 파악할 수 있으므로 공식 문서는 반드시 읽어보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자료 읽기를 먼저 해야하고, 그 뒤에 코드 분석을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아키텍처-분석-큰-숲-바라보기&#34;&gt;아키텍처 분석 (큰 숲 바라보기)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116687-9e40a300-adc9-11eb-9873-4357a112947d.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소스코드의 폴더 구성을 보면서, 대략적인 기능들과 아키텍처를 파악해볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음에는 오픈 소스의 아키텍처를 파악한 후에, 디테일한 부분으로 이동하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 모듈들이 어떤 역할을 하고 있는지 살펴보고 상호간에 어떻게 연결되어 있는지 파악하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;큰 아키텍처를 연필이나, 다이어 그램 도구로 직접 그려보면서 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분석을 할 때, 라이브러리 또는 다른 오픈 소스에 대한 지식이 필요할 때가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;디테일-분석-나무-바라보기&#34;&gt;디테일 분석 (나무 바라보기)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116755-b57f9080-adc9-11eb-8f79-d17a216cd422.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큰 숲을 파악한 후에, 디테일한 부분을 분석한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 알고리즘에 대해서는 때로는 이론 보다는 코드가 더 보기 쉬울 때가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스는 어떤 정보를 담고 있으며, 어디서 사용되는지, 그리고 어떤 방식으로 동작하는지 등을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 함수를 파악하려고 하지 말고, 조금씩 자신이 살펴보려는 기능과 관련된 함수 들을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디버거를 통해서, BP (&lt;code&gt;Break Point&lt;/code&gt;)를 걸어놓고 직접 실행해보면서, 코드의 흐름을 파악해보는 것도 많은 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수의 인풋(&lt;code&gt;Input&lt;/code&gt;)에는 어떤 데이터가 들어오고, 아웃풋(&lt;code&gt;Output&lt;/code&gt;)은 어떤 데이터를 반환하는지 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 통해서, 각 함수의 사용법 및 인풋, 아웃풋을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 분석을 빠르게 하기 위해서는 분석에 필요한 로그를 추가하여, 재 컴파일을 한 후에 실행을 해보면서 로그를 확인하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단순히 코드만 보면 특정 연산의 흐름이 어떻게 진행되고 있는지 파악하기 어려울 때가 많이 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수정, 실행, 확인 사이클을 최대한 짧게 만드는 것이 좋다. 코드를 분석하기 위해서는 분석에 필요한 정보를 출력하는 코드나 확인을 위한 코드를 추가한 후에 기능을 실행하여 확인해야하는 경우가 많다. 이 경우에, (수정, 실행, 확인)을 하는 사이클이 짧아질 수록 효율이 높아지고 작업 패턴이 있다면 이를 스크립트 형태로 만드는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 분석 방법에는 &lt;code&gt;Bottom Up&lt;/code&gt; 방식과, &lt;code&gt;Top Down&lt;/code&gt; 방식이 있다. 서로 장단점이 있고, 사람마다 스타일이 다르지만 여러명이서 같이 분석을 한다면 두 스타일을 섞어서 하되, 약간 더 레벨이 높은 사람을 한 명 끼워서 팀을 만들면 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;오픈-소스-활동을-지속하기-위한-팁-tip&#34;&gt;오픈 소스 활동을 지속하기 위한 팁 (TIP)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116845-cfb96e80-adc9-11eb-94a8-9a1bbb70c697.jpg&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포기 하지 않는 것이 중요하다!!!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자신에게 질문을 많이하는 것이 중요하다. 특정 기능에 대해서 &amp;ldquo;나라면 어떻게 개발했을까?&amp;rdquo; 라고 자신에게 질문을 던지고, 머리속에 어떻게 구현할 것인지를 먼저 생각을 해본다. 처음에는 자신이 예측한 부분이 많이 틀리겠지만 코드를 많이 보고 연습을 많이 하면 이것도 얼추 많이 맞추게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분석하면서 그림 또는 문서로 정리하면 분석하는 시점에도 도움이 되지만 나중에도 도움이 된다. 이렇게 정리하면서 중간 중간에 머리속에서만 빙빙 돌던 생각 이 정리될 때가 많고 &amp;ldquo;분석이 다 된 다음에 정리해야지&amp;quot;라는 생각이면 거의 정리는 못한다고 봐도 된다. 나중에 정리하려고 생각하면 정리도 어렵고, 잘 생각나지 않으므로 분석하면 정리하는 습관을 가지자!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;혼자서 하기 힘들면, 다른 사람들과 같이 분석하는 방법이 있고, &lt;strong&gt;힘들어도 싸이클을 정하고 싸이클을 도는 것이 중요하다!!!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 경우 혼자서 하는 것보다 함께 하는 것이 낫다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 메인테이너의 문서 및 논문, 그리고 유튜브 영상을 보는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드를 무조건 많이 보는 것이 좋다. 코드를 인쇄하여 보는 사람들도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;당장 관심있는 부분부터 집중적으로 파악하라, 방대한 시스템을 보다 보면은 금방 지루해지고, 갈 곳을 잃어버리는 수가 많은데, 당장 필요한 부분부터 집중해서 보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;느낀점&#34;&gt;느낀점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특정 기능에 대해서 &amp;ldquo;나라면 어떻게 개발했을까&amp;rdquo; 충분히 생각을 해 본 후에, 코드를 보면서 이를 확인하는 과정을 통해서, 개발 실력을 많이 높힐 수 있을 것이라고 생각을 한다. 또한 분석하면서 재미를 느낄 수 있는 포인트가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/#open-source%EB%9E%80&#34;&gt;오픈 소스 분석 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.popit.kr/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%82%98/&#34;&gt;오픈소스: 코드 분석 어떻게 하나?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 05 May 2021 16:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나의 핵심 역량 및 성취 그리고 주요 프로젝트 및 성과에 대해서 생각을 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API를 컨슈머를 위주로 작성하는 법에 대해서 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;유용한 블로그 글 및 좋은 소식을 들을 수 있는 사이트를 발견하였다. &lt;a href=&#34;https://awesome-devblog.netlify.app/&#34;&gt;어썸 데브 블로그&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://okky.kr/article/408595&#34;&gt;작은 오픈소스 프로그램을 분석해서 실력을 쌓아 나간 사례&lt;/a&gt; 라는 글을 읽어 보게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;libuv&lt;/code&gt;에 대해서 분석한 글을 읽어 볼 수 있었다. &lt;a href=&#34;https://blog.naver.com/pjt3591oo/222339028273&#34;&gt;https://blog.naver.com/pjt3591oo/222339028273&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;삼성에서 운영하는 오픈 소스 사이트 및 행사를 알게 되었다. 그리고 행사에 참여하게 되었다.&lt;a href=&#34;https://opensource.samsung.com/community/mine/mineArticle/10?lang=KR&#34;&gt;Circle-OpSelector를 설계하고 기능 추가 하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;평소에 정리를 하지 않아서 막상 생각나는 것들이 없었다. 따라서 이러한 점을 고려하면서 나의 핵심 역량 및 어떤 성취를 하였는지 그리고, 내가 맡은 주요 프로젝트에서 어떤 성과를 내었는지를 항상 생각하고, 정리를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매주마다, 나의 핵심 역량 및 회사에서 어떤 성과를 내었는지를 정리하는 시간을 가져야겠다. 이는 주간 회고에서 작성하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 회사에서 일을 하면서, 계획을 세우고 코딩을 하는 과정에서 내가 어떤 사고 과정을 거쳐서 이렇게 구현을 하게 되었는지에 대한 글을 작성해보는 것이 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API를 컨슈머 관점에서 디자인 하는 법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 채용 부분과, 토이프로젝트 부분이 많이 유용하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오랜만에 페이스북에 들어가서, 개발자 커뮤니티의 글을 읽었는데, 많은 정보가 있었다. 주기적으로 페이스북에 개발자 커뮤니티의 글을 읽고 정보를 얻어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인공지능 분야라서 잘은 모르지만, 일단 해보도록 하였다. 오픈소스 관련된 행사는 매우 드물기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실력을 어떻게 쌓을 수 있었는지에 대한 글을 읽어보았을 때, 다음의 과정을 거쳐서 실력을 쌓은 것을 확인할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 자신을 관찰하는 시간을 가졌다.
2. 자신이 가지고 있었던 과거의 사고방식의 문제점을 깨달았다.
3. 과거의 사고 방식을 버리고 새로운 사고 방식을 실천했다.
4. 배우는 과정을 일지에 기록했고, 왜(why), 어떻게(how)를 사용하여 자기 스스로 질문하고 대답하였다.
5. 위의 과정에서 자신이 생각하고 행동했던 것과 행동했던 것들이 뭐가 다른지를 관찰하여 깨달은 점을 기록하였다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117120460-53755a00-adce-11eb-931f-56dee0e7f158.png&#34; alt=&#34;사고 과정&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 진행할 때 기록하는 사고 과정을 참고 할 수 있는 내용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117120637-8cadca00-adce-11eb-980c-d2aae31de799.png&#34; alt=&#34;사고과정2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이를 통해서, 개발을 할 때 일지를 적는 것이 좋다는 것을 배우게 되었다. 또한 그냥 일지를 막 적는 것이 아니라, 리서치 한줄을 작성하더라도 그것을 &lt;strong&gt;왜 하는지 알 수 있게 작성한다.&lt;/strong&gt; 또한 &lt;strong&gt;알고자 하는 정보의 방향이나 얻을 수 있을 것이라는 효과를 미리 정하고&lt;/strong&gt; 나서 리서치를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일이 막혀서 잘 진행이 안되는 경우에는 붙잡지 말고, 빠르게 현재 상황에서 선택할 수 있는 옵션을 만들어 내자. 어떤 문제가 잘 안풀려서 일이 진행이 되지 않는 것 보다는 이를 해결할 수 있는 옵션을 만들고 선택하는 행위를 하지 않아서 일이 진행이 되지 않는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리서치를 할 때, 내가 이러한 리서치를 왜 하는지 그리고 알고자 하는 방향 및 어떤 정보를 얻기 위해서 이러한 리서치를 하는지에 대해서 미리 정해놓고 리서치를 하자. 그렇지 않으면 검색 엔진에서 옛날 처럼 많은 시간을 소모하고 허우적 댈 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항상 모든 행동을 할 때, 내가 이러한 행동을 왜하는지 그리고 어떤 목적을 가지고 하는지에 대해서 생각을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제가 안 풀릴때는 안풀린다고만 생각하지 말고 이를 해결 할 수 있는 옵션을 만들고 이를 하나씩 적용하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 04 May 2021 14:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 한 블로그 글을 읽었다.&lt;a href=&#34;https://taetaetae.github.io/2019/01/10/spring-redirect-oom/&#34;&gt;Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;네트워크 기초에 대해서 다시 공부하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드의 문제점을 재현해보고 직접 눈으로 확인하면서 해결하는 모습이 인상 깊었다. &lt;code&gt;nGrinder&lt;/code&gt;로 부하를 주고, &lt;code&gt;Pinpoint&lt;/code&gt;로 모니터링을 하고 힙 덤프를 통해서 실제로 &lt;code&gt;JVM&lt;/code&gt;에서 &lt;code&gt;FULL GC&lt;/code&gt;가 몇 번 일어나는지 측정까지 하고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;허브, 브릿지, 스위치에 대해서 알게 되었고, 각각 어느 계층에서 동작하는지를 파악하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117107370-6ed76980-adbc-11eb-9796-c8e589c83733.png&#34; alt=&#34;Screen Shot 2021-05-05 at 4 09 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;허브(L2) : 단순 브로드 캐스트를 하는 통신 장비이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브릿지(L2) : 컴퓨터와 컴퓨터간의 통신할 수 있는 통신 연결 장비이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스위치 (L2) : 여러 컴퓨터간의 통신 연결 장비를 말한다. (오류 검사, 빠른 속도, 멀티 포트 브릿지) 기능이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;라우터 (L3) : 네트워크 통신 데이터(패킷)을 네트워크 주소를 기준으로 도착지에 전달하는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;게이트웨이에 대해서 배웠는데, 이는 캐시와 같이 상대적인 개념이라는 것을 알게 되었다. 게이트웨이의 역할을 서로 다른 네트워크를 연결하는 역할로써, L3 레이어에서는 라우터가 될 수 있고 L2 레이어 관점에서는 스위치가 될 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 서브넷팅에 대한 개념에 대해서도 배울 수 있었고, &lt;code&gt;IPv4&lt;/code&gt;에 대해서도 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NAT&lt;/code&gt;에 대해서 배웠으며, 사설 IP 주소와 공인 IP 주소를 테이블을 이용하여 맵핑 해준다는 것을 배웠다. 분명히 학부 네트워크 수업때 들었던 내용이지만 생소한 내용이 많았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;학부때 배웠던 개념이라고 하더라도, 많이 잊어버린 기초 지식들이 많았고 이를 일하면서 틈틈히 채워나가야 하는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;실무와 연결시켜서 지식을 배우니까 좀 더 기억에 오래 남을 수 있었던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전산 컴퓨터 기초 지식을 다시 복습해보면서, 내가 어떤 부분이 부족한지 꾸준히 파악하고 채워나갈 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 03 May 2021 16:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 클린 아키텍처 파이썬이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 디자인에서 중요한 컨셉중에 관심사의 분리와 제어의 역전이 중요하다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;추상화를 할 때, 웹 프레임워크는 웹을 통해서 프로그램을 이용할 수 있게 해주는 것이며 분리가 잘 되어 있다면, &lt;code&gt;CLI&lt;/code&gt;를 통해서 비즈니스 로직의 변경없이 프로그램을 사용할 수 있어야한다.&lt;/li&gt;
&lt;li&gt;데이터베이스 역시, 관계형 데이터베이스 뿐만 아니라, &lt;code&gt;NoSQL&lt;/code&gt;도 빠르게 바꿔서 사용할 수 있도록 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 02 May 2021 22:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;숫자 야구를 구현하는 간단한 과제를 하였다.&lt;/li&gt;
&lt;li&gt;오픈 소스 분석 방법이라는 블로그 글을 읽었다.&lt;/li&gt;
&lt;li&gt;회사에서 성능 개선 이슈를 맡아서 진행을 하였다.&lt;/li&gt;
&lt;li&gt;회사에서 진행하고 있는 솔루션에서 개선해야할 점들을 발표 자료로 만들어서, 발표를 해보았다.&lt;/li&gt;
&lt;li&gt;파이썬으로 클린 아키텍처를 만드는 방법에 대해서, 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;장기적으로 보았을 때, 체력과 건강이 중요하기 때문에, 복싱 도장에 등록을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아직 함수나, 클래스를 나누는 연습이 많이 부족한 것을 느낄 수 있었다.&lt;/li&gt;
&lt;li&gt;회사에서 코딩을 할때, 계획을 세우고 이 계획을 꾸준히 변경하면서 코딩을 해야겠다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;시간이 없다는 핑계로 오픈 소스 활동을 하고 있지 않은데, 다른 사람들이 바쁜 와중에도 매일매일 조금씩이라도 소스 코드를 보면서, 기여를 하려는 것을 보고 많은 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;성능 개선 이슈를 진행할 때, 코드에 역할에 대해서 이해를 하지 않고 해결하려고 했던 것 같다. 따라서 앞으로는 무조건 성능을 개선하기 전에 이 코드들이 각자 어떤 역할을 하고 있는지를 먼저 파악해야겠다.&lt;/li&gt;
&lt;li&gt;내가 말하고 싶은 점들을 말 할 수 있어서 좋았고, 다른 사람들의 의견을 들을 수 있어서 좋았다.&lt;/li&gt;
&lt;li&gt;책은 PDF 형태로, 무료로 저자가 공개하였는데, 그 이유는 자신도 다른 사람들이 무료로 공개한 정보로 부터 많은 도움을 받았고 이 책을 쓸 수 있었다고 했기 때문에 무료로 공개했다고 했다. 굉장히 멋있었고 나도 이 저자처럼 나중에 책을 집필해서, 다른 사람들에게 무료로 공개할 수 있으면 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 주도 개발 방법을 사용해서 코딩을 해야겠다는 생각이 들었고, 의존성 분리가 잘 되어있지 않은 모듈에 대해서는 우선 테스트 코드를 기존의 코드를 신경쓰지 않고 작성을 한 후에, 테스트 코드가 돌아가도록 작성해보는 것도 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 내가 알고 있는 것을 공유하고 다른 사람들의 생각을 듣는 것이 매우 재미있고 배울점이 많았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 코드, 클래스, 메서드 주석을 나중에 작성하려는 마음을 먹지 말고, 무조건 먼저 작성을 하고 나서, 구현을 하자 절대로 나중에는 작성하지 않는다!&lt;/li&gt;
&lt;li&gt;회사에서 외주를 위한 API 문서를 작성하고 있는데, 기존에 있는 API 문서가 관리 되지 않아, 작업하기 많이 힘든데, 문서를 작성하면 이를 관리하여 유용한 문서가 될 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계획을 세우는 것은 계획대로 실천하기 위해서 세우는 것보다, 계획을 계속 수정하면서 방향을 잡는 것이다. 따라서 계획이 쓸데 없는 것으로 생각하지 말자.&lt;/li&gt;
&lt;li&gt;배운 것을 남들에게 공유하고, 발표를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 30 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 복싱 도장에 등록을 했다.&lt;/li&gt;
&lt;li&gt;오늘은 하루종일 API 문서만 작성했다.&lt;/li&gt;
&lt;li&gt;요즘에는 내가 배운 것들을 어떻게 공유하지라는 상상을 하곤 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;맨날 앉아만 있어서 그런지, 몸이 무겁고 작은일에도 짜증이 나고 만사가 귀찮기도 했는데 운동을 배우면서, 건강해지고 코딩도 잘 할 수 있으면 좋겠다. 공부할 시간도 없다는 핑계로 여태까지 미뤄왔는데 지금이라도 해야겠다&lt;/li&gt;
&lt;li&gt;문제를 해결하기 위해서, 줌을 하듯이 확대 축소를 할 수 있어야한다. 때로는 아키텍처만 파악하고 나서, 필요한 부분을 돋보기로 보듯이 확대해서 문제를 해결해나가자.&lt;/li&gt;
&lt;li&gt;내가 설계한 API도 아니고, 문서화도 잘 되어있지 않아서, 굉장히 힘들었다. 다음에 이러한 일이 없으려면 어떻게 API를 설계해야하는지 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들에게 공유를 하자라는 마음으로, 공부를 하고 자료를 만들다보니 더 배우는 게 많았고 머리에도 오래 남는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서화를 할 때, 나중에 내가 작성한 코드나 설계한 API를 사용할 사람을 생각하는 마음으로 작성하고, 때로는 귀찮다고 커밋 메시지를 대충 적을 때도 있는데, 이를 개선해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;운동을 꾸준히 하여 , 몸과 마음을 건강하게 할 것이다.&lt;/li&gt;
&lt;li&gt;다른 개발자들을 배려하면서, 개발을 하자 현재는 혼자 개발을 할 지라도, 나중에 언제든지 다른 개발자들이 내 소스 코드를 이용하여 개발을 이어나간다는 생각을 하고, 배려하면서 코딩하자.&lt;/li&gt;
&lt;li&gt;내가 배운 것을 적극적으로 공유하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 29 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클린코드를 플라스크에서 작성하는 법에 대한 책을 읽고 공부하였다.&lt;/li&gt;
&lt;li&gt;모바일 개발 외주를 주기 위해서, API 문서를 정리하였다. 제대로 작성하는 법에 대해서 주말에 공부하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우연히, 우아한 테크 코스 영상을 보았는데, 이를 보면서 블로그에 정리하고 실제로 녹화를 해보면서 발표 연습을 하자라는 마음을 먹었던게 기억이 났다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해야할 일을 일일 회고에는 많이 기록을 해두었는데, 막상 기억이 나지 않을 때가 있으므로, 따로 투두 리스트를 정리해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 비슷한 일로, 백기선님의 자바 강의를 듣고, 이를 기술 블로그에 정리하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파이썬으로 작성하는 클린 아키텍처 및 어떻게 테스트 코드를 작성하는 법에 대해서 배울 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출퇴근을 하는데, 많은 시간이 소모되고 있다. 따라서, 앞으로는 일찍 출근을 하여서, 이를 최대한 줄일 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;건강 관리를 지금 부터 해야지, 나이들어서도 계속 공부나 자기 개발을 할 수 있을 것 같다. 따라서 지금부터 운동을 배우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>마크다운으로 슬라이드 쇼 만드는 방법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft.html</link>
      <pubDate>Wed, 28 Apr 2021 11:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기존에 슬라이드 쇼를 만드는데, 콘텐츠에 집중하기 보다는 부가적인 요소에 집중할 때가 많았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 발표 자료는 사실, 슬라이드 디자인이 크게 영향을 미치지 않는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프레젠테이션을 만들때 드는 비용을 많이 줄여줄 수 있다고 생각을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 웹에서 동작하기 때문에, 커스터 마이징을 할 수 있고 더 실험적인 동작을 할 수 있을 것 같다. (예제 코드를 실행해보기)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래에 비슷한 툴들이 많이 있다. 따라서 이를 통해서 슬라이드를 만들어보면 좋을 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark.show/#/&#34;&gt;MarkShow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4136&#34;&gt;마크다운으로 슬라이드 쇼 만들기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jxnblk/mdx-deck#presenter-mode&#34;&gt;MDX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marpit.marp.app/markdown&#34;&gt;Marpit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 28 Apr 2021 09:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네이버에서 &lt;a href=&#34;https://d2.naver.com/news/7591059&#34;&gt;NDTI&lt;/a&gt;라는 맞춤 채용 제안을 확인할 수 있었다. 재미있고 좋은 아이디어인 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지도 서비스를 구축하는데 도움이 되는 라이브러리 및 도구를 발견하였다. 토이 프로젝트를 하는데 많은 도움이 될 것 같다. &lt;a href=&#34;https://news.hada.io/topic?id=4135&#34;&gt;OPEN STREET MAP으로 나만의 지도시스템 만들기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDD를 하는 이유 중에, 테스트를 하면서 미리 설계를 같이 하고 이를 검증해볼 수 있다는 점도 있지만 무엇보다 좋은 점은 구현을 먼저하면 테스트 코드를 귀찮아서 작성하지 않는다는 점이다. 또한 문서화도 마찬가지인데 메서드를 설명하는 코드나 클래스를 설명하는 코드를 작성할 때, 미리 클래스나 메서드를 설명하는 주석을 먼저 작성하면 나중에 귀찮아서 작성하지 않아도 되는 장점이 있고 메서드 주석을 작성하면서 내가 작성하려는 메서드의 목적과 좋은 메서드 이름을 지을 수 있는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전에 계획을 먼저 세우고 코딩을 하려고 하였지만, 구현하면서 계획이 자주 바뀌어 결국에는 원래대로 돌아가고 말았다. 하지만, 기능 구현은 기능 구현을 하면서 언제든지 바뀔 수 있다는 점을 간과한 것 같다. 또한 처음부터 모든 기능 목록을 완벽하게 정리해야한다는 것도 부담을 가지게 된 것 중에 하나인 것 같다. 따라서 처음부터 모든 기능 목록을 정리해야하는다는 부담을 가지기 보다는 기능을 구현하면서 문서를 계속 업데이트하는 방향으로 가자. 너무 학교 과제물을 제출하던 습관이 들어, 회사에서도 한번 만들면 끝이라고 생각하는데 이러한 생각은 학교에서까지만 가지고, 현실에서는 계속 꾸준하게 고쳐가는 것이 중요하다고 생각을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구조 개선을 해야한다고 외치기만 하면서, 구체적으로 어떤 부분을 어떻게 고쳐야겠다고 정리하여 &lt;code&gt;PM&lt;/code&gt;에게 구체적으로 말해본 적이 없었던 것 같다. 따라서, 제안을 하기 위해서는 구현하면서 개선해야할 점이 보이면, 틈틈히 정리를 해두고 구체적으로 어필을 해야겠다. 여태까지 구체적인 방향을 제시하지도 않으면서 불평만 하지 않았는지 되돌아봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계획을 세우고 코딩을 하되, 이 계획은 언제든지 바뀔 수 있다는 것을 명심하자. 죽어있는 계획 보다는 계속해서 살아있는 문서를 만들려고 노력하자. 또한 기능 목록을 메서드 설계나 구현과 같이 너무 상세하게 적으려고 하지 않는다. 따라서 정상적인 부부도 중요하지만, 예외적인 상황도 기능 목록에 정의한다. 특히 예외사항은 시작하는 단계에서 모두 찾기 힘들기 때문에, 기능을 구현하면서 계속해서 추가해나가도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로젝트를 진행하면서 개선할 점이 보이면, 틈틈히 정리를 해두고 다음 이관에 처리할 일감화를 시켜서 &lt;code&gt;PM&lt;/code&gt; 분들에게 나의 의견을 제시하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획을 먼저 세우고 코딩을 할 때, 계획은 항상 변화한다는 것을 명심하면서 이를 수정하면서 코딩을 해야겠다. 죽은 계획이 아니라, 살아있는 계획을 세우는 것을 목표로 하자. 참고로 이 부분은 &lt;code&gt;PULL REQUEST&lt;/code&gt;를 할 때, 토의를 할 텐데 이 부분에서 논의를 같이 하면 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나중에, 테스트 코드를 지우더라도, 먼저 테스틑 코드를 작성하고 이를 구현하는 연습을 하자, 그리고 메서드를 작성하기 전에 메서드 주석을 먼저 작성하고 이로부터 메서드의 목적과 좋은 이름을 도출해내자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 네트워크 도구 (테스트, 추적, 모니터링 명령어)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4.html</link>
      <pubDate>Wed, 28 Apr 2021 00:12:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4.html</guid>
      <description>&lt;h3 id=&#34;hping3&#34;&gt;hping3&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;hping3 -S www.daum.net -p 80
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP/UDP, ICMP 및 다양한 종류의 패킷을 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 빠른 주기로 패킷을 보내고 싶다면 &lt;code&gt;--fast&lt;/code&gt; 옵션을 줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iptables&#34;&gt;iptables&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이 명령어는 특정 IP 주소의 요청을 막을 수 있는 명령이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# localhost의 UDP 요청을 차단하는 규칙을 추가하였다.
iptables -I OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

# iptables 설정을 확인해본다.
iptables -L -n

# 다른 터미널에서 실제 요청을 보내보지만 응답이 오지 않는다.
hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast

# 위의 설정을 삭제한다.
iptables -D OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

iptables -L -n

# 요청이 정상적으로 보내짐을 확인할 수 있다.

hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 도구를 사용하는 것은 내부적으로 커널의 기능을 사용하는 것이고, 리눅스 커널 안에 넷 필터(&lt;code&gt;NET FILTER&lt;/code&gt;) 라는 기능을 이용하여 구현하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정이 늘어날수록 점점 느려진다는 단점이 있어서, 요즘에는 &lt;code&gt;BPF&lt;/code&gt;라는 툴을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nslookup&#34;&gt;nslookup&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;도메인 이름을 IP 주소로 변환해주는 명령어이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270076-bd33a980-a7b9-11eb-83fc-a8ffaef46022.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 08 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이와 비슷한 도구로 &lt;code&gt;dig&lt;/code&gt; 라는 도구가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270202-dccad200-a7b9-11eb-9f82-fa515cebecdd.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 45 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;nmap&#34;&gt;nmap&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;포트 스캔을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270489-18fe3280-a7ba-11eb-8d79-95571243f764.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 38 40 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어 및 결과는 &lt;code&gt;localhost&lt;/code&gt;에 열려있는 포트들을 터미널에 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iftop&#34;&gt;iftop&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270960-89a54f00-a7ba-11eb-9c44-38576b8ffebf.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 41 42 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bmon&#34;&gt;bmon&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271227-c113fb80-a7ba-11eb-8473-232acc8656c2.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 42 55 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;li&gt;특이한 점은 TUI 그래픽으로 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dstat&#34;&gt;dstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271795-47304200-a7bb-11eb-9aea-bbeba62def27.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 47 14 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 형태로 시스템 정보와 같이 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ss&#34;&gt;ss&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272077-8fe7fb00-a7bb-11eb-869c-6110b9b5a938.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 49 12 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;소켓의 리시브 큐와 센드 큐를 모니터링 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272413-d76e8700-a7bb-11eb-9726-d953b812550b.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 50 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>가상 파일 시스템(VFS)이란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Wed, 28 Apr 2021 00:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;가상-파일-시스템virtual-file-system&#34;&gt;가상 파일 시스템(Virtual File System)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116267696-9c6a5480-a7b7-11eb-86f3-ca2a38093928.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 20 52 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리눅스가 하는 일을 생각해보면 크게 하드웨어 자원 관리 및 소프트웨어의 자원을 관리한다고 생각을 해볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스는 이러한 자원을 파일로써 관리하게 되며 모든 것이 가상 파일 시스템을 통해서 접근하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;NGINX&lt;/code&gt; 같은 웹 서버 프로그램이 시스템 자원을 요청할 때, 시스템 콜을 호출하게 되며 (open, read, write) 이러한 자원은 가상 파일 시스템(VFS)를 통해서 자원에 접근하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MSS 그리고 MTU (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft.html</link>
      <pubDate>Tue, 27 Apr 2021 23:44:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116261520-b0f81e00-a7b2-11eb-96dd-03ae4f909358.png&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mss-maximun-segment-size&#34;&gt;MSS (Maximun Segment Size)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262109-3aa7eb80-a7b3-11eb-8648-27d4cdfb5779.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 48 40 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSS는 TCP 상에서 전송할 수 있는 사용자의 데이터(&lt;code&gt;payload&lt;/code&gt;) 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP 헤더를 제외한 데이터의 크기이다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP(L4) 계층에서 데이터의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;위의 사진을 보면, TCP 헤더를 제외한 데이터 부분을 MSS라고 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mtu-maximun-transmission-unit&#34;&gt;MTU (Maximun Transmission Unit)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262489-8bb7df80-a7b3-11eb-8254-7a56a5d13018.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 51 49 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTU는 네트워크에서 전송 될 수 있는 최대 패킷의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MTU는 IP(L3) 계층에서 패킷이라고도 불리운다.&lt;/li&gt;
&lt;li&gt;MTU에서 IP 헤더와 TCP 헤더를 제외하면 그것이 바로 MSS가 된다.&lt;/li&gt;
&lt;li&gt;MTU를 패킷이라고 부른다.&lt;/li&gt;
&lt;li&gt;참고로 L2는 프레임이라는 용어로 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;설정된-mtu-크기를-확인하는-방법&#34;&gt;설정된 MTU 크기를 확인하는 방법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116263219-27e1e680-a7b4-11eb-90c7-995a0ef1d0e5.png&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ip link&lt;/code&gt; 라는 명령어를 치면 현재 리눅스 환경에서 설정된 MTU 값을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;MTU 값이 1500 BYTES 으로 잡혀 있는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;패킷을-보내고-이를-트레이싱-해보자&#34;&gt;패킷을 보내고 이를 트레이싱 해보자&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;패킷을 보내기 위해서 &lt;code&gt;ping&lt;/code&gt; 이라는 도구를 통해서 구글 DNS 서버 (8.8.8.8)에 요청을 보내보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ping -M do -s 68 8.8.8.8&lt;/code&gt; 이 명령어는 서버에 68 바이트를 보내는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264144-03d2d500-a7b5-11eb-8d04-05da9a3b3b39.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 02 18 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사진을 보면 데이터는 68바이트를 보냈지만 실제로는 96 바이트가 전송된 것을 확인할 수 있다. 이유는 데이터에 헤더 부분이 포함되었기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추가로 &lt;code&gt;ping -M do -s 1500 8.8.8.8&lt;/code&gt; 명령어로 패킷의 최대 크기인 1500 MTU 만큼 데이터를 전송해본다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264626-6926c600-a7b5-11eb-9487-b472c8c1264a.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 05 06 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러가 발생하는 것을 확인해볼 수 있는데, 그 이유는 헤더가 포함되었기 때문이다. 하지만 이 에러는 커널 레벨에서 발생한 것은 아니고 &lt;code&gt;ping&lt;/code&gt; 도구에서 발생시킨 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 확인해보기 위해서, &lt;code&gt;ping&lt;/code&gt; 보다 많은 기능을 지원하는 &lt;code&gt;hping3&lt;/code&gt; 도구를 이용해서 테스트 해보겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f icmp -Y &amp;quot;ip.dst == 8.8.8.8 or ip.src == 8.8.8.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용해서 패킷을 캡처하고 아래 명령어를 다른 터미널에서 입력을 해본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo hping3 -d 2000 --icmp 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116265856-61b3ec80-a7b6-11eb-9333-e8b070648840.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 12 05 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 결과를 확인해 볼 수 있다. 자세히 살펴보면, 패킷이 정상적으로 전송이 된 것을 확인해볼 수 있지만 서버로 부터 응답이 오지 않는 것을 확인할 수 있다. 이로서 구글 도메인 서버에 요청할 수 있는 최대 패킷 크기는 1500 bytes 라는 것을 확인할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 2000 바이트를 데이터로 전송을 하였는데 MTU는 최대 1500 바이트이다. 따라서 패킷이 쪼개져서 전송되고 있다는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>데이트 타임 및 표준 규격에 대해서 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft.html</link>
      <pubDate>Tue, 27 Apr 2021 18:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ISO_8601&#34;&gt;ISO 8061 - WIKI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2822&#34;&gt;RFC 2822&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 27 Apr 2021 13:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UUG0h7torbs&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;출근길에, 소프트웨어 엔지니어를 평가하는 4가지 항목이라는 영상을 보았다.&lt;/li&gt;
&lt;li&gt;기존에 느리게 동작하던 코드를 개선하였다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/&#34;&gt;오픈 소스 분석 방법&lt;/a&gt; 이라는 블로그 글을 읽었다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ohgyun.com/798&#34;&gt;강연: 호갱노노 이렇게 만듭니다&lt;/a&gt; 이라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;오늘 사내 메신저에서 이해하지도 못했는데, 대충 이해했다고 생각하여 넘어갔지만, 실제로는 다른 이야기였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;성능 개선을 할 때, 코드를 이해하지 못해서 이 부분이 필요한 부분인지를 미쳐 파악하지 못했던 것 같다. 따라서, 사실 필요없는 부분 이었음에도 불구하고, 필요하다고 생각하여 어려웠던 것이다. 따라서 성능 개선을 할 때는 코드를 이해하도록 하고, 병목이 걸리는 부분이 필요한 부분인지를 먼저 파악해야할 것 같다.&lt;/li&gt;
&lt;li&gt;제대로 이해하지 못한 것을 대충 넘어가지 말고, 이해가 되지 않았다면 다시 되물어보거나 질문을 하는 자세를 가지자.&lt;/li&gt;
&lt;li&gt;오픈 소스 분석 방법이라는 글을 읽고, 다시 오픈 소스에 대한 열정이 타올랐고, 분석하는 구체적인 방법이 나와있어서 좋았다.&lt;/li&gt;
&lt;li&gt;기술 블로그를 읽다가 호갱 노노라는 회사를 알게 되었는데 내가 생각하는 개발자가 주도적인 회사인 것 같아서 너무 좋았다. 특히 개발자가 기획하는 회사라는 것이 너무 마음에 들었다. 평소에 개발자가 기획에 참여하지 못하고 어느 순간 어떤 방향으로 이미 결정이 되었을 때 같이 고민을 해보고 싶었지만 그러지 못해서 아쉬웠던 나의 마음을 알아주는 것 같았다.&lt;/li&gt;
&lt;li&gt;그리고 직군을 따로 나누지 않은 것도 너무 마음에 든다. 특히 서버 개발자가 데이터 처리나, 인프라에 접근할 수 있다는 것이 단점으로 생각되는 사람도 있겠지만 나는 장점으로 생각이 된다. 왜냐하면 내가 개발하는 서비스 위에 올라가는 환경을 알고 싶고 더 개선하고 싶은 마음이 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것을 그냥 얼렁뚱땅 넘어가지 말고, 모르면 모른 상태로 확실히 하거나 아니면 알려고 해야겠다. 모르는 것을 안다고 착각하면서 살지 말자.&lt;/li&gt;
&lt;li&gt;엔지니어를 평가하는 4가지 항목이라는 영상을 보았다. 평가하는 항목 중에는 다음과 같은 항목이 있다. (1.프로젝트 임펙트: 새로 개발한 기능이 올바른 방향으로 갈 수 있게 하는 것이 프로젝트 임펙트이다. 2.엔지니어링 엑설런스 : 새로운 기술을 도입해서 서버가 더 안정적으로 되었다. 또는 어떤 문제를 해결한 것을 말한다. 3.디렉션 : 방향을 제시할 수 있는가? 우리가 장기적으로 가야하는 방향을 제시할 수 있는 사람을 원한다. 4. 피플: 커뮤니케이션 문제 뿐만 아니라, 다른 팀들과 같이 일할 수 있는가? 다른 사람들과 더 큰일을 할 수 있는가?)&lt;/li&gt;
&lt;li&gt;위의 항목들 중에서 엔지니어링 엑설런스 능력을 주니어 프로그래머 시절에 무조건 실력을 쌓아야한다고 생각을 한다.&lt;/li&gt;
&lt;li&gt;또한 동시에 방향을 제시할 수 있는 사람이 되면 더할 나위 없이 좋을 것이다. 이관을 분기마다 하고 회고를 하는데, 이때 프로젝트를 경험하면서 공유하면 좋을 점들을 발표할 수 있는 기회가 있다. 이때 발표 자료와 내가 이야기하고 싶은 점들을 잘 이야기하면, 팀에게 좋은 방향을 제시할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;그리고 내가 가장 부족하다고 생각되는 점 중에하나가 바로 피플이다. 다른 팀들과 아직은 점접이 많이 없고 선배가 소통을 주로 하기 때문에 큰 장애는 없는데 이제 곧 연차가 쌓이면 이러한 능력도 무시할 수 없을 것이다. 회사에서 대인 관계가 좋은 사람들을 보고 배울점을 배워야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;성능 개선을 할 때 기본인 이 코드가 과연 필요한 부분인지를 생각하고, 코드를 어떻게 개선할까 생각하기에 앞서서 현재 코드를 제대로 이해하고 있는지를 먼저 파악해야겠다.&lt;/li&gt;
&lt;li&gt;내가 개발자로서 이루고 싶은 목표중에 오픈 소스 메인컨트리뷰터가 되는 목표가 있었는데, 관심있고 좋아하는 프로젝트를 꾸준히 살펴보고 사용하면서 내가 기여하는 자세를 평소에 길러야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 26 Apr 2021 23:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;과제를 끝냈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 한 번 더 느낄 수 있었다.&lt;/li&gt;
&lt;li&gt;객체지향적인 코딩 실력이 부족한 것을 느낄 수 있었고, 자바 실력을 더 키워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 미리 계획을 세우고 코딩을 하면서 내가 놓친 부분이 있지 않는지 생각을 하면서 코딩을 해야겠다.&lt;/li&gt;
&lt;li&gt;기존 회사 소스코드 의존성 때문에 테스트 코드를 작성하기 힘들다는 핑계를 대면서 테스트 코드를 작성하는 것을 미루었는데, 지금부터라도 테스트 코드를 작성하려고 노력하면서 좋은 설계를 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD 방식으로 개발을 하면서, 코딩 실력을 늘리려고 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;코딩을 하기 전에, 미리 계획을 세우고 계획대로 코딩을 하는 연습을 지금부터 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 기회에 부족함을 느끼고 성장했다고 생각을 하자.&lt;/li&gt;
&lt;li&gt;내가 너무 건방졌던 것 같다. 따라서 지금부터라도 회사에서 코딩을 하기 전에 미리 계획을 세우고 코딩을 하는 연습을 하자.&lt;/li&gt;
&lt;li&gt;또한, 어떻게 방식으로 코딩을 하는 것 보다 무엇을 방식으로 코딩을 하는 연습을 한다면 실력을 더 빨리 키울 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 25 Apr 2021 22:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근 시간에 개발 유튜브 영상을 시청하였다.&lt;/li&gt;
&lt;li&gt;코드를 작성할 때, 더 빨리 자주 실패하라는 문구를 잊어버린 느낌이었다.&lt;/li&gt;
&lt;li&gt;정신이 없다는 핑계로, 동료가 물어보는 질문에 생각하지 않고 답변을 해버려서 잘못된 정보를 전달하였다.&lt;/li&gt;
&lt;li&gt;파라미터에 여러가지 인자를 많이 전달하지 말라는 유튜브 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발 유튜브 영상중에 하나가 코딩을 할 때, 어떻게에 집중해서 코딩을 하지 말고 무엇을에 집중해서 코딩을 하라는 것이었다. 내가 작성한 코드를 뒤돌아보았을 때 어떻게 코딩을 할지 집중해서 코딩된 것이 많았던 것 같다. 따라서 코딩을 하는 의도를 드러낼 수 있게 무엇을에 집중해서 코딩을 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;코딩을 잘하려면, 많이 배우는 것도 중요하지만 많이 해보는 것 또한 중요하다. 따라서 토이 프로젝트를 계속 해나가야한다.&lt;/li&gt;
&lt;li&gt;아무리 바뻐도 확인을 하고, 순간 헷갈린다면, 확인해보고 답변을 준다는 식으로 말하거나, 바쁘다고 말하고, 지금 상태를 상대방에게 이야기하자.&lt;/li&gt;
&lt;li&gt;현재 회사 소스코드에 이러한 코딩이 많이 되어있는데, 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 방식으로 코딩하는 것은 절차지향 방식으로 코딩을 하는 것이고, 무엇을에 집중해서 코딩을 하는 것은 함수형에 가깝게 코딩을 하는 것이다.&lt;/li&gt;
&lt;li&gt;많이 해보고, 많은 실패로부터 배우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 의식적으로, 내가 구현에 집중해서 코드를 작성하고 있지는 않은가 되돌아봐야겠다.&lt;/li&gt;
&lt;li&gt;파이썬 코드를 공부하면서, 대충 구현하지 말고, 언어에서 정석이 있는지 찾아고보고 항상 더 좋은 방법이 있는지를 생각하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 좋은 코드에 대해서 생각을 하고, 현재 바뻐서 그냥 지나쳤던 코드라도, 메모를 해두고, 고쳐야할 코드라는 것을 표시하자.&lt;/li&gt;
&lt;li&gt;어떻게 하면, 코드를 더 좋은 구조로 개선시키킬 수 있는지 고민을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 23 Apr 2021 23:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클린 파이썬이라는 책을 읽었다.&lt;/li&gt;
&lt;li&gt;배포날이 다가오니까, 야근을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확실히 베스트 프랙티스를 보니까, 그동안 작성되었던 코드들의 개선사항이 눈에 보였다.&lt;/li&gt;
&lt;li&gt;아직은 회사 생활을 할만하다고 느끼지만, 구조를 개선하려는 노력이 없어서 아쉽고, 코드가 망가지는 것을 볼 때마다 가슴이 아프다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 하면, 코드를 깔끔하게 개선할 수 있고, 구조를 더 좋게 만들 수 있을지를 고민해봐야겠다.&lt;/li&gt;
&lt;li&gt;다른 회사에서는 이러한 상황에 처해있을 때, 어떻게 변화를 하는지 알아봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;불편함에 익숙해지지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 22 Apr 2021 22:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/MIYwej-VodE&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;오늘 출근을 할 때, 프로그래밍 왕초식 시리즈중에 하나인 왕파라미터를 사용하지 말자라는 영상을 보았다.&lt;/li&gt;
&lt;li&gt;오늘은 회사에서 코딩을 할 때, 비교적 일이 잘 풀린 편인 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에서 코드를 작성할 때, 위와 같은 왕파라미터를 사용하는 경우를 많이 보았고  이 경우에, 파이썬에서 지원하는 네임드 튜플을 사용하면 좋겠다는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;이제 마지막 이슈만을 남겨 놓고 있다. 이 이슈를 잘 처리하여 문제 없이 이관을 할 수 있으면 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍 언어를 사용할 때, 제대로 된 정석을 사용하려고 노력하고, 조금씩 코드를 발전시켜 나가자.&lt;/li&gt;
&lt;li&gt;틈틈히 파이썬 공부를 하면서, 최대한 파이썬 언어의 특징을 살려서 개발을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 코드를 대충 작성하지 않고, 사소한 부분이라도 가능한 최선을 다해서 작성할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 21 Apr 2021 23:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 정신이 없어서 생각하지 않고 동료에게 잘못된 정보를 전달하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아무리 바뻐도, 확인을 완전히 하고 전달을 해야겠다.&lt;/li&gt;
&lt;li&gt;구현을 할 때 일정을 고려해서 코딩하는 것과 정석대로 구현하는 것의 균형을 잡기 어렵다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;최대한 기존 소스 코드에 영향을 주지 않는 방향으로 구현을 해야하는 것인지 아니면, 과감하게 구현해야할때는 언제인지가 궁금했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아무리 바쁘더라도, 제대로 확인을 하고 정보를 전달하고 헷갈린다면 확인해보고 알려준다고 말을 하자.&lt;/li&gt;
&lt;li&gt;상대방이 무엇을 원하는지 이해가 되지 않는다면 이해가 되지 않는다고 말하자, 그냥 내가 이해한게 맞겠지라고 생각하고 말하면 안될 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확인을 하고, 정보를 전달하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신과정 추적해보기 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft.html</link>
      <pubDate>Tue, 20 Apr 2021 23:51:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft.html</guid>
      <description>&lt;h3 id=&#34;추적-과정&#34;&gt;추적 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;추적하기 전에 클라이언트와 서버 코드를 컴파일 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;client.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define MAXLINE 1024

int main(int argc, char **argv) {
        struct sockaddr_in serveraddr;
        int server_sockfd;
        int client_len;
        char buf[MAXLINE];

        if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                perror(&amp;quot;error : &amp;quot;);
                return 1;
        }
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
        serveraddr.sin_port = htons(4000);

        client_len = sizeof(serveraddr);

        if(connect(server_sockfd, (struct sockaddr*)&amp;amp;serveraddr, client_len) == -1) {
                perror(&amp;quot;connect error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        read(0, buf, MAXLINE);
        if(write(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;write error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        if(read(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;read error: &amp;quot;);
                return 1;
        }
        close(server_sockfd);
        printf(&amp;quot;server:%s\n&amp;quot;, buf);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;server.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

#define BUFF_SIZE 1024

int main(void){
   int server_socket;
   int client_socket;
   int client_addr_size;
   struct sockaddr_in server_addr;
   struct sockaddr_in client_addr;
   char buff_rcv[BUFF_SIZE+5];
   char buff_snd[BUFF_SIZE+5];

   server_socket = socket(PF_INET, SOCK_STREAM, 0);
   if(-1 == server_socket){
      printf( &amp;quot;server socket 생성 실패n&amp;quot;);
      exit( 1);
   }

   memset(&amp;amp;server_addr, 0, sizeof(server_addr));
   server_addr.sin_family     = AF_INET;
   server_addr.sin_port       = htons(4000);
   server_addr.sin_addr.s_addr= htonl(INADDR_ANY);

   if(-1 == bind(server_socket, (struct sockaddr*)&amp;amp;server_addr, sizeof(server_addr))){
      printf( &amp;quot;bind() 실행 에러n&amp;quot;);
      exit(1);
   }

   while(1){
      if(-1 == listen(server_socket, 5)){
         printf( &amp;quot;대기상태 모드 설정 실패n&amp;quot;);
         exit(1);
      }

      client_addr_size  = sizeof( client_addr);
      client_socket     = accept( server_socket, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_size);

      if (-1 == client_socket){
         printf( &amp;quot;클라이언트 연결 수락 실패n&amp;quot;);
         exit(1);
      }

      read (client_socket, buff_rcv, BUFF_SIZE);
      printf(&amp;quot;receive: %s\n&amp;quot;, buff_rcv);

      sprintf(buff_snd, &amp;quot;%ld : %s&amp;quot;, strlen(buff_rcv), buff_rcv);
      write(client_socket, buff_snd, strlen(buff_snd)+1);          // +1: NULL까지 포함해서 전송
      close(client_socket);
   }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 소스 코드를 복사하여, 파일을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -pg -g -o client client.c
gcc -pg -g -o server server.c
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;그리고 위의 명령어를 통해서 컴파일을 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uftrace&#34;&gt;UFTRACE&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115418135-35d3bc80-a234-11eb-898d-50f3f8eb093e.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 57 42 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서는 &lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;ufrace&lt;/a&gt;를 이용하여 함수를 추적할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UFTACE는 C/C++로 작성된 프로그램의 실행을 추적하고 분석하는 도구이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;uftrace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신에 대해서 알아보자...</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90....html</link>
      <pubDate>Tue, 20 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90....html</guid>
      <description>&lt;h3 id=&#34;tcp-transmission-control-protocol&#34;&gt;TCP (Transmission Control Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115409556-cf976b80-a22c-11eb-9c4c-c2f61110b0e2.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 IP 네트워크를 통해서 통신하는 호스트에서 실행되는 애플리케이션 간에 신뢰할 수 있고, 순서가 정해져있으며, 오류를 체크하고 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;월드 와이드 웹, 이메일, 원격 관리, 파일 전송과 같은 주요 인터넷 애플리케이션은 전송 계층의 일부인 TCP에 의존한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/TLS 또한 TCP 위에서 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 인터넷 프로토콜 (IP)과 작동하여 컴퓨터가 서로 데이터 패킷을 보내는 방법을 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-맺는-과정&#34;&gt;연결을 맺는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411131-2d788300-a22e-11eb-8557-0eb3e42d1096.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN: 클라이언트가 서버에 SYN를 전송한다. 클라이언트는 세그먼트의 시퀀스 번호를 임의의 값으로 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN-ACK: 응답으로 서버는 SYN-ACK로 응답을 한다. 수신된 시퀀스 보다 많은 숫자로 설정 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACK: 마지막으로 클라이언트가 서버에 다시 ACK를 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정을 통해서 서버와 클라이언트는 연결을 맺으며 &lt;code&gt;3 Way HandShake&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;직접 확인하기&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f &amp;quot;tcp port 80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 명령어를 입력하여 포트 번호 80의 TCP 패킷들을 필터링 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이어서 다른 터미널에서 &lt;code&gt;curl www.google.com&lt;/code&gt; 으로 구글 서버에 요청을 날린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414010-a2e55300-a230-11eb-8c2d-07636049b212.png&#34; alt=&#34;today&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정상적으로 연결이 맺어진 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-끊는-과정&#34;&gt;연결을 끊는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411888-d58e4c00-a22e-11eb-82d0-c47393198d7f.png&#34; alt=&#34;520px-TCP_CLOSE svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 종료하는 과정은 &lt;code&gt;4 Way HandShake&lt;/code&gt; 라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 끊겼음에도 클라이언트에서 &lt;code&gt;TIME WAIT&lt;/code&gt;을 하는 이유는 지연되거나 유실된 패킷이 뒤늦게 전송되는 경우가 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;확인해보기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414505-0c656180-a231-11eb-98de-cdabc90dba20.png&#34; alt=&#34;4way&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 했던 것과 같이 패킷을 캡처링 했을 때, 실제로 위와 같은 과정으로 커넥션을 끊는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-헤더-구조&#34;&gt;TCP 헤더 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115412590-6bc27200-a22f-11eb-85e4-619fcac22d79.png&#34; alt=&#34;header&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 전송하는 SYN 패킷과 ACK 패킷은 TCP 헤더에서 위치에 해당하는 비트가 켜져서 전송된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-연결이-맺음과-끊어짐에-따른-소켓의-변화&#34;&gt;TCP 연결이 맺음과 끊어짐에 따른 소켓의 변화&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415800-294e6480-a232-11eb-85f8-ad556e694641.png&#34; alt=&#34;1920px-Tcp_state_diagram_fixed_new svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 맺고 끊을 때마다 소켓의 내부 상태가 변하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트에서 요청을 보내기 위해서 소켓을 생성할 때 파일 디스크립터가 생성되며 연결을 끊고 싶을 때 파일을 닫게 되며, FIN 패킷을 날리게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415367-d07ecc00-a231-11eb-86cb-2b5c569c07f1.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 40 13 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch -n0.6 &amp;quot;netstat -atnp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 watch 명령어를 통해서 0.6초마다 netstat의 결과를 모니터링 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, CURL을 통해서 서버에 요청을 날리면 클라이언트 소캣의 상태를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34;&gt;Transmission Control Protocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 20 Apr 2021 17:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;더 빨리 자주 실패하자라는 원칙을 잊어버린 느낌이었다.&lt;/li&gt;
&lt;li&gt;최근에 시청하였던 왕 파라미터 금지라는 소프트웨어 원칙을 파이썬에서 네임드 튜플을 이용하여 지킬 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 할 때 자꾸 생각만 하고 코딩을 하지 않는 것 같다. 따라서 의도적으로라도 코딩을 계속하려는 노력을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 코딩을 해야한다. 완벽한 구조는 계속 만들어가는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지금 당장 완벽한 코딩을 하려고 하지 말고, 계속 발전시켜나가자! 때로는 무식하더라도 토이프로젝트 만큼은 구현하면서 생각을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 19 Apr 2021 12:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/4xg4OeGzGIw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
 출근 시간에 위의 영상을 시청하였다.&lt;/p&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한번도 무엇과 어떻게에 대해서 생각을 하면서 코딩한 적이 없는데, 신선한 충격이었고, 가독성을 높히기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;무엇을 할지와 어떻게 할지는 다르다는 것을 알게 되었고, 가독성을 위해서 무엇을 할지에 대해서 생각을 하면서 코딩을 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 의식적으로 무엇을 하려고 하는지 생각을 하면서 코딩해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가독성 있는 코딩을 하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 18 Apr 2021 20:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기대했던 결과가 나오지 않아서 조금 실망하기는 했다.&lt;/li&gt;
&lt;li&gt;졸업 작품으로 했던 프로젝트를 다시 만들어가고 있다.&lt;/li&gt;
&lt;li&gt;네트워크에 대한 기반 지식이 부족한 것을 알게 되었서, 관련된 공부를 하면서 기본기를 쌓고 있다.&lt;/li&gt;
&lt;li&gt;자바스크립트 프로토타입에 대해서 세미나 준비 및 세미나를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그래도 내가 어떤 점이 부족하고, 채워가야하는지 시야가 넓어져서 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;평소에 발표 연습을 많이 하고, 녹화하면서 안좋은 습관들을 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;다시 한번 복습하며서, 부족한 점을 채워나가고 있다.&lt;/li&gt;
&lt;li&gt;세미나때 너무 빨리 끝나지 않을까 걱정을 했는데, 생각보다 반응이 좋고, 질문을 많이 해주셔서 딱 맞게 끝난 것 같다.&lt;/li&gt;
&lt;li&gt;발표를 하기 전에는 스트레스를 많이 받았는데, 발표가 끝나니 재미있었고 아쉬웠다. 다음에도 기회가 있으면 발표를 해야겠다고 느꼈고, 공유하면 좋을 점들을 평소에 PPT로 만들어서 혼자서 영상을 제작하거나, 직접 발표를 해도 되겠다고 물어봐도 좋을 것이다.&lt;/li&gt;
&lt;li&gt;토이프로젝트를 하면서, 문제를 겪은 점과 이를 해결하는 과정을 PPT로 만들고 공유하는 것도 재미있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표하는 것에 대해서 너무 내 자신을 과대평가 했던 것 같다.&lt;/li&gt;
&lt;li&gt;요즘 할일을 미루는 습관 및 시간을 가치있게 사용하지 못하고 있는데, 이러한 점을 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본기가 튼튼한 개발자가 될 것이다. 그리고 현재 부족한 기본기는 네트워크인데, 이를 제대로 알기 위해서 노력해야겠다.&lt;/li&gt;
&lt;li&gt;발표를 잘하는 개발자가 되어서, 나중에 컨퍼런스에서 발표를 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SHADOW DOM 이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Thu, 15 Apr 2021 22:07:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM&#34;&gt;Using shadow DOM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 15 Apr 2021 18:23:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자바스크립트 세미나 발표를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많이 부족한 세미나 발표였음에도 불구하고 열심히 들어주셔서 고마웠다.&lt;/li&gt;
&lt;li&gt;세미나를 하기 전에는 많은 걱정을 하였지만, 막상 하고 나니까 속이 후련하고 다음에 한 번 더 하고 싶은 마음이 생겼다.&lt;/li&gt;
&lt;li&gt;사람들의 호응이 많을 때, 발표자로서 힘이 나는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확실히 문서를 기반으로 발표를 하는 것 보다는 프레젠테이션으로 발표를 하는게 더 효과가 좋은 것 같았다.&lt;/li&gt;
&lt;li&gt;발표를 할 때, 사람들의 궁금증을 이끌어 낼 수 있도록 프레젠테이션을 작성하고 역으로 질문을 하는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;평소에 정리한 내용을 발표할 수 있도록 블로그 글을 프레젠테이션 형식으로 만들어보는 것도 재미있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;발표준비가 제대로 되어있지 않을 때 발표를 하면서 헷갈리고, 자신감이 떨어지게 된다. 따라서 제대로 아는 부분을 발표하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발표를 하기 전에, 연습을 많이 안했던 것 같다. 막상 발표할 때 연습대로 되지 않는 것은 알지만, 그래도 연습을 하면서 발표 실력을 늘릴 수 있도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 연습을 많이 하고, 평소에 관심있던 주제로 프레젠테이션을 만들고 공유하는 연습을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;이제 토이 프로젝트에 집중해서 내가 만들고 싶은 소프트웨어를 만들어봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>디바운스란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft.html</link>
      <pubDate>Wed, 14 Apr 2021 18:54:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;디바운스란&#34;&gt;디바운스란?&lt;/h3&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>DNS란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 23:15:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;dnsdomain-name-system&#34;&gt;DNS(Domain Name System)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;내가-활용중인-dns-ip-주소-확인하기&#34;&gt;내가 활용중인 DNS IP 주소 확인하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567743-7bc9d700-9cae-11eb-82f9-9dcf503ef717.png&#34; alt=&#34;dns&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 내가 사용하고 있는 &lt;code&gt;DNS&lt;/code&gt; 서버의 &lt;code&gt;IP&lt;/code&gt; 주소를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568053-c4819000-9cae-11eb-8d25-3a8be64a3411.png&#34; alt=&#34;dns-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에 명령어를 통해서 나온 주소를 구글에 검색하면, 어떤 &lt;code&gt;DNS&lt;/code&gt; 서버를 사용하는지 대략적으로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns-동작과정-추적하기&#34;&gt;DNS 동작과정 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568459-1b876500-9caf-11eb-8ffb-d43a61af1ffe.png&#34; alt=&#34;dns-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568479-1e825580-9caf-11eb-8d1e-4165d8c43077.png&#34; alt=&#34;dns-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위와 같은 과정을 통해서, DNS 서버에 요청하고, 도메인 주소를 통해서 &lt;code&gt;IP&lt;/code&gt; 정보를 받아오는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114569074-a4060580-9caf-11eb-9311-dff133504ae0.png&#34; alt=&#34;flush&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemd-resolve --flush-caches
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;DNS 캐시 정보를 지우고 싶다면 위의 명령어를 입력하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ARP란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;arpaddress-resolution-protocol&#34;&gt;ARP(Address Resolution Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;L2(데이터 링크 계층) 통신 프로토콜이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IP&lt;/code&gt; 네트워크 주소를 데이터 링크 프로토콜에서 사용하는 하드웨어 주소(Mac ADDRESS)에 맵핑하기 위해서 사용하는 프로토콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565725-84211280-9cac-11eb-9fa7-fef4c8b44361.png&#34; alt=&#34;arp&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arp -n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 명령어를 통해서, ARP 테이블을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;arp-패킷-추적하기&#34;&gt;ARP 패킷 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566386-2ccf7200-9cad-11eb-8ace-088abe48ea0e.png&#34; alt=&#34;arp-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 패킷 추적을 시작한다. 그리고 MAC 주소를 확인하기 위해서 &lt;code&gt;PING&lt;/code&gt; 명령어를 자신의 IP 주소로 보내며, 네트워크 패킷이 호출되는 것을 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566398-2fca6280-9cad-11eb-9b7e-13eb549a4a3c.png&#34; alt=&#34;arp-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566393-2e993580-9cad-11eb-8886-2ee5ee935ad9.png&#34; alt=&#34;arp-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffff:ffff:ffff는 목적지 주소를 나타내며, 브로드 캐스트의 의미이다. 바로 뒤에오는 주소가 바로 송신지의 주소이며 목적지의 MAC 주소를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567037-d0b91d80-9cad-11eb-81a4-dc9aea24b583.png&#34; alt=&#34;arp-4&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MAC&lt;/code&gt; 주소를 확인하면, 나의 &lt;code&gt;MAC&lt;/code&gt; 주소와 일치하는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ICMP란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;icmpinternet-control-message-protocol&#34;&gt;ICMP(Internet Control Message Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;L3(네트워크 계층) 통신 프로토콜로서, 라우터를 포함한 네트워크 장치가 다른 IP 주소와 통신을 할 때 성공 또는 실패를 나타내는 오류 메시지 및 운영정보를 보내는데 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흔히 사용하는 &lt;code&gt;PING&lt;/code&gt; 명령어가 &lt;code&gt;ICMP&lt;/code&gt; 프로토콜을 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564433-45d72380-9cab-11eb-88c5-8529a0adb7ee.png&#34; alt=&#34;ping&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;네트워크-패킷-추적하기&#34;&gt;네트워크 패킷 추적하기&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install tshark
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력하여 &lt;code&gt;tshark&lt;/code&gt;를 설치한다, 네트워크 패킷 분석을 할 수 있는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565051-e299c100-9cab-11eb-8c29-8c0c4a1f914f.png&#34; alt=&#34;ping-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력해서, &lt;code&gt;ICMP&lt;/code&gt; 패킷을 분석을 시작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564927-c3029880-9cab-11eb-8081-63f0837202a8.png&#34; alt=&#34;ping-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제로 &lt;code&gt;PING&lt;/code&gt;을 8.8.8.8 주소로 날리게 되면, 패킷 추적이 되는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>MAC 주소란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:21:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;mac-주소란&#34;&gt;MAC 주소란?&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mac-주소-알아내는-법&#34;&gt;MAC 주소 알아내는 법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114561564-a0bb4b80-9ca8-11eb-822e-f5123ca09728.png&#34; alt=&#34;mac&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용하면 사용하고 있는 하드웨어의 &lt;code&gt;MAC&lt;/code&gt; 주소 및 네트워크 카드 &lt;code&gt;ID&lt;/code&gt;, 제조사를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>라우팅이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:20:48 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;라우팅이란&#34;&gt;라우팅이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 패킷이 목적지를 찾아가기 위한, 최적의 경로이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요청한-서버까지-라우터를-추적하는-방법&#34;&gt;요청한 서버까지 라우터를 추적하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114563693-98fca680-9caa-11eb-85d8-1ea7de69d92a.png&#34; alt=&#34;router&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 서버까지 굉장히 많은 라우터를 거쳐간다는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;네이버 서버에 요청하였을 때는 보안상의 이유로 라우터가 가려진 것을 확인할 수 있다. 모든 라우터의 주소를 확인할 수 있는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>웹 클라이언트(브라우저) 부터 웹서버까지의 구조 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114560424-a5333480-9ca7-11eb-9929-ae4566a72689.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 주소를 입력하면 &lt;code&gt;HTTP&lt;/code&gt; 통신이 일어나게 되고, DNS 서버에서, 도메인 주소를 &lt;code&gt;IP&lt;/code&gt; 주소로 변환하는 요청을 하게 된다.&lt;/li&gt;
&lt;li&gt;IP 주소를 알아내면, 라우터를 통해서 &lt;code&gt;TCP / IP&lt;/code&gt; 통신을 하게 된다.&lt;/li&gt;
&lt;li&gt;웹 서버에 도착했을 때는 최종적으로 &lt;code&gt;HTTP&lt;/code&gt; 통신이 이루어지게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 13 Apr 2021 21:23:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크에 대해서 공부를 하였다.&lt;/li&gt;
&lt;li&gt;자바 스크립트 세미나 자료를 작성하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크에 대한 지식이 부족함을 알게 되었고, 부족한 점을 채우기 위해서 노력해야겠다는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;생각보다 대략적으로 알고 있는 내용이 많았고, 제대로 알고 넘어가야하는 점이 많다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;생각보다 발표준비를 할 시간이 많이 남지 않았다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 지식이 나중에 문제를 해결할 때 많은 도움을 줄 것이라고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 기본기가 부족한 부분이 어디인지를 파악할 필요성을 느끼게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본기가 튼튼한 프로그래머가 되어서, 문제를 해결할 수 있는 개발자로 성장할 것이다.&lt;/li&gt;
&lt;li&gt;리더십과 책임감이 있는 개발자로 성장할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>문서화를 코드로 관리하는 법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft.html</link>
      <pubDate>Tue, 13 Apr 2021 15:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114509642-b745b080-9c70-11eb-95f6-f5083a8b8f5e.jpg&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에 프로젝트를 진행할 때는 문서화에 대한 고민이 정말로 많았다. 왜냐하면 요구사항은 나날이 변경되는데, 요구사항에 맞춰서 문서화를 변경하는 일은 손이 많이가고 귀찮은 일이었기 때문이다. 또한 변경사항이 변경할 때마다, 어느 부분을 어떤 이유로 수정하였는지 추적하기도 힘이 들었다.&lt;/p&gt;
&lt;p&gt;따라서 추후에 프로젝트를 다시 시작할 때 무조건 문서화를 코드에 가깝게 두려고 노력을 했다. 또한 깃으로 상태 관리를 할 수 있었으면 좋겠다는 생각을 하기도 하였다. 그러던 중에, &lt;code&gt;plantuml&lt;/code&gt; 이라는 도구를 알게 되었다. 이 도구는 아키텍처를 도식화할 때 사용할 수 있는 툴로써 다양한 다이어그램을 그릴 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://plantuml.com/ko/&#34;&gt;Plantuml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kroki.io/&#34;&gt;Kroki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>윈도우 함수에서 WHERE 절을 사용하지 못하는 이유(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft.html</link>
      <pubDate>Tue, 13 Apr 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learnsql.com/blog/window-functions-not-allowed-in-where/&#34;&gt;Why Window Functions Are Not Allowed in WHERE Clauses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 12 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 친구랑 같이 밥을 먹었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예상은 했지만, 그래도 기대를 해서 그런지 기분이 조금 꿀꿀한 하루였다.&lt;/li&gt;
&lt;li&gt;친구랑 밥먹으면서 얘기를 하니까 기분이 조금은 풀렸다.&lt;/li&gt;
&lt;li&gt;오늘 일이 쉽게 풀려서 기분이 좋았다. 목표한 기간내에 마감을 할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 알 수 있는 소중한 기회였다.&lt;/li&gt;
&lt;li&gt;진행하고 있는 프로젝트를 열심히 해보고, 꾸준히 해야겠다. 매주 일요일마다. 조금씩 하는 것을 계획하고 있다.&lt;/li&gt;
&lt;li&gt;프로젝트를 제대로 하여서, 실패한 졸업 작품을 키우면 좋겠다고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 실력을 키우기&lt;/li&gt;
&lt;li&gt;일을 미루지 않기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일을 미루지 않고 하기로 계획한 일은 바로바로 실행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 11 Apr 2021 12:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우아한 형제들에서 일하고 있는 박재성 개발자의 10년차 이상의 개발자는 어떤 준비를 하면 좋을까라는 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사에서 이슈를 처리하다가, 각각의 이슈의 경우에는 해결이 되었지만, 그 이슈들이 조합되어서 나타났을 때의 상황을 고려하지 못했던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전에 레디스에서 &lt;code&gt;Sorted Set&lt;/code&gt;이 어떻게 구현되어있는지 궁금해서 직접 찾아보고, &lt;code&gt;SKIP LIST&lt;/code&gt; 자료구조를 이용해서 구현을 했다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 다른 사람들을 이끌고 설계할 수 있는 리더십 역량이 필요할텐데 시니어 때가 되서 부랴부랴 준비하려면 늦을 것 같다. 따라서, 미리 발표 능력 및 내가 생각하고 있는 것들을 글로 조리있게 작성할 수 있는 연습을 하고, 항상 큰 그림을 볼 수 있게 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브랜치를 만들 때, 기존에 작업한 내용이 다른 이슈에 영향을 줄 것 같다면, 다른 이슈로 분리가 되어있다고 하더라도, 밑에 이전에 구현했던 이슈를 깔고 구현해야겠다는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SKIP LIST&lt;/code&gt;에 대해서 공부를 하고 나서, 이러한 개념을 직접 구현을 하려고 할 때, 어디서부터 구현을 해야하는지 막막했다. 그리고 어떤 개념을 배웠다고 하더라도, 이를 코딩으로 구현하는 능력이 부족하다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 내가 알고 있다고 생각한 것을 발표하고 이를 녹화하였는데, 매우 형편없이 말하고 있다는 것을 알게 되었다. 따라서 발표를 잘 하기 위해서 연습을 해야겠다는 생각을 했고, 이를 녹화하면서 내가 얼마만큼 발전했는지 측정하면 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기술 세미나를 볼 때, 기술 적인 내용뿐만 아니라, 이 사람이 어떻게 발표하고 있는지에 대해서 유심히 살펴보게 된 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설계나, 개념을 구현하는 능력을 미리미리 키워야겠다는 생각을 했다. 이는 알고리즘 문제를 풀면서 증가시킬 수 있다고 생각할 수도 있지만, 조금은 다른 것 같다. 처음에는 학부때 배웠던 알고리즘의 의사코드나, 개념에 대해서 공부하고 이를 내가 코드로 옮길 수 있는지를 측정해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우선은 발표 실력을 늘리고, 자주 발표를 하고 녹화하면서 피드백을 얻어야겠다.&lt;/li&gt;
&lt;li&gt;목표를 달성하기 위한 구체적인 방법을 세워야겠다는 것을 느끼게 되었다. 예를 들어서, 막연하게 영어를 잘해야지, 코딩을 잘해야지 보다는 구체적인 목표를 세우고 이를 달성하기 위해서 구체적인 노력을 하는게 목표를 이룰 가능성이 높을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들 앞에서 발표를 잘하고, 의사소통을 잘 할 수 있는 개발자가 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 10 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 다시 마음을 다잡고 공부를 이어가야겠다.&lt;/li&gt;
&lt;li&gt;사내 세미나 준비를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 주말에 재충전을 하였고, 다시 앞으로 나갈 힘을 얻은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많은 것을 배울 수 있었으며, 나에게 현재 어떤점이 부족한지를 파악할 수 있었다.&lt;/li&gt;
&lt;li&gt;사내 세미나 준비를 하면서, 나의 발표 실력을 키울 수 있는 기회로 삼아야겠다.&lt;/li&gt;
&lt;li&gt;영어 공부를 하여서, 인생에서 내가 선택할 수 있는 선택지를 늘려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한점을 파악했으니, 이제 그것을 채우기 위해서 노력하자.&lt;/li&gt;
&lt;li&gt;운동을 꾸준히 하여, 건강 상의 문제가 없도록 하고 스트레스 관리를 하여 일을 열심히 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 실력 및 부족한 점을 키워야겠다.&lt;/li&gt;
&lt;li&gt;운동을 꾸준히 하여, 건강 및 스트레스 관리를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 08 Apr 2021 09:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정신없는 하루를 보냈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 주말에 재정비를 하고, 다시 앞으로 나가야할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;평소에 준비를 하지 않으면 기회를 잡을 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상황에 닥쳐서 하지 말고, 미리미리 준비하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 기술 블로그에 내가 배운 것들을 차곡차곡 준비할 것이다.&lt;/li&gt;
&lt;li&gt;어떤 기술을 익힐 때, 내부 원리에 대해서 이해하려고 노력할 것이다.&lt;/li&gt;
&lt;li&gt;나는 평소에 발표 실력을 키워서 내가 가지고 있는 생각이나 지식을 조리 있게 말할 수 있도록 할 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주키퍼란 무엇인가? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft.html</link>
      <pubDate>Thu, 08 Apr 2021 08:53:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zookeeper.apache.org/&#34;&gt;What is ZooKeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>카프카란 무엇인가? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft.html</link>
      <pubDate>Thu, 08 Apr 2021 08:19:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/0974525&#34;&gt;KafkaConsumer Client Internals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE-LOCK(2PL)이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Wed, 07 Apr 2021 18:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;two-phase-lock&#34;&gt;TWO PHASE LOCK&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949645-b4028d00-984a-11eb-98e5-e1d592569831.png&#34; alt=&#34;100518_0439_DBMSConcurr1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949641-b238c980-984a-11eb-8ae0-64619edcf82c.png&#34; alt=&#34;2PL&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PC(TWO PHASE COMMIT)&lt;/code&gt;과 헷갈리는 개념이 있다. 그것은 바로 &lt;code&gt;2PL(TWO PHASE LOCK)&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2단계 잠금 프로토콜은 트랜잭션 도줌에 락을 걸어서 동일한 데이터에 동시에 접근하려는 트랜잭션을 차단하여 직렬화를 보장하는 &lt;code&gt;DBMS&lt;/code&gt;의 동시 제어 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt;의 동시성 문제를 해결하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 잠금 프로토콜은 트랜잭션의 실행 단계를 세 단계로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 번째 단계에서는 트랜잭션이 실행되기 시작할 때 필요한 락에 대한 권한을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 부분은 트랜잭션이 모든 락 권한을 얻는 부분이다. 트랜잭션이 첫 번째 락을 해제할 때 세번째 단계가 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 세 번째 단계에서는 트랜잭션이 새로운 락을 요청할 수 없으며, 대신 획득한 락을 해제할 수 만 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;2PL&lt;/code&gt;에서는 각 트랜잭션이 두 단계로 락 획득 또는 해제 요청을 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Growing Phase&lt;/strong&gt;: 이 단계에서는 오직 잠금을 획득할 수 있고, 해제할 수는 없다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shrinking Phase&lt;/strong&gt;: 이 단계에서는 트랜잭션이 잠금을 해제할 수는 있지만 새로운 잠금을 획득하지는 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PL&lt;/code&gt; 프로토콜 방식은 직렬화는 보장하지만, 교착 상태가 발생하지 않도록 보장하지 못한다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/two-phase-locking-protocol/&#34;&gt;Two Phase Locking protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.guru99.com/dbms-concurrency-control.html#5&#34;&gt;dbms-concurrency-control&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 07 Apr 2021 09:01:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전에 레디스에 구현되어 있는 &lt;code&gt;SORTED SET&lt;/code&gt; 연산이 어떻게 구현되어 있는지 찾아보다가, &lt;code&gt;SKIP LIST&lt;/code&gt; 까지 조사하게 되었다. 대충 돌아가는 구현은 파악하였지만, 실제 구현된 코드를 보고 이해하기는 힘들었고, 내가 이를 실제로 코드로 구현할 생각을 하니까 자신이 없었다.&lt;/li&gt;
&lt;li&gt;발표 연습을 위해서 내가 어떤 주제를 가지고 발표를 하려는데, 잘 정리된 발표 자료가 필요했다. 물론 내가 발표할 주제에 맞게 구성을 변경할 수는 있지만, 내용이 탄탄해야했다. 그러던 중에 적합한 사이트를 발견하였다. (GeeksforGeeks)[https://www.geeksforgeeks.org/two-phase-locking-protocol/]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;따라서 이때 부터 개념을 내가 실제로 코드로 옮길 수 있는 능력을 키워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;논문에 나와있는 개념을 익혀서 실제로 코드로 옮기는 작업을 전부터 해보고 싶다는 생각을 하였다.&lt;/li&gt;
&lt;li&gt;어떤 개념을 보고 나서 구현하는 능력이 부족함을 느끼게 되었고, 어떻게 하면 이러한 능력을 키울 수 있을지를 고민해보았다.&lt;/li&gt;
&lt;li&gt;어떤 개념에 대해서 매우 잘 정리가 되어있고, 데이터베이스 뿐만 아니라 컴퓨터공학 기반 지식에 대해서 잘 정리가 된 사이트이다. 이러한 사이트를 참조하여 학습하고 발표를 하면 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113792124-22c6e400-9780-11eb-9f2a-a0a5914eeb5f.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 능력을 키우려면 우선 &lt;code&gt;The Art of Computer Programming&lt;/code&gt; 책에 나와있는 의사 코드를 보고 코드로 옮기는 연습부터 해야겠다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;이러한 과정이 익숙해진다면, 나중에 논문에 나와있는 의사 코드를 보고 실제 코드로 구현할 때 많은 도움이 될 것 같다.&lt;/li&gt;
&lt;li&gt;그냥 막연히 시간이 지나면 좋아질 것이라고 착각했던 것 같다. 내가 현재 키우고자 하는 발표 능력, 구현 능력, 개발자 리더십은 시간이 지나면서 저절로 키워지지 않는다.&lt;/li&gt;
&lt;li&gt;따라서, 목표에 도달하기 위한 구체적인 방법이 있어야 한다. 발표 능력의 경우에는 특정 주제를 학습하고 이를 발표하는 영상을 녹화함으로써, 키운다. 구현 능력의 경우에는 우선은 알고리즘 책에 의사코드를 보고 직접 구현을 함으로써 키워나간다. 마지막으로 개발자 리더십의 경우에는 어떻게 키워야할지 생각이 나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘의 개념을 익히고 실제 코드에 녹여낼 수 있는 연습을 하고, 이러한 능력을 갖추기 위해서 노력할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 06 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 이슈를 처리하는데 느낀게 많았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 이슈 각각의 구현을 끝내고 나서, 고려할 사항이 끝났다고 생각했는데 이슈들이 조합될때의 경우를 고려하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이슈는 각각으로 나누어져 있어도 사실, 이슈가 조합되면 내가 예상하지 못하는 버그가 생길 수 있다는 점을 염두해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 05 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근길에 박재성님의 &lt;a href=&#34;https://www.youtube.com/watch?v=93qrbRRPZUU&#34;&gt;10년차 이상의 개발자는 어떤 준비를 하면 좋을까?
&lt;/a&gt; 영상을 보았다.&lt;/li&gt;
&lt;li&gt;오늘 기술 주제를 가지고, 설명을 하는 과정을 녹화하고 녹화된 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 리더십 역량이 필요할 날이 올텐데 미리 준비하면 좋을 것 같다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;우선 발표 실력부터 늘리고, 내 생각을 남에게 논리적으로 표현할 수 있어야 겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;설명을 할 때는 완벽하지는 않아도 설명을 그럭저럭 했다고 생각했는데, 녹화된 영상을 보니까 논리가 하나도 맞지 않고 횡설 수설 하였다.&lt;/li&gt;
&lt;li&gt;그리고 설명을 하다 보니, 목소리가 기어들어가고, 자신감도 없어 보여 집중할 수 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시니어 개발자가 된다면 어떤 능력이 필요할 지 생각을 해보게되었다.&lt;/li&gt;
&lt;li&gt;실제 내가 발표하는 과정을 녹화하고 녹화된 영상을 시청하여  피드백을 스스로 얻거나, 남에게 얻는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;최근에 발표하는 것을 연습하다보니까 기술 세미나를 볼 때, 그저 기술적인 내용을 보는 것 뿐만 아니라 이 사람이 어떻게 말하고 있는지, 시선처리는 어떻게 하는지 그리고 어떤 방식으로 발표하는지에 대해서 보이는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;책상에 앉아서 모니터를 보고 발표하는 것보다, 실제 프로젝터나, 큰 스크린 앞에서 발표하는 것은 또 다를 것이다. 따라서 이를 연습하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꾸준하게 내가 발표하는 것을 녹화하고, 내가 배운 것을 실제로 발표하면서 제대로 알고 있는지 검증하자.&lt;/li&gt;
&lt;li&gt;시선처리와 제스처, 그리고 발성이 중요하다는 것을 알고 이를 연습하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GC(Garbage Collector) 종류 및 내부 원리</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</link>
      <pubDate>Sun, 04 Apr 2021 20:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC.html</guid>
      <description>&lt;p&gt;모든 자바 애플리케이션은 JVM(&lt;code&gt;Java Virtual Machine&lt;/code&gt;) 위에서 작동한다. 따라서, &lt;code&gt;JVM&lt;/code&gt;이 작동하는데 있어서 메모리 구조와 &lt;code&gt;GC&lt;/code&gt;는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 맺고 있다.&lt;/p&gt;
&lt;h3 id=&#34;gc란-무엇인가&#34;&gt;GC란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GC(Garbage Collection)는 자바 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C/C++&lt;/code&gt; 같은 언어는 메모리를 할당하고 직접 해제해야했지만, 자바에서는 &lt;code&gt;GC&lt;/code&gt;를 이용하여 개발자들이 메모리 관리를 비교적 신경쓰지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-메모리-영역&#34;&gt;JVM 메모리 영역&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507707-1deb1000-9587-11eb-9ab6-2bbe0091be87.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GC&lt;/code&gt;의 동작 방법을 이해하려면, 먼저 자바의 메모리 구조를 이해할 필요가 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 애플리케이션에서 사용되는 객체는 오래 유지되는 객체보다 잠시 사용되는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507754-5a1e7080-9587-11eb-91e9-f14a446cb441.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바에서는 크게 두 영역으로 메모리를 구분한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Young&lt;/code&gt; 영역과 &lt;code&gt;Old&lt;/code&gt; 영역인데, &lt;code&gt;Young&lt;/code&gt; 영역은 생성된지 얼마 되지 않은 객체들을 저장하는 장소이고 &lt;code&gt;Old&lt;/code&gt; 영역은 생성된지 오래된 객체를 저장하는 장소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;영역&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;New/Young 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;이 영역은 자바 객체가 생성되자마자 저장되고 생긴지 얼마 안 된 객체가 저장되는 곳이다. 자바 객체가 생성되면 이 영역에서 저장되다가 시간이 지남에 따라서 우선 순위가 낮아지면 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮겨진다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Old 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;New/Young&lt;/code&gt; 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어서 저장되는 영역이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Perm 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Class, Method 등의 코드가 저장되는 영역으로, JVM에 의해서 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jvm이-메모리를-관리하는-방식&#34;&gt;JVM이 메모리를 관리하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508143-4c69ea80-9589-11eb-84be-2ec3ff175995.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;New/Young&lt;/code&gt; 영역을 &lt;code&gt;Minor GC&lt;/code&gt; 라고 부른다. &lt;code&gt;New/Young&lt;/code&gt; 영역은 &lt;code&gt;Eden / Survivor&lt;/code&gt; 이라는 두 영역으로 또 나뉘게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 영역은 자바 객체가 생성되자마자 저장되는 곳이다. 이렇게 생성된 객체는 &lt;code&gt;Minor GC&lt;/code&gt;가 발생할 때 &lt;code&gt;Survivor&lt;/code&gt; 영역으로 이동하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt; 영역은 &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 두 영역으로 나뉘는데, &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor1&lt;/code&gt;에 활성 객체를 &lt;code&gt;Survivor2&lt;/code&gt;로 복사한다.&lt;/li&gt;
&lt;li&gt;활성이 아닌 객체는 자연스럽게 &lt;code&gt;Survivor1&lt;/code&gt;에 남아있게 되고, &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Eden&lt;/code&gt; 영역을 클리어 한다. (결과적으로 활성 객체만 &lt;code&gt;Survivor2&lt;/code&gt;)로 이동하게 된 것이다.&lt;/li&gt;
&lt;li&gt;다음번 &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 같은 원리로 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 영역에서 활성 객체를 &lt;code&gt;Survivor1&lt;/code&gt;으로 이동시키게 된다. 계속 이런 방식을 반복하면서 &lt;code&gt;Minor GC&lt;/code&gt;를 수행한다.&lt;/li&gt;
&lt;li&gt;이렇게 &lt;code&gt;Minor GC&lt;/code&gt;를 수행하다가 &lt;code&gt;Survivor&lt;/code&gt; 영역에서 오래된 객체는 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮기게 된다.&lt;/li&gt;
&lt;li&gt;이러한 방식의 &lt;code&gt;GC&lt;/code&gt; 알고리즘을 &lt;code&gt;Copy &amp;amp; Scavenge&lt;/code&gt; 라고 한다. 이 방식은 속도가 매우 빠르며 작은 크기의 메모리를 콜렉팅하는데 매우 효과적이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Minor GC&lt;/code&gt;의 경우에는 자주 일어나기 때문에 &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 짧은 알고리즘을이 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;full-gc&#34;&gt;FULL GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508252-e3cf3d80-9589-11eb-9792-a038da5850d1.jpg&#34; alt=&#34;java-gc-29-638&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Old&lt;/code&gt; 영역의 가비지 컬렉션을 &lt;code&gt;Full GC&lt;/code&gt; 라고 부르며 &lt;code&gt;Full GC&lt;/code&gt;에 사용되는 알고리즘을 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘은 객체들의 참조를 확인하면서 참조가 연결되지 않은 객체를 표시한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 표시하고 이 표시된 객체를 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Full GC&lt;/code&gt;는 속도가 매우 느리며, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 도중에는 순간적으로 자바 애플리케이션이 멈춰버리기 때문에, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 정도와 시간은 애플리케이션의 성능과 안정성에 아주 큰 영향을 미친다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc가-중요한-이유&#34;&gt;GC가 중요한 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;가비지 컬렉션 중에서 마이너 GC의 경우에는 보통 0.5 이내에 끝나기 때문에 큰 문제가 되지 않지만, 그러나 FULL GC의 경우에는 자바 애플리케이션이 멈춰 버리기 때문에, 문제가 될 수 있다.&lt;/li&gt;
&lt;li&gt;멈추는 동안 사용자의 요청이 큐에 들어있다가, 순간적으로 요청이 한꺼번에 들어오기 때문에 과부하에 의한 여러 장애를 만들 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 원활한 서비스를 위해서는 &lt;code&gt;GC&lt;/code&gt;가 어떻게 일어나게 하느냐가 시스템의 안정성과 성능에 큰 변수로 작용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-gc-알고리즘&#34;&gt;다양한 GC 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;앞에서 설명한 방식 말고도 다양한 &lt;code&gt;GC&lt;/code&gt; 방법을 제공하고 있다. 방식은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Default Collector&lt;/li&gt;
&lt;li&gt;Parallel GC for young generator&lt;/li&gt;
&lt;li&gt;Concurrent GC for old generator&lt;/li&gt;
&lt;li&gt;Incremental GC (Train GC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;default-collector&#34;&gt;Default Collector&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 설명했던 전통적인 GC 방식으로, Minor GC로 &lt;code&gt;Scanvenge&lt;/code&gt;를 Full GC로 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508603-f8acd080-958b-11eb-9c89-f025df1daab9.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자바는 멀티 스레드 환경을 지원하지만, 하나의 CPU에서는 동시에 하나의 스레드 밖에 수행할 수 없어서 예전에는 하나의 CPU에서만 GC를 수행하였지만 후에 하나의 CPU에서 동시에 여러 개의 스레드를 실행할 수 있는 하이퍼스레딩 기술이나 여러개의 CPU를 동시에 장착한 하드웨어의 보급으로 하나의 하드웨어에서 동시에 여러 개의 스레드를 수행할 수 있게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parallel GC&lt;/code&gt;에는 크게 두 가지 종류의 옵션을 가지고 있는데, &lt;code&gt;Low-pause&lt;/code&gt; 방식과 &lt;code&gt;Throughput&lt;/code&gt; 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Low-pause&lt;/code&gt; 방식은 GC가 일어날 때 애플리케이션이 멈추는 현상을 최소화하는데 역점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Throughput&lt;/code&gt; 방식의 &lt;code&gt;Parallel&lt;/code&gt; GC는 마이너 GC가 발생하였을 때 되도록이면 신속하게 수행하도록 &lt;code&gt;throughput&lt;/code&gt;에 중점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;concurrent-gc&#34;&gt;Concurrent GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC 즉, Old 영역을 GC하는데 시간이 길고 애플리케이션이 순간적으로 멈춰버리므로, 애플리케이션이 멈추는 현상을 최소화 하는 GC 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full GC에 소요되는 작업을 애플리케이션을 멈추고 진행하는 것이 아니라, 일부는 애플리케이션이 돌아가는 단계에서 수행하고 최소한의 작업만을 애플리케이션이 멈췄을 때 수행하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;incremental-gc-train-gc&#34;&gt;Incremental GC (Train GC)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Train GC&lt;/code&gt;라고도 불리는 &lt;code&gt;GC&lt;/code&gt; 방식은 의도는 &lt;code&gt;Full GC&lt;/code&gt;에서 의해서 애플리케이션이 멈추는 시간을 줄이기 위한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동은 &lt;code&gt;Minor GC&lt;/code&gt;가 일어날 때마다 &lt;code&gt;Old&lt;/code&gt; 영역을 조금씩 &lt;code&gt;GC&lt;/code&gt; 해서 &lt;code&gt;Full GC&lt;/code&gt;가 발생하는 횟수나 시간을 줄이는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Incremental GC&lt;/code&gt;는 많은 자원을 소모하고 &lt;code&gt;Minor GC&lt;/code&gt;를 자주 일으켜서, 그리고 &lt;code&gt;Incremental GC&lt;/code&gt;를 사용한다고 &lt;code&gt;Full GC&lt;/code&gt;가 없어지거나 그 횟수가 획기적으로 줄어드는 것이 아니다. 오히려 느려지는 경우가 많으므로 반드시 테스트를 거치고 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc-로그-수집-방법&#34;&gt;GC 로그 수집 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;에서는 GC 상황에 대한 로그를 남기고자 옵션을 제공하고 있다.&lt;/li&gt;
&lt;li&gt;자바 옵션에 &lt;code&gt;-verbosegc&lt;/code&gt; 라는 옵션을 주면 되고, &lt;code&gt;&amp;gt;&lt;/code&gt; 리다이렉션 명령어를 통해서 파일로 저장하고 분석할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509041-6659fc00-958e-11eb-92e2-bc0633609ea6.png&#34; alt=&#34;자바&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위는 스프링 부트로 만든 간단한 웹 애플리케이션이다. 이를 터미널에서 &lt;code&gt;jar&lt;/code&gt; 파일로 만들어 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;./gradlew bootjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509104-b6d15980-958e-11eb-8a43-07b56114335a.png&#34; alt=&#34;jar&#34;&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 생성이 되면, 다음과 같은 경로에 &lt;code&gt;jar&lt;/code&gt; 파일이 생성된다. 터미널을 통해서 이 경로로 이동한다.&lt;/p&gt;
&lt;p&gt;그런 후에 다음과 같은 명령어를 터미널에서 실행 시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar -verbosegc app.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509189-26474900-958f-11eb-836f-e70adb0a34ac.png&#34; alt=&#34;Screen Shot 2021-04-04 at 9 45 53 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러면 애플리케이션이 실행되자마자 &lt;code&gt;GC&lt;/code&gt;와 관련된 로그들이 출력된다.&lt;/li&gt;
&lt;li&gt;마이너 GC는 &amp;ldquo;GC&amp;quot;로 표기되고, FULL GC는 &amp;ldquo;FULL GC&amp;quot;로 표기된다.&lt;/li&gt;
&lt;li&gt;그 다음의 값은 &lt;code&gt;HEAP SIZE BEFORE GC&lt;/code&gt;인데, GC전의 힙 사용량 (New/Young 영역 + Old 영역 + Perm 영역의) 크기를 나타낸다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 GC가 발생한 후의 HEAP 사용량이다. 마이너 GC가 발생하였을 때는 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor&lt;/code&gt; 영역을 &lt;code&gt;GC&lt;/code&gt; 하게 되므로 &lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 Old 영역의 용량과 유사하다.&lt;/li&gt;
&lt;li&gt;마지막 값은 &lt;code&gt;GC&lt;/code&gt;에 소요된 시간을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-gc-튜닝&#34;&gt;JVM GC 튜닝&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;step-1-애플리케이션의-종류-및-튜닝-목표값을-설정&#34;&gt;STEP 1. 애플리케이션의 종류 및 튜닝 목표값을 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JVM 튜닝을 할 때 가장 중요한 것은 튜닝의 목표를 설정하는 것이다.&lt;/li&gt;
&lt;li&gt;메모리를 적게 사용하는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt; 횟수를 줄이는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 문제인지, 애플리케이션의 성능(&lt;code&gt;Throughput or Response Time&lt;/code&gt;) 향상이 목표인지를 먼저 정하고 나서 목표치에 근접하도록 &lt;code&gt;JVM&lt;/code&gt; 파라미터를 조정하는 것이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-2-힙크기와-perm-크기-설정&#34;&gt;STEP 2. 힙크기와 &lt;code&gt;Perm&lt;/code&gt; 크기 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-ms, -mx 옵션을 이용해서 힙 크기를 정한다. 일반적으로 서버 애플리케이션은 ms와 mx크기를 같게 하는 것이 메모리의 &lt;code&gt;Growing&lt;/code&gt;와 &lt;code&gt;Shrinking&lt;/code&gt;에 의한 불필요한 로드를 막을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ms&lt;/code&gt;와 &lt;code&gt;mx&lt;/code&gt; 크기를 다르게 하는 경우는 애플리케이션의 시간대별 메모리 사용량이 급격하게 변화가 있는 애플리케이션에 효과적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-3-테스트와-로그-분석&#34;&gt;STEP 3. 테스트와 로그 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; 옵션에 &lt;code&gt;GC&lt;/code&gt;로그를 수집하기 위한 &lt;code&gt;-verbosegc&lt;/code&gt; 옵션을 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nGrinder&lt;/code&gt;와 같은 스트레스 테스트 도구로 애플리케이션에 스트레스를 주어서, 그 로그를 수집한다.&lt;/li&gt;
&lt;li&gt;튜닝에 있어서 가장 중요한 것은 목표 산정이지만, 그만큼이나 중요한 것은 실제 튜닝한 파라미터가 애플리케이션에 어떤 영향을 주는지를 테스트 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-4-perm-크기-조정&#34;&gt;STEP 4. Perm 크기 조정&lt;/h4&gt;
&lt;h4 id=&#34;step-5-gc-수행-시간-분석&#34;&gt;STEP 5. GC 수행 시간 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC가 일어나는 횟수가 많아서 &lt;code&gt;Old&lt;/code&gt; 영역을 늘려주면, Full GC 가 일어나는 횟수가 줄어들 것이고, 반대로 Full GC 수행 시간은 늘어날 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 서버 애플리케이션은 Full GC가 일어날 때는 &lt;code&gt;JVM&lt;/code&gt; 자체가 멈춰버리기 때문에 일정 시간동안 응답을 못하는 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 애플리케이션에서 Full GC가 적게 일어나게 하고, Full GC 시간을 양쪽 다 줄이려면 &lt;code&gt;Old&lt;/code&gt; 영역의 메모리를 줄이고 여러 개의 인스턴스를 동시에 띄워서 로드 밸런싱을 해주면 부하가 분산된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇게 되면, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 횟수가 줄어들게 되며 &lt;code&gt;Old&lt;/code&gt; 영역을 줄였기 때문에 Full GC가 수행되는 시간 또한 줄어든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 하나의 서버 인스턴스가 멈춰있는 동안 로드 밸런싱이 되는 다른 서버가 응답하고 있기 때문에 &lt;code&gt;Full GC&lt;/code&gt;로 인하여 애플리케이션이 멈추는 상황에서 받을 영향을 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-6-파라미터-변경&#34;&gt;STEP 6. 파라미터 변경&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 영역의 허용 범위를 기준으로, &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역을 적절하게 조절한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Perm&lt;/code&gt; 크기와 &lt;code&gt;New&lt;/code&gt; 영역의 배분(Eden, Survivor) 영역을 조정한다.&lt;/li&gt;
&lt;li&gt;가장 중요한 것은 &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역의 비율을 어떻게 조정하는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;향상 포인트&lt;/th&gt;
&lt;th&gt;GC 알고리즘&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Perfomance (속도)&lt;/td&gt;
&lt;td&gt;Parallel GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Concurrent GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Incremental GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반&lt;/td&gt;
&lt;td&gt;Default GC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>그림으로 공부하는 IT 인프라 구조를 읽고나서 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90.html</link>
      <pubDate>Sun, 04 Apr 2021 20:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507344-cd72b300-9584-11eb-9235-ec9bbdfc400a.jpg&#34; alt=&#34;k642736774_1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데브옵스 팀이 따로 있기 때문에, 실무에서 인프라 지식을 접할 기회가 별로 없었다. 따라서 이 책을 읽게 되었다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 시스템을 구축하는 기반 지식들을 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;특히 웹 데이터 흐름이라는 파트가 많은 도움이 되었는데, 내가 어떤 웹 사이트에 접속을 하였을 때, 내부적으로 어떻게 동작하는지 알 수 있었다.&lt;/li&gt;
&lt;li&gt;특히 네트워크에 대한 지식이 많이 부족했는데, 네트워크의 흐름에 대해서 알게 되었다.&lt;/li&gt;
&lt;li&gt;다양한 계층에서의 이중화 전략에 대해서 알게 되었다. 현재 나에게도 도움이 많이 되었던 책이지만, 나 말고도 많은 신입 개발자들에게 많은 도움이 될 것 같다.&lt;/li&gt;
&lt;li&gt;나중에 후배들이 들어와서 내게 좋은 책을 추천해줄 수 있냐고 물어볼 때 주저없이 이 책을 추천해줄 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=257114341&#34;&gt;그림으로 공부하는 IT 인프라 구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 04 Apr 2021 15:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서버 성능 튜닝 및 성능 개선에 관련된 책을 읽었다.&lt;/li&gt;
&lt;li&gt;구글 번역기 관련 이슈가 발생하였다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서가 업데이트 되지 않는 문제가 있어서, 이를 수정하는 작업을 하였다.&lt;/li&gt;
&lt;li&gt;사내 세미나가 거의 코 앞으로 다가 왔다.&lt;/li&gt;
&lt;li&gt;예전에 리눅스 공부 및 정리한 내용을 블로그에 옮겨서 적어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서버 성능 튜닝을 제대로 이해하려면 학부 때 배운 운영체제 지식 및 데이터베이스에 대한 이해가 필수라는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;이론으로만 배운 지식이 어떤 원리로 나타나는지 확인하는 과정이 재미있었다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 스트레스 관리를 잘하는 것도 중요하다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;최근에 무리해서 밤을 새워서 어떤 공부를 하였는데, 그러니까 몸에 힘도 없고 우울했다.&lt;/li&gt;
&lt;li&gt;처음에는 원인을 찾기 힘든 이슈를 서서히 범위를 좁혀나가고 결국에, 원인을 파악하고 실제 이슈를 해결하니까 뿌듯했다.&lt;/li&gt;
&lt;li&gt;코드랑 &lt;code&gt;API&lt;/code&gt; 문서가 떨어지니까 많이 힘들었고, 올바르게 작성되지 않은 &lt;code&gt;API&lt;/code&gt;를 수정하고 싶은 마음이 들었다.&lt;/li&gt;
&lt;li&gt;같은 팀에 새롭게 입사한 분이 생겼는데, 그 분에게 배울 점이 있는 사람이라고 느껴지고 싶었다. 따라서 제대로 발표하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;학부 때 배운 운영체제, 네트워크, 데이터베이스에 대한 깊은 지식을 배우고 이를 실제로 옵션 값이나 눈으로 확인하면서 익히는 것이 재미도 있고 기억에도 오래 남는 것 같다.&lt;/li&gt;
&lt;li&gt;톰캣 AP 서버나, &lt;code&gt;JVM&lt;/code&gt;의 내부 동작 원리 및 &lt;code&gt;GC&lt;/code&gt; 원리에 대해서 공부를 해야겠다는 마음을 먹었다.&lt;/li&gt;
&lt;li&gt;좋은 컨디션으로 꾸준히 공부하는 것이 중요하다. 급하다고 단기간에 무리해서 공부하면 길게 가지 못하고 공부를 하면서 재미도 없는 것 같다.&lt;/li&gt;
&lt;li&gt;오픈 소스 커뮤니티에서 원인 분석 및 해결책이 이미 나와있었지만, 만약 나와있지 않고 내가 첫번째로 버그를 발견한 상태라면 조금 많이 헤매였을 것 같다. 따라서 직접 원인 분석 및 해결책을 알려면 평소에 내부를 어떻게 분석할 수 있는지 파악할 수 있는 능력이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 올바르게 작성하고, 사용자들이 어떻게 하면 더 쉽게 이해할 수 있을지를 고민하고 작성하자.&lt;/li&gt;
&lt;li&gt;발표를 연습하기 위해서는 꾸준하게 많이 연습을 하는 것이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;실제로 내가 배운 것을 설명할 때 생각처럼 말이 쉽게 나오지는 않았다. 그리고 설명하면서 내가 제대로 알 고 있지 못하다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;발표를 할 때, 내용도 중요하지만, 청중을 집중시키는 능력 또한 중요한 것 같다. 이를 위해서는 자신감 있게 발표하는 것이 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;발표 연습을 할 때, 완벽한 준비 또는 준비할게 많다는 핑게로 자꾸 미루는 것 같다. 따라서 발표 연습을 꾸준하게 하려면, 작게나마 연습하는 것이 중요한 것 같다. 예를 들어서, 발표 자료를 준비하지 않고 책을 읽었다면 한 챕터에 대해서 요약을 해보는 것 부터 시작하는 것이다. 이를 통해서 나의 생각을 정리할 수 있고 내가 모르는 것이 있는지 체크 해 볼 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;연습을 할 때 가능한 스스로 그림을 그려가면서, 다른 사람들에게 설명할 것을 추천한다고 나와있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인내심을 가지고, 프로그래밍 및 기반 지식을 깊게 공부해야겠다.&lt;/li&gt;
&lt;li&gt;잘 만들어진 소프트웨어는 코드가 클린하거나, 기능이 풍부한 것 뿐만 아니라, 커뮤니티, 문서화에도 뛰어난 것을 알고, 이러한 능력을 키우기 위해서 노력하자.&lt;/li&gt;
&lt;li&gt;생각만 하는 것보다는 직접 행동을 하면서 피드백을 얻고 배우자.&lt;/li&gt;
&lt;li&gt;관심있는 시스템 개발쪽도 항상 놓치지 말고 공부할 수 있도록 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;건강 관리를 해서 건강하게 오래 코딩 공부 및 일을 할 수 있도록 하자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 지식을 잘 이해하면, 튜닝을 하는데 많은 즐거움을 느낄 수 있다. 따라서 부족한 컴퓨터 공학 지식들을 이번 기회에 다시 한 번 더 복습하자.&lt;/li&gt;
&lt;li&gt;해커의 자세를 가지고 내가 사용하고 있는 시스템들의 내부 원리를 어떻게 눈으로 확인할 수 있을 지 실제로 분석할 수 있을지를 연구하자.&lt;/li&gt;
&lt;li&gt;블로그에 기록을 잘 하는 것도 중요하지만, 내가 알고 있는 지식들을 잘 설명하는 능력도 중요하다. 따라서 남에게 잘 설명하는 연습을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 03 Apr 2021 22:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예전에 리눅스 커널을 보면서 공부했던 내용을 블로그에 정리하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아쉽게도 공부한 직후에 바로 기록하여 내용이 정리 되어 있지는 않았다. 블로그를 예전 부터 시작하고, 기록 했으면 편했을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오랜만에 운영체제에 대해서 공부하게 되었고, 지금은 잊어버린 시스템 코드를 분석하는 툴 및 방법을 다시 확인해볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 개발에 대한 열정을 일어버리지는 말자.&lt;/li&gt;
&lt;li&gt;현재는 다른 것을 공부하느라 바쁘지만, 언젠가는 시스템 개발을 취미로 할 수 있을 정도로 실력을 키우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재는 시간이 부족하지만, 시스템 개발을 잘 할 수 있도록 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>메모리 액세스 과정</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95.html</link>
      <pubDate>Sat, 03 Apr 2021 21:21:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95.html</guid>
      <description>&lt;h3 id=&#34;메모리-액세스-과정&#34;&gt;메모리 액세스 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478449-da7b9d80-94c3-11eb-989d-f4926b2321d5.png&#34; alt=&#34;Slide07&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그램을 실행 할 때, 반드시 모두 물리 메모리에 있어야 할 필요는 없으므로, 일부분만 물리 메모리에 올려 놓고 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프로그램은 더 이상 물리 메모리에 의해서 더 이상 제약 받지 않으며, 사용자들은 매우 큰 가상 공간을 가정하고 프로그램을 만들 수 있고, 프로그래밍 과정이 간단해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 사용자 프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 메모리에서는 페이지들이 실행 과정에서 실제 필요할 때, 메모리에 적재되게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림을 보면, &lt;code&gt;CPU&lt;/code&gt;에서 메모리에 접근할 때, &lt;code&gt;MMU&lt;/code&gt;를 통해서 페이지 테이블에 접근한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 테이블은 가상 주소와 물리 주소를 맵핑하고 있고, &lt;code&gt;MMU&lt;/code&gt;를 통해서 접근하는 메모리가 테이지 테이블에 맵핑 되어 있지 않다면 페이지 폴트(&lt;code&gt;page fault&lt;/code&gt;)를 발생 시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 폴트가 발생하고 나서 가상 메모리와 물리 메모리가 맵핑되고, 가상 메모리를 통해서 물리 메모리에 접근할 수 있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이지-교체&#34;&gt;페이지 교체&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기본적인 페이지 교체는 다음과 같다. 메모리에서 빈 프레임이 없다면 현재 사용되지 않는 프레임을 찾아서 그것을 비워버린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 프레임의 내용을 스왑 (&lt;code&gt;swap&lt;/code&gt;) 공간에 쓰고 그 페이지가 메모리에 더 이상 존재하지 않는다는 것을 나타내기 위해서, 페이지 테이블을 비운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 페이지를 비울지에 대해서는 다음과 같은 알고리즘이 있다. (&lt;code&gt;FIFO&lt;/code&gt;, &lt;code&gt;LRU&lt;/code&gt;, &lt;code&gt;LFU&lt;/code&gt;, &lt;code&gt;MFU&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세그먼트-폴트와-페이지-폴트의-차이점&#34;&gt;세그먼트 폴트와 페이지 폴트의 차이점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;세그먼트 폴트 : 세그먼트 폴트는 컴퓨터 소프트웨어의 실행중에 일어날 수 있는 오류로서, 프로그램이 허용되지 않은 메모리 영역에 접근을 시도하였을 때 발생합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 폴트 : 페이지 폴트는 메모리에 적재된 페이지 중에 사용 페이지가 없을 때 발생한다. 페이지 폴트가 발생하고 나서, 페이지 테이블에 가상 주소와 물리 주소가 맵핑되고 나서는 발생하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ps-명령어를-사용하여-실제-사용하는-메모리와-가상-메모리-크기를-확인하는-방법&#34;&gt;&lt;code&gt;PS&lt;/code&gt; 명령어를 사용하여 실제 사용하는 메모리와 가상 메모리 크기를 확인하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478868-7ad2c180-94c6-11eb-879a-bd526b1c4d86.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 49 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps&lt;/code&gt; 명령어를 통해서, &lt;code&gt;RSS&lt;/code&gt; 항목을 보면 다음과 같이 설명하고 있다.&lt;/li&gt;
&lt;li&gt;상주하고 있는 메모리 사이즈이며, 스왑되지 않은 물리적 메모리라고 설명되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478927-dac96800-94c6-11eb-93d1-375419b14f4d.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 52 07 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반면에 &lt;code&gt;VSZ&lt;/code&gt;는 프로세스의 가상 메모리 크기라고 설명되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ps -eo pmem,rss,vsz,comm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 명령어를 실행하여, 프로세스 별 실제 사용하고 있는 물리 메모리와 가상 메모리를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478993-3ac00e80-94c7-11eb-88a1-63a0ad9fd7f5.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 54 48 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=46380306&#34;&gt;운영체제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>좀비 프로세스와 고아 프로세스</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html</link>
      <pubDate>Sat, 03 Apr 2021 18:57:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html</guid>
      <description>&lt;h3 id=&#34;좀비zombie-프로세스란&#34;&gt;좀비(zombie) 프로세스란&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료 될 때, 마지막 문장의 실행을 끝내고, &lt;code&gt;exit()&lt;/code&gt; 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면서 종료된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 시점에서, 프로세스는 자신의 부모가 호출한 &lt;code&gt;wait()&lt;/code&gt; 시스템 호출을 통해서, 상태 값을 반환할 수 있고, 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제로 반납된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모 프로세는 &lt;code&gt;wait()&lt;/code&gt; 시스템 호출을 사용하여 자식 프로세스가 종료할 때를 기다릴 수 있고, 부모가 자식의 종료 상태를 얻어 낼 수 있도록 하나의 인자를 전달 받는다. 이 시스템 호출은 부모가 어떤 자식이 종료되었는지 구별할 수 있도록 종료된 자식의 프로세스 식별자를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료되면 사용하던 자원은 운영체제가 되찾아가게 된다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 &lt;code&gt;wait()&lt;/code&gt;을 호출할 때까지 남아있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 종료가 되었지만 부모 프로세스가 아직 &lt;code&gt;wait()&lt;/code&gt; 호출을 하지 않은 프로세스를 좀비 (&lt;code&gt;zombie&lt;/code&gt;) 프로세스라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 프로세스는 종료하게 되면, 좀비 상태가 되지만 아주 짧은 시간 동안 머무르게 되고, 부모가 &lt;code&gt;wait()&lt;/code&gt;를 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에게 반환된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;고아-프로세스란orphan&#34;&gt;고아 프로세스란(orphan)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;좀비 프로세스와 비슷한 고아 프로세스라는 것이 있다.&lt;/li&gt;
&lt;li&gt;고아 프로세스는 부모 프로세스가 &lt;code&gt;wait()&lt;/code&gt;을 호출하는 대신에 그냥 종료를 해버리는 것이다. 이러한 상황에 처한 자식 프로세스를 고아(&lt;code&gt;orphan&lt;/code&gt;) 프로세스라고 한다.&lt;/li&gt;
&lt;li&gt;이 경우에는 고아 프로세스의 새로운 부모 프로세스로 &lt;code&gt;init&lt;/code&gt; 프로세스를 지정함으로써 이 문제를 해결한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 프로세스는 주기적으로 &lt;code&gt;wait()&lt;/code&gt; 시스템 콜을 호출하여 고아 프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실습&#34;&gt;실습&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

int main ()
{
  pid_t child_pid;
  int child_status;

  child_pid = fork ();
  if (child_pid &amp;gt; 0) {
    // parent process will sleep for 30 seconds and exit, without a call to wait()
    fprintf(stderr,&amp;quot;parent process - %d\n&amp;quot;, getpid());
    sleep(30);
    exit(0);
  }
  else if (child_pid == 0) {
    // child process will exit immediately
    fprintf(stderr,&amp;quot;child process - %d\n&amp;quot;, getpid());
    exit(0);
  }
  else if (child_pid == -1) {
    // fork() error
    perror(&amp;quot;fork() call failed&amp;quot;);
    exit (-1);
  }
  else {
    // this should not happen
    fprintf(stderr, &amp;quot;unknown return value of %d from fork() call&amp;quot;, child_pid);
    exit (-2);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같은 소스 코드를 작성하고 컴파일을 한 뒤에 실행을 해보자.
소스 코드의 대략적인 내용은 부모 프로세스에서 자식 프로세스를 만들고 나서, &lt;code&gt;wait()&lt;/code&gt; 호출을 하지 않고 종료 시켜버리는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -o zombie zombie.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;실행을 하기 전에, &lt;code&gt;top&lt;/code&gt; 명령어를 통해서 좀비 프로세스의 여부를 확인한 모습이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113477959-c1252200-94c0-11eb-946c-384317e800aa.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 05 53 PM copy&#34;&gt;&lt;/p&gt;
&lt;p&gt;좀비 프로세스가 없다는 것을 확인할 수 있다. 아까 작성한 프로그램을 실행 시킨 후에, 다시 한 번더 확인하였을 때는 다음과 같이 표시됨을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478040-4a3c5900-94c1-11eb-9d54-dc99e1262648.png&#34; alt=&#34;zombie_after&#34;&gt;&lt;/p&gt;
&lt;p&gt;아까는 존재 하지 않았던, 좀비 프로세스가 생긴 것을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=46380306&#34;&gt;운영체제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로그램 실행시 메모리 구조 및 실제로 확인해보는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Sat, 03 Apr 2021 18:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;p&gt;컴퓨터 구조 시간때 배웠듯이 프로그램이 메모리에 올라가면 다음과 같은 구조로 메모리가 할당되고 실행이 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474822-3d156f00-94ad-11eb-815d-f3bc78df9d97.png&#34; alt=&#34;FdJ8Xbd&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스크에 저장되어 있는 프로그램이 메모리에 올라가게 된다.&lt;/li&gt;
&lt;li&gt;메모리에는 크게 코드, 스택, 힙 영역이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 리눅스에서 확인해보려면 다음과 같은 명령어를 사용하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/self/maps
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 명령어가 뜻하는 바는 &lt;code&gt;cat&lt;/code&gt;이라는 프로그램을 실행했을 때의 메모리 구조를 의미한다.&lt;/li&gt;
&lt;li&gt;여기서 &lt;code&gt;self&lt;/code&gt;는 자기 자신을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474795-10f9ee00-94ad-11eb-9b69-e7ec306975b3.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 46 26 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서부터 코드 영역, 힙 영역, 스택이 메모리에 할당되어 있는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;개념으로만 알고 있던 것을 실제로 눈으로 확인해보니까 더 와닿았다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스는 특별한 프로그램인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80.html</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80.html</guid>
      <description>&lt;h3 id=&#34;리눅스는-과연-특별한가&#34;&gt;리눅스는 과연 특별한가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;리눅스 파일이 다른 실행 파일과 다른지 알아보기 위해서 커널을 실제로 빌드 해보고 일반 실행파일과 다른점이 있는지 알아보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474362-8c0dd500-94aa-11eb-9173-aa348199400c.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 29 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 리눅스 커널을 &lt;code&gt;make&lt;/code&gt; 명령어를 통해서, 빌드한 모습이다. 빌드를 마치게 되면 &lt;code&gt;vmlinux&lt;/code&gt; 라는 실행 파일이 나오게 된다.&lt;/p&gt;
&lt;p&gt;이를 &lt;code&gt;file&lt;/code&gt; 도구를 통해서 알아보았다. &lt;code&gt;file&lt;/code&gt; 도구는 파일이 어떤 타입인지를 알려주는 리눅스 도구이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474446-faeb2e00-94aa-11eb-8e60-54f4e516c57f.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 32 41 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt;을 통해서 메뉴얼을 확인해보면 더욱 자세한 사용법을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474566-a1373380-94ab-11eb-9f23-c2d46c38b3c8.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 37 15 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474587-b57b3080-94ab-11eb-8abc-1cf19518211c.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 37 49 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;리눅스 실행 파일과 간단한 프로그램을 만들어서 비교한 결과, 거의 같은 파일이라는 것을 확인할 수 있었다. 차이가 있다면 리눅스의 경우에는 정적 링킹이 되었고 예제 프로그램의 경우에는 동적 링킹이 되어있다는 차이점 밖에는 없다. 이에 대해서는 나중에 자세하게 정리하도록 하겠다.&lt;/p&gt;
&lt;p&gt;따라서 결론은 리눅스도 하나의 프로그램일 뿐이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>운영체제의 역할 및 리눅스를 공부할 때 중요한 핵심 개념</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90.html</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90.html</guid>
      <description>&lt;p&gt;예전에 시스템 프로그래밍을 조금 더 잘 알고 싶어서 &lt;a href=&#34;https://reallinux.co.kr&#34;&gt;리얼 리눅스&lt;/a&gt;에서 강의를 들은 적이 있는데, 그 때는 노션에 정리를 하던 시절이라서 블로그에 게시하지 못했다. 따라서 그때 정리한 개념을 블로그에 글로 작성해보고 다시 운영체제에 대해서 복습하였다.&lt;/p&gt;
&lt;h3 id=&#34;리눅스를-공부할-때-중요한-개념&#34;&gt;리눅스를 공부할 때 중요한 개념&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;리눅스를 공부할 때는 다음과 같은 개념이 중요하다고 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소프트웨어 기본 원리 : 당연한 말이지만, 소프트웨어의 기본 동작 원리를 제대로 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리 액세스 원리 : 운영체제에서 메모리를 어떻게 액세스 하고 관리하는지 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일(디스크) IO : 디스크 및 파일 시스템에 대해서 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크 IO: 네트워크 통신 및 기초에 대해서 알아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;운영체제의-역할&#34;&gt;운영체제의 역할&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;운영체제의 핵심 역할은 다음과 같이 나누어 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 관리 (&lt;code&gt;Process Management&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;메모리 관리 (&lt;code&gt;Memory Management&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;인터럽트(&lt;code&gt;Interrupt&lt;/code&gt;) / 예외 처리(&lt;code&gt;Exception&lt;/code&gt;) / 락킹(&lt;code&gt;Locking&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;IO 처리
&lt;ul&gt;
&lt;li&gt;네트워크 (L4: TCP, L3: IP, L2: DD)&lt;/li&gt;
&lt;li&gt;스토리지 (&lt;code&gt;VFS&lt;/code&gt;/ &lt;code&gt;FS&lt;/code&gt;/ &lt;code&gt;BLOCK&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기타 : 보안(&lt;code&gt;security&lt;/code&gt;), 도구(&lt;code&gt;tools&lt;/code&gt;), 사운드(&lt;code&gt;sounds&lt;/code&gt;), 드라이버(&lt;code&gt;drivers&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113473846-17856700-94a7-11eb-84d9-7bf3c267ec28.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 04 31 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 스크린샷은 리눅스 커널 소스코드인데, 위에서 설명한 운영체제의 핵심 역할에 맞게 디렉터리가 구성되어 있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kernel&lt;/code&gt; : 리눅스 커널 내부와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm&lt;/code&gt; : 메모리와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs&lt;/code&gt; : 파일 시스템과 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net&lt;/code&gt; : 네트워크와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 02 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자바스크립트 세미나를 들었다.&lt;/li&gt;
&lt;li&gt;내가 개발하고 있는 솔루션에서 이제 슬슬 성능 문제가 나오고 있다.&lt;/li&gt;
&lt;li&gt;엔지닉스 및 톰캣에 대해서 자세히 공부를 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자신감 있게 발표하는 것이 중요할 것 같다. 내용 뿐만 아니라 자신감 있는 목소리는 우선 집중이 되기 때문이다. 따라서 비언어적인 요소에도 신경을 많이 쓰자&lt;/li&gt;
&lt;li&gt;발표 연습을 할 주제를 정하기가 어려워서 자꾸 발표 연습을 하는 것을 꺼리게 된다. 그리고 발표 자료를 만들어야한다는 마음에 자꾸 발표를 미루게 되는 것 같다.&lt;/li&gt;
&lt;li&gt;정확한 원인을 파악하고 분석하는 것이 어려운 것 같다. 곰곰히 생각해보니까 그 이유는 원인을 파악하는 정보를 수집하지 못했기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;발표를 하는데, 내용도 중요하지만, 맺음말, 그리고 발성 시선 처리 또한 무시못하는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=59668172&#34;&gt;그림으로 공부하는 시스템 성능구조&lt;/a&gt; 라는 책을 읽으면서 초반에 이러한 글귀가 나온다.
&amp;ldquo;가능한 스스로 그림을 그려가면서, 다른 사람에게 설명할 것을 추천한다. 해보면 알겠지만 막상 직접 설명하려고 하면, 자신이 애매하게 이해하고 있었다는 것을 깨닫게 된다.&amp;rdquo;
따라서 나도 그림을 그려가면서 어떤 개념을 남에게 설명하는 연습을 하고 이를 녹화하면서 피드백을 얻어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 저자는 엔지니어를 가르치는 일을 5년간 하면서 발표 능력이나 설명 능력을 키울 수 있었다고 한다. 이를 통해서 그림을 그려서 설명하는 것과, 기본을 먼저 이해하는 것이 가장 분명한 방법이라는 것을 깨달았다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 측정의 시작은, 바로 측정이라는 것을 배웠다. 측정이 되지 않으면 성능에 대해서 이야기를 할 수 없다. 또한 성능 문제의 대처나, 성능 튜닝은 항상 바른 측정이 수반되어야 한다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 발성을 바꾸도록 노력해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 작은 발표를 해보자. 그리고, 이를 측정하고 내가 얼마나 괜찮아졌는지를 측정하고 기록하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 01 Apr 2021 20:10:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 곧 있으면 자바스크립트 관련 사내 세미나 발표를 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;곧 회사 사람들 앞에서 발표를 한다고 생각하니까 떨리고 살짝 무섭기도 하다.&lt;/li&gt;
&lt;li&gt;최근 팀에 새로운 분이 들어왔는데, 뭔가 부끄럽지 않은 모습과 배울 점이 있는 사람으로 느껴졌으면 하는 마음이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;발표 할 수 있는 것을 좋은 기회라고 생각하고, 회고를 작성했던 것 처럼, 말하는 연습을 하는데 좋은 동기로 작용했으면 좋겠다.&lt;/li&gt;
&lt;li&gt;발표를 하기 전에, 자료를 준비하고 이를 녹화해보면서 블로그에 글을 꾸준히 작성하는 것 처럼 주말마다. 주제를 정해서, 슬라이드를 만들고 이에 대해서 남에게 설명하는 연습을 하면 좋을 것이다. 그리고 슬라이드는 슬라이드 쉐어에 공유를 하고 발표 영상 또한 유튜브에 공유하면 나의 노력에 대해서 알아주는 사람이 있을 것이라고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생각만 하지 말고 행동으로 보이자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료 준비 및 발표를 잘해서, 사람들에게 배울 점이 있는 사람으로 생각되자.&lt;/li&gt;
&lt;li&gt;준비를 철저하게 하고, 이를 통해서 말하는 연습을 꾸준히 하는 계기로 삼자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ARIES란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft.html</link>
      <pubDate>Wed, 31 Mar 2021 22:56:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&#34;&gt;WIKI - ARIES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 31 Mar 2021 22:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제는 한 시간정도 일찍 취침을 했다.&lt;/li&gt;
&lt;li&gt;오늘 회사에서, 모바일 개발을 위한 &lt;code&gt;API&lt;/code&gt; 정리를 하였다.&lt;/li&gt;
&lt;li&gt;팀이 변경되어서 자리를 옮기게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서가 현재와 맞지 않는 것들이 많아서 어지러웠다. 그리고 어떻게 해야지 모바일 개발자들이 더 쉽게 &lt;code&gt;API&lt;/code&gt;를 사용할 수 있을까 그리고 쉽게 사용하려면 사실 컨트롤러 부분을 수정해야하는것이 아닌지 고민을 하게 되었다.&lt;/li&gt;
&lt;li&gt;새로운 팀에서 새롭게 시작한 기분이 되어서 조금 기분 전환이 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 제대로 관리하고 되도록이면 소스 코드랑 동떨어지지 않도록 노력해야겠다.&lt;/li&gt;
&lt;li&gt;새로운 팀에서 새롭게 시작한다고 생각을 하면서 더 좋은 모습을 처음부터 보여드려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;잘 만들어진 소프트웨어는 코드 및 기능 뿐만 아니라, 주석, 문서화, 커뮤니티까지 완벽한 경우가 많다 따라서, 이러한 부분의 능력을 기르기 위해서 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 어떻게 하면 잘 작성할 지 고민하고 &lt;code&gt;API&lt;/code&gt; 설계를 잘 하는 방법 및 문서화를 어떻게 하면 코드와 함께 맞출 수 있을지에 대해서 고민을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;내부 원리 및 이를 디버깅할 수 있는 방법을 찾아서 계속 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스에 대해서 배울 수 있는 좋은 강의 (CS186Berkeley)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley.html</link>
      <pubDate>Wed, 31 Mar 2021 20:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley.html</guid>
      <description>&lt;p&gt;우연히 유튜브에서 데이터베이스에 대해서 체계적이고 좋은 영상이 있는 것을 발견하였다.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/ZLtwOp8pz_Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;커리큘럼을 보면, 초반에는 디스크, 버퍼, 파일 및 인덱스 B+Tree 부터 시작해서 간단한 &lt;code&gt;SQL&lt;/code&gt; 및 간단하 쿼리 튜닝까지 배운다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154480-0227f700-9273-11eb-9683-6ac82864c697.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154484-03592400-9273-11eb-8897-6de7f64fb366.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고, 트랜잭션 처리 부터 시작해서, 병렬 쿼리 실행 그리고 분산 트랜잭션 처리까지 철저하게 배운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심지어 과제 및 시험문제도 풀어볼 수 있다. &lt;a href=&#34;https://cs186.gitbook.io/project/assignments/proj0&#34;&gt;CS186&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;남는시간에 틈틈히 DBMS에 대해서 공부하면서 부족했던 기본기를 튼튼하게 하면서, 오픈 소스에 기여할 때 도움이 되도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt; 프로젝트를 이해할 때, 기본기에 대한 부족함을 많이 느꼈다. 따라서 이 강의를 통해서 기본기를 다진다면 한결 흐름을 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/user/CS186Berkeley/videos&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 30 Mar 2021 22:09:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 어제 발생했던 이슈의 원인을 찾아보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루 우울하고 힘이 없었던 것 같다.&lt;/li&gt;
&lt;li&gt;오늘 밤에는 조금 쉬기로 하였다.&lt;/li&gt;
&lt;li&gt;내일이면 팀이 새롭게 개편되어서 자리를 옮길 것 같다. 팀원들이랑 정들었는데 조금 아쉽다. 새로운 팀이랑 일을 잘 할 수 있을지 조금은 걱정되기도 한다.&lt;/li&gt;
&lt;li&gt;이슈가 발생한 정확한 원인을 파악해서 기쁘다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;오픈 소스 커뮤니티에 가면, 대부분 발생했던 문제들의 해결책이 있고 만약 없더라도 내가 이슈를 만들어서 보고하도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;조금 쳐졌을 때, 마음을 다잡고 열심히 해보려는 마음이 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;나의 마음을 드러내지 않도록 하는 것이 중요하고, 팀원들에게 좋은 모습을 보여야겠다.&lt;/li&gt;
&lt;li&gt;이번에는 오픈 소스 커뮤니티에서 원인 분석과 해결책을 주었지만, 만약 그러지 못할 경우를 대비해야한다. 따라서 평소에 사용하는 프레임워크의 내부 동작을 잘 익히고 이를 어떻게 디버깅할 수 있을지를 항상 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내부 원리 및 이를 디버깅할 수 있는 방법을 찾아서 계속 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>리액트에서 구글 번역기가 번역하면서, DOM 트리를 변경해 렌더링이 되지 않는 현상</title>
      <link>https://dongwooklee96.github.io/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81.html</link>
      <pubDate>Tue, 30 Mar 2021 13:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81.html</guid>
      <description>&lt;h3 id=&#34;문제-상황&#34;&gt;문제 상황&lt;/h3&gt;
&lt;p&gt;개발을 진행하다가,  &lt;code&gt;PM&lt;/code&gt;에서 데이터가 이상하다고, 확인해달라는 요청을 받았다. 확인을 해본 결과, 데이터베이스 및 서버에서 내려오는 데이터는 정상이였다. 하지만 화면에서 업데이트를 시키지 않고, 기존에 데이터가 그대로 남아있어 화면 업데이트가 안되는 상황이였다. 재현을 해봤을 때는 아무런 문제가 없어서 혹시나 하고 구글 번역기를 켜고 재현을 해보았을 때 버그가 발생하였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934001-d82fe100-915b-11eb-917b-9405fadc17da.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 28 22 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;원인&#34;&gt;원인&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934219-407ec280-915c-11eb-8a90-c8be38c7c471.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 31 30 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;검색을 해보니, 비슷한 현상이 이미 보고가 되어있었고, 원인을 파악하기 위해서 살펴보았다.&lt;/p&gt;
&lt;p&gt;구글 번역기를 켰을 때 변경된 텍스트가 업데이트 되지 않는 이유는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;웹 사이트에서 구글 번역기를 켰을 때 번역기가 텍스트를 &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; 태그로 대체한다. 하지만 리액트에서 변경된 것을 감지하지 못해서, 이미 &lt;code&gt;DOM&lt;/code&gt; 트리에서 사라진 객체를 참조한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;텍스트는 조건부로 렌더링이 되며, 부모 노드의 유일한 하위 노드가 아니다. 그런 후에 텍스트 노드가 제거되면 &lt;code&gt;React&lt;/code&gt;는 &lt;code&gt;parent.removeChild(textNode)&lt;/code&gt;를 호출하고 텍스트 노드가 더 이상 상위 노드의 하위 노드가 아니기 때문에 삭제한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;조건부로 렌더링 된 텍스트 노드가 부모의 유일한 자식일 때는 던지지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;텍스트 노드가 앞의 노드가 조건 부로 렌더링되고, 그런 다음에 노드가 삽입 될 때 &lt;code&gt;parent.insertBefore(someNode, textNode)&lt;/code&gt;를 호출하고 &lt;code&gt;textNode&lt;/code&gt;가 더이상 상위 노드가 아니기 때문에 예외를 던진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934676-39a47f80-915d-11eb-81b9-2cf4771030db.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 38 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해결책은, 텍스트를 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그로 감싸서 내용이 &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; 태그로 대체되더라도 리액트에서 참조하는 노드가 &lt;code&gt;DOM&lt;/code&gt; 트리에서 사라지지 않게 하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/react/issues/11538&#34;&gt;Make React resilient to DOM mutations from Google Translate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클라우드 이벤트 스펙이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Mon, 29 Mar 2021 22:55:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;클라우드-이벤트-스펙이란&#34;&gt;클라우드 이벤트 스펙이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941452-927a1500-9169-11eb-9947-5291c6d27c86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 06 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트는 어디에서든지 발생하지만, 이벤트를 생산하는 생산자에 따라서 이벤트를 다르게 정의하는 경향이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 설명하는 표준이 없기 때문에, 개발자는 이벤트 사용방법을 계속해서 배워야 한다. 또한 &lt;code&gt;SDK&lt;/code&gt;, 이벤트 라우터 또는 추적 시스템과 같은 환경에서 이벤트 데이터를 전달하는데 도움이 되는 도구 및 인프라의 잠재력을 제한한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우드 이벤트는 서비스, 플랫폼 및 시스템간에 상호 운영성을 제공하기 위해서 이벤트 데이터를 공통 형시으로 설명하기 위한 스펙이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941821-277d0e00-916a-11eb-83bd-4a426cf9ea86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 11 01 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서를 보면 프로토콜 별로 스펙과 문서를 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 카프카에 관심이 있으므로 카프카 메시지에 대한 문서를 살펴보도록 하겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;카프카-메시지-맵핑&#34;&gt;카프카 메시지 맵핑&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112943105-01f10400-916c-11eb-88a1-546ffe6c47a1.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 24 17 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;카프카 &lt;code&gt;0.11.0.0&lt;/code&gt; 이상에서는 이벤트 발신자가 콘텐츠 모드를 선택한다, 특정 콘텐츠 모드를 사용해서 이벤틀르 요청을 허용할 수 있는 프로토콜 사용 패턴은 응용 프로그램에서 정의 할 수 있지만, 여기에서는 정의되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 수신자는 카프카 메시지의 &lt;code&gt;Content-type&lt;/code&gt; 헤더를 검사하여 두 콘첸츠 모드를 구분할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;미디어 타입이 &lt;code&gt;application/cloudevents&lt;/code&gt; 인 경우에는 이벤트 형식의 사용을 나타내고 수신자는 구조화된 모드를 사용합니다. 그렇지 않은 경우에는 디폴트로 바이너리 모드입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 다음과 같은 &lt;code&gt;JSON&lt;/code&gt; 형태로 작성하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------ Message -------------------

Topic Name: mytopic

------------------- key ----------------------

Key: mykey

------------------ headers -------------------

content-type: application/cloudevents+json; charset=UTF-8

------------------- value --------------------

{
    &amp;quot;specversion&amp;quot; : &amp;quot;1.0&amp;quot;,
    &amp;quot;type&amp;quot; : &amp;quot;com.example.someevent&amp;quot;,
    &amp;quot;source&amp;quot; : &amp;quot;/mycontext/subcontext&amp;quot;,
    &amp;quot;id&amp;quot; : &amp;quot;1234-1234-1234&amp;quot;,
    &amp;quot;time&amp;quot; : &amp;quot;2018-04-05T03:56:24Z&amp;quot;,
    &amp;quot;datacontenttype&amp;quot; : &amp;quot;application/xml&amp;quot;,

    ... further attributes omitted ...

    &amp;quot;data&amp;quot; : {
        ... application data encoded in XML ...
    }
}

-----------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34;&gt;cloudevents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec/blob/v1.0.1/kafka-protocol-binding.md&#34;&gt;cloudevents - kafka spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>메시지 큐를 이용한 비동기처리 및 에러 처리</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC.html</link>
      <pubDate>Mon, 29 Mar 2021 22:19:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC.html</guid>
      <description>&lt;h2 id=&#34;메시지-큐를-이용한-비동기-요청-처리&#34;&gt;메시지 큐를 이용한 비동기 요청 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112848087-a9295900-90e2-11eb-82ce-b6dd8ec80708.png&#34; alt=&#34;engineering linecorp&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요청을 처리하는 방법에는 전통적인 동기식 방식도 있지만, 비동기식 방식도 있는데, 동기 방식이 클라이언트가 요청을 보내면 처리한 다음에 응답이 오는 방식이라면 비동기 방식은 요청을 보낸 후 비즈니스 로직이 처리가 완료되지 않은 상태에서 다음 로직을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버로 전달된 요청은 나중에 처리되며 나중에 클라이언트로 응답이 전달된다. (응답을 전달하지 않을 때도 있다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동기식 방식과 비동기식 방식의 가장 큰 차이점은 동기식 방식은 응답이 올 때까지 클라이언트가 대기하는 것이고, 비동기식 방식은 요청만 보내놓고 응답이 오는 것과 상관없이 클라이언트 대기 없이 다음 로직을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선택적으로 콜백 메시지를 보내는 경우가 있는데, 콜백은 클라이언트에게 비동기로 요청된 작업이 끝났음을 알려주는 호출이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 페이스북 사진을 첨부해서 글을 올리면, 브라우저에서는 글이 등록되었다고는 하지만 바로 타임라인에 표시되지 않고 1 ~ 2 초 후에 업데이트 되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 브라우저에서 글쓰기 요청을 받으면 먼저 클라이언트에게 완료되었다는 응답을 보낸 후 서버는 뒷단에서 그림의 크기를 조정하는 등의 추가적인 작업을 한후에 데이터베이스에 저장한 후 타임라인에 반영하기 때문이다. 이러한 처리가 대표적인 비동기 처리의 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주로 시간이 오래 걸리는 대규모 작업에 유리하고, 동영상 인코딩 같은 변환 작업이나 시간이 오래 걸리는 계산 작업, 또는 하나의 메시지를 보냈지만 여러 개의 작업이 필요한 경우 등 여러 시나리오에 폭 넓게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 비동기식 패턴 구현에는 일반적으로 메시지 큐라는 것을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 메시지 큐는 들어온 요청을 쌓아놓는 임시 공간으로, 쌓여있는 요청 메시지는 뒤의 비즈니스에 의해서 처리 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112851308-d3c8e100-90e5-11eb-8524-592565d189ff.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 비동기식 구현에서 가장 중요하게 고려해야 할 사항은 전달된 요청 메시지가 잘 처리되었느냐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트는 단순하게 요청을 보내고, 그에 대한 응답을 받지 않기 때문에, 해당 요청이 제대로 처리되었는지 보장할 방법이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 클라이언트는 요청을 보내고 메시지 큐에 잘 저장된 후에 응답을 받는다. 이 상태에서 클라이언트는 이 메시지가 제대로 처리될 것을 기대하지만, 메시지 큐에서 해당 메시지를 읽어서 처리하는 서버가 메시지를 꺼내서 처리하다가 장애를 일으켜서 정지하였다고 가정해보면 그 메시지는 유실되고 처리되지 않게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112852203-ab8db200-90e6-11eb-9746-2c7cd11dc9d2.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 이러한 비동기 구현에서는 에러 처리 부분에 가장 많은 신경을 써야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 컴포넌트에서 메시지 처리 중 에러가 났을 때, 해당 메시지를 에러 큐라는 재처리용 큐로 전달한다. 메시지의 에러 처리 정책을 정해서 에러를 어떻게 처리할지를 지정할 수 있는데, 비동기 메시지 처리에서는 다음과 같이 크게 4가지 정책을 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-재처리-retry&#34;&gt;1. 재처리 (Retry)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;메시지 처리 중 에러가 발생하였을 때, 다시 처리를 시도하도록 하는 방법ㅇ다.&lt;/li&gt;
&lt;li&gt;메시지를 처리하는 비즈니스 컴포넌트가 일시적인 장애 (네트워크 문제, 리소스 부족 등) 일 경우에는 효율적으로 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;재처리를 할 때는 반드시 최대 재처리 횟수를 지정해야 한다. (통상적으로 3 ~ 5 번 정도를 사용한다).&lt;/li&gt;
&lt;li&gt;그리고 재처리를 할 때, 에러 발생 후 바로 재처리를 시도하면 같은 원인으로 같은 에러가 발생할 수 있기 때문에 일정 시간을 기다렸다가 다시 처리하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-무시-ignore&#34;&gt;2. 무시 (Ignore)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;에러가 난 메시지는 무시하고 메시지를 없애 버리는 방식이다. 중요하지 않는 로그 정보를 저장할 때와 같이 메시지 유실이 허용되는 경우에만 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-알림-notify&#34;&gt;3. 알림 (Notify)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;메시지 처리 중 에러가 발생하였을 때 이메일, &lt;code&gt;SMS&lt;/code&gt;등을 이용하여 관리자에게 통보하여 관리자가 직접 에러에 대한 후 처리를 할 수 있도록 하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-사람이-처리하도록-함-human-interaction&#34;&gt;4. 사람이 처리하도록 함 (Human Interaction)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;에러가 발생하였을 때, 자동으로 처리하지 않고 관리자가 직접 처리할 수 있는 사용자 인터페이스를 제공한다.&lt;/li&gt;
&lt;li&gt;관리자가 에러난 메시지를 확인하고 재처리할지 무시할지 등을 결정하도록 한다.&lt;/li&gt;
&lt;li&gt;에러 재처리 부분이 복잡하거나 규모가 큰 경우 이런 메시지에 대한 에러 처리를 별도의 컴포넌트로 구현하기도 하는데, 이를 &lt;code&gt;Error Hospital&lt;/code&gt; 이라고 부른다.
처리 중 에러가 난 메시지를 모아서 다양한 에러 처리 정책에 따라서 재처리를 할 수 있는 기능을 갖는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;메시지-큐-구성-시-고려해야-할-사항&#34;&gt;메시지 큐 구성 시 고려해야 할 사항&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;성능 및 페일 오버를 고려한 Persistence의 선택&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지를 물리적으로 어디에 저장할 것인지 고민하는 것으로, 메시지는 보통 메모리, 디스크 또는 &lt;code&gt;RDBMS&lt;/code&gt;와 같은 저장소에 저장할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보통 메모리에 저장하는 모델이 가장 빠르기는 하지만, 서버 장애가 났을 때는 처리되지 않은 메시지들이 유실 될 수 있는 위험이 있기 때문에 아주 고성능에 메시지 유실이 허용되는 시스템이 아닌 경우에는 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 메시지 큐를 클러스터링 해서 사용할 경우에는, 클러스터된 인스턴스 중 특정 인스턴스가 죽었을 경우, 처리되지 않은 메시지를 살아 있는 인스턴스로 넘기기 위해서는 이 파일 시스템이 인스턴스 간에 공유 되어야하는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러 인해서 &lt;code&gt;NFS(Network File System)&lt;/code&gt;와 같은 공유 파일 저장소를 사용해야 하는 경우가 있는데, 이 경우 &lt;code&gt;NFS&lt;/code&gt; 성능 저하로 말미아마 전체 메시징 시스템의 성능 저하가 올 수 있기 때문에 이 부분에 대해서 고려해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 마지막 방법으로는 &lt;code&gt;RDBMS&lt;/code&gt;를 메시지 저장소로 사용할 수 있는데, 클러스터링 구성 시 페일 오버(Fail Over)도 비교적 잘되고, 메시지에 대한 관리도 매우 쉽다는 장점을 가지고 있지만, 3가지 구조 중에서 가장 느리고 추가적으로 &lt;code&gt;RDBMS&lt;/code&gt; 운영이 필요하다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;펜딩 메시지로 말미암은 Out of Memory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음 고려사항으로, 메세지 큐 미들웨어는 메모리 과다 사용으로 말미 암은 &lt;code&gt;Out of Memory&lt;/code&gt; 에러에 주의해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리에 메시지를 저장하는 &lt;code&gt;Persistence&lt;/code&gt; 구조를 가지고 있을 경우에는 메시지를 큐에서 꺼내 가지 않은면 쌓여 있는 메시지들이 정체되어 메모리를 잡아먹으면서 &lt;code&gt;Out of Memory(메모리 부족 에러)&lt;/code&gt;를 일으킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 쌓여있는 메세지들을 펜딩 (Pending Message) 라고 하는데, 이 펜딩 메시지에 의한 &lt;code&gt;Out of Memory&lt;/code&gt; 에러는 메시지 저장소를 이용하지 않더라도 발생하는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 메시지 큐 미들웨어의 특성상 성능 향상을 위해서 메시지를 파일이나 &lt;code&gt;RDBMS&lt;/code&gt;에 저장하더라도, 최소한의 메시지에 대한 메타 정보(메시지 ID와 같은 인덱스 정보)를 메모리에 저장할 때 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;트랜잭션 지원 기능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;높은 신뢰성을 요구하는 시스템은 트랜잭션 지원 기능을 고려해야 하는데, 메시지를 큐에서 빼간 후에 처리하다가 에러가 났을 경우의 이 메시지는 다시 큐에 복귀되거나 또는 에러 큐로 보내져야 한다. 이런 기능을 지원 하려면 트랜잭션 지원 기능이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션 기능을 지원하는 경우가 많지만 근래의 &lt;code&gt;AMQP&lt;/code&gt;나 고속 메시징 시스템의 경우 이러한 트랜잭션 기능을 지원하지 않는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 큐에서 메시지를 읽고 그 메시지를 데이터베이스에 쓰는 것은 하나의 트랜잭션으로 묶는 경우, 메시지를 큐에서 꺼내 온 후 메시지를 데이터베이스에 넣는 것을 실패하였을 때 이 트랜잭션을 실패로 처리하고 메시지를 다시 큐에 돌려 넣거나 아니면 에러 큐에 보내야 하는데, 분산 트랜잭션을 지원하는 메시지 큐 시스템은 데이터베이스와 큐의 트랜잭션을 하나로 묶어서 자동으로 이러한 작업을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 트랜잭션을 지원하지 않을 때에는 에러가 발생하였을 때, 개발자가 에러 큐로 메시지를 던지거나 또는 다시 큐에 넣는 작업을 해줘야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;클러스터링 기능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 클러스터링 지원 여부로, 메시지 큐에서 클러스터링이란 여러 개의 메시지 큐를 하나의 클러스터로 묶는 기능을 정의하느데, 여기서 오는 장점은 크게 두 가지 관점에서 고민 해 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫 번째로는 클러스터링을 통해서 특정 인스턴스 장애 시 다른 인스턴스들이 장애가 난 인스턴스의 메시지를 받아서 처리하는 페일 오버(&lt;code&gt;Fail Over&lt;/code&gt;) 기능이 있을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째로는 한 대의 서버로 처리할 수 없는 양의 메시지를 여러 대의 서버에서 분산 처리하면서 올 수 있는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐 미들웨어는 한 번 선택이 되면 표준처럼 계속 사용되기 때문에 서비스의 특성을 잘 파악하고 위의 고려 사항을 기반으로 적절한 제품군을 선택할 것을 권고한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>멤티어 벤치마크로 아커스 성능 측정하기</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0.html</link>
      <pubDate>Mon, 29 Mar 2021 22:04:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112841192-2c46b100-90db-11eb-8c96-0eb41685ebb4.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 06 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아커스에 내가 작성한 코드를 도입하고 나서, 얼마만큼의 성능 개선이 이루어졌는지 궁금했다. 따라서 오픈 소스 컨트리뷰톤 행사를 참여할 때, 도움을 주셨던 멘토님이 &lt;a href=&#34;https://github.com/RedisLabs/memtier_benchmark&#34;&gt;memtier_benchmark&lt;/a&gt; 라는 툴을 알려주셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 멘토님께서는 눈에 띄는 변화는 없을 것이라고 하셨다. 하지만, 내가 작성한 코드가 과연 성능 개선이 있을까 궁금해서 이를 측정해보고 싶었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/RedisLabs/memtier_benchmark.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112842051-1f768d00-90dc-11eb-942c-9e1b54aed4f9.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 14 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;README&lt;/code&gt; 문서에 나와있는데로, 의존성 패키지들을 다운로드 받고 이를 빌드 하면된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112843612-b98b0500-90dd-11eb-9d1f-7ea73465e0ec.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 25 46 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;귀찮은 의존성들을 모두 설치해주고, &lt;code&gt;make&lt;/code&gt;를 해주면, 드디어 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112844625-e2f86080-90de-11eb-93d3-880f0eb66c29.png&#34; alt=&#34;memtier&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은, &lt;code&gt;help&lt;/code&gt; 명령어를 실행한 모습이다. 많은 옵션이 있지만 나는 다음과 같이 사용했다. 우선 아커스 서버를 띄운다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845032-57330400-90df-11eb-9f08-eb62de685aad.png&#34; alt=&#34;arcus&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 쉘 스크립트를 이용해서 아커스 서버를 실행시켰는데, 포트번호 11216 인것 만 확인하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845376-c4469980-90df-11eb-8871-e5c75b1f26d5.png&#34; alt=&#34;arcus&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버를 띄우면 다음과 같은 화면이 뜨고, 이제 &lt;code&gt;memtier_benchmark&lt;/code&gt;를 다음의 옵션을 설정해서 실행을 시키면 끝난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845383-c6105d00-90df-11eb-81d9-4e9afe5634b7.png&#34; alt=&#34;memtier&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./memtier_benchmark -s 127.0.0.1 -p 11216 -t 4 -c 50 -P memcache_text
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위에 작성한 명령어는 &lt;code&gt;localhost&lt;/code&gt; 주소의 &lt;code&gt;11216&lt;/code&gt; 포트로 쓰레드 4개와 커넥션 50개를 이용하여 &lt;code&gt;memcached&lt;/code&gt; 프토로콜 테스트를 하겠다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112846408-fc9aa780-90e0-11eb-86e8-ea810284c90a.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 48 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트가 모두 끝나면 결과가 나온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/RedisLabs/memtier_benchmark&#34;&gt;memtier_benchmark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 29 Mar 2021 21:53:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 서버 성능 튜닝 및 알아야할 지식에 대한 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;운영 체제 및 기반 지식을 이해하고, 이렇게 구성하면 빨라지겠구나를 이해하고 튜닝을 하는 것은 재미있는 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 스트레스 관리를 잘 하는 것이 중요할 것 같다. 최근에 무리해서 공부를 했더니 오늘 조금 지쳐있어서 제대로 일을 하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;기술적인 역량 및 운영체제, 네트워크, 디스크에 대한 깊은 지식이 있어야 겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;또한 특정 솔루션에 대한 전문적인 지식을 쌓아야겠다는 생각을 했다, 톰캣의 내부 구조 및 &lt;code&gt;JVM&lt;/code&gt;의 동작 원리에 대해서 공부를 해야겠다는 마음을 먹었다.&lt;/li&gt;
&lt;li&gt;인내심을 가지고, 디컴파일을 하던, 덤프를 추출하건 구준히 보고 오픈 소스의 경우에는 소스코드를 참조해서 로직을 따라가다 보면 풀어갈 수 있다고 했다.&lt;/li&gt;
&lt;li&gt;좋은 컨디션으로 꾸준히 공부하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인내심을 가지고, 프로그래밍 및 기반 지식을 깊게 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자기 관리를 해서, 업무에 지장이 없는 상태로 만들자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 기반지식을 잘 이해하면 튜닝하는데, 즐거움을 느낄 수 있다. 따라서 컴퓨터 공학 기반 지식을 이해하려고 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>슬로우 쿼리란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft.html</link>
      <pubDate>Mon, 29 Mar 2021 20:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;슬로우-쿼리란&#34;&gt;슬로우 쿼리란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&#34;&gt;MySql - The Slow Query Log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>성능 엔지니어링 및 절차</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8.html</link>
      <pubDate>Sun, 28 Mar 2021 23:24:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8.html</guid>
      <description>&lt;h2 id=&#34;1성능-엔지니어링이란&#34;&gt;1.성능 엔지니어링이란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;성능 엔지니어링은 시스템의 목표 성능 (응답 시간과 동시 접속자 수)를 정의하고 이를 달성하기 위해서 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좁게 생각하면 코드 상의 병목을 잡고 시스템의 설정을 바꿔서 성능을 높이는 튜닝으로 생각할 수 있지만, 성능 목표의 정의부터 최적의 성능을 위한 디자인 및 구현 같은 개발 초기의 설계 부분과 개발 후의 운영 단계 그리고 모니터링까지 전 과정을 포함한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능-엔지니어링을-해야하는-시기&#34;&gt;성능 엔지니어링을 해야하는 시기&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-분석-단계&#34;&gt;1. 분석 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;초기 요구사항 분석 및 시스템 기획 단계에서 성능에 대한 목표를 정해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표시간 , 시스템을 사용할 사용자 수와 시스템을 사용하는 동시 접속자수가 어떻게 되는지와 같은 성능 목표를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 성능 모델을 만들어서, 시스템에 부하가 어떤 패턴으로 들어오는지를 정의할 필요가 있다. 예를 들어서, 주부를 대상으로 하는 사이트라면 시스템의 부하는 한국 시간으로 아이들이 학교나 유치원에 간 시간에 많이 몰릴 것이라고 추측할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-디자인-단계&#34;&gt;2. 디자인 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 디자인 단계에서는 목표 성능과 용량을 달성할 수 있는 규모로 시스템 설계를 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 관점에서 시스템 디자인은 항상 피크 타임(최대 성능)에 맞춰서 디자인 된다. 전체 시스템이 감당할 수 있는 용량과 응답 시간을 고려해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 성능과 용량은 애플리케이션 디자인뿐만 아니라 기술을 결정하는 데도 많은 도움을 준다. 어떤 미들웨어나 프레임워크를 사용할 것인지에 따라서 성능의 차이가 많이 발생하기 때문에, 디자인 단계부터 성능과 용량을 고려해서 시스템을 설계 해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하드웨어 관점에서는 예전에는 성능 모델을 산정하고, 피크 타임을 기준(최대 성능 요구)으로 시스템을 설계하고 하드웨어를 구매하였으나, 근래에는 클라우드를 이용하여 필요 시에만 하드웨어를 탄력적으로 사용하는 오토 스케일 모델을 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 성능이나 용량에 관련된 제품 선정이나 설계는 돌려 보지 않으면 확신하기 어렵다 따라서 사용할 기술은 선택한 다음에, 간단한 프로토타입을 구현하고 시나리오가 단순한 대규모 성능 및 용량 테스트를 해보는 &lt;code&gt;PoC(Proof of Concept)&lt;/code&gt;같은 작업을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-개발-단계&#34;&gt;3. 개발 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발 단계는 리스크가 높은 부분과, 아키텍처에 관련되는 부분, 난도가 높은 부분, 핵심 기능 등을 개발 초기의 스프린트에서 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 스프린트가 끝나고 릴리즈 돼서 성능 테스트나 가능한 &lt;code&gt;QA&lt;/code&gt;나 스테이징 환경으로 시스템이 이전되면 성능 엔지니어링 역량을 이 단계에서 집중하여 시스템의 아키텍처와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 단계에서 성능 목표의 달성 가능 여부가 판단되어야 아키텍쳐 변경이 가능하고 주요 성능 이슈들을 초반에 발견해야 성능에 대해서 같은 문제가 발생하지 않도록 디자인 가이드나 코딩 가이드를 개발자들에게 배포하여 위험을 줄인다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-최종-테스트-단계&#34;&gt;4. 최종 테스트 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞의 단계에서 성능과 용량을 고려해서 설계했고 개발 초기 단계에서 성능과 용량 부분의 검증을 제대로 하였다면, 최종 테스트 단계에서는 개발된 최종 시스템에 대한 성능, 용량 부분의 측정, 미세 튜닝을 하는 정도로 마무리되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정에서는 실수로 잘못한 설정이나, 코딩의 검증이 이루어진다. 예를 들어서 로그 파일을 &lt;code&gt;NFS&lt;/code&gt;와 같은 리모트 디스크에 쓴다든지, 인텔 계열의 &lt;code&gt;CPU&lt;/code&gt;에서 하이퍼스레딩 &lt;code&gt;ON&lt;/code&gt;을 하지 않았든지 같은 실수가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 오류들이 해결되면 실제 미세 튜닝에 들어가는데, &lt;code&gt;JVM&lt;/code&gt; 튜닝이나 톰캣의 설정 튜닝, &lt;code&gt;SQL&lt;/code&gt; 튜닝 등이 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 미세 튜닝에서 성능이 비약적으로 향상되지는 않는다, 보통 &lt;code&gt;20%&lt;/code&gt; 내외 정도의 성능이 올라간다고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-운영-단계&#34;&gt;5. 운영 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 시에 발견되지 않은 성능 문제가 있을 수 있기 때문에, 모니터링 도구를 사용하여 지속적으로 성능을 모니터링하고 성능 상태에 문제가 있는 부분을 지속적으로 수정해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 및 목표 용량 설정은 매우 중요한 과정이다. 기존 업무 시스템의 사용 패턴을 분석하는 것이 효율적이기 때문에, 운영 시스템의 로그를 수집하고 분석하여 성능 모델을 분석 및 보유해두는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2시스템-용량-산정&#34;&gt;2.시스템 용량 산정&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;response-time-응답-시간&#34;&gt;Response Time (응답 시간)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사용자가 서버에 요청을 한 시간부터 응답을 받을 때까지의 모든 시간을 포함한다. 이 응답 시간은 내부적으로 세분화 하여 분리된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Time(또는 Latency Time) : 서버에 요청을 보내고 받을 때 소요되는 네트워크 시간&lt;/li&gt;
&lt;li&gt;Transaction Time : 서버에서 실제 트랜잭션에 처리되는 시간을 의미한다.&lt;/li&gt;
&lt;li&gt;Think Time : 사용자가 보낸 요청에 대한 응답을 받고, 웹 페이지를 보거나 화면을 보는 시간을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrent-user동시-사용자&#34;&gt;Concurrent User(동시 사용자)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112756483-512a1e00-9020-11eb-9d33-9da5f8dac741.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템을 사용하는 사용자를 말한다. 웹 사이트를 사용하기 위해서 현재 브라우저를 열어놓고 웹 사이트를 보는 것과 같이 현재 시스템을 사용하는 사용자 수를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;active-user액티브-사용자&#34;&gt;Active User(액티브 사용자)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템에 트랜잭션을 실행하여 부하를 주는 사용자를 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;는 클릭을 통해 그 시간에 서버에 트랜잭션을 발생시키는 사용자를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 서버에서 순간 실행되고 있는 스레드 수(스레드 기반의 자바 서버인 경우)나 프로세스의 수와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 실제로 서버가 동시에 처리할 수 있는 트랜잭션의 양을 판단할 수 있는 기준이 되기 때문에, 매우 중요한 성능 요인이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transaction-트랜잭션&#34;&gt;Transaction (트랜잭션)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션이란 사용자로부터 요청을 다루는 단위를 말한다.&lt;/li&gt;
&lt;li&gt;이러한 트랜잭션의 정의는 무엇을 판단 기준으로 할 것인가에 따라 결정되는데, 예를 들어 리소스를 톰캣과 같은 애플리케이션 서버에서 처리하지 않고 앞단의 &lt;code&gt;CDN&lt;/code&gt;이나 웹 서버에서 처리할 때, 톰캣은 리소스에 대한 트랜잭션 요청을 받지 않는다.&lt;/li&gt;
&lt;li&gt;리소스에 대한 로딩은 비즈니스 로직 처리보다 부하가 상대적으로 적고, 일반적으로 브라우저에 캐시 되기 때문에, 보통 서버의 성능 측정 시 이러한 리소스 로딩에 대한 부하는 트랜잭션 단위로 처리하지 않는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tpstransaction-per-second&#34;&gt;TPS(Transaction per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;초당 처리할 수 있는 트랜잭션의 양을 말한다.&lt;/li&gt;
&lt;li&gt;보통 서버의 성능 평가 기준이 된다, &lt;code&gt;Active User&lt;/code&gt;가 순간 트랜잭션을 처리한다고 하면 이는 목표 응답시간 &lt;code&gt;(Response Time)&lt;/code&gt;으로 나눈 값이 목표 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;li&gt;예를 들어서 &lt;code&gt;Active User&lt;/code&gt;가 50 명이고 개당 응답 시간이 2초라고 하면 이 시스템의 &lt;code&gt;TPS&lt;/code&gt;는 25 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hpshit-per-second&#34;&gt;HPS(Hit Per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 처리할 수 있는 모든 웹 요청의 초당 처리량이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TPS&lt;/code&gt;가 비즈니스 트랜잭션에 대한 처리 시간만을 정의한다면 &lt;code&gt;HPS&lt;/code&gt;는 리소스(이미지, 자바 스크립트)에 대한 요청 처리량을 포함하기 때문에 &lt;code&gt;TPS&lt;/code&gt;보다 약 10 ~ 20 배 높게 나온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-테스트와-모니터링&#34;&gt;3. 테스트와 모니터링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;부하 테스트를 할 때, 주요 성능 요인을 모니터링하고 기록해야한다.&lt;/li&gt;
&lt;li&gt;주요 모니터링 해야하는 대상 및 관점은 애플리케이션, 미들웨어, 인프라 관점으로 나눌 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;애플리케이션-관점&#34;&gt;애플리케이션 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적으로 애플리케이션, 즉 시스템의 성능을 측정해야한다. 주요 모니터링 내용은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Response Time&lt;/code&gt; : 요청(&lt;code&gt;Request&lt;/code&gt;)별 응답시간&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TPS(Throughput per second)&lt;/code&gt; 초당 요청(&lt;code&gt;Request&lt;/code&gt;) 처리량&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 요인들이 성능의 궁극적인 최종 목표 값이 되기 때문에, 가장 중요한 성능 요인이 되며 부하 생성 도구를 통해서 쉽게 측정 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;미들웨어-관점&#34;&gt;미들웨어 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;미들웨어는 애플리케이션이 동작하기 위한 기본적인 솔루션이다.&lt;/li&gt;
&lt;li&gt;아파치와 같은 웹 서버나 톰캣과 같은 웹 애플리케이션 서버, &lt;code&gt;RabbitMQ&lt;/code&gt;와 같은 메시지 큐, &lt;code&gt;MySQL&lt;/code&gt;과 같은 데이터베이스가 해당한다.&lt;/li&gt;
&lt;li&gt;각 성능 시나리오 별로 거쳐가는 모든 미들웨어를 모니터링 해야하는데, 이를 위해서는 각 솔루션에 대한 깊은 이해가 필요하다.&lt;/li&gt;
&lt;li&gt;웹 서버는 성능이 문제가 되는 부분은 거의 없다, 성능 문제는 대부분 네트워크 아웃 바운드 (&lt;code&gt;IO&lt;/code&gt;, 대역폭) 쪽에서 발생할 때가 많다.&lt;/li&gt;
&lt;li&gt;웹 서버가 설치된 하드웨어 네트워크 아웃바운드 &lt;code&gt;IO&lt;/code&gt;의 대역폭을 모니터링하는 것이 유용하다.&lt;/li&gt;
&lt;li&gt;대부분의 성능 문제는 실제 애플리케이션 로직이 수행되는 톰캣과 같은 애플리케이션 서버와 데이터베이스 단에서 많이 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;애플리케이션 서버는 스레드의 수오 큐의 길이가 1차 모니터링 대상이 된다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;서버가 용량을 추가하게 되면 유휴 스레드(&lt;code&gt;Idle Thread&lt;/code&gt;) 수가 떨어지게 되고 유휴 스레드가 0이 되면 요청 메시지가 앞단의 큐에 저장된다.&lt;/li&gt;
&lt;li&gt;따라서 이 두개를 모니터링 하면, 시스템이 병목 상태인지 아닌지를 판단할 수 있다.&lt;/li&gt;
&lt;li&gt;이 값들은 &lt;code&gt;JMX(Java Management Extenstion)&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;를 이용하여 모니터링 하면된다.&lt;/li&gt;
&lt;li&gt;DB의 경우에는 슬로우 쿼리를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다.&lt;/li&gt;
&lt;li&gt;슬로우 쿼리를 찾았으면, &lt;code&gt;EXPLAIN&lt;/code&gt; 명령어를 이용하여 쿼리의 수행 내용을 분석한 후에 인덱스 등의 튜닝을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인프라-관점--cpu-메모리-네트워크-io-디스크-io&#34;&gt;인프라 관점 : CPU, 메모리, 네트워크 IO, 디스크 IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하드웨어 인프라 모니터링은 전문적인 인프라 모니터링 도구를 사용하거나 &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;sar&lt;/code&gt;와 같은 기본적인 유닉스 또는 리눅스 명령어를 사용해도 가능하다.&lt;/li&gt;
&lt;li&gt;부하 테스트 중에 &lt;code&gt;top&lt;/code&gt;을 띄워놓고 모니터링 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 &lt;code&gt;CPU&lt;/code&gt;는 대부분 잘 모니터링 한다.&lt;/li&gt;
&lt;li&gt;목표 성능을 달성할 시에는 보통 70 ~ 80 퍼센트를 사용하는 것이 좋고 항상 20 ~ 30 퍼센트의 여유를 두는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;메모리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로, 메모리 부분이다. 피크 타임시에 메모리가 얼마나 사용되느냐가 중요한데, 자바 애플리케이션은 특성상 전체 &lt;code&gt;JVM&lt;/code&gt; 프로세스가 사용할 메모리 양을 미리 정해놓기 때문에, 부하 테스트 중에도 메모리 사용량은 크게 변화지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만, 스와핑 (&lt;code&gt;Swapping Status&lt;/code&gt;)를 자주 놓치게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스, 유닉스 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해서 가상 메모리라는 개념을 사용하고 스와핑 공간이라는 디스크 공간에 자주 사용하지 않는 메모리의 내용을 덤프해 저장해여, 다시 사용할 때 메모리에 로딩하는 방식을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런데 이 메모리의 내용을 디스크에 저장 및 로드 하는 과정 (스와핑)이 실제 디스크 &lt;code&gt;IO&lt;/code&gt;를 발생시키기 때문에 실제 메모리 액세스 성능이 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 시스템에서 스와핑이 발생하면 시스템 성능이 장애 수준으로 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;디스크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디스크 &lt;code&gt;IO&lt;/code&gt;는 파일 시스템에 파일을 저장하는 시나리오나 로그를 저장하는 모듈, 그리고 데이터베이스와 같이 뒷단에서 파일 시스템을 요구하는 모듈에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디스크 IO에 대한 병복은 여러 가지 해결 방법이 있다. 먼저 하드웨어 인프라 자체에서 접근하는 방식은 디스크 자체를 &lt;code&gt;SSD&lt;/code&gt;로 변경하거나, 버퍼가 크거나 &lt;code&gt;RPM&lt;/code&gt;이 높은 디스크로 변경하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RAID&lt;/code&gt; 구성을 스트리핑 방식으로 변경해서,&lt;code&gt;IO&lt;/code&gt;를 여러 디스크로 분산시키는 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 차원에서는 데이터베이스 앞에 &lt;code&gt;Memcached&lt;/code&gt;와 같은 캐싱을 사용하거나, 로깅의 경우에는 중간에 메시지 큐를 써서 로그를 다른 서버에 쓰도록 하여 &lt;code&gt;IO&lt;/code&gt;를 분산시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 백 라이트(&lt;code&gt;Back Write&lt;/code&gt;)같은 방식으로 로그 메시지가 발생할 때마다, 디스크에 쓰는 것이 아니라, 20, 30개씩 한꺼번에 디스크로 플러싱하는 방식을 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조금 더 높은 아키텍처 수준으로는, 디스크 &lt;code&gt;IO&lt;/code&gt;가 많이 발생하는 로직은 동기 처리에서, 메시지 큐를 이용하는 비동기 방식으로 시스템 설계를 변경하는 방법을 고민할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 사진을 올려서 변환하는 서비스는 파일을 업로드 하는 시나리오와 변경하는 모듈을 분리하여, 파일 업로드가 끝나면 사용자에게 동기 방식으로 바로 응답을 줘서 응답 시간을 빠르게 하고, 업로드된 파일은 뒷단에서 비동기 프로세스를 통한 변환 과정을 끝낸 후에 사용자에게 결과를 알려주는 방법을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 &lt;code&gt;IO&lt;/code&gt;는 특히 고용량의 파일이나 이미지 전송에서 병목이 주로 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주로 &lt;code&gt;Reverse Proxy&lt;/code&gt;, &lt;code&gt;NAT(Network Address Translator)&lt;/code&gt;, 라우터, 로드 밸런서 등에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지 지점과 장비에 대해서 모니터링해야하기 때문에, 일반적인 유닉스, 리눅스 명령어를 사용하는 것 보다는 전문적인 툴을 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래프를 보면서 추이를 지켜보는 것이 중요한데, 부하를 넣으면 일정 수준이 되어도 시스템들의 &lt;code&gt;CPU&lt;/code&gt;, 메모리, 디스크 등의 기타 자원들은 넉넉한데 네트워크 입력, 출력 수준이 일정 수준 이상으로 올라가지 않는 경우가 있다. 이러한 경우는 네트워크 병목일 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 소프트웨어 기반의 로드 밸런서 및 소프트웨어 기반의 &lt;code&gt;NAT&lt;/code&gt; 장비에서 많이 발생하는데 이미지와 같은 정적 콘텐츠는 될 수 있으면 &lt;code&gt;CDN&lt;/code&gt;이나 분리된 웹 서버를 이용해서 서비스 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우는 특히나 소프트웨어기반의 &lt;code&gt;NAT&lt;/code&gt; 및 로드밸런서를 사용해서 문제가 생기는 경우가 많은데, &lt;code&gt;NAT&lt;/code&gt;의 경우에는 여러 개의 &lt;code&gt;NAT&lt;/code&gt;을 사용해서 로드를 분산하도록 하고 로드 밸런서의 경우에도 충분히 용량이 큰 로드 밸런서를 사용하거나 두 개 이상의 로드 밸런서를 사용하고 &lt;code&gt;DNS&lt;/code&gt; 라운드 로빈을 사용하는 방법을 고려해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 28 Mar 2021 18:15:49 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 시작했다.&lt;/li&gt;
&lt;li&gt;내가 여태까지 정리했던 글을 보면서, 남에게 이를 설명할 수 있는지 녹화를 해보고 이를 시청하였다.&lt;/li&gt;
&lt;li&gt;다른 곳에 적어두었지만, 미쳐 블로그에 올리지 않은 내용을 정리해서 블로그에 포스팅을 해보았다.&lt;/li&gt;
&lt;li&gt;회의 때 토의했던 내용중에 다르게 해석한 부분이 있었다.&lt;/li&gt;
&lt;li&gt;회의 때 토의했던 내용을 착각한 뒤로 팀원에게 메신저로 내가 했던 일을 공유하고 그 다음에 어떤 일을 진행할 것인지 상세하게 말했다.&lt;/li&gt;
&lt;li&gt;내가 궁금해하는 기업이 어떤 기술을 쓰는지를 분석하기 위해서 그 회사의 기술 블로그 및 세미나 발표 영상을 보면서 공부를 하였다.&lt;/li&gt;
&lt;li&gt;토이 프로젝트를 진행할 때 사용자 관점에서 생각을 하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112748805-4b6d1200-8ff9-11eb-93b1-24b0b3265418.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 진행할 때 주 마다 사용자는 무엇을 할 수 있는지를 적어야 하는데, 나는 우선 개발이 되지 않았으므로 사용자는 할 수 있는 것이 없다고 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 하면서 혼자서 많은 일을 하는 것 보다, 다른 사람들에게 일감을 나누고 같이 협업하는 방법을 배우는게 중요하다고 생각했다.&lt;/li&gt;
&lt;li&gt;실제로 설명을 해보면서 내가 제대로 설명하지 못하는 것을 알게 되었고, 실제로 모르고 있었음에도 불구하고 안다고 착각하는 것도 많았다.&lt;/li&gt;
&lt;li&gt;내가 공부한 내용을 포스팅 하면서 다시 복습하니까 몰랐던 부분도 이해가 되고 좋았다. 다만 시간이 너무 많이 들어서 진작 포스팅에 재미를 느꼈으면 어떨까하는 아쉬움도 남는다.&lt;/li&gt;
&lt;li&gt;회의때 집중을 하면서 들어야겠다는 생각이 들었고 조금 많이 부끄러웠다.&lt;/li&gt;
&lt;li&gt;팀원 분들이 좋아하셨고, 내가 어떤 문제를 막혔을 때 내가 진행했던 상황을 이해시키는 시간도 훨씬 빨랐다.&lt;/li&gt;
&lt;li&gt;과거에 그 회사가 고민한 내용을 배울 수 있었고, 현재 어떤 기술을 사용하는지도 익힐 수 있었다.&lt;/li&gt;
&lt;li&gt;하지만, 트레이너분은 사용자에게 어떤 방식으로도 가치를 전달할 수 있는 것이 중요하다고 했고 구글 스프레드를 이용해서 사용자에게 가치를 전달 할 수 있다고 했다. 그 이야기를 듣고 내가 너무 개발자 적인 사고에 갇혀있다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배운 내용을 직접 남에게 설명하듯이 설명해보면서 내가 정말로 알고있는지를 검증하는 법을 배웠다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 보안이 정말로 중요함에도 불구하고 보안에 대해서 소흘히 생각하고 있었다.&lt;/li&gt;
&lt;li&gt;실제 웹 애플리케이션을 만들 때 비즈니스 로직 뿐만 아니라 인프라적인 지식이 중요하다는 것을 깨닫게 되었다. 현재 회사에서 데브옵스 팀이 있다고 해서 인프라적인 지식을 몰라도 되는 것은 아니다 토이프로젝트를 하거나 따로 익히면서 인프라적인 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;브라우저 보안을 위한 다양한 정책을 알게 되었고, 어떠한 에러가 발생하였을 때, 왜 이러한 에러가 발생하였는지 브라우저, 운영체제, 프레임워크 설계자 관점에서 생각을 해봐야겠다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;일을 시작하기전에, 다른 팀원들에게 내가 하려는 일과 했던 일을 공유하자.&lt;/li&gt;
&lt;li&gt;기업을 분석할 때, 그 회사 및 부서에서 작성한 기술 블로그를 살펴보고 세미나에서 발표한 영상을 보면서 분석하면 그 회사에 대해서 자세히 알 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;개발적으로만 문제를 해결하려고 하지 말자. 다양한 방법으로 문제를 해결할 수 있다 중요한 것은 어떤 가치를 줄 수 있는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배우려고 노력했고, 기록하려고 노력했다, 이제는 남에게 쉽게 알려줄 수 있게 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남에게 설명해본적이 별로 없는 것 같다. 이는 나중에 들어오는 사람에게 뭔가를 설명할 때 제대로 설명해주지 못해서 많은 도움을 줄 수 없을 수도 있다. 따라서 지금부터라도 내가 알고 있는 것을 잘 설명할 수 있는 연습을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 정말로 알고 있는지 남에게 설명하면서 이를 검증해보자.&lt;/li&gt;
&lt;li&gt;발표를 평소에 많이 해보고, 혼자서라도 남에게 설명해주듯이 설명하는 연습을 하자.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리플리케이션이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 17:43:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;gelera-리플리케이션&#34;&gt;Gelera 리플리케이션&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113364491-a05caf80-938e-11eb-8a11-e5933db7f28d.png&#34; alt=&#34;Screen Shot 2021-04-02 at 8 36 21 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MariaDB&lt;/code&gt; 클러스터에서, 서버는 트랜잭션과 관련된 쓰기를 클러스터의 모든 노드에 브로드캐스트해서 커밋을 할 때, 모든 노드에 트랜잭션을 복사한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트는 &lt;code&gt;DBMS&lt;/code&gt;에 직접 연결하여 대부분의 경우 기본의 &lt;code&gt;MariaDB&lt;/code&gt;와 유사한 동작을 경험할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wsrep(write set replication API)&lt;/code&gt;를 이용하여 &lt;code&gt;Galera&lt;/code&gt; 리플리케이션과 &lt;code&gt;MariaDB&lt;/code&gt; 사이의 인터페이스를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;동기-vs-비동기-리플리케이션&#34;&gt;동기 vs 비동기 리플리케이션&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동기식 복제와 비동기식 복제의 기본적인 차이점은 동기식 복제는 클러스터에서 한 노드에서 변경이 발생한 경우에, 클러스터의 다른 노드에서 동기적으로 변경이 발생한다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비동기적인 복제는 마스터 노드에 변경사항을 적용하는 것과 슬레이브 노드에 변경사항을 전파 하는 도중에 데이터가 다를 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 마스터 노드가 비동기적인 복제 중에 오류가 생기면 변경 사항중에 일부가 손상 될 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 이점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 가용성이 높다.&lt;/li&gt;
&lt;li&gt;노드중에 하나가 손실 되더라도 데이터는 손실되지 않으며 모든 클러스터 노드는 항상 일관적이다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터를 사용하면, 모든 노드에 동시에 트랜잭션을 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 전체 클러스터에서 인과 관계를 보장할 수 있다. 즉, 클러스터 노드에서 트랜잭션을 실행한 후에 하나의 클러스터 노드에서 &lt;code&gt;SELECT&lt;/code&gt;가 실행되는 경우 해당 트랜잭션의 영향을 확인해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만, 동기식 데이터베이스 복제는 전통적으로 매우 느린것으로 판명된 &lt;code&gt;2PC(two phase commit)&lt;/code&gt;또는 분산 잠금을 통해서 구현되었다.&lt;/li&gt;
&lt;li&gt;동기식 복제의 낮은 성능과 구현의 복잡성으로 인해서 비동기식 복제가 데이터베이스 성능 확장성 및 가용성의 주요 수단으로 사용되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만, &lt;code&gt;Galera&lt;/code&gt;의 리플리케이션은 완전하게 동기화된 것은 아니지만 이것은 가상 동기 리플리케이션이라고 불린다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/about-galera-replication/&#34;&gt;About Galera Replication&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>쿼리 오프 로딩이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 17:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>네트워크 메시지 암호화 및 방식 (중간자 공격, HMAC, 대칭, 비대칭 키)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4.html</link>
      <pubDate>Sun, 28 Mar 2021 16:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4.html</guid>
      <description>&lt;h3 id=&#34;네트워크전송-레벨-암호화&#34;&gt;네트워크(전송) 레벨 암호화&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745214-a7c43780-8fe1-11eb-8d75-3bd315668317.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적이고 필수적인 &lt;code&gt;REST API&lt;/code&gt; 보안 방법은 네트워크 전송 프로토콜에서 &lt;code&gt;HTTPS&lt;/code&gt; 보안 프로토콜을 사용하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt; 프로토콜을 사용한다 하더라도, 메세지 자체를 암호화해서 전송하기 때문에 해킹으로 말미암은 메시지 누출 위협을 해소할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 &lt;code&gt;HTTPS&lt;/code&gt;를 사용하더라도 메시지를 낚아 채거나 변조하는 방법이 있는데 이러한 해킹 방법을 바로 중간자 공격 (&lt;code&gt;Man-In-The-Middle-Attack&lt;/code&gt;)이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정상적인 &lt;code&gt;HTTPS&lt;/code&gt; 통신의 경우 다음과 같이 서버에서 제공하는 인증서를 이용하여 API와 서버 상호간에 암호화된 신뢰할 수 있는 새로운 네트워크 연결을 만든다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745283-1bfedb00-8fe2-11eb-8bf1-6c7de2d8fcee.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;중간자 공격의 경우에는 신뢰할 수 있는 연결을 만들려고 할 때 해커가 &lt;code&gt;API&lt;/code&gt; 클라이언트와 서버 사이에 끼어들어 온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;신뢰할 수 있는 연결을 만들고자 서버가 인증서를 클라이언트에 내릴 때 해커가 이 인증서가 아닌 다른 인증서를 클라이언트에게 전달하고, 다른 인증서를 이용하여 &lt;code&gt;API&lt;/code&gt; 클라이언트와 해커간에 HTTPS SSL 연결을 만든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 서버에게서 받은 인증서를 이용해서 서커와 &lt;code&gt;API&lt;/code&gt; 서버 간의 HTTP SSL 연결을 맺는다. 이렇게 되면 해커는 중간에서 API 클라이언트와 서버 사이에 메시지를 모두 열어보고 변조도 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 중간자 공격을 방지하는 방법중에는 여러가지가 있지만, 가장 손쉬운 방법은 공인인증서를 사용하고 인증서를 확인하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공인인증서는 &lt;code&gt;Verisign&lt;/code&gt;과 같은 기관에서 인증서에 대한 공인 인증을 해준다. 즉, 이 인증서를 발급한 사람이 누구인가에 대한 신원 정보를 가지고 있다. 이를 공인 인증서라고 하는데, 공인 인증서는 인증 기관의 서명이 되어 있다. (공인 인증기관이 인증했다는 정보가 암호화 되서 들어간다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해커가 공인인증서를 사용하려면 인증 기관에 가서 개인 정보를 등록해야하고, 자체 발급한 비공인 인증서를 사용하기 때문에 이를 이용해서 체크가 가능하다. 특히 인증서 안에는 인증서를 발급한 기관의 정보와 인증서에 대한 고유 일련번호가 들어가 있기 때문에 클라이언트에서 이 값을 확인해서 내가 발급하고 인증 받은 공인 인증서인지를 점검하도록 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메시지-본문-암호화&#34;&gt;메시지 본문 암호화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;암호화가 필요한 특정 필드만 애플리케이션 단에서 암호화하여 보내는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지를 암호화하여 통신하려면, 클라이언트와 서버가 암호화 키를 가져야하는데, 암호화키는 크게 대칭 키와 비대칭 키 알고리즘 두 가지가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비대칭 키 알고리즘은 암호화를 하는 키와 암호를 푸는 복호화 키가 다른 경우로, 암호화 하는 키를 공개 키(&lt;code&gt;Public Key&lt;/code&gt;)라고 하고, 암호화를 푸는 키를 비밀 키(&lt;code&gt;Private Key&lt;/code&gt;)라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 공개 키는 암호화 할 수 있지만, 반대로 암호화된 메시지는 풀 수 없으므로 누출이 되어도 안전하다. (해커가 중간에서 공개 키를 낚아 챈다하더라도 이 키로는 암호화된 메시지를 복호화할 수 없다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 처음 클라이언트가 서버에 인증이 되었을 때 클라이언트에게 이 공개 키를 내리고, 이 후에 메시지를 이 공개 키를 통해서 암호화를 하게 되면 암호화된 메시지는 비밀키를 가진 서버만이 풀 수 있어서 안전하게 서버로 메시지를 보낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 비대칭 키 알고리즘으로는 &lt;code&gt;RSA&lt;/code&gt; 등이 있으며 익숙한 &lt;code&gt;HTTPS&lt;/code&gt;의 경우에도, 이 &lt;code&gt;RSA&lt;/code&gt; 알고리즘을 사용한다. &lt;code&gt;RSA&lt;/code&gt; 알고리즘을 사용하는 비대칭 키 암호화 로직과 라이브러리등은 공개된 것들이 많으므로 참고해서 사용하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비대칭 키 알고리즘은 클라이언트에서 서버로 보내는 단방향 메시지에 대해서는 암호화하여 사용할 수 있지만, 반대로 서버에서 클라이언트로 내려오는 응답 메시지 등에는 적용하기 어렵다. 아니면 클라이언트가 서버에 등록될 때, 위와 반대 방법으로 클라이언트가 서버로 공개 키를 보내서 향후 서버에서 클라이언트로 통신에 그 공개 키를 사용하도록 해도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 클라이언트와 서버 그리고 서버와 클라이언트 간의 키 쌍 두개를 관리해야 하기 때문에 복잡할 수 있는데, 이런 때에는 대칭 키 알고리즘을 고려해 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대칭 키 알고리즘은 암호화와 복호화 키가 같은 알고리즘이다. 이 경우 &lt;code&gt;API&lt;/code&gt; 클라이언트와 서버가 같은 키를 알고 있어야 한다. 키를 네트워크를 통해서 보내면 중간에 해커에 의해서 낚아 채일 염려가 있기 때문에, 양쪽에 안전하게 키를 전송하는 방법이 필요하다. 따라서 다음과 같은 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 서버에서 공개 키 KA1과 비공개 키 KA2 쌍을 생성한다.
2. 클라이언트에게 공개 키 KA1을 네트워크를 통해서 내려 보낸다.
3. 클라이언트는 새로운 비공개 대칭 키 KB를 생성하고 KA1을 이용하여 암호화하여 서버로 전송한다.
4. 서버는 전송된 암호화 메세지를 `KA2`로 복호화하여 그 안에 있는 비 공개 키 KB를 꺼낸다.
5. 향후 클라이언트와 서버는 상호 API 통신시 비공개 대칭 키 KB를 이용하여 암호화와 복호화를 진행한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;메시지-무결성-보장&#34;&gt;메시지 무결성 보장&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;무결성이란 서버에서 &lt;code&gt;API&lt;/code&gt; 호출을 받았을 때, 이 호출이 신뢰할 수 있는 호출인지 아닌지를 구별하는 방법을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉, 해커가 중간에서 메시지를 가로채고 나서 내용을 변조하여 서버에 보냈을 때 내용이 변조되었는지를 판단하는 방법인데, 일반적으로 &lt;code&gt;HMAC&lt;/code&gt;을 이용한 방식이 널리 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745861-6c783780-8fe6-11eb-9f69-b693913434ed.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 먼저 클라이언트는 호출하고자 하는 REST API의 메시지를 앞에서 정의한 키를 이용하여 HMAC 알고리즘을 이용하여 해시 값을 추출한다.

2. API를 호출할 때, 메시지에 추출한 HMAC을 포함해서 호출한다.
3. 서버는 호출된 메시지를 보고 HMAC을 제외한 나머지 메시지를 미리 정의된 키를 이용해서 HMAC 알고리즘으로 해시 값을 추출한다.
4. 서버는 3버에서 생성된 HMAC 값과 API 호출시 같이 넘어온 HMAC 갑을 비교해서 값이 같으면 이 호출이 유효한 호출이라고 판단한다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약에 해커가 메시지를 중간에 가로채 변조했을 경우 서버에서 해시를 생성하면 변조된 메시지에 대한 해시가 생성되기 때문에, 클라이언트에서 변조 전에 보낸 해시 값과 달라진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 통해서 메시지 변조의 여부를 판단할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 메시지를 변경하지 않고 해커가 같은 요청을 반복해서 보낸다면 메시지를 변조하지 않았다는 것으로, 서버는 이를 유효한 호출로 인식할 수 있는데 이를 재전송 공격(&lt;code&gt;Reply Attack&lt;/code&gt;)이라고 한다. 따라서 이를 방지하기 위해서는 &lt;code&gt;timestamp&lt;/code&gt;를 이용하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방법은 &lt;code&gt;HMAC&lt;/code&gt;을 생성할 때, 메시지를 이용해서 해시 값을 생성하는 것이 아니라, 타임 스탬프를 포함해서 메시지를 생성하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;API&lt;/code&gt;를 호출할 때 &lt;code&gt;timestamp&lt;/code&gt; 값을 같이 실어 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://service.myapi.com/restapiservice?xxxxx&amp;amp;hmac={hashvalue}&amp;amp;timestamp={호출시간}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이렇게 하면 서버는 메세지가 호출된 시간을 알 수 있고, 호출된 시간 +- 10분(또는 개발자가 정한 시간 폭)만큼의 호출만 정상적인 호출로 인식하고 시간이 지난 호출의 메시지는 비정상적인 호출로 무시하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST API 보안 및 인가 방식</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D.html</link>
      <pubDate>Sun, 28 Mar 2021 15:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D.html</guid>
      <description>&lt;h3 id=&#34;권한-인가&#34;&gt;권한 인가&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;인증이 끝나면 다음 단계는 권한에 대한 인증, 즉 인가(&lt;code&gt;Authoriation&lt;/code&gt;) 과정이 필요하다. 사용자가 인증을 받고 로그인을 했더라도, 해당 API를 호출할 수 있는 권한이 있는가를 확인 해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;api-인가-방식&#34;&gt;API 인가 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;권한 인가(Authorization) 방식에는 여러 가지 방식이 있는데, 대표적인 방식 몇 가지만 보면 가장 일반적인 권한 인증 방식으로는 사용자의 역할을 기반으로 하는 &lt;code&gt;RBAC (Role Based Access Control)&lt;/code&gt; 이라는 방식이 있다. 이 방식은 정해진 연결에 권한을 연결해놓고, 이 역할을 가진 사용자에게 해당 권한을 부여하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 &lt;code&gt;API&lt;/code&gt; 권한 인가 체크는 인증(Authentication)이 끝난 후에 인가에 사용된 API Access Token을 이용하여 사용자 정보를 조회하고, 사용자 정보에 연관된 정보(&lt;code&gt;Permission&lt;/code&gt;이나 &lt;code&gt;Role&lt;/code&gt; 정보)를 받아서 이 권한 정보를 기반으로 &lt;code&gt;API&lt;/code&gt; 사용 권한을 인가하는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 권한 검증을 이용하여 &lt;code&gt;API Access Token&lt;/code&gt; 으로 사용자를 찾고 사용자에게 할당된 역할이나 &lt;code&gt;Access Control&lt;/code&gt;을 받아서 &lt;code&gt;API&lt;/code&gt; 인증을 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인가 방식의 종류로는 아래 두 가지 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rbacrole-based-access-control&#34;&gt;RBAC(Role Based Access Control)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744459-3d0ffd80-8fdb-11eb-9300-594cc1bebe93.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;일반 사용자 : 사용자 관리, 게시물 관리, 회원 가입 승인
마스터 관리자 : 카폐 게시판, 관리, 메뉴 관리, 사용자 관리, 게시물 관리, 회원 가입 승인
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 권한을 만들고, 사용자에게 &lt;code&gt;마스터 관리자&lt;/code&gt;라는 역할을 부여하면, 사용자는 카페 게시판 관리, 사용자 관리, 게시물 관리, 회원 가입 승인 등의 권한을 가지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 권한 부여의 대상이 되는 사용자나 그룹을 &lt;code&gt;Object&lt;/code&gt;라고 하고 개별 권한을 &lt;code&gt;Permission&lt;/code&gt; 이라고 정의하며 사용자의 역할을 &lt;code&gt;Role&lt;/code&gt; 이라고 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RBAC&lt;/code&gt;는 이 &lt;code&gt;Role&lt;/code&gt;에 권한을 맵핑한 다음 &lt;code&gt;Object&lt;/code&gt;에 이 &lt;code&gt;Role&lt;/code&gt;을 부여하는 방식으로, 많은 권한 인가는 사용자 역할을 기반으로 하기 때문에 사용하기 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;aclaccess-control-list&#34;&gt;ACL(Access Control List)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744519-c45d7100-8fdb-11eb-8ee7-9f2e073c8752.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RBAC 방식이 권한을 &lt;code&gt;Role&lt;/code&gt;이라는 중간 매개체를 통해서 사용자에게 부여하는데 반해서 ACL 방식은 사용자 (또는 그룹과 같은 권한의 부여 대상) 에게 직접 권한을 부여하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자에게 직접 카페 게시판 관리, 메뉴 관리, 게시물 관리, 회원 가입 승인 권한을 부여하는 방식이 대표적인 &lt;code&gt;ACL&lt;/code&gt;의 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;api-권한-인가-처리-위치&#34;&gt;API 권한 인가 처리 위치&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API에 대한 권한 인가 처리는 여러가지 계층에서 처리할 수 있다. 권한 인가는 API를 호출하는 쪽인 클라이언트, API를 실행하는 API 서버, 그리고 API에 대한 중간 길목 역할을 하는 게이트웨이 등 3군데에서 처리할 수 있으며 근래에는 API 서버쪽에서 처리하는 것이 가장 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;권한 인가 위치는 아래와 같은 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클라이언트에-대한-api-권한-인가-처리&#34;&gt;클라이언트에 대한 API 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;를 호출하는 클라이언트 쪽에서 사용자의 권한에 따라서 &lt;code&gt;API&lt;/code&gt;를 호출하는 방식인데, 이 방식은 클라이언트가 신뢰할 수 있는 경우에만 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 기존에 웹 &lt;code&gt;UX&lt;/code&gt; 로직이 서버에 배치된 형태 (스트러츠나 스프링 &lt;code&gt;MVC&lt;/code&gt;와 같은 웹 레이어가 있는 경우)에 주로 사용했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞의 사용자 &lt;code&gt;API&lt;/code&gt;를 예로 들어보면 웹 애플리케이션에서 사용자 로그인 정보(세션 정보와 같은)를 보고 사용자 권한을 조회하고 API를 호출하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 세션에서 사용자 ID와 역할을 본 후에, 역할이 일반 사용자일 경우 세션 내의 사용자 ID와 조회하고자 하는 사용자 ID가 일치하는 경우에만 API를 호출하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744706-69c51480-8fdd-11eb-83cf-cc16fefd7fb6.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 구조를 사용할 때, 모바일 디바이스 등에 제공하는 API는 사용자 역할을 하는 API와 같이 별도의 권한 인가가 필요 없는 API를 호출하는 구조를 갖는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;게이트웨이에-의한-권한-인가-처리&#34;&gt;게이트웨이에 의한 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 권한 인가는 모바일 클라이언트, 자바스크립트 기반의 웹 클라이언트 등 다양한 클라이언트가 지원됨에 따라서 점차 서버쪽으로 이동하게 되었는데, 특히 자바 스크립트 클라이언트는 클라이언트에서 권한에 대한 인가는 의미가 없어서 어쩔 수 없이 서버 쪽에서 권한 인가 처리를 할 수 밖에 없게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약에 자바스크립트에 권한 인가 로직을 넣은 경우, 브라우저의 디버거로 코드 수정이 가능하기 때문에 권한 처리 로직을 우회할 수도 있고, 또한 &lt;code&gt;API&lt;/code&gt; 포맷만 안다면 직접 &lt;code&gt;API&lt;/code&gt; 서버로 호출해서 권한 인가 없이 API를 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버에서 권한을 처리하는 방법은 &lt;code&gt;API&lt;/code&gt; 호출의 길목이 되는 게이트웨이나 &lt;code&gt;API&lt;/code&gt; 비즈니스 로직 두 군데서 처리할 수 있다. &lt;code&gt;API Gateway&lt;/code&gt;에 의한 권한 처리를 쉽지 않기 때문에 API 서머에서 권한 처리를 하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 호출이 들어오면 API 토큰 관리 정보를 이용해서, &lt;code&gt;API Access Token&lt;/code&gt;을 사용자 정보와 권한 정보로 변환하고 접근하고자 하는 &lt;code&gt;API&lt;/code&gt;에 대해서 권한 인가 처리를 한다. 이때는 &lt;code&gt;API&lt;/code&gt; 별로 &lt;code&gt;API&lt;/code&gt;에 접근하고자 하는데 필요한 권한을 확인해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 &lt;code&gt;HTTP GET /users/{:id}&lt;/code&gt;의 API를 예로 들면 이 &lt;code&gt;URL&lt;/code&gt;에 대한 &lt;code&gt;API&lt;/code&gt;를 호출하려면 일반 사용자 권한을 가진 사용자는 호출하는 사용자 &lt;code&gt;ID&lt;/code&gt;와 &lt;code&gt;URL&lt;/code&gt;상의 {id}가 일치할 떄, 호출을 허용하고, 같지 않을 때는 호출을 거절 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 이러한 &lt;code&gt;API Gateway&lt;/code&gt;에서의 권한 인가는 쉽지 않은데, 앞의 &lt;code&gt;/users/{id}&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;의 경우에는 사용자 ID가 &lt;code&gt;URL&lt;/code&gt;에 들어가 있기 때문에 &lt;code&gt;API Access Token&lt;/code&gt;과 맵핑되는 사용자 &lt;code&gt;ID&lt;/code&gt;와 그에 대한 권한을 통해서 &lt;code&gt;API&lt;/code&gt; 접근 권한을 통제할 수 있다. 하지만 &lt;code&gt;API&lt;/code&gt;에 따라서 사용자 아이디나 권한 인증에 필요한 정보가 &lt;code&gt;HTTP&lt;/code&gt; 바디에 &lt;code&gt;JSON&lt;/code&gt; 형태나 &lt;code&gt;HTTP&lt;/code&gt; 헤더 등에 들어가 있는 경우 일일히 메시지 포맷에 따라 별도의 권한 로직을 게이트 웨이 단에서 구현해야 하는 부담이 있고, 권한 통제를 위해서 &lt;code&gt;HTTP&lt;/code&gt; 메시지 전체를 일일히 파싱해야하는 오버로드가 발생하기 때문에 공통 필드 등으로 &lt;code&gt;API&lt;/code&gt; 권한 처리를 하지 않을 때에는 사용하기 어렵다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서버에-의한-api-권한-인가-처리&#34;&gt;서버에 의한 API 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 일반적이고 보편적인 방법은 &lt;code&gt;API&lt;/code&gt; 요청을 처리하는 &lt;code&gt;API&lt;/code&gt;서버의 비즈니스 로직 단에서 권한 처리를 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 앞에서 언급한 &lt;code&gt;API Gateway&lt;/code&gt; 방식과 비교했을 때, 각 비즈니스 로직에서 &lt;code&gt;API&lt;/code&gt; 별로 권한 인가 로직을 구현하기 용이하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 권한 인가에 필요한 필드들을, &lt;code&gt;API Gateway&lt;/code&gt;에서 변환해서 &lt;code&gt;API&lt;/code&gt; 서버로 전달해줌으로써 구현을 간략하게 할 수 있는데, 다음 그림과 같이 &lt;code&gt;API&lt;/code&gt; 클라이언트가 &lt;code&gt;API Access Token&lt;/code&gt;을 이용해서 &lt;code&gt;API&lt;/code&gt;를 호출 했을 경우, &lt;code&gt;API Gateway&lt;/code&gt;가 이 &lt;code&gt;Access Token&lt;/code&gt;을 권한 인가에 필요한 사용자 아이디, 롤 등으로 변환해서 &lt;code&gt;API&lt;/code&gt; 서버에 전달해주게 되면, 각 비즈니스 로직은 &lt;code&gt;API&lt;/code&gt; 권한 인가에 필요한 사용자 정보를 별도의 데이터베이스에서 찾지 않고도 이 헤더의 내용만을 이용해서 API 권한 인가 처리를 할 수 있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HTTP란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</guid>
      <description>&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol)의 약자로서, 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP는 요청(&lt;code&gt;REQUEST&lt;/code&gt;), 응답(&lt;code&gt;RESPONSE&lt;/code&gt;)을 통해서 정보를 주고 받으며, HTTP 메시지 구조는 크게 헤더(&lt;code&gt;HEADER&lt;/code&gt;)와 바디(&lt;code&gt;BODY&lt;/code&gt;)로 나누어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;curl-명령어를-통한-요청&#34;&gt;CURL 명령어를 통한 요청&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;요청 헤더 및 응답 헤더&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562451-79b14980-9ca9-11eb-9b65-dcee73144654.png&#34; alt=&#34;google&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 &lt;code&gt;curl&lt;/code&gt; 명령어를 통해서 구글 서버에 &lt;code&gt;GET&lt;/code&gt; 요청을 날려보았다.&lt;/li&gt;
&lt;li&gt;요청 헤더 및 응답 헤더를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;응답 바디&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562913-e62c4880-9ca9-11eb-9df8-b399eaa6e1da.png&#34; alt=&#34;response&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;, &lt;code&gt;CSS&lt;/code&gt;, &lt;code&gt;JS&lt;/code&gt; 파일을 응답한 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;웹 서버가 응답하는 파일은 이것이 전부이고, 브라우저에는 응답받은 파일을 통해서 화면에 그려주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>HTTP와 HTTPS의 차이점 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2818&#34;&gt;RFC - 2818&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST API 보안 및 인증 방식</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D.html</link>
      <pubDate>Sun, 28 Mar 2021 13:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D.html</guid>
      <description>&lt;h3 id=&#34;rest-api-보안&#34;&gt;REST API 보안&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;보안에 관해서는 백번, 천번을 강조해도 과함이 없다.&lt;/li&gt;
&lt;li&gt;근래의 대부분의 서비스 시스템들은 API를 기반으로 통신한다.&lt;/li&gt;
&lt;li&gt;앱과 서버 간의 통신 또는 자바 스크립트 웹 클라이언트와 서버 간 대부분의 통신이 이 API들을 이용해서, 이루어지기 때문에 한번 보안이 뚫리면 개인 정보가 탈취되는 것 뿐만 아니라, 더 많은 문제를 일으킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api-보안-관점-및-개요&#34;&gt;REST API 보안 관점 및 개요&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;인증authentication&#34;&gt;인증(Authentication)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;인증은 누가 서비스를 사용하는지를 확인하는 절차이다.&lt;/li&gt;
&lt;li&gt;쉽게 생각하면 웹 사이트에 사용자 아이디와 비밀번호를 넣어서 사용자를 확인하는 과정이 인증이다.&lt;/li&gt;
&lt;li&gt;API도 마찬가지로 API를 호출하는 대상 (단말이 되었던 다른 서버가 되었던 사용자가 되었건) 확인하는 절차가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112742701-a5ef7980-8fcb-11eb-8813-b50f905cdefe.png&#34; alt=&#34;Screen Shot 2021-03-28 at 1 43 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링 시큐리티에서는 인증을 &lt;code&gt;who are you?&lt;/code&gt; 라고 표현하고 인가를 &lt;code&gt;what are you allow to do?&lt;/code&gt; 라는 문장으로 비유하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인가authorization&#34;&gt;인가(Authorization)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인가는 해당 리소스에 대해서 사용자가 그 리소스를 사용할 권한이 있는지 확인하는 권한 체크 과정이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;/users&lt;/code&gt; 라는 리소스가 있을 때, 일반 사용자 권한으로는 내 사용자 권한만 볼 수 있지만, 관리자 권한으로는 다른 사용자 정보를 볼 수 있는 것과 같은 권한의 차이를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;네트워크-레벨-암호화&#34;&gt;네트워크 레벨 암호화&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인증과 인가 과정이 끝나서 API를 호출하게 되면, 네트워크를 통해서 데이터가 오가는데, 해커나 누군가 중간에서 이 네트워크 통신을 낚아채 (감청) 데이터를 볼 수 없게 할 필요가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 네트워크 프로토콜단에서 처리하는 것을 네트워크 암호화라고 하는데, &lt;code&gt;HTTP&lt;/code&gt;에서의 네트워크 암호화는 일반적으로 &lt;code&gt;HTTPS&lt;/code&gt; 기반의 프로토콜을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-무결성-보장&#34;&gt;메시지 무결성 보장&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 무결성이란, 메시지가 해커와 같은 외부 요인에 의해서 중간에 변조가 되지 않게 방지하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무결성을 보장하기 위해서 많이 사용하는 방식은 메시지에 대한 서명(Signature)를 생성해서 메시지와 같이 보내고 검증하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 메시지 문자열이 있을 때, 이 문자열에 대한 해시 코드를 생성해서 문자열과 함께 보내고 이 받은 문자열로 생성한 해시 코드를 문자열과 함께 온 해시 코드와 비교하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약에 문자열이 중간에 변조되었으면 원래 문자열과 함께 전송된 해시 코드와 맞지 않기 때문에 메시지가 중간에 변조되었는지 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 무결성의 경우 앞에서 언급한 네트워크 레벨의 암호화를 완벽하게 사용한다면 외부적인 요인(해커)에 의해서 메시지를 해석당할 염려가 없으므로 사용할 필요가 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-본문-암호화&#34;&gt;메시지 본문 암호화&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 레벨의 암호화를 사용할 수 없거나, 또는 이를 신뢰할 수 없는 상황에서 추가로 메시지 자체를 암호화하는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 애플리케이션 단에서 구현하는데, 전체 메시지를 암호화하는 방법과 특정 필드만 암호화하는 방식 두 가지로 접근할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전체 메시지를 암호화할 경우 암호화에 드는 비용이 많은 뿐더러 중간에 &lt;code&gt;API Gateway&lt;/code&gt;를 통해서 메시지를 열어보고 메시지 기반으로 라우팅 변환 작업이 어렵기 때문에 일반적으로 전체 암호화보다는 보안이 필요한 특정 필드만 암호화하는 방식을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인증authentication-방식의-종류&#34;&gt;인증(Authentication) 방식의 종류&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;에 대한 인증 방식은 여러 가지 방식이 있으며 각 방식에 따라 보안 수준과 구현 난도가 달라서 각 방식의 장단점을 잘 이해하여 서비스 수준에 맞는 적절한 API 인증 방식을 선택하도록 할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-키-방식&#34;&gt;API 키 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;가장 기초적인 방법은 &lt;code&gt;API&lt;/code&gt; 키를 이용하는 방법이다.&lt;/li&gt;
&lt;li&gt;API 키(Key)란 특정 사용자만 알 수 있는 일종의 문자열이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;를 호출하고자 할 때, 개발자는 &lt;code&gt;API&lt;/code&gt; 제공사의 포탈 페이지에서 &lt;code&gt;API&lt;/code&gt; 키를 발급 받고 API를 호출 할 때 API 키를 메시지 안에 넣어 호출한다.&lt;/li&gt;
&lt;li&gt;서버는 메시지 안에서 API 키를 읽어서 이 API를 누가 호출한 API인지를 인증하는 흐름이다.&lt;/li&gt;
&lt;li&gt;모든 클라이언트가 같은 API 키를 공유하기 때문에, 한번 API 키가 노출되면 전체 API가 뚫려버리는 문제가 있으므로 높은 보안 인증이 필요할 때에는 권장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-토큰-방식&#34;&gt;API 토큰 방식&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743016-a5a4ad80-8fce-11eb-9511-bf6a22147f08.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 토큰(&lt;code&gt;Token&lt;/code&gt;)을 발급하는 방식이 있는데, ID, 비빌번호 등으로 사용자를 인증한 다음에 그 사용자가 API 호출에 사용할 기간이 유효한 API 토큰을 발급해서 API 토큰으로 사용자를 인증하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매번 API 호출 시 사용자 ID, 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자 비밀번호는 주기적으로 바뀔 수 있기 때문이고, 매번 네트워크를 통해서 사용자 ID와 비밀번호를 보내는 것은 보안상 사용자 계정 정보를 탈취당할 가능성이 크기 때문에 API 토큰을 별도로 발급해서 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 토큰을 탈취당하면, &lt;code&gt;API&lt;/code&gt;를 호출할 수는 있지만, 반대로 사용자 ID와 비밀번호는 탈취당하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 비밀번호를 탈취당하면 일반적으로 사용자들은 다른 서비스에도 같은 비밀번호를 사용하는 경우가 많아서 연쇄적으로 공격을 당할 가능성이 커진다. 따라서 이러한 연쇄적인 피해를 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림을 보면 다음과 같은 형태로 인증이 이루어진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;API 클라이언트가 사용자 ID, 비밀번호를 보내서 API 호출을 위한 API 토큰을 요청한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;API 인증 서버는 사용자 ID, 비밀번호를 바탕으로 사용자를 인증한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;인증된 사용자에 대해서 API 토큰을 발급한다 (유효시간을 가지고 있다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;API 클라이언트는 이 API 토큰으로 API를 호출한다. API 서버는 API 토큰이 유효한지를 API 토큰 관리 서버에 문의하고 API 토큰이 유효하면 API 호출을 받아들인다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;보안-수준에-따른-사용자-인증-방식&#34;&gt;보안 수준에 따른 사용자 인증 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;http-basic-auth&#34;&gt;HTTP Basic Auth&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743145-bc97cf80-8fcf-11eb-9784-08fb6ffbd620.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적이고 단순한 형태의 인증 방식으로, 사용자 ID와 비밀번호를 가지고, HTTP 헤더에 &lt;code&gt;Base64&lt;/code&gt; 인코딩 형태로 넣어서 인증을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 사용자 ID가 &amp;ldquo;terry&amp;quot;이고 비밀번호가 &amp;ldquo;hello world&amp;rdquo; 일 때 다음과 같이 &lt;code&gt;HTTP&lt;/code&gt; 헤더에 &amp;ldquo;terry: hello world&amp;rdquo; 라는 문자열을 &lt;code&gt;Base64&lt;/code&gt; 인코딩을 해서 &lt;code&gt;Authorization&lt;/code&gt; 라는 이름의 헤더로 서버에 전송하여 인증을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Authorization: Basic ZG9uZ3dvb2s6cGFzc3dvcmQ=
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743286-f0272980-8fd0-11eb-9871-dc55b2ee30f2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 Base64 인코딩을 도와주는 사이트이다. &lt;a href=&#34;https://www.base64decode.org/&#34;&gt;https://www.base64decode.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;중간에 패킷을 가로채서 이 헤더를 Base64로 디코딩하면 사용자 ID와 비밀번호가 그대로 노출되기 때문에, 반드시 &lt;code&gt;HTTPS&lt;/code&gt; 프로토콜을 사용해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;digest-access-authentication&#34;&gt;Digest Access Authentication&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP Basic Auth가 Base64 형태로 비밀번호를 실어서 보내는 단점을 보강하여 나온 인증 프로토콜이 &lt;code&gt;Digest Access Authentication&lt;/code&gt; 이라는 방법으로, 기본 원리는 클라이언트가 인증을 요청할 때, 클라이언트가 서버로부터 &lt;code&gt;nonce&lt;/code&gt; 라는 일종의 난수 값을 받고 (클라이언트와 서버가 이 난수 값을 알 고 있다.) 사용자 ID와 비밀번호를 이 난수 값을 이용해서 해시화하여 서버로 전송하는 방식&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 직접 ID와 비밀번호가 평문 형태로 날아가지 않기 때문에, 해커가 중간에 비밀번호를 탈취할 수 없고, 설령 &lt;code&gt;HASH&lt;/code&gt; 알고리즘을 알고 있다고 하더라도 해시된 값에서 반대로 비밀번호를 추출하기가 어려워서 &lt;code&gt;Basic Auth&lt;/code&gt; 방식보다 향상된 보안을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743403-f23db800-8fd1-11eb-9e18-ce8415bf64d9.gif&#34; alt=&#34;digest-auth1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;흐름은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 서버에 특정 리소스를 요청한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;서버는 해당 세션에 대한 &lt;code&gt;nonce&lt;/code&gt; 값을 생성하여 저장하고, 클라이언트에게 반환한다. 이때 &lt;code&gt;realm&lt;/code&gt;을 같이 반환하는데, &lt;code&gt;realm&lt;/code&gt;은 인증의 범위로, 예를 들어 웹 서버에 car.war, market.war가 각각 &lt;code&gt;http://myweb/car&lt;/code&gt;, &lt;code&gt;http://myweb/market&lt;/code&gt;이라는 &lt;code&gt;URL&lt;/code&gt;로 배포되었다고 하면, 이 웹사이트는 각각 애플리케이션 &lt;code&gt;car.war&lt;/code&gt;와 &lt;code&gt;market.war&lt;/code&gt;에 대해서 서로 다른 인증 &lt;code&gt;realm&lt;/code&gt;을 가진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;클라이언트는 앞에서 서버로 부터 받은 &lt;code&gt;realm&lt;/code&gt;과 &lt;code&gt;nonce&lt;/code&gt; 값으로 해시 값을 생성하는데 다음을 통해서 응답 해시 값을 생성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HA1 = MD5(사용자 이름:realm:비밀번호)
HA2 = MD5(HTTP method:HTTP URL)
  response hash = MD5(HA1:nonce:HA2)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;서버는 3번에서 전달된 &lt;code&gt;nonce&lt;/code&gt; 값을 이 세션을 위해서 서버에 저장된 &lt;code&gt;nonce&lt;/code&gt; 값과 같은지 비교를 한 후, 전달된 사용자 이름인 &lt;code&gt;terry&lt;/code&gt;와 &lt;code&gt;nonce&lt;/code&gt;값 그리고 서버에 저장된 사용자 비밀번호를 이용해서 같은 3번과 같은 방식으로 해시 값을 계산하여 클라이언트에서 전달된 해시 값과 같은지를 비교한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클라이언트-인증-추가&#34;&gt;클라이언트 인증 추가&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;추가적인 보안 강화를 위해서 사용자 인증 뿐만 아니라, 클라이언트 인증 방식을 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;페이스북은 API 토큰을 발급 받도록 사용자 ID, 비밀번호 뿐만 아니라, &lt;code&gt;Client ID&lt;/code&gt;와 &lt;code&gt;Client Secret&lt;/code&gt;이라는 것을 같이 입력받도록 하는데, &lt;code&gt;Client ID&lt;/code&gt;는 특정 앱에 대한 등록 ID이고 &lt;code&gt;Client Secret&lt;/code&gt;은 특정 앱에 대한 비밀번호로, 앱을 등록하면 앱 별로 발급되는 일종의 비밀번호이다.&lt;/li&gt;
&lt;li&gt;API 토큰을 발급 받을 때, Client ID와 Client Secret을 이용하여 클라이언트 앱을 인증하고, 사용자 ID와 비밀번호를 추가적으로 받아서 사용자를 인증하여 API 액세스 토큰을 발급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ip-화이트-리스트를-이용한-터널링&#34;&gt;IP 화이트 리스트를 이용한 터널링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 API를 호출하는 클라이언트의 API가 일정하다면 사용할 수 있는 손쉬운 방법인데, 서버 간의 통신이나 타사 서버와 자사 서버 간의 통신 같은 경우에 API 서버는 특정 API URL에 대해서 들어오는 IP 주소를 화이트 리스트로 유지하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 서버 앞단에 &lt;code&gt;HAProxy&lt;/code&gt;나 &lt;code&gt;Apache&lt;/code&gt;와 같은 웹 서버를 배치하여서 특정 URL로 들어올 수 있는 IP 목록을 제한하거나 아니면 전체 &lt;code&gt;API&lt;/code&gt;가 특정 서버와의 통신에만 사용된다면 아예 하드웨어 방화벽 자체에 들어올 수 있는 IP 목록을 제한할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정만으로 가능한 방법이기 때문에, 서버간의 통신이 있을 때 적용할 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bi-directional-certification-mutual-ssl&#34;&gt;Bi-directional Certification (Mutual SSL)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보통은 &lt;code&gt;HTTPS&lt;/code&gt; 통신을 할 때, 서버에 공인 인증서를 놓고 단방향으로 &lt;code&gt;SSL&lt;/code&gt;을 제공하는데, &lt;code&gt;Bi-directional Certification&lt;/code&gt; (양방향 인증서 방식) 방식은 클라이언트에도 인증서를 놓고 양방향으로 &lt;code&gt;SSL&lt;/code&gt;을 제공하면서 &lt;code&gt;API&lt;/code&gt; 호출에 대한 인증을 클라이언트의 인증서를 이용하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구현 방법이 가장 복잡한 방식이기는 하지만, 공인 기관에서 발생된 인증서를 사용한다면 &lt;code&gt;API&lt;/code&gt;를 호출하는 쪽의 신원을 확실하게 할 수 있고 메세지까지 암호화되기 때문에, 가장 높은 수준의 인증을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 인증 방식은 일반 서비스에서는 사용되지 않으며 높은 인증 수준을 제공하는 몇몇 서비스나 특정 서버 통신에 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;제-3자-인증-방식-oauth-20-authorization-grant-type&#34;&gt;제 3자 인증 방식 (OAuth 2.0 Authorization grant type)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;제 3자 인증 방식은 페이스북이나, 구글, 트위터 같은 API 서비스 제공자들이 인증을 대신 해주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743810-704f8e00-8fd5-11eb-8a83-905f69044f67.jpg&#34; alt=&#34;maxresdefault&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;claim-기반의-jwt-방식&#34;&gt;Claim 기반의 JWT 방식&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Claim 기반 토큰의 개념&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OAuth&lt;/code&gt;에 의해서 발급되는 &lt;code&gt;access_token&lt;/code&gt;은 랜덤 문자열로, 토큰 자체에는 특별한 정보를 가지고 있지 않은 일반적인 스트링 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;access_token&lt;/code&gt;을 통해서 사용자와 연관된 정보를 구별하여 이를 허용해주는 구조인데, 서버 입장에서는 토큰을 가지고 그 토큰과 연관된 정보를 서버 쪽에서 찾아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 &lt;code&gt;JWT&lt;/code&gt;는 &lt;code&gt;Claim&lt;/code&gt; 기반이라는 방식을 사용하는데, &lt;code&gt;Claim&lt;/code&gt;은 사용자에 대한 프로퍼티나 속성을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토큰 자체가 정보를 가지는 방식인데, &lt;code&gt;JWT&lt;/code&gt;는 이 클레임을 &lt;code&gt;JSON&lt;/code&gt;을 이용해서 정리한다. 아래와 같은 형태로 표현된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;id&amp;quot;: &amp;quot;terry&amp;quot;,
  &amp;quot;role&amp;quot;: &amp;quot;[&amp;quot;admin&amp;quot;, &amp;quot;user&amp;quot;]&amp;quot;,
  &amp;quot;company&amp;quot;: &amp;quot;pepsi&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743985-0d5ef680-8fd7-11eb-955b-80b7a9778016.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;결과적으로 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며, 토큰을 사용하는 &lt;code&gt;API&lt;/code&gt; 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;는 이 &lt;code&gt;JSON Claim&lt;/code&gt;을 &lt;code&gt;Base64&lt;/code&gt;로 인코딩하여 &lt;code&gt;HTTP&lt;/code&gt; 헤더에 쉽게 넣을 수 있으며, &lt;code&gt;JSON&lt;/code&gt; 기반이기 때문에 파싱과 사용이 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결과적으로 &lt;code&gt;Claim&lt;/code&gt; 기반의 토큰은 토큰 자체가 정보를 담음으로써 토큰으로 서비스나 &lt;code&gt;API&lt;/code&gt; 접근을 제어할 때, 별도의 작업이 서버에서 필요하지 않으며, 토큰 자체를 서버에서 관리할 필요가 없어서 구현이 상대적으로 단순해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;jwt의-단점&#34;&gt;JWT의 단점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;길이 : &lt;code&gt;Claim&lt;/code&gt;에 넣는 데이터가 많아질 수록 &lt;code&gt;JWT&lt;/code&gt; 토큰의 길이가 길어진다. &lt;code&gt;API&lt;/code&gt; 호출에 사용할 시에 호출마다 헤더에 붙어서 가야하기 때문에 길이가 길다는 것은 그만큼 네트워크 대역폭 낭비가 심하다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한번 발급된 토큰은 값을 수정하거나 폐기가 불가 : &lt;code&gt;JWT&lt;/code&gt;는 토큰 내에 모든 정보를 다 가지고 있기 때문에 한 번 발급된 토큰에 대한 변경은 서버에서는 더는 불가능하다. 예를 들어서, 토큰을 잘못 발행해서 삭제하고 싶더라도 서명만 맞으면 맞는 토큰으로 인식하기 때문에 서버에서는 한번 발급된 토큰의 정보를 바꾸는 일이 불가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 만약 &lt;code&gt;JWT&lt;/code&gt;를 사용한다면 만료 시간(&lt;code&gt;Expire Time&lt;/code&gt;)을 꼭 명시적으로 두도록 하고 &lt;code&gt;Refresh Token&lt;/code&gt;등을 이용하여 중간마다 토큰을 재발행하도록 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;암호화 : &lt;code&gt;JWT&lt;/code&gt;는 기본적으로 &lt;code&gt;Claim&lt;/code&gt;에 대한 정보를 암호화하지 않는다, 단순히 &lt;code&gt;Base64&lt;/code&gt;로 인코딩만 하기 때문에, 중간에 패킷을 가로채거나 기타 방법으로 토큰을 취득했으면 토큰 내부 정보를 통해서 사용자 정보가 노출될 가능성이 있다. 따라서 이를 보완하는 방법으로 토큰 자체를 암호화하는 방법이 있고, &lt;code&gt;JSON&lt;/code&gt;을 암호화하기 위한 스펙으로는 &lt;code&gt;JWE&lt;/code&gt;가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://grooveshark.tistory.com/25&#34;&gt;https://grooveshark.tistory.com/25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bcho.tistory.com/955&#34;&gt;https://bcho.tistory.com/955&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7617&#34;&gt;RFC - 7617&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>나만의 지도 시스템을 만드는데 유용한 도구 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft.html</link>
      <pubDate>Sun, 28 Mar 2021 10:45:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft.html</guid>
      <description>&lt;h3 id=&#34;지도-시스템을-만드는데-추천하는-도구&#34;&gt;지도 시스템을 만드는데, 추천하는 도구&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지도 시스템을 만드는데 추천하는 도구들은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우선 프론트엔드로는, &lt;a href=&#34;https://leafletjs.com/&#34;&gt;Leaflet&lt;/a&gt;, &lt;a href=&#34;https://openlayers.org/&#34;&gt;Openlayers&lt;/a&gt;, &lt;a href=&#34;https://geoext.org/&#34;&gt;GeoExt&lt;/a&gt;, &lt;a href=&#34;https://turfjs.org/&#34;&gt;Turf.js&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;벡엔드로는 &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/contrib/gis/&#34;&gt;GEODjango&lt;/a&gt;, &lt;a href=&#34;http://geoserver.org/&#34;&gt;GeoServer&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스는 &lt;a href=&#34;https://postgis.net/&#34;&gt;PostGIS&lt;/a&gt;를 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터는 &lt;a href=&#34;https://qgis.org/ko/site/&#34;&gt;QGIS&lt;/a&gt;, &lt;a href=&#34;https://mapshaper.org/&#34;&gt;Mapshaper&lt;/a&gt; 등이 있고, 데이터소스로는 &lt;a href=&#34;https://www.openstreetmap.org/#map=7/35.948/127.736&#34;&gt;OpenStreetMap&lt;/a&gt;을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/swlh/tools-i-recommend-for-building-geospatial-web-applications-274d6939536c&#34;&gt;Tools I recommend for building Geospatial Web Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스토리지 티어링이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft.html</link>
      <pubDate>Sat, 27 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;스토리지-티어링이란&#34;&gt;스토리지 티어링이란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 27 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네이버 기술 블로그를 대략적으로 보면서, 시스템 성능 분석 및 디버깅을 통해서 객관적인 자료를 수집하는 것을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발을 잘하기 위해서는 호기심을 가지고 실험을 많이 해보고, 이를 확인할 수 있는 디버깅 툴을 많이 알아두고 적재 적소에 사용할 수 있어야겠다.&lt;/li&gt;
&lt;li&gt;나도 네트워크 패킷을 분석하면서 문제점을 빠르게 찾고 개선해나갈 수 있는 개발자가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 도구 및 성능 측정 도구를 많이 사용해봐야겠다. 그리고 평소에 궁금했던 것들을 모두 테스트 해볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그냥 귀찮다고 문서나 눈으로만 보고 넘어가지 말고, 실제로 테스트를 해보고 이를 도구로 증명하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;궁금했던 점들을 직접 확인할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>인코딩과 캐릭터 셋의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Sat, 27 Mar 2021 17:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;p&gt;최근에 인코딩과 캐릭터 셋의 차이를 아는지에 대한 질문을 받았고, 제대로 답변하지 못한 기억이 난다. 따라서 이 두개의 차이점 및 추가적인 궁금증에 대해서 조사를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112772028-8c9d0a80-9069-11eb-85a4-adb185619b6b.png&#34; alt=&#34;Screen Shot 2021-03-29 at 8 33 54 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;유니코드와-utf-8-utf-16은-무엇이-다른가&#34;&gt;유니코드와 &lt;code&gt;UTF-8&lt;/code&gt;, &lt;code&gt;UTF-16&lt;/code&gt;은 무엇이 다른가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;유니코드는 문자 집합으로, 문자 집합만 의미하며, 실제로 저장되는 방식(바이트로 맵핑)에 대해서는 아무런 설명을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16 은 문자열 또는 바이트 배열에서 바이트로 문자를 맵핑하는 방법을 정의하는 인코딩이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16, UTF-32는 기본적으로 일부 문자를 인코딩하는데, 사용되는 바이트의 양이 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8은 ASCII에 정의된 문자에 대해서 1바이트를 사용하고, 다른 문자에 대해서는 2~4 사이의 바이트를 사용합니다. UTF-32는 각 문자에 대해서 4바이트를 지속적으로 사용하므로 문자열의 문자에 대한 반복은 사소한 것이지만 공통 문자열의 경우에는 더 많은 공간을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;캐릭터-셋과-인코딩의-차이점&#34;&gt;캐릭터 셋과 인코딩의 차이점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;캐릭터 셋은 단순히 특정 인코딩으로 나타낼 수 있는, 문자의 집합을 의미한다.&lt;/li&gt;
&lt;li&gt;예를 들면, &amp;lsquo;☯&amp;rsquo; 같은 문자는 유니코드 문자 집합과 다른 문자 집합에도 사용할 수 있다. 하지만 이 문자에 대한 인코딩을 서로 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Unicode character: ☯
UTF-8 encoded: 0xE2 0x98 0xAF
UTF-16 encoded: 0x26 0x2F
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kore-nordmann.de/blog/php_charset_encoding_FAQ.html#what-is-the-difference-between-a-charset-and-an-encoding&#34;&gt;what is the difference between a charset and an encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST 및 베스트 프랙티스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4.html</link>
      <pubDate>Sat, 27 Mar 2021 17:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4.html</guid>
      <description>&lt;h3 id=&#34;rest&#34;&gt;REST&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 웹의 창시자 중의 한 사람인 로이 필딩이 2000년에 발표한 논문에 의해서 처음 소개되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 아키텍처가 웹의 장점을 잘 활용하지 못하고 있다고 판단했기 때문에 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이바로 &lt;code&gt;Representational Safe Transfer(REST)&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 근래에 들어 &lt;code&gt;HTTP&lt;/code&gt;와 &lt;code&gt;JSON&lt;/code&gt;을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 &lt;code&gt;OPEN API&lt;/code&gt;는 이 &lt;code&gt;REST&lt;/code&gt; 아키텍처를 기반으로 설계 및 구현되고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-기본&#34;&gt;REST의 기본&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;REST는 크게 리소스, 메서드, 메시지의 3가지 요소로 구성된다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &amp;ldquo;이름이 Terry인 사용자를 생성했을 때&amp;rdquo; 사용자는 생성되는 리소스, 생성한다라는 행위는 메서드 그리고, 이름이 &lt;code&gt;Terry&lt;/code&gt;는 메시지가 된다.&lt;/li&gt;
&lt;li&gt;이를 REST로 표현해보면 다음과 같은 형태가 된다, &amp;lsquo;생성한다&amp;rsquo;라는 의미가 있는 메서드는 &lt;code&gt;HTTP&lt;/code&gt; &lt;code&gt;POST&lt;/code&gt;가 되고, 생성하고자 하는 대상이 되는 사용자라는 리소스는 &lt;code&gt;http://myweb/users&lt;/code&gt;라는 형태의 URI로 표현되며, 생성하고자 하는 사용자의 구체적인 내용은 &lt;code&gt;JSON&lt;/code&gt; 문서를 이용하여 표현된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;users&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;http-메서드&#34;&gt;HTTP 메서드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;행위에 대한 메서드는 HTTP 메서드를 그대로 사용한다.&lt;/li&gt;
&lt;li&gt;HTTP에는 여러가지 메서드가 있지만, &lt;code&gt;REST&lt;/code&gt;에서는 &lt;code&gt;CRUD(CREATE, READ, UPDATE, DELETE)&lt;/code&gt;에 해당하는 4가지의 메서드만 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112715716-53f41880-8f25-11eb-96a0-52dc9613dc36.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;멱등성은 여러 번 수행해도 결과가 같은 경우를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 연산은 리소스를 추가하는 연산이기 때문에, 멱등성을 성립하지 않지만, 나머지 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;는 반복수행하더라도, 멱등하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;의 경우 게시물의 조회 카운트를 늘려준다거나 하는 기능을 같이 수행했을 때는 멱등하지 않은 메서드로 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REST&lt;/code&gt;는 개별 &lt;code&gt;API&lt;/code&gt;를 상태 없이 수행하게 된다, 따라서 해당 &lt;code&gt;REST&lt;/code&gt; API를 다른 API와 함께 호출하다가 실패했을 때 트랜잭션 복구를 위해서 다시 실행해야하는 경우가 있는데, 멱등하지 않은 메서드의 경우에는 기존 상태를 저장했다가 다시 원상 복구시켜줘야 하는 경우가 있지만, 멱등한 메서드의 경우에는 반복적으로 다시 메서드를 수행하면 된다.&lt;/li&gt;
&lt;li&gt;멱등성을 충족하지 않는 메서드에 대해서는 트랜잭션에 대한 처리에 주의가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-리소스&#34;&gt;REST의 리소스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 리소스 지향 아키텍처 스타일이라는 정의 답게 모든 것을 리소스, 즉 명사로 표현하며, 각 세부 리소스에는 &lt;code&gt;ID&lt;/code&gt;를 붙인다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스가 명사의 형태를 띄우다 보니 명령 성격의 API를 정의하는데 혼동이 올 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동사형을 명사형으로 바꿔서 적용해보면 리소스 형태로 표현하기가 조금 더 수월해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api의-간단한-예제&#34;&gt;REST API의 간단한 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;사용자 생성&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;name&amp;quot;:&amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;:&amp;quot;seoul&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP GET, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;업데이트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP PUT, http://myweb/users/terry 
{
  &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;suwon&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;삭제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP DELETE, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;상당히 간단하다, 단순하게 리소스를 URI로 정해주고, 거기에 HTTP 메서드를 이용해서 CRUD를 구현하고 메세지를 &lt;code&gt;JSON&lt;/code&gt;으로 표현하여 &lt;code&gt;HTTP&lt;/code&gt; 바디에 실어서 보내면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; 에 리소스 ID가 없다는 것을 빼면 크게 신경쓸 부분이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-특성&#34;&gt;REST의 특성&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;유니폼-인터페이스uniform-interface&#34;&gt;유니폼 인터페이스(Uniform Interface)&lt;/h4&gt;
&lt;p&gt;REST는 HTTP 표준에만 따른다면 어떤 기술이든지 사용할 수 있는 인터페이스 스타일이다. 예를 들어, HTTP + JSON으로 REST APII를 정의했다면, 안드로이드 플랫폼이건 IOS 플랫폼이건 특정 언어나 기술에 종속받지 않고, HTTP와 JSON을 모든 플랫폼에서 사용할 수 있는 느슨한 결합이다.&lt;/p&gt;
&lt;h4 id=&#34;무상태성스테이트리스stateless&#34;&gt;무상태성/스테이트리스(Stateless)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 Representational State Transfer의 약어로 Stateless(상태를 유지하지 않음)란ㄴ 특징을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태가 있다 없다는 사용자나 클라이언트의 컨텍스트를 서버에 유지하지 않는다는 의미로, 쉽게 표현하면 HTTP 세션과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메시지로 처리하면 되며, 세션과 같은 컨텍스트 정보를 신경쓸 필요가 없으므로 구현이 단순해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;캐시-가능cacheable&#34;&gt;캐시 가능(Cacheable)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 큰 특징 중에 하나는 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 프로토콜 기반의 로드 밸런서나 SSL은 물론이고, HTTP가 가진 가장 강력한 기능중에 하나인 캐싱 기능을 적용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 시스템에서 &lt;code&gt;60%&lt;/code&gt;에서 많게는 &lt;code&gt;80%&lt;/code&gt; 가량의 트랜잭션이 &lt;code&gt;SELECT&lt;/code&gt;와 같은 조회성 트랜잭션인 것을 고려하면, &lt;code&gt;HTTP&lt;/code&gt;의 리소스들은 웹 캐시 서버 등에 캐싱하는 것은 용량이나 성능 면에서 많은 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 HTTP 프로토콜 표준에서 사용하는 &lt;code&gt;Last-Modified&lt;/code&gt; 태그나 &lt;code&gt;E-Tag&lt;/code&gt;를 이용하면 캐싱을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음과 같이 클라이언트가 HTTP GET을 &lt;code&gt;Last-Modified&lt;/code&gt; 값과 함께 보냈을 때 콘텐츠에 변화가 없으면 &lt;code&gt;REST&lt;/code&gt; 컴포넌트는 &lt;code&gt;304 Not Modified&lt;/code&gt;를 반환하며 클라이언트는 자체 캐시에 저장된 값을 사용하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112716331-0d082200-8f29-11eb-95d1-21b0a40accbe.png&#34; alt=&#34;267E914554241E6512&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이렇게 캐시를 사용하게 되면 네트워크 응답 시간뿐만 아니라, &lt;code&gt;REST&lt;/code&gt; 컴포넌트가 위치한 서버에 트랜잭션을 발생시키지 않기 때문에 전체 응답 시간과 성능 그리고 자원 사용률을 비약적으로 향상시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;자체-표현-구조self-descriptiveness&#34;&gt;자체 표현 구조(Self-descriptiveness)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 가장 큰 특징중의 하나는 REST API 자체가 쉬워서 API 메시지만 보고도 이를 이해할 수 있는 자체 표현 구조로 되어 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스와 메서드를 이용해서, 어떤 메서드에 무슨 행위를 하는지 알 수 있으며, 또한 메시지 포맷 역시 JSON을 이용해서 직관적으로 이해할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 REST 기반 Open API가 API 문서를 제공하고는 있지만, 디자인 사상은 최소한의 문서의 도움만으로 API 자체를 이해할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;클라이언트-서버-구조client-server&#34;&gt;클라이언트 서버 구조(Client-Server)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST 서버는 API를 제공하고 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임 진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 각자의 역할이 확실하게 구분되면서 개발 관점에서 클라이언트와 서버에서 개발해야 할 내용이 명확해지고, 서로의 개발에서 의존성이 줄어들게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;계층형-구조layered-system&#34;&gt;계층형 구조(Layered System)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트로서는 REST API 서버만 호출한다. 그러나 서버는 다중 계층으로 이루어질 수 있다.&lt;/li&gt;
&lt;li&gt;순수 비즈니스 로직을 수행하는 &lt;code&gt;API&lt;/code&gt; 서버와 그 앞단에 사용자 인증(Authentication), 암호화(SSL), 로드 밸런싱을 하는 계층을 추가해서 구조상의 유연성을 둘 수 있다.&lt;/li&gt;
&lt;li&gt;이는 마이크로서비스의 API GATEWAY나 간단한 기능은 리버스 프록시를 이용해서 구현하는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-안티-패턴&#34;&gt;REST 안티 패턴&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;다음은 REST API를 디자인할 때 하지 말아야 할 것들이다.&lt;/p&gt;
&lt;h4 id=&#34;getpost를-이용한-터널링&#34;&gt;GET/POST를 이용한 터널링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 나쁜 디자인 중에 하나가 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 메서드의 실제 동작은 리소스를 업데이트 하는 내용인데, HTTP PUT을 사용하지 않고, GET에 쿼리 파라미터로 이 메서드가 수정 메서드임을 표시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대단히 안좋은 디자인인데, &lt;code&gt;HTTP&lt;/code&gt; 메서드 사상을 따르지 않았기 때문에 REST라고 부를 수 없고, 또한 웹 캐시 인프라도 사용할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 많이 사용하는 안좋은 예는 &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 생성 요청이 아닌데도 바디에 명령을 넘겨서 호출하는 방식인데 좋지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;getuser&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;terry&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;self-descriptiveness-속성을-사용하지-않음&#34;&gt;Self-descriptiveness 속성을 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 특성 중 하나는 자체 표현 구조로, REST URI와 메서드, 그리고 정의된 메시지 포맷에 의해서 쉽게 API를 이해할 수 있는 기능이 되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히나 자체 표현 구조를 갉아 먹는 가장 대표적인 사례가 앞서 언급한 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-응답-코드를-사용하지-않음&#34;&gt;HTTP 응답 코드를 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 많이 하는 실수가 HTTP 응답 코드를 충실하게 따르지 않고, 성공은 200, 실패는 500 같이 1 ~ 2개의 HTTP 응답 코드만 사용하는 경우이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심한 경우에는 에러도 &lt;code&gt;200&lt;/code&gt; 응답 코드와 함께 보내는 경우인데, 이는 &lt;code&gt;REST&lt;/code&gt; 디자인 사상에도 어긋남은 물론이고 자기 표현 구조에도 어긋난다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api-디자인-가이드&#34;&gt;REST API 디자인 가이드&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;단순하고-직관적으로-만들어라&#34;&gt;단순하고 직관적으로 만들어라&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;URI에 리소스명은 동사보다는 명사를 사용하라.&lt;/li&gt;
&lt;li&gt;REST API는 리소스에 대해서, 행동을 정의하는 형태를 사용한다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &lt;code&gt;/dogs&lt;/code&gt;는 리소스를 생성하라는 의미고, URL은 HTTP 메서드에 의해서 CRUD(생성, 수정, 수정, 삭제)의 대상이 되는 개체(명사)라야 한다.&lt;/li&gt;
&lt;li&gt;그리고 될 수 있으면 단수형 명사보다는 복수형 명사를 사용하는 것이 의미상 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;리소스-간의-관계를-표현하는-방법&#34;&gt;리소스 간의 관계를 표현하는 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;REST 리소스 간에는 연관 관계가 있을 수 있다.&lt;/li&gt;
&lt;li&gt;예를 들어서 사용자가 소유한 디바이스 목록이나, 사용자가 가진 강아지들이 예가 될 수 있다.&lt;/li&gt;
&lt;li&gt;사용자 - 디바이스 또는 사용자 - 강아지 등 각각의 리소스 간의 관계를 표현하는 방법에는 여러가지가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 서브 리소스로 표현하는 방법
/&amp;quot;리소스명&amp;quot;/&amp;quot;리소스 아이디&amp;quot;/&amp;quot;관계가 있는 다른 리소스명&amp;quot;
HTTP GET, /users/{userId}/devices
예) /users/1/devices
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;2. 서브 리소스에 관계를 명시하는 방법
HTTP GET, /users/{userid}/likes/devices
예) /uesrs/1/likes/devices
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러 처리의 기본은 &lt;code&gt;HTTP&lt;/code&gt; 응답 코드를 사용한 후 응답 바디(&lt;code&gt;Response Body&lt;/code&gt;)에 에러에 대한 자세한 내용을 서술하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 &lt;code&gt;API&lt;/code&gt; 서비스들이 어떤 응답 코드를 사용하는지를 살펴보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 : &lt;code&gt;200, 201, 304, 400, 401, 403, 404, 409, 410, 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;넷플릭스 : &lt;code&gt;200, 201, 304, 400, 403, 404, 412, 500&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 응답 코드를 사용하면 명시적이긴 하지만, 코드 체계 관리가 복잡해져서 다음과 같이 몇 가지 응답 코드만 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;200 - 성공
400 Bad Request - field validation 실패 시
401 Unauthorized - API 인증, 인가 실패
404 Not Found - 해당 리소스가 없음
500 Internal Server Error - 서버 에러
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러에는 에러 내용에 대한 구체적인 내용을 HTTP 바디에 정의해서 상세한 에러의 원인을 전달하는 것이 디버깅에 유리하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Twillo&lt;/code&gt;의 에러 메시지 형식은 다음과 같은데, 에러 코드 번호와 이 번호에 대한, &lt;code&gt;Error dictionary link&lt;/code&gt;를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자나 트러블 슈팅하는 사람에게 많은 정보를 제공해서 디버깅을 손쉽게 해주는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에러 발생시에 스택 정보를 포함시킬 수 있지만, 이는 대단히 위험한 일이다. 내부적인 코드 구조와 프레임워크 구조를 외부에 노출함으로써, 해커들에게 해킹을 할 수 있는 정보를 제공해주기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 구조에서는 이를 제공하지 않는 것이 일반적이지만 내부 개발중이거나 서비스 개발할 때는 매우 유용하다. 따라서 API 서비스를 개발할 때 프로덕션과 데브 환경을 분리해서 개발하면 디버깅에 매우 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;api-버전-관리&#34;&gt;API 버전 관리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 정의에서 중요한 것은 버전 관리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이미 배포된 API 경우에는 계속해서 서비스를 제공하면서 새로운 기능이 들어간 API를 배포할 때는 하위 호환성을 보장하면서 서비스를 제공해야하기 때문에, 같은 &lt;code&gt;API&lt;/code&gt;라도 버전에 따라서는 다른 기능을 제공하도록 하는 것이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 버전을 정의하는 방법에는 여러가지가 있는데, 다음과 같은 형태를 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{servicename}/{version}/{REST URL}
예) api.server.com/account/v2.0/groups
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이는 서비스의 배포 모델과 관계가 있는데, 자바 애플리케이션의 경우 &lt;code&gt;account.v1.0.war&lt;/code&gt;, &lt;code&gt;account.v2.0.war&lt;/code&gt;와 같이 다른 &lt;code&gt;war&lt;/code&gt;로 각각 배포하여 버전별로 배포 바이너리를 관리할 수 있고, 앞단에 서비스명을 별도로 &lt;code&gt;URL&lt;/code&gt;로 떼어 놓은 것은 서비스가 확장되었을 때, &lt;code&gt;account&lt;/code&gt; 서비스만 별도의 서버로 분리해서 배포하는 경우를 대비하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이징&#34;&gt;페이징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큰 사이즈의 리스트 형태의 응답을 처리하려면 페이징 처리와 부분 응답(Partial Response) 처리가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반환되는 리스트가 &lt;code&gt;100,000,000&lt;/code&gt; 개인데, 이를 하나의 HTTP 응답으로  처리하는 것은 서버 성능, 네트워크 비용도 문제지만, 무엇보다 비현실적이다. 그래서 페이징을 고려하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이징을 처리하려면 여러가지 디자인이 있다. 예를 들어서 100번째부터 125번째 레코드까지 받는 API를 정의하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이스북 API 스타일 : &lt;code&gt;/record?offset=100&amp;amp;limit=25&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;트위터 API 스타일 : &lt;code&gt;/record?page=5&amp;amp;rpp=25&lt;/code&gt; (RPP는 Record Per Page)로 페이지 당 레코드 수로 RPP=25이면 페이지 5는 100~125가 된다.&lt;/li&gt;
&lt;li&gt;링크드인 API 스타일 : &lt;code&gt;/record?start=50&amp;amp;count=25&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;부분-응답-처리&#34;&gt;부분 응답 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리소스에 대한 응답 메시지에 대해서 굳이 모든 필드를 포함할 필요는 없다.&lt;/li&gt;
&lt;li&gt;예를 들어서 페이스북 피드에는 사용자 ID, 이름, 글, 내용, 날짜, 좋아요, 카운트, 댓글, 사용자 사진 등 여러가지 정보를 갖는데, API를 요청하는 클라이언트의 용도에 따라서 선별적으로 몇 가지 필드만이 필요할 수 있다.&lt;/li&gt;
&lt;li&gt;필드를 제한하는 것은 전체 응답의 양을 줄여서 네트워크 대역폭 (특히 모바일에서) 절약할 수 있고, 응답 메시지를 간소화하여 파싱 등을 간략화 할 수 있다.&lt;/li&gt;
&lt;li&gt;이러한 부분 응답 기능을 제공하는 주요 서비스를 보면 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;링크드인 : /people:(id, first-name, last-name, industry)
페이스북 : /terry/friends?fields=id, name
구글 : ?fields=title, media:group(media:thumnail)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;검색-전역-검색과-지역-검색&#34;&gt;검색 (전역 검색과 지역 검색)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;검색은 &lt;code&gt;HTTP&lt;/code&gt; GET에서 쿼리 스트링 검색 조건을 정의하는 경우가 일반적인데, 이 경우 검색 조건이 다른 쿼리 스트링이랑 섞여 버릴 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;name=lee&lt;/code&gt; 이고 &lt;code&gt;region=seoul&lt;/code&gt;인 사용자를 검색하는 검색을 쿼리 스트링만 사용하게 되면 다음과 같이 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/users?name=lee&amp;amp;region=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;추가적으로 페이징 처리를 추가하면 다음과 같이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?name=cho&amp;amp;region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;페이징 처리에 의해서 정의된 offset과 limit 가 검색조건인지 페이징 조건인지 잘 분간이 가지 않으므로 따라서 쿼리 조건은 하나의 쿼리 스트링으로 정의하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/user?q=name=lee, region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이런식으로 구분자를 사용하면, 검색 조건은 다른 쿼리스트링과 분리된다.&lt;/li&gt;
&lt;li&gt;물론 이 검색 조건은 서버에 의해서 토큰 단위로 파싱 되어야 한다.&lt;/li&gt;
&lt;li&gt;다음으로는 검색 범위에 대해서 고민할 필요가 있는데, 전역 검색은 전체 리소스에 대한 검색을, 리소스에 대한 검색은 특정 리소스에 대한 검색을 정의한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어서 특정 리소스 안에 대한 검색은 다음과 같이 리소스명에 쿼리 조건을 붙이는 식으로 표현할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?q=id=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;전역 검색은 다음과 같은 식으로 정의할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/search?q=id=lee
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hateoas를-이용한-처리&#34;&gt;HATEOAS를 이용한 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;HATEOS는 &lt;code&gt;Hypermedia as the engine of application data&lt;/code&gt;의 약자로 하이퍼미디어의 특징을 이용하여, &lt;code&gt;HTTP&lt;/code&gt; 응답에 다음 액션이나 관계된 리소스에 대한 &lt;code&gt;HTTP&lt;/code&gt; 링크를 함께 반환하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  [
    {
      &amp;quot;id&amp;quot;: &amp;quot;user1&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: &amp;quot;user2&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;carry&amp;quot;
    }
  ],
  &amp;quot;links&amp;quot;: [
    {
      &amp;quot;rel&amp;quot;: &amp;quot;pre_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=6&amp;amp;limit=5&amp;quot;
    },
    {
      &amp;quot;rel&amp;quot;: &amp;quot;next_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=11&amp;amp;limit=5&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이징 처리의 경우 반환 시 페이지에 대한 링크를 제공하거나, 위와 같이 표현하거나 연관된 리소스에 대한 디테일한 링크를 표시하는 것에 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HATEOAS&lt;/code&gt;를 API에 적용하게 되면, 자체 표현 구조 특성이 증대되어 API에 대한 가독성이 증가하는 장점을 가지고 있는데 반해서, 응답 메시지가 다른 리소스 &lt;code&gt;URI&lt;/code&gt;에 대한 의존성을 가지기 때문에 구현이 다소 까다롭다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단일-api-엔드-포인트-활용&#34;&gt;단일 API 엔드 포인트 활용&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 서버가 물리적으로 분리된 여러 개의 서버에서 작동하고 있을 때, &lt;code&gt;user.apiserver.com&lt;/code&gt;, &lt;code&gt;car.apiserver.com&lt;/code&gt;과 같이 API 서버마다 URL이 분리되어 있으면 개발자가 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매번 다른 서버로 연결해야 하거나와 중간에 방화벽이라도 있으면 일일히 이를 해제해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 서비스는 물리적으로 서버가 분리되어 있더라도 단일 URL을 사용하는 것이 좋은데, 방법은 &lt;code&gt;HAProxy&lt;/code&gt;와 &lt;code&gt;Reverse Proxy&lt;/code&gt;를 사용하는 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/user/&lt;/code&gt;는 user.apiserver.com으로 라우팅하고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/car/&lt;/code&gt;는 car.apiserver.com으로 라우팅하도록 구현하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 할 경우 향후 뒷단에 API 서버 들이 확장되도라도 &lt;code&gt;API&lt;/code&gt;를 사용하는 클라이언트로서는 단일 엔드포인트를 보면 되고, 관리 관점에서도 단일 엔드 포인트를 통해서 부하 분산 및 로그를 통해서 감사(Audit)을 할 수 있기 때문에 편리하며, API에 대한 라우팅을 Reverse Proxy를 이용해서 함으로써 조금 더 유연한 운영이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리버스 프록시란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>메시지 교환 패턴이란(MESSAGE EXCHNAGE PATTERN)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern.html</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern.html</guid>
      <description>&lt;h2 id=&#34;비동기-메시지-패턴&#34;&gt;비동기 메시지 패턴&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;비동기 메시지 패턴은 앞서 살펴보았듯이 중간에 큐를 두어서 구현하기 때문에, 여러 가지 메시지 전달 패턴을 구현할 수 있다. 몇 가지 대표적인 패턴에 대해서 알아보자.&lt;/p&gt;
&lt;h3 id=&#34;fire--forgot-패턴&#34;&gt;Fire &amp;amp; Forgot 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 사용하는 패턴 중에 가장 일반적인 비동기 호출 패턴으로, 클라이언트가 호출한 후 큐에 메시지가 제대로 들어갔을면 메시지의 처리 결과에 관계없이 응답을 기다리지 않고 바로 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;큐에 저장된 메시지는 비즈니스 컴포넌트에 의해서 나중에 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;publish--subscribe-패턴&#34;&gt;Publish &amp;amp; Subscribe 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐에 구독자를 등록하면 클라이언트에서 보낸 하나의 메시지가 등록된 모든 구독자에게 전달이 되어서 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 : N 관계의 비동기 처리를 구현하고자 할 때 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JMS&lt;/code&gt;의 &lt;code&gt;Topic&lt;/code&gt;이 이에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;routing-패턴&#34;&gt;Routing 패턴&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112854564-f14b7a00-90e8-11eb-8463-8e0152c7a3c6.png&#34; alt=&#34;0_gFwb04MsfqtVB5bY&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;라우팅 패턴은 큐에 저장된 메시지를 조건에 따라서, 특정 비즈니스 컴포넌트로 라우팅 하는 기능이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Pub/Sub&lt;/code&gt; 처럼 큐에 여러 개의 비즈니스 컴포넌트가 붙기는 하지만, 특정 메시지는 조건에 따라서 특정 비즈니스 컴포넌트 한 개에만 전달 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;콜백-패턴&#34;&gt;콜백 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 이용한 비동기 패턴은 클라이언트가 메시지 처리에 대한 응답을 받을 수 없다고 설명했었는데, 예외적으로 콜백 패턴을 사용하면 메시지 처리에 대한 응답을 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트가 요청을 보내서, 메시지 큐에 저장한 후에 &lt;code&gt;CallBack&lt;/code&gt; 패턴도 다른 비동기 패턴과 마찬가지로 응답을 기다리지 않고 다음 로직을 진행한다. (그래야지 비동기 패턴이므로)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 컴포넌트에서 처리가 끝나면 서버는 다시 클라이언트에 처리가 끝났다는 응답과 함께 처리 결과 (&lt;code&gt;Response&lt;/code&gt;) 메시지를 콜백으로 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이때 클라이언트가 응답 메시지가 올 때까지 기다리는 것이 아니라 비즈니스 로직을 수행하고 있기 때문에, 서버가 응답 메시지를 보내면 이벤트 핸들러 방식에 의해서 응답 메시지를 처리하는 이벤트 핸들러를 호출하여 응답 메시지를 처리하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;콜백 방식의 호출은 응답 메시지를 받기 위해서, 몇 가지 부가적인 정보가 필요한데, 콜백 주소와 &lt;code&gt;Correlation ID&lt;/code&gt; 라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;콜백 주소는 서버가 메시지를 다 처리하고 난 후에 클라이언트로 응답을 보낼 때 사용하는 클라이언트의 IP 주소와 포트이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 &lt;code&gt;Correlation ID&lt;/code&gt; 라는 것이 특이한데, 클라이언트에서 10개의 요청을 서버에 보냈다고 가정하면, 서버가 메시지를 처리한 후에 콜백을 이용하여 응답을 보내면 해당 응답 메시지가 10개의 요청중 어느 요청에 대한 응답인지 식별할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이를 식별하기 위해서 요청을 할 때, &lt;code&gt;Corrleation ID&lt;/code&gt;를 같이 실어 보낸후 응답에 이 &lt;code&gt;ID&lt;/code&gt;를 다시 실어서 보내게 된다. 따라서 콜백 응답 메시지가 어느 요청에 대한 응답 메시지인지를 식별할 수 있게 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/getstarted.html&#34;&gt;MEP 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>아키텍처란 무엇인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</link>
      <pubDate>Sat, 27 Mar 2021 14:23:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</guid>
      <description>&lt;h3 id=&#34;아키텍처란-무엇인가&#34;&gt;아키텍처란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;아키텍처에 대한 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;아키텍처는 비즈니스 요구사항을 만족하는 시스템을 구축하기 위해서 전체 시스템에 대한 구조를 정의한 문서로, 시스템을 구성하는 컴포넌트와 그 컴포넌트 간의 관계, 그리고 컴포넌트가 다루는 정보(데이터)를 정의한다&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;아키텍처-설계-프로세스&#34;&gt;아키텍처 설계 프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아키텍처 설계 방법론은 여러 가지가 있으나, 주로 사용되는 프레임워크로는 &lt;code&gt;Zachman&lt;/code&gt;, &lt;code&gt;TOGAF&lt;/code&gt;, &lt;code&gt;Federal Enterprise Architecture&lt;/code&gt;등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 이러한 전통적인 방법론은 학문적이고, 그 깊이가 매우 깊어서 일반적인 개발자들이 실무에 적용하기가 매우 어렵다. 따라서 &lt;code&gt;TOGAF&lt;/code&gt;를 경량화한 프로세스를 정의하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;먼저 비즈니스 요구사항을 기반을 한 아키텍처를 정의한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;비즈니스 아키텍처란 구현하고자 하는 소프트웨어의 기능, 시장 상황, 로드맵 등 기능 보다는 비즈니스 관점에서의 소프트웨어를 정의한 모델이다. 주로 요구사항 정의서나 시장 조사서를 기반으로 이를 요약해서 정리해놓은 것을 비즈니스 아키텍처라고 한다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;설계 원칙을 정의한다. 아키텍처 설계 중 여러가지 옵션이 나왔을 때, 의사 결정의 기초가 되는 것으로, 시스템의 설계 사상에 해당한다. 이 아키텍처 설계 원칙과 비즈니스 아키텍처를 기반으로 기술적인 시스템 아키텍처를 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 아키텍처는 관점에 따라서 소프트웨어 코드로 구성되는 애플리케이션 아키텍처, 하드웨어 등 인프라에 대한 테크니컬 아키텍처, 웹 서버 데이터베이스 구성 등에 관련되는 솔루션 아키텍처와 데이터 저장 구조를 기술하는 데이터 아키텍처로 구분된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;아키텍처 설계 과정 중 의사 결정이 필요한 경우에는 앞서 언급한 아키텍처 설계 원칙을 기반으로 하여, 내부적인 의사결정 프로세스에 따른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SOA, 모놀리틱, 그리고 MSA 아키텍처</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.html</link>
      <pubDate>Sat, 27 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.html</guid>
      <description>&lt;h3 id=&#34;soa&#34;&gt;SOA&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOA(Service Oriented Architecture)는 1990년대에 정의되어, 2008년에 유행했던 아키텍처 스타일이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 서버 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 많은 영향을 받았고 많은 분산 아키텍처가 거의 이 &lt;code&gt;SOA&lt;/code&gt; 사상에 기인한다고 해도 될 만큼 중요한 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;soa의-기본-개념&#34;&gt;SOA의 기본 개념&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112712065-4f713500-8f10-11eb-9b36-a603fccd7e3d.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SOA&lt;/code&gt;란 기존 애플리케이션들의 기능을 비즈니스적인 의미가 있는 기능 단위로 묶고, 표준화된 호출 인터페이스를 통해 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을 서로 조합(&lt;code&gt;Orchestration&lt;/code&gt;)하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 시스템이 각각 독립된 업무 시스템으로 개발되어왔던 반면에 &lt;code&gt;SOA&lt;/code&gt;는 기업의 전체 업무가 하나의 거대한 &lt;code&gt;SOA&lt;/code&gt; 시스템으로 구성이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 시스템의 기능들을 업무를 기준으로 주요 기능들로 묶어서 플랫폼에 독립적인 인터페이스(예를 들어 &lt;code&gt;XML/HTTP&lt;/code&gt;, &lt;code&gt;CORBA&lt;/code&gt;, &lt;code&gt;SOAP&lt;/code&gt;)를 구현하여 외부 서비스로 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 제공된 서비스 이벤트를 조합하여, 새로운 기능을 개발할 때, 시스템을 신규 개발하는 것이 아니라, 기존에 제공된 서비스들을 조합하여 하나의 업무를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;수직적 분할(Vertical Slicing) : 수직적 분할이란 애플리케이션을 여러 개의 서비스로 나누고 각각의 서비스를 독립적으로 개발하는 것을 말한다. 따라서 각 서비스간의 의존성이 최소화 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준 인터페이스 기반(Has Standard Interface) : 서비스가 제공하는 인터페이스는 표준 기술로 구현되어야 한다. 서비스를 사용하고자 하는 사람이 &amp;lsquo;서비스 규약&amp;rsquo; 만을 가지고도 해당 서비스를 호출 할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;느슨한 결합(Loosely Coupled) : 수직적 분할에서도 설명하였듯 각 서비스 컴포넌트들은 다른 서비스에 대해서 의존성이 최소화되어 있어서 서비스의 구현 내용을 변경하였을 때 다른 서비스는 이에 거의 영향을 받지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조합 가능(Composable) : 서비스형 컴포넌트들은 서로 연결되어 하나의 조합된 형태의 애플리케이션을 구성해야하기 때문에, 서비스 간에 연결 및 조합이 가능해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모놀리틱-아키텍처&#34;&gt;모놀리틱 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713152-1b4d4280-8f17-11eb-8529-5f69c0d9b17b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마이크로 서비스 아키텍처를 이해하려면 먼저 모놀리틱 아키텍처 스타일에 대해서 이해해야한다.&lt;/li&gt;
&lt;li&gt;모놀리틱 아키텍처 스타일은 기존의 전통적인 웹 시스템 개발 스타일로, 하나의 애플리케이션 내에 모든 로직이 들어가있는 &amp;lsquo;통짜 구조&amp;rsquo;이다.&lt;/li&gt;
&lt;li&gt;각 컴포넌트는 상호 호출을 함수를 이용한 참조에 의한 호출 구조를 취한다.&lt;/li&gt;
&lt;li&gt;전체 애플리케이션을 하나로 처리하기 때문에 개발 도구에서 하나의 애플리케이션만 개발하면 되고, 배포 역시 간편하며 테스트도 하나의 애플리케이션만 수행하면 되므로 간편하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;문제점&#34;&gt;문제점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;작은 크기의 애플리케이션에서는 유리하지만, 규모가 큰 애플리케이션에서는 불리한 점이 많다.&lt;/li&gt;
&lt;li&gt;크기가 커서 빌드 및 배포시간, 서버의 가동 시간이 오래 걸린다.(서버 가동에만 2시간까지 걸리는 경우도 있다)&lt;/li&gt;
&lt;li&gt;시스템 컴포넌트들이 서로 로컬 콜 기반으로 타이트하게 연결되어 있으므로, 전체 시스템의 구조를 제대로 파악하지 않고 개발을 진행하면 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향을 주게 된다.&lt;/li&gt;
&lt;li&gt;이러한 문제를 해결하려면 개발자가 대략적인 전체 시스템의 구조를 이해햐야하는데 시스템의 구조가 커질 수록 이해하기 힘들다.&lt;/li&gt;
&lt;li&gt;특정 컴포넌트를 수정할 때, 컴포넌트 재배포 시 수정된 컴포넌트만 재배포 하는 것이 아니라 전체 애플리케이션을 재컴파일해서 전체를 다시 통을 재배포 해야한다.&lt;/li&gt;
&lt;li&gt;이 때문에 잦은 배포가 있는 시스템은 불리하며 컴포넌트 별로 기능/비기능에 특성에 맞춰서 다른 기술을 도입하고자 할 때 유연하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처&#34;&gt;마이크로 서비스 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처(MSA)는 근래의 웹 기반 분산 시스템의 디자인에 많이 반영되어 있는 스타일로, 특정 사람이 정의한 아키텍처가 아니라 분산 웹 시스템과 비슷한 구조로 설계 되면서 개념적으로만 존재하던 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 대용량 웹 서비스가 많아짐에 따라 정의된 아키텍처인데, 그 근간은 &lt;code&gt;SOA(Service Oriented Architecture)&lt;/code&gt;에 두고 있다. &lt;code&gt;SOA&lt;/code&gt;가 엔터프라이즈 시스템을 중심으로 고안된 아키텍처라면, 마이크로 서비스 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 근간을 두고, 대용량 웹 개발 서비스 개발에 맞는 구조로 사상이 경량화 되고 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스&#34;&gt;서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처에서는 각 컴포넌트를 서비스라는 개념으로 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스는 데이터부터 비즈니스 로직까지 독립적으로 상호 컴포넌트 간의 의존성 없이 개발된 컴포넌트 (이를 수직 분할이라고 함)로, REST API 같은 표준 인터페이스로 그 기능을 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 경계는 구문 또는 도메인 (업무)의 경계를 따른다. 예를 들어 사용자 관리, 상품 관리, 주문 관리와 같이 업무별로 서비스를 나눠서 정의해도 사용자/사품 관리 처럼 여러개의 업무를 동시에 하나의 서비스로 섞어서 정의하지는 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;msa-아키텍처-구조&#34;&gt;MSA 아키텍처 구조&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713447-6b78d480-8f18-11eb-8af4-a41448e23a94.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;배포 구조 관점에서도 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성 없이 독립적으로 배포된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;확장을 위해서 서비스가 배치된 톰캣 인스턴스는 횡적으로 스케일(인스턴스를 더함으로써)이 가능하고, 앞단에 로드 밸런서를 배치하여 서비스 간의 로드를 분산 시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 로직을 분리해서 여러 개의 애플리케이션으로 나눠서 서비스화하고 서비스 별로 톰캣을 분산 배치한 것이 가장 큰 특징이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터-분리&#34;&gt;데이터 분리&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713617-80099c80-8f19-11eb-864a-e539715b08a5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터 저장 관점에서는 중앙 집중화된 하나의 데이터베이스를 사용하는 것이 아니라, 서비스 별로 별도의 데이터베이스를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스의 종류 자체를 다른 데이터베이스로 사용할 수도 있지만, 같은 데이터베이스를 사용하더라도 &lt;code&gt;DB&lt;/code&gt;를 나누는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우 다른 컴포넌트에 대한 의존성 없이 서비스를 독립적으로 개발 및 배포 / 운영 할 수 있다는 장점을 가지고 있으나, 다른 컴포넌트의 데이터를 API 통신을 통해서 가지고 와야하므로, 성능상의 문제를 일으킬 수 있고, 또한 이 기종 데이터베이스 간의 트랜잭션을 묶을 수 없다는 문제점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-gateway&#34;&gt;API GATEWAY&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처 설계에서 가장 많이 언급되는 컴포넌트 중에 하나가 &lt;code&gt;API GATEWAY&lt;/code&gt;라는 컴포넌트이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;는 마치 프록시 서버처럼 &lt;code&gt;API&lt;/code&gt;들 앞에서 모든 &lt;code&gt;API&lt;/code&gt;에 대한 엔드 포인트를 통합하고, 몇 가지 추가적인 기능을 제공하는 미들웨어로, 다음과 같은 기능을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;엔드-포인트-통합-및-토폴로지-정리&#34;&gt;엔드 포인트 통합 및 토폴로지 정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처의 문제점 중 하나는 각 서비스가 다른 서버에 분리, 배포 되기 때문에 API의 엔드포인트, 즉 서버의 URL이 각기 다르다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 컴포넌트는 &lt;code&gt;http://user.server.com&lt;/code&gt;, 상품 컴포넌트는 &lt;code&gt;http://product.server.com&lt;/code&gt;과 같은 분리된 URL을 사용하는데 이는 API 사용자 경험 관점에서도 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 마이크로 서비스 아키텍처는 될 수 있으면 컴포넌트를 업무 단위로 잘게 자르는 작은 덩어리(&lt;code&gt;Fine Grained&lt;/code&gt;)의 서비스를 지향하기 때문에, 컴포넌트의 &lt;code&gt;URL&lt;/code&gt;수는 더 많이 늘어날 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713879-d1fef200-8f1a-11eb-8f72-eb90fa0360e9.png&#34; alt=&#34;t1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 토폴로지의 문제점을 해결하기 위해서, 중앙에 서비스 버스와 같은 역할을 하는 채널을 배치 시켜서 전체 토폴로지를 &lt;code&gt;Hub &amp;amp; Spoke&lt;/code&gt; 방식으로 변화시켜서 서비스 간 호출을 단순화 시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;오케스트레이션-orchestration&#34;&gt;오케스트레이션 (Orchestration)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 포인트 적립과 물품 구매라는 서비스가 있을 때, 이 두 개의 서비스를 묶어서 &amp;lsquo;물품 구매 시 포인트 적립&amp;rsquo; 이라는 새로운 서비스를 만들어 낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 오케스트레이션 기능은 &lt;code&gt;API Gateway&lt;/code&gt;를 통해서 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;공통-기능-처리cross-cutting-function-handling&#34;&gt;공통 기능 처리(Cross Cutting Function Handling)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;에 대한 인증(&lt;code&gt;Authentication&lt;/code&gt;)이나 로깅과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;에서 이러한 공통 기능을 처리하게 되면, API 자체는 비즈니스 로직에만 집중하여 개발중에 발생할 수 있는 중복을 방지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;중재mediation&#34;&gt;중재(Mediation)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;이외에도 &lt;code&gt;XML&lt;/code&gt;이나 네이티브 메시지 포맷을 &lt;code&gt;JSON&lt;/code&gt;으로 상호 변환해주는 메시지 변환 기능이나 프로토콜을 변환하는 기능, 서비스 간의 메시지를 라우팅해주는 여러 가지 고급 중재 기능을 제공하지만, &lt;code&gt;API GATEWAY&lt;/code&gt;를 최대한 가볍게 가져간다는 설계 원칙 아래에서 될 수 있으면 고급 중재 기술을 사용할 때는 높은 설계와 기술적인 노하우를 동반해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배포&#34;&gt;배포&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;마이크로서비스의 큰 장점중에 하나가 바로 유연한 배포 모델이다.&lt;/li&gt;
&lt;li&gt;각 서비스가 다른 서비스와 물리적으로 완벽하게 분리되기 때문에, 변경이 있는 서비스 부분만 부분 배포가 가능하다.&lt;/li&gt;
&lt;li&gt;예를 들어, 사용자 관리 서비스 로직이 변경되었을 때, 모놀리틱 아키텍처는 전체 시스템을 재배포해야하지만, 마이크로 서비스 아키텍처는 변경이 있는 사용자 관리 서비스 부분만 재배포하면 되기 때문에 전체 시스템의 영향을 최소화한 수준에서 빠르게 배포를 진행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;확장성&#34;&gt;확장성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서비스 별로 독립된 배포 구조는 확장성에서도 많은 장점이 있는데, 부하가 많은 특정 서비스에 대해서만 확장할 수 있어서 조금 더 유연한 확장 모델을 가져갈 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모노리틱 아키텍처는 특정 서비스의 부하가 많아서 성능 확장이 필요할 때 전체 서버의 수를 늘리거나 각 서버의 &lt;code&gt;CPU&lt;/code&gt; 숫자를 늘려줘야 하지만, 마이크로 서비스 아키텍처는 부하를 많이 받는 서비스 컴포넌트만 확장시켜주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처의-문제점&#34;&gt;마이크로 서비스 아키텍처의 문제점&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;성능&#34;&gt;성능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모놀리틱 아키텍처는 하나의 프로세스 내에서, 서비스 간의 호출에 참조 호출 모델을 이용하지만, 마이크로서비스 아키텍처는 서비스 간의 호출을 &lt;code&gt;API&lt;/code&gt; 통신을 이용하기 때문에, 값을 &lt;code&gt;JSON&lt;/code&gt;이나 &lt;code&gt;XML&lt;/code&gt;에서 프로그래밍에서 사용하는 데이터 모델(자바 객체)로 변환하는 마샬링 오버헤드가 발생하고 호출을 위해서 이 메시지들이 네트워크를 통해서 전송되기 때문에 그 만큼 시간이 많이 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;테스팅이-어려움&#34;&gt;테스팅이 어려움&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 서비스들이 분리되어 있고, 다른 서비스에 대한 종속성을 가지고 있어서, 특정 사용자 시나리오나 기능을 테스트하고자 할 경우 여러 서비스에 걸쳐서 테스트를 진행해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 때문에 테스트 환경 구축이나, 문제 발생시에 분리된 여러 개의 시스템을 동시에 봐야 하기 때문에 테스팅의 복잡도가 올라간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스간-트랜잭션-처리&#34;&gt;서비스간 트랜잭션 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현상의 가장 어려운 점 중에 하나가 바로 트랜잭션 처리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 해결하기 위한 방법으로 SAGA 패턴이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Choreography SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714624-7df60c80-8f1e-11eb-80f9-071d84562006.png&#34; alt=&#34;0_mcZ5UcSdTd4RvlnH&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하나의 큰 트랜잭션으로 묶지 않고, 각 서비스의 작업을 트랜잭션 단위로 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 서비스의 이벤트에 의해서 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Orchestrator SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714669-ada51480-8f1e-11eb-84f8-516e4d291a38.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 통해서가 아니라, 각 서비스를 관리하는 &lt;code&gt;Orchestration&lt;/code&gt; 클래스가 직접 처리하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 패턴에서처럼 메시지 이벤트를 사용하지 않고 동기식 &lt;code&gt;API&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a&#34;&gt;Event Driven Architecture란?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jjeongil.tistory.com/1100&#34;&gt;MSA - SAGA 패턴&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>네이버 페이 배송 모듈 아키텍처 및 사용기술 분석</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D.html</link>
      <pubDate>Sat, 27 Mar 2021 10:31:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D.html</guid>
      <description>&lt;p&gt;많은 양의 트래픽을 감당하고 어떻게 고가용성의 시스템을 구축하는지 알아보기 위해서 네이버 기술 블로그 및 세미나를 보면서 사용하는 기술을 분석하고 어떤 고민을 하고 있는지 살펴보았다.&lt;/p&gt;
&lt;h3 id=&#34;네이버-페이가-고민했던-문제점&#34;&gt;네이버 페이가 고민했던 문제점&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;https://tv.naver.com/v/16970002&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112708898-58560c80-8ef8-11eb-8cbf-63e2c05e0c08.png&#34; alt=&#34;Watch the video&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위에 있는 기술 세미나 영상을 보면서, 기존에 네이버 페이에서 발생했던 문제점들과 이를 해결하기 위한 기술들을 살펴볼 수 있었다.&lt;/p&gt;
&lt;h4 id=&#34;네이버-페이에서-유저와-상호-작용하는-서비스&#34;&gt;네이버 페이에서 유저와 상호 작용하는 서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;스마트 스토어에 보이는 주문형 페이&lt;/li&gt;
&lt;li&gt;배달의 민족에 연동되어 있는 결제형 페이&lt;/li&gt;
&lt;li&gt;송금&lt;/li&gt;
&lt;li&gt;네이버 통장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;배송 모듈은 주문형 페이에 속하고, 주문형 페이에는 이커머스 삼대장인 &lt;code&gt;주문&lt;/code&gt;, &lt;code&gt;배송&lt;/code&gt;, &lt;code&gt;클레임&lt;/code&gt; 을 관리하는 부서이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709049-59d40480-8ef9-11eb-8706-414fe24baa17.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 38 32 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;배송-모듈의-특징-및-문제점&#34;&gt;배송 모듈의 특징 및 문제점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;배송 모듈은 트래픽이 높았고, 다른 모듈과는 다른 특성이 있었다.&lt;/li&gt;
&lt;li&gt;다른 모듈들은, 온라인에서 데이터가 생성되며 액션의 주체가 사용자 및 내부시스템이다.&lt;/li&gt;
&lt;li&gt;배송은 오프라인에 의해서 데이터가 생성되며 액션의 주체가 유저가 아닌 외부 시스템이다.&lt;/li&gt;
&lt;li&gt;다른 모듈은 자체적으로 데이터를 생산하기에 데이터 보정 및 생성 규칙에 대해서 지정을 할 수 있지만, &lt;strong&gt;배송 모듈은 외부에 의해서 생성되는 데이터이기 때문에 데이터에 대한 필터링 및 검증이 어렵다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709148-11691680-8efa-11eb-81ee-b8f45b245d10.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 43 35 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709170-3fe6f180-8efa-11eb-959e-5729c28895f3.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 44 52 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;또한 점점 더 비즈니스 로직이 복잡해지고, 따라서 배송 모듈에 대한 트래픽도 증가했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;기존-배송-시스템&#34;&gt;기존 배송 시스템&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709273-3dd16280-8efb-11eb-8648-562344390386.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 52 00 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;택배사와 다이렉터로 연결하는 것이 아니라, 배송 모듈을 엔드포인트로 하여, 택배사의 정보를 제공해주는 업체와 연동을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;배송 데이터가 생성되면 연동 업체에 전달하고, 변경 사항이 발생했을 때, 연동 업체에서 변경분에 대해서 &lt;code&gt;FTP&lt;/code&gt; 통신으로 정보를 주고 받았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최소 설계시에는 빠른 배송에 대한 관심이 없었던 시절이라서 &lt;code&gt;FTP&lt;/code&gt; 통신으로도 문제가 없었지만, 빠른 배송에 대한 니즈 및 실시간성을 사용자들이 요구하면서 위의 구조는 한계점을 드러내었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;배송 데이터 생성 패턴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709318-c0f2b880-8efb-11eb-86a3-e797569ce216.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 55 43 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배송의 경우 특정 시간대에 트래픽이 몰리게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;한계점&#34;&gt;한계점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HPA(Horizontal Pod Autoscaler) 구성이 되어있지 않음&lt;/li&gt;
&lt;li&gt;배송 처리로 인해서 상품 주문 및 클래임으로 다른 모듈에 부하가 전파된다.&lt;/li&gt;
&lt;li&gt;장애 인지의 어려움 (지연, 누락, 장애)&lt;/li&gt;
&lt;li&gt;내부 시스템에서 장애가 발생한 경우에는 비교적 빠른 대응이 가능했지만, 외부 업체에서 생성된 장애를 인지하기에는 어려웠다.&lt;/li&gt;
&lt;li&gt;모니터링 시스템이 미비하여 쉽게 장애를 캐치하기 어려웠다.&lt;/li&gt;
&lt;li&gt;택배사가 코드에 적용되어 있어, 심심하면 나타나는 택배사를 추가해주어야하는 업무가 있었다.&lt;/li&gt;
&lt;li&gt;이전에는 국내 택배사만 있었지만 최근에는 (일반, 해외, 물류, 장보기) 등 다양한 종류의 택배사가 등장했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;개선-시도&#34;&gt;개선 시도&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;과거 &lt;code&gt;FTP&lt;/code&gt;를 통해서 통신하던 배치에서 &lt;code&gt;Kafka&lt;/code&gt;로 변경하여 적용하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결제 모듈과 다르게, 배송은 특정 시간대에 몰리게 되며, 배송은 N개 단위의 벌크로 진행하게 된다. 이 통신 사이에는 데이터 밸리데이션을 수행하고 데이터가 유실될 경우 데이터를 재보정 처리할 수 있어야하는 구조여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 데이터가 외부 업체와 연동이 되어야하므로, 누구 귀책으로 데이터가 처리되지 않았는지를 알아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 한 요청당 약 1000건의 데이터 통신이 이루어 지므로, 통신이 길어지는 문제가 발생하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709472-58a4d680-8efd-11eb-8968-274833727a20.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 07 06 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API로 수신한 내용들을 파일로 저장하고, 그 파일을 배치로 처리하는 구조로 변경하였다.&lt;/li&gt;
&lt;li&gt;하지만 여전히 대량의 데이터를 처리하는데에는 많은 한계를 가지고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709525-c2bd7b80-8efd-11eb-81d1-4b3bb51ca795.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 10 04 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;따라서 카프카를 이용하여, 이러한 작업을 처리해주었다.&lt;/li&gt;
&lt;li&gt;배치가 주는 모니터링의 장점을 버리게 되었다.&lt;/li&gt;
&lt;li&gt;배치가 카프카로 변경되는 건 기술을 적용했을 뿐 큰 변화는 없었다.&lt;/li&gt;
&lt;li&gt;데이터 누수 및 보정에 대한 새로운 FLOW 생성이 필요했다.&lt;/li&gt;
&lt;li&gt;메시지 스펙 정의 시 확장이 아닌 기능 기반 설계를 진행하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배송-분리-프로젝트-plasma&#34;&gt;배송 분리 프로젝트 Plasma&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네이버 페이 서비스의 &lt;code&gt;Scalability&lt;/code&gt; 확보&lt;/li&gt;
&lt;li&gt;모놀리틱 구조의 네이버 페이 주문 서비스를 분리&lt;/li&gt;
&lt;li&gt;기존 네이버 페이 서비스 개발자와 사내 플랫폼 개발자가 협업&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;문제 해결 접근 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술적인 부분과 비즈니스 적인 부분을 나누어서 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분에는 나도 공감하는데, 기술적으로 풀려고 시도했을 경우 많은 생각을 해야하지만 사실 비즈니스적으로 변경하여 문제가 쉽게 풀리는 경우가 많았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;렉 모니터링에 대한 세분화된 알람이 필요할 것으로 보임&lt;/li&gt;
&lt;li&gt;앞 모듈에 컨트롤 할 수 있는 부분을 두어서 랙이 기준치 이상 도달 할 경우, 우선순위가 중요한 메시지는 특정 큐에 집어 넣고 특정 큐에 대한 오퍼레이션을 별도로 수행하는 구조를&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;배송-서비스를-분리한-후에-구조&#34;&gt;배송 서비스를 분리한 후에 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709855-192bb980-8f00-11eb-9807-d750cf2865c3.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 26 47 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡한 쿼리가 필요한 데이터들은 분산 &lt;code&gt;RDBMS&lt;/code&gt;에 저장을 한다.&lt;/li&gt;
&lt;li&gt;로직이 간단한 데이터들은 &lt;code&gt;Redis&lt;/code&gt;에 저장을 한다.&lt;/li&gt;
&lt;li&gt;간단한 조회의 경우에는 API 서버를 통해서 분산 저장소에서 데이터를 읽어와 처리한다.&lt;/li&gt;
&lt;li&gt;추가 처리가 필요한 경우에는 &lt;code&gt;Kafka&lt;/code&gt;에 추가 처리나 이벤트를 발송시키게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kafka&lt;/code&gt;에서 처리하는 모든 이벤트는 &lt;code&gt;Logstash&lt;/code&gt;를 통해서 &lt;code&gt;Elasticseach&lt;/code&gt;에 저장이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;이벤트-기반-모니터링&#34;&gt;이벤트 기반 모니터링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에는 최종 데이터만 저장하고 갱신하기 때문에, 이벤트 기반 모니터링 시스템을 구축하였다. 따라서 특정 시간에 대한 데이터를 배송 이벤트를 분석해서 데이터를 처리하기 때문에 상태를 추적하거나, 상태를 복원할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;확장성에 대해서는 분산 저장소를 사용하여, 스토리지 확장성을 높혔고, 쿠버네티스를 활용하여 컴퓨팅 확장성을 높혔다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모니터링을 강화함으로써, 운영 비용을 절감시켰다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인스턴스 분리 및 의존성 분리를 통해서 장애적으로 독립적인 상태가 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네이버-페이-아키텍처-및-인프라-구성&#34;&gt;네이버 페이 아키텍처 및 인프라 구성&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706593-a2cf8d00-8ee8-11eb-902b-c52b16ce62d6.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 38 54 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;나도 현재는 웹 개발자로 일하고 있지만 언젠가는 플랫폼 개발을 경험하고 싶은 마음이 있는데, 멋있다는 생각이 들었다. 내가 만든 기능을 통해서 개발자들이 어떤 서비스를 만들었다고 생각하면 자부심과 동시에, 책임감을 느낄 수 있을 것 같다. 물론 이는 모든 개발자가 마찬가지지만 특히 플랫폼 개발을 하면 더욱 와닿을 것 같은 생각이 들었다. 내가 오픈 소스 활동을 하는 이유도 이와 비슷하다. 다른 사람들에게 선한 영향력을 주고 싶다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네이버페이는 비즈니스 성장과 트래픽 급증에 대응할 수 있도록 마이크로 서비스 아키텍처와 이벤트 드리븐 아키텍처를 적용해서 개발하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 구조를 사용하면 각각의 마이크로서비스가 독자적으로 유연하게 개발되고 데이터가 더 다양한 곳에 다양한 형태로 존재하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 기존에 고려되었지 않았던 새로운 문제가 발하고 이러한 문제를 플랫폼에서 지원해서 시스템적으로 해결하면 서비스와 완성도를 높일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 기존 서비스 개발자와 플랫폼 개발자가 협력하여 일을 하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;마이크로서비스 아키텍처 및 이벤트 드리븐 아키텍처에 대해서 대략적으로만 알고 있어서 이 기회에 정리를 해보았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;마이크로 서비스 아키텍처&lt;/strong&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706776-e5459980-8ee9-11eb-85d0-29316803cc43.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 47 46 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706932-e5926480-8eea-11eb-8161-373b02c6dd56.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 애플리케이션을 느슨하게 결합된 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로서비스 아키텍처에서 서비스들은 섬세하고, 프로토콜은 가벼운 편이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처의 서비스들은 독립적인 배포가 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스의 교체가 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이벤트 드리븐 아키텍처&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706975-3dc96680-8eeb-11eb-8174-3e310a6fae21.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707012-7f5a1180-8eeb-11eb-8828-510c5390ffc9.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 59 22 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트 드리븐 아키텍처(EDA)는 이벤트의 생산, 감지, 소비 및 반응을 제고하는 소프트웨어 아키텍처 패턴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트는 &amp;ldquo;상태의 변화&amp;quot;로 정의할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 내부 및 외부에 발생한 주목할 만한 상태의 변환에 기반하여 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, 소비자가 자동차를 구매할 때, 자동차의 상태는 &amp;ldquo;판매 중&amp;quot;에서 &amp;ldquo;판매 완료&amp;quot;로 바뀐다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 행동이 자동으로, 순서에 따라서 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 패턴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;이벤트-주도-마이크로서비스edm&#34;&gt;&lt;strong&gt;이벤트 주도 마이크로서비스(EDM)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;이벤트 주도 마이크로 서비스(EDM)은 &lt;strong&gt;MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며, 비동기 통신을 통해 시스템 내 통합(integeration)을 수행하는 아키텍처이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707540-8daa2c80-8eef-11eb-9e23-ee07bae1391d.png&#34; alt=&#34;0_FvyN47z7FwnKPflx&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트 : 이벤트 주도에서 언급하는 이벤트는 상태의 변경, 즉 데이터의 변경, 생성, 삭제 (&lt;code&gt;CUD&lt;/code&gt;)를 통해서 발생하는 서비스의 의미있는 변화를 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 로그 보관: 현재의 데이터는 상태 변경의 누적이라는 생각에서 시작한다. 이 때의 상태 변경은 이벤트를 뜻하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EDM&lt;/code&gt;에서 생성한 이벤트는 반드시 보관되어야 한다. 보관된 이벤트는 데이터의 현재 상태를 구성하는 근간이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행한다. 이벤트 로그를 보관하는 장소를 이벤트 스토어라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비동기 통신 : &lt;code&gt;AMQP&lt;/code&gt;, &lt;code&gt;MQTT&lt;/code&gt;, &lt;code&gt;JMS&lt;/code&gt;등 메세지 프로토콜을 통한 메시지 큐 방식이 자주 사용된다. 서비스에서 데이터의 생성, 변경, 삭제(CUD)를 통해 이벤트가 발생하면, 발생 서비스는 메시지의 형태로 이벤트를 발생하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네이버-페이를-뒷-받침하는-플랫폼&#34;&gt;네이버 페이를 뒷 받침하는 플랫폼&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707316-c1845280-8eed-11eb-9a00-62e759d3b2d6.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707334-e8428900-8eed-11eb-89c5-e3397fd6f3cc.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;빠르고 유연한 확장을 위해서, 쿠버네티스 클러스터에서 서비스 이미지를 배포해서 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메인 데이터베이스 저장소로는 자체 분산 데이터베이스 클러스터(&lt;code&gt;nBase-T&lt;/code&gt;)와 분산 레디스 클러스터를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 전달 및 저장을 위해서 &lt;code&gt;Kafka&lt;/code&gt;, &lt;code&gt;ElasticSearch&lt;/code&gt; 클러스터와 &lt;code&gt;LogStash&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모니터링과 분석을 위해서 사용하는 플랫폼은 &lt;code&gt;Grafana&lt;/code&gt;를 사용하고 있고, &lt;code&gt;Elasticsearch&lt;/code&gt; 상태와 데이터 확인을 위해서 &lt;code&gt;Kibana&lt;/code&gt;와 &lt;code&gt;Cerebro&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;로그 수집과 매트릭 수집은 자체 플랫폼을 사용하고 있고 &lt;code&gt;APM(application performance management)&lt;/code&gt;로는 사내에서 오픈 소스로 발표한 &lt;code&gt;Pinpoint&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 플랫폼을 활용해서 서비스를 개발하고 있고, 공통화가 필요한 부분은 플랫폼에 적용하거나 라이브러리화 하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인상 깊었던 부분은 &lt;code&gt;Spring Data JDBC&lt;/code&gt;에서 제공하지 않는 추가 기능들은 직접 개발해서 사용한다는 것이다. 기술에 이해도가 높지 않으면 절대로 쉽지 않다는 것을 알기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;인프라-운영&#34;&gt;인프라 운영&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CI/CD&lt;/code&gt; 시스템으로 젠킨스를 적극적으로 활용하고 있다.&lt;/li&gt;
&lt;li&gt;서비스가 메모리나 CPU를 과도하게 사용하고 있으면 &lt;code&gt;Grafana&lt;/code&gt;가 알려주고, 오류 로그가 있으면 로깅 시스템이 알려주고, &lt;code&gt;Kafka&lt;/code&gt;에 &lt;code&gt;LAG&lt;/code&gt;이 생기면 매트릭 시스템이 알려주고, 에러 응답이 늘어나면 &lt;code&gt;Pinpoint&lt;/code&gt;가 알려주는 식으로 동작한다.&lt;/li&gt;
&lt;li&gt;서비스가 복잡해지고 문제 상황에서 확인해봐야 하는 곳이 늘어나도 이러한 알람을 통해서 빠르게 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;이러한 플랫폼들을 활용하여 시간을 아낄 수 있었고, 아낀 시간을 서비스 개발에 투자할 수 있었다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;새로운 플랫폼을 접했을 때는 대부분 개념 증명부터 해보면서 필요한 부분만 빨리 익혀서 사용하는 편이라고 했다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;일하는-방식&#34;&gt;일하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;길거나 짧은 목표를 설정한 후 거기까지 각자의 역량을 발휘해서 자유롭게 도달하는 방식으로 일한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표에 어떤 방법으로도 도달해도 좋지만, 그 방식에 타당한 이유가 있어야하고, 방식에 확신이 없을 때는 주위 사람과 활발하게 논의해서 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스의 목표 내지는 문제를 해결하는 과정에서 플랫폼이 지원하면 효율적인 일도 도출되었던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기록과 공유가 권장되는 분위기이다. 그렇기에 팀에서는 사내/외 세미나나 기고를 통해서 경험을 활발하게 공유하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/naver_diary/222059276316&#34;&gt;네피셜 플랫폼 개발자의 커머스 서비스 개발기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Microservices&#34;&gt;Wiki - Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a&#34;&gt;Event Driven Architecture란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tv.naver.com/v/16970002&#34;&gt;페이왕국 주문가문 배송용사 독립기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>샤딩이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;샤딩&#34;&gt;샤딩&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클러스터링이란?(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;클러스터링&#34;&gt;클러스터링&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/docs/multi-node/galera-cluster/understand-mariadb-enterprise-cluster/#architecture&#34;&gt;Understanding MariaDB Enterprise Cluster&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://kaaproject.github.io/kaa/docs/v0.10.0/Administration-guide/System-installation/Cluster-setup/MariaDB-cluster-setup-guide/&#34;&gt;MariaDB cluster setup&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/what-is-mariadb-galera-cluster/&#34;&gt;What is MariaDB Galera Cluster?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://menakamadushanka.wordpress.com/2017/12/15/how-to-deploy-a-mysql-cluster-from-scratch-with-docker/&#34;&gt;How to deploy a MySQL Cluster from Scratch with Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CONCURRENCY(동시성)와 PARALLELISM(병행성) (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft.html</link>
      <pubDate>Sat, 27 Mar 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft.html</guid>
      <description>&lt;h3 id=&#34;concurrency동시성와-parallelism병행성&#34;&gt;CONCURRENCY(동시성)와 PARALLELISM(병행성)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112660338-af2bf980-8e98-11eb-8aec-e165f24e7fde.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;병행성&#34;&gt;병행성&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성&#34;&gt;동시성&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CONCURRENCY(동시성)&lt;/strong&gt; 에서 가장 중요한 것은 동시에 수행되는 기능들의 빠른 반응이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 빠른 반응은, 운영체제의 핵심인 커널에서 프로세스 스케줄러가 선점형(&lt;code&gt;Preemption&lt;/code&gt;)으로 동작하느냐가 관건이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 자원은 한정되어 있는데 반해서 작업 진행이 필요한 프로세스들은 여러 개가 생길 수 있다. 이때 CPU 자원을 어떻게 분배하느냐가 스케줄링이 필요한 이유이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컴퓨터에서 사용자가 파일을 다운로드 받을 때 파일을 다운로드 받는 프로세스가 &lt;code&gt;CPU&lt;/code&gt; 자원을 할당 받아서 작업을 진행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이때 사용자가 뮤직 플레이를 실행 시켜서 또 다른 프로세스가 생성되었다고 할 때 비선점형의 경우에는 파일을 다운로드 받는 프로세스 작업이 끝나야 음악을 플레이 하는 프로세스가 CPU 자원을 할당 받아서 작업을 진행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 파일 다운로드가 완료될 때까지 음악이 나오지 않을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선점형 스케줄링의 경우에는 스케줄러가 강제로 그 즉시 음악을 플레이하는 프로세스에게 자원을 할당해주고, 상황에 따라서 적당히 &lt;code&gt;CPU&lt;/code&gt; 자원을 분배하여 두 개의 프로세스가 작업을 진행하는데 문제가 없도록 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 자세히 들어가면 비선점형 스케줄링 방식을 사용하더라도 여러 가지 방법을 통해서 동시에 실행되는 것 처럼 보이게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>트랜잭션과 ACID</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid.html</link>
      <pubDate>Fri, 26 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid.html</guid>
      <description>&lt;p&gt;누군가 트랜잭션에 대해서 물어보았을 때, 분명히 알고 있다고 생각한 것인데도 제대로 답변하지 못했다. 이건 평소에 생각이 정리되지 않아서 그런 것 같다. 따라서 이참에 이에 대해서 정리를 해보도록 했다.&lt;/p&gt;
&lt;h3 id=&#34;트랜잭션이란&#34;&gt;트랜잭션이란&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112649044-6de21c80-8e8d-11eb-9e40-2f597a3555ac.png&#34; alt=&#34;트랜잭션&#34;&gt;&lt;/p&gt;
&lt;p&gt;위키 백과에서는 트랜잭션을 다음과 같이 정의하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 트랜잭션은 데이터베이스에 대해서 DBMS 내에서 수행되고 다른 트랜잭션과 무관하게 일관되고 신뢰할 수 있는 방식으로 처리되는 작업 단위를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션은 일반적으로 데이터베이스의 모든 변경 사항이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 환경의 트랜잭션에는 두 가지의 주요 목적이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행 중지 (완전 및 부분적으로) 및 데이터베이스에 대한 많은 작업이 완료되지 않은 상태로 남아있는 경우에 장래로부터 정확하게 복구하고 데이터베이스를 일관성 있게 유지할 수 있는 신뢰할 수 있는 작업 단위를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 동시에 액세스 하는 프로그램 간에 분리를 제공한다. 이러한 분리를 제공하지 않으면 프로그램의 결과가 잘못될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112650101-6707d980-8e8e-11eb-8d32-a92f3bce761b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;ACID 트랜잭션은 관계형 데이터베이스에서 여러 개의 SQL 연산을 하나의 단일 트랜잭션으로 처리하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;여러 개의 테이블에 대해서 읽고 쓰고 하는 행동을 하나의 연산처럼 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID 라는 단어는 분해할 수 없이 원자적(Atomicity)이고, 일관된(Consistency) 데이터 상태를 유지하고, 고립(Isolation)되어 다른 연산이 끼어들 수 없고, 데이터가 영원히(Durability) 반영된 상태로 있는 것을 의미한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;원자성(Atomicity) : 데이터베이스에서 가장 중요한 개념은 원자성일것이다, 여러개의 SQL 연산이 하나의 연산 처럼 동작해야한다. 어느 것 하나라도 실패했다면 모든 연산이 실행되지 않아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 같은 시점에 접속하는 클라이언트는 항상같은 데이터를 보고 있어야 한다는 것이다. 동일한 시간에 A와 B가 요청을 할 때, A가 읽은 데이터와 B가 읽은 데이터가 다르다면 아주 기본적인 일관성이 보장되지 않은 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고립성(Isolation) : 트랜잭션이 수행되는 동안에, 다른 연산이 끼어들지 못한다는 것이다. 이에 대해서는 고립 수준이라는 것이 있는데 이는 나중에 자세히 알아보도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;영속성(Durability) : 트랜잭션이 완료된 이후의 데이터는 업데이트 된 상태 그대로 영원히 반영되어 있다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Database_transaction&#34;&gt;WIKI - Database transaction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 26 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 일을 하기전에, 내가 어떤 일을 할 계획이고 그 일이 마감되었다면 내가 구현한 것을 녹화하여 공유하였다.&lt;/li&gt;
&lt;li&gt;내가 경험해보지 못한 생소한 업계에는 어떤 기술을 사용하고, 어떤 고민을 할까라는 생각을 해봤다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그렇게 하니까 동료들이 내가 무엇을 했는지 쉽게 이해할 수 있고, 개발자 뿐만 아니라 &lt;code&gt;PM&lt;/code&gt; 및 &lt;code&gt;QA&lt;/code&gt; 분들도 작업이 어떻게 진행되고 있는지 쉽게 이해하시는 것 같았다.&lt;/li&gt;
&lt;li&gt;내가 어떤 일을 하고 있는지 설명하기가 더 쉬워지고 상대방도 더 빠르게 이해하는 것 같았다.&lt;/li&gt;
&lt;li&gt;기술 블로그를 통해서, 대략적인 아키텍처와 사용하는 기술을 파악할 수 있다는 생각이 들었다. 따라서 내가 분석하고 싶은 분야 회사 기술 블로그를 파악하고 관련된 기술을 공부하면 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;말로 설명하는 것 보다는 내가 작업한 내용을 동영상으로 결과만이라도 같이 공유하는 것이 의사소통에 도움이 된다.&lt;/li&gt;
&lt;li&gt;나도 다른 사람들에게 내가 했던 작업을 이해시키기가 훨씬 쉬워진다.&lt;/li&gt;
&lt;li&gt;다양한 매체로 내가 작업하고 있는 내용, 그리고 앞으로 작업할 내용, 고민하고 있는 내용을 관계된 사람들에게 알리자.&lt;/li&gt;
&lt;li&gt;은행들은 개발자 관점에서 어떤 기술을 사용하고, 어떤 고민을 할 지 파악하는 가장 좋은 방법은 기술 블로그를 분석하고 이와 관련된 주제를 공부하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;영상으로 녹화하는 작업을 일일히 수작업으로 하는 것이 아니라, 테스트 코드를 통해내가 작업한 과정을 자동화 시키면 업무 시간을 획기적으로 단축 시킬 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;결과가 화면상으로 나타나지 않는 코드 레벨에서 고민해야할 것은 화면으로 공유하기 어려울 것 같다. 따라서 이러한 경우에는 어쩔 수 없이 글로 라도 작성해야하는데, 코드를 글로 설명하기가 어려워 이러한 공유를 꺼리는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CAP 이론이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;cap-정리&#34;&gt;CAP 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112651209-86533680-8e8f-11eb-9579-2d9a2389ce27.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CAP 정리에 의하면 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림에서 볼 수 있듯이, Consistency, Availablity를 합치면, &lt;code&gt;CA&lt;/code&gt; 또는 Consistency와 Partition tolerance를 조합하면 &lt;code&gt;AP&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 모든 속성을 다 포함한 시스템은 절대로 존재할 수 없다는 것이 CAP 정리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;각-특징의-의미&#34;&gt;각 특징의 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. &lt;code&gt;ACID&lt;/code&gt; 원리에서 의미하는 것과 같다. 어떤 데이터베이스 속성에 &lt;code&gt;C&lt;/code&gt;가 있다면, 트랜잭션 기능 또는 그와 비슷한 매커니즘이 존재한다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가용성(Availablity) : 가용성은 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 처리 응답을 보애주어야 한다는 것을 의미한다. 클라이언트가 읽기, 쓰기 요청을 하면 제대로 읽고 쓰는 작업을 해야한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분단 허용성(Partition tolerance) : 분단 허용성은 클러스터가 여러 대 동작하고 있을 때, 해당 클러스터 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 시스템이 잘 동작해야 한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;관계형 데이터베이스는 CA 시스템이다. 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다.
만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;해결책은 간단한데, CA를 포기하면 된다. CA를 포기한다는 뜻이 극단적으로 일관성과 가용성을 포기하는 것이 아닌 1 ~ 100까지의 수치가 있을 때 일관성과 가용성을 100% 지원하던 것에서 수치를 60%로 낮춘다고 생각을 하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;대부분의 NoSQL 데이터베이스는 CA가 아닌 CP나 AP 시스템이다. 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MVCC(다중 버전 동시성 제어)란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE COMMIT 이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80.html</guid>
      <description>&lt;h3 id=&#34;two-phase-커밋이란&#34;&gt;TWO-PHASE 커밋이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113822026-dd260d80-97b7-11eb-8ea8-b3c939d08cec.png&#34; alt=&#34;95&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;투 페이즈 커밋은 여러 노드에 거쳐서 원자성 트랜잭션 커밋을 달성하기 위한 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분산 데이터베이스의 트랜잭션 처리를 위해서 사용하는 고전적인 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC에서는 일반적으로 단일 노드 트랜잭션에서는 나타나지 않는 새로운 구성 요소인 코디네이터(트랜잭션 관리자)를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC 트랜잭션은 애플리케이션이 정상적으로 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋할 준비가 되면 트랜잭션 관리자는 1 단계를 시작한다. 그런 다음에 각 노드에 준비 요청을 보내서 커밋 가능 여부를 묻게 되며, 참가자의 응답에 따라서 커밋을 할지, 롤백을 할지 결정을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 노드가 &amp;ldquo;예&amp;rdquo; 라고 대답하여, 커밋할 준비가 되었다고 하면, 트랜잭션 매니저는 2단계에서 커밋 요청을 전송하고 커밋이 실제로 수행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자가 &amp;ldquo;아니오&amp;quot;라고 대답하면 코디네이터는 2단계의 모든 노드에 중단 요청을 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113823077-32aeea00-97b9-11eb-888f-4a5f9b9d2ae5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 과정은 결혼식에 비유할 수 있는데, 주례자가 신랑과 신부에서 각각 결혼하고 싶은지 물어보고, 모두 결혼을 하고 싶다는 대답을 받고 나서, 결혼식을 마무리하는 과정이라고 비유를 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주례자는 트랜잭션 매니저이며, 신랑과 신부는 각 데이터베이스 노드들이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;two-phase-커밋의-단점&#34;&gt;TWO-PHASE 커밋의 단점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;2PC의 가장 큰 단점은 블록킹이라는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Two-phase_commit_protocol&#34;&gt;Two-phase commit protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ebrary.net/64872/computer_science/introduction_phase_commit&#34;&gt;introduction_phase_commit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>합의(Consensus) 알고리즘이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft.html</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Consensus_(computer_science)&#34;&gt;WIKI - Consensus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zookeeper.apache.org/doc/r3.4.13/zookeeperInternals.html&#34;&gt;ZOOKEEPER DOCS -  CONSENSUS ALGORITHMS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://betterprogramming.pub/demystifying-consensus-algorithms-and-their-implementations-c52f8aca3020&#34;&gt;Demystifying Consensus Algorithms and Their Implementations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://raft.github.io/&#34;&gt;RAFT 합의 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/5663184&#34;&gt;D2 - Raft 분산 합의 알고리즘과 Python에서의 활용&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC의 여러가지 구현 방식(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft.html</link>
      <pubDate>Thu, 25 Mar 2021 19:03:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft.html</guid>
      <description>&lt;p&gt;스프링 문서를 보면서, &lt;code&gt;IoC&lt;/code&gt;에 대해서 공부를 하다가, 서비스 로케이터 패턴을 알게 되었다. 서비스 로케이터 패턴을 조사하다가 자연스럽게 다른 &lt;code&gt;IoC&lt;/code&gt; 구현 방식도 알게 되었는데 정리를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292089-15b3ea80-8cd4-11eb-80fd-943416430267.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ahea.wordpress.com/2018/09/09/1754/&#34;&gt;IOC 구현 방식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 25 Mar 2021 18:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;팀 회식을 했다.&lt;/li&gt;
&lt;li&gt;회의때 진행한 이야기중에 내가 놓친것들이 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회의때 집중을 해야겠다는 생각을 하게 되었고, 부끄러웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;회의때 내용을 파악하고 이를 기록하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일을 진행할 때 다시한번 회의때 내가 파악하고 있는것이 맞는지 확인하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회의때 집중하고, 내가 놓친부분이 있을 수 있으니 이를 확인하고 일을 시작하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>빈 펙토리와 애플리케이션 컨텍스트의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Wed, 24 Mar 2021 23:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;h3 id=&#34;궁금증을-가지게-된-이유&#34;&gt;궁금증을 가지게 된 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112328879-10699680-8cfa-11eb-8c22-2db852326801.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 38 22 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 문서를 보면서 공부하다가 위와 같은 문구를 보게 되었다. &lt;code&gt;ApplicationContext&lt;/code&gt;가 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 타입의 인터페이스라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇다면 무슨 차이가 있을까라는 생각을 하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean-facotry&#34;&gt;BEAN FACOTRY&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112329428-88d05780-8cfa-11eb-8c53-63c801dadfbb.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 41 55 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다행스럽게도 위와 같은 문서가 스프링 공식문서에서 제공되고 있었다. 차이점은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API는 &lt;code&gt;Spring IoC&lt;/code&gt; 기능을 위한 기초적인 기반을 제공한다.&lt;/li&gt;
&lt;li&gt;이것의 구체적인 계약은, 주로 스프링의 다른 부분과 관련된 써드 파티 프레임워크와의 통합에 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 및 관련 인터페이스 (예: &lt;code&gt;BeanFactoryAware&lt;/code&gt;, &lt;code&gt;Initializing Bean&lt;/code&gt;, &lt;code&gt;DispisableBean&lt;/code&gt;)는 다른 프레임워크 구성 요소의 중요한 통합지점이다.&lt;/li&gt;
&lt;li&gt;어노테이션이랑 리플렉션이 필요하지 않으므로, 컨테이너와 컴포넌트간에 매우 효율적인 상호작용을 할 수 있다.&lt;/li&gt;
&lt;li&gt;응용 프로그램 수준 빈은 동일한 콜백 인터페이스를 사용할 수 있지만, 일반적으로 어노테이션을 또는 설정을 통한 선언적 종속성 주입을 선호한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API 레벨과, &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 구현에서는 구성 형식이나 사용할 구성 요소 어노테이션에 대해서 가정을 하지 않는다.&lt;/li&gt;
&lt;li&gt;이러한 것은 확장 기능(예: &lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;, &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;)을 통해서 제공되며, 공유 &lt;code&gt;BeanDefinition&lt;/code&gt; 개체에서 핵심 메타데이터 표현으로 작성한다.&lt;/li&gt;
&lt;li&gt;이것이 바로 스프링 컨테이너를 유연하고 확장 가능하게 만드는 본질이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;솔직히 이 부분은 아직 잘 모르겠다&amp;hellip; 그래도 정리를 해둔 기억이 있으니 코딩을 하면서 관련된 API를 사용할 때 다시 한번 확인해봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;빈-펙토리와-애플리케이션-컨텍스트&#34;&gt;빈 펙토리와 애플리케이션 컨텍스트&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112332863-70ae0780-8cfd-11eb-8ad5-23a995c1a92d.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 28 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 섹션에서는 &lt;code&gt;BeanFactory&lt;/code&gt;와 &lt;code&gt;ApplicationContext&lt;/code&gt; 컨테이너 수준 간의 차이와 부트스트래핑에 대한 의미에 대해서 설명한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 부트스트랩핑을 &lt;code&gt;GenericApplicationContext&lt;/code&gt;, &lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;를 이용하여 구현할 것이 아니라면 일반적으로는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 공통 목적을 위해서 스프링의 핵심 컨테이너에 대한 기본 진입 지점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;에는 &lt;code&gt;BeanFactory&lt;/code&gt;의 모든 기능이 포함되므로, &lt;code&gt;BeanFactory&lt;/code&gt;에 대한 완전한 제어가 필요한 시나리오를 제외하고 일반적으로 &lt;code&gt;BeanFactory&lt;/code&gt;보다는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;(일반 애플리케이션 컨텍스트 구현 등) 내에서 몇 가지 종류의 빈이 컨벤션에(특히, &lt;code&gt;post-processors&lt;/code&gt;) 의해서 탐지되는 반면에 일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;는 특별한 빈들에게 대해서 관련이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주석 처리 및 &lt;code&gt;AOP&lt;/code&gt; 프록시와 같은 많은 확장 컨테이너 기능의 경우, &lt;code&gt;BeanPostProcessor&lt;/code&gt; 확장 지점이 필수적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;만 사용하는 경우에는 기본적으로 이러한 사후 프로세스가 탐지 및 활성화 되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈 구성에 아무런 문제가 없기 때문에 이러한 상황은 혼란스러울 수 있지만 오히려 이러한 시나리오에서 컨테이너를 추가 설정을 통해서 완전히 부트스트랩 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112334414-c0410300-8cfe-11eb-87ba-a5566175c744.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 42 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;는 &lt;code&gt;Bean&lt;/code&gt;을 인스턴스화 하거나 와이어링 하는 것 빼고는 &lt;code&gt;ApplicationContext&lt;/code&gt;과 비교해서 많은 기능을 제공하지 않는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;BeanFactory&lt;/code&gt;에서 사후 프로세서를 명시적으로 등록하려면, 다음의 예외 같이 프로그래밍 방식으로 &lt;code&gt;addBeanPostProcessor&lt;/code&gt;를 호출해야한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음에 생각했던 것 과는 달리 기능을 제공하지 않을 뿐, 코드 상으로 설정을 해주면 사용할 수는 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그래도 이렇게 명시적으로 등록을 해주어야 하기 때문에, 다양한 &lt;code&gt;ApplicationContext&lt;/code&gt; 변형이 일반 &lt;code&gt;DefualtListableBeanFactory&lt;/code&gt; 보다 선호 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 일반적인 엔터프라이즈 환경에서 확장 컨테이너 기능을 위해서 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 및 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 인스턴스에 의존하는 경우 더욱 그렇다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일단 내가 생각하기에 가장 와닿는건 빈의 생명주기 관리를 할 수 없고, &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 자동으로 등록해주지 않는다는 것이다. 뭐 수동으로 등록해주면 되기는 하지만, 상당히 불편하다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-introduction&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wonwoo.ml/index.php/post/1571&#34;&gt;ApplicationContext와 BeanFactory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC 컨테이너란 무엇일까</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</link>
      <pubDate>Wed, 24 Mar 2021 18:13:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</guid>
      <description>&lt;p&gt;스프링 전반적인 기술을 주제로 사내 세미나를 하였다. 따라서 이를 공식 문서를 보면서 복습하면서 다시 정리해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112285137-55c39f00-8ccd-11eb-9416-87ba7f879ce0.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 18 09 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 코어 문서 가장 첫 부분에 나와있는 문구이다. 전체적인 기술을 다루지만 특히 스프링 프레임워크의 &lt;code&gt;IoC(Inversion of Control)&lt;/code&gt; 컨테이너가 가장 중요하다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring Framework&lt;/code&gt;의 IoC 컨테이너에 대한 처리는 &lt;code&gt;Spring&lt;/code&gt;의 &lt;code&gt;AOP(Aspect-Oriented Programmin)&lt;/code&gt; 기술을 밀접하게 따르고 있다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프링 프레임워크는 개념적으로 이해하기 쉽고 자바 엔터프라이즈 프로그래밍에서 &lt;code&gt;AOP&lt;/code&gt; 요구사항의 80%를 성공적으로 해결하는 &lt;code&gt;AOP&lt;/code&gt; 프레임워크가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스프링-ioc-컨테이너-및-빈bean&#34;&gt;스프링 IoC 컨테이너 및 빈(Bean)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112286205-6c1e2a80-8cce-11eb-9eef-2ca033148bc9.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 26 06 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 장에서는 제어의 반전(&lt;code&gt;IoC&lt;/code&gt;) 원칙의 스프링 프레임워크 구현에 대해서 다룬다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IoC&lt;/code&gt;는 의존성 주입이라고 알려져 있다. &lt;code&gt;(DI)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DI&lt;/code&gt;는 객체가 생성자 파라미터, 펙토리 메서드에서 반환된 후 객체 인스턴스에 설정된 속성을 통해서만 객체의 종속성을 정의하는 프로세스이다.&lt;/li&gt;
&lt;li&gt;그런 다음에, 컨테이너가 빈을 생성할 때, 이러한 종속성을 주입한다.&lt;/li&gt;
&lt;li&gt;이러한 프로세스는 기본적으로 클래스 직접 구성이나 서비스 로케이터 패턴과 같은 매커니즘을 이용하여, 종속성의 인스턴스 화를 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt;와 &lt;code&gt;org.springframework.context&lt;/code&gt; 패키지들이 스프링 프레임워크 &lt;code&gt;IoC&lt;/code&gt; 컨테이너의 기본 구성을 이루고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 인터페이스는 모든 타입의 객체를 관리할 수 있는 고급 설정 매커니즘을 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;는 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112288026-48f47a80-8cd0-11eb-8efe-6d675e3ae5da.png&#34; alt=&#34;ApplicationContextInterface&#34;&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 그림으로 이해하면 이해하기 편하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단히 말해서 &lt;code&gt;BeanFactory&lt;/code&gt;는 구성 프레임워크와 기본 기능을 제공하며 &lt;code&gt;Application Context&lt;/code&gt;는 더 많은 엔터프라이즈별 기능을 추가한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;에서는 애플리케이션의 핵심을 구성하고, &lt;code&gt;Spring IoC&lt;/code&gt; 컨테이너에 의해서 관리되는 개체를 빈(Bean)이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈은 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너에 의해서 인스턴스화, 조립 및 관리되는 객체이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇지 않으면 빈(Bean)은 응용 프로그램의 여러 객체에 불과하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈과 빈 사이의 종속성은 컨테이너가 사용하는 설정 메타데이터에 의해서 반영된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;컨테이너-개요&#34;&gt;컨테이너 개요&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289026-434b6480-8cd1-11eb-9a2c-3a924dee26c7.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 46 34 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;org.springframework.context.ApplicationContext&lt;/code&gt;는 &lt;code&gt;Spring Ioc&lt;/code&gt; 컨테이너를 나타내며 빈의 인스턴스화 및 구성 및 조립을 담당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 메타데이터 설정을 읽어서, 인스턴스화, 구성 및 조립할 객체에 대한 지침을 가져온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구성 메타데이터는 &lt;code&gt;XML&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt; 어노테이션 또는 &lt;code&gt;Java&lt;/code&gt; 코드로 표시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션을 구성하는 객체와 이러한 객체간의 풍부한 상호 종속성을 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289745-e9976a00-8cd1-11eb-9b9d-8022fe6a673b.png&#34; alt=&#34;container-magic&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 그림은, 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너가 빈 설정정보를 읽어서, &lt;code&gt;ApplicationContext&lt;/code&gt; 생성되고 초기화되면 완전히 구성되고 실행 가능한 시스템 또는 응용 프로그램의 생성을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-스코프와-라이프-사이클bean-scope-and-lifecycle&#34;&gt;빈의 스코프와 라이프 사이클(Bean Scope and LifeCycle)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292568-8f4bd880-8cd4-11eb-95e0-2884097eed6f.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 10 07 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너는 하나 이상의 빈을 관리한다. 이러한 빈은 컨테이너에 제공하는 메타데이터 XML &lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt; 형식으로 제공된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너 자체 내에서 이러한 빈 정의는 &lt;code&gt;BeanDefinition&lt;/code&gt; 객체로 표시되며, 여기에는 (다른 정보 중에서도) 다음과 같은 메타데이터가 포함된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스 이름: 정의되는 빈의 실제 구현 클래스이다.&lt;/li&gt;
&lt;li&gt;빈이 클래스에서 어떻게 동작해야하는지를 나타내는 동작 구성 요소이다. (범위, 라이프 사이클 콜백 등).&lt;/li&gt;
&lt;li&gt;빈이 동작하는데 의존성을 가지는 다른 빈에 대한 참조이다. 이러한 참조를 &lt;code&gt;collaborators&lt;/code&gt; 또는 &lt;code&gt;dependencies&lt;/code&gt; 라고 한다.&lt;/li&gt;
&lt;li&gt;새로 생성된 개체에서 설정할 기타 구성 설정(예: 풀의 크기 제한 또는 연결 풀을 관리하는 빈에서 사용할 연결 수)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112293473-87d8ff00-8cd5-11eb-9250-16ae9694c705.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 17 00 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 표는 빈의 정의를 나타내고 속성은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;: Bean을 생성하기 위한 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;: Bean의 이름을 말한다. Bean이 누군가에 의해 참조되어야 할 때 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scope&lt;/code&gt;: Bean의 생명주기와 관련하여 어느 Scope에 유일하게 존재할 것이냐에 대한 정의이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constructor arguements&lt;/code&gt;: 빈의 생성자로 의존성을 명시 하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Properties&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt;의 생성자로 의존성을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Autowiring&lt;/code&gt;: &lt;code&gt;Autowiring&lt;/code&gt;에 대한 방법을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lazy initializaton&lt;/code&gt;: &lt;code&gt;Lazy&lt;/code&gt; 하게 &lt;code&gt;Bean&lt;/code&gt;을 초기화 시키도록 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Initialization method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 초기화 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destuction method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 파괴 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112295826-9d4f2880-8cd7-11eb-8792-a5ce9d603d7e.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 31 54 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;: (Default) SPRING IoC 컨테이너당 하나의 레퍼런스만 존재하는 스코프입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;: 임의의 수의 객체 인스턴스로 단일 빈의 범위를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;: 단일 빈 정의의 범위를 단일 HTTP 요청의 수명 주기로 지정한다, 각, HTTP 요청에는 단일 빈 정의 뒤에 생성된 빈 인스턴스가 있다, 오직 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 단일 빈 정의의 범위를 HTTP 세션의 생명주기로 지정한다. 오직 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application&lt;/code&gt;: 단일 빈의 정의를 서블릿 컨텍스트의 생명주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt; 에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;websocket&lt;/code&gt;: 단일 &lt;code&gt;bean&lt;/code&gt;의 정의를 &lt;code&gt;WebSocket&lt;/code&gt;의 생명 주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-생명-주기-콜백lifecycle-callbacks&#34;&gt;빈의 생명 주기 콜백(Lifecycle Callbacks)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112397674-e8078980-8d45-11eb-8439-6ab8de4ed0b0.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 41 23 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨테이너의 빈 생명주기와 상호 작용하기 위해서 &lt;code&gt;InitializingBean&lt;/code&gt;, &lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 빈을 초기화 하기 전에 &lt;code&gt;afterPropertiesSet()&lt;/code&gt;을 호출하고 &lt;code&gt;Bean&lt;/code&gt; 소멸시에 &lt;code&gt;destory()&lt;/code&gt;를 호출하여 특정 작업을 수행하게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JSR-250 스펙에서는 &lt;code&gt;@PostConstruct&lt;/code&gt;, &lt;code&gt;@PreDestory&lt;/code&gt; 어노테이션을 사용하는데, 일반적으로 최신 스프링 애플리케이션에서 생명 주기 콜백을 수신하기 위한 좋은 방법이다. 어노테이션을 사용한다는 것은 스프링이 특정 인터페이스에 결합되지 않는다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내부적으로 &lt;code&gt;SpringFramework&lt;/code&gt;는 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 구현을 사용하여 적절한 메서드를 찾아 호출할 수 있는 모든 콜백 인터페이스를 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 기능이 필요하거나, 스프링이 기본적으로 제공하지 않는 다른 라이프 사이클 동작이 필요한 경우 &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 직접 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398510-b8f21780-8d47-11eb-8584-09600530656c.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 54 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InitializingBean&lt;/code&gt; 인터페이스는 불 필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PostConstruct&lt;/code&gt; 주석을 사용하거나 &lt;code&gt;POJO&lt;/code&gt; 초기화 방법을 지정하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XML 기반 구성 메타 데이터의 경우 &lt;code&gt;init-method&lt;/code&gt; 속성을 사용하여 인수없는 빈 서명이 있는 메서드의 이름을 지정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 설정으로는 &lt;code&gt;@Bean&lt;/code&gt;의 &lt;code&gt;initMethod&lt;/code&gt; 속성을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;여러 가지 방법으로 구현할 수 있지만, 인터페이스 방법은 권장하지 않는 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398918-84cb2680-8d48-11eb-8b2a-29065259f433.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 00 11 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.beans.factory.DisposableBean&lt;/code&gt; 인터페이스를 구현하면 이를 포함하는 컨테이너가 소멸될 때, &lt;code&gt;Bean&lt;/code&gt;이 콜백을 받을 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스는 단일 메서드를 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기화와 같이 인터페이스 구현은 불필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PreDestory&lt;/code&gt; 주석을 사용하거나 빈 정의에서 지원하는 일반 메서드를 지정하는 것이 좋습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112400248-4d11ae00-8d4b-11eb-9b5c-8de0b739da81.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 19 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 고유의 &lt;code&gt;InitializingBean&lt;/code&gt; 또는 &lt;code&gt;DisposableBean&lt;/code&gt; 콜백 인터페이스를 사용하지 않는 초기화 및 폐기 메서드 콜백을 작성할 때는 일반적으로 &lt;code&gt;init()&lt;/code&gt;, &lt;code&gt;initialize()&lt;/code&gt;, &lt;code&gt;dispose()&lt;/code&gt;등과 같은 이름으로 작성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이상적으로는 이러한 수명주기 콜백 메서드의 이름은, 모든 개발자가 동일한 메서드 이름을 사용하고 일관성을 보장하기 위함이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;그렇다면 InitializingBean과 DisposableBean 인터페이스를 구현하는 것과 @PostConstruct, @PreDestory를 사용하는 것의 차이점은 무엇일까?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 24 Mar 2021 09:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SOP에 대해서 정리해보았다.&lt;/li&gt;
&lt;li&gt;스프링 문서를 보면서, 세미나에서 들었던 내용을 다시 한번 보았다.&lt;/li&gt;
&lt;li&gt;빈 펙토리와 애플리케이션 컨텍스트의 차이에 대해서 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SOP에 대해서 정리하면서 CORS에 대해서도 알게 되었는데, 퍼즐이 맞춰지는 기분이였다.&lt;/li&gt;
&lt;li&gt;이전에는 CORS 에러가 발생했을 때, 왜 발생했는지 원인을 파악하고 해결 방법만 찾고나서 끝이였다. 하지만 중요한 것은 왜 브라우저에서 CORS 에러를 나게 했을까라는 근본적인 물음을 가지고, 해결하는 것이 중요하다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;막연히 문서를 바로 보는 것 보다 세미나를 통해서 전체적인 흐름을 한번 훓고 나서 문서를 보니까, 훨씬 이해도 잘되고 재미있었다.&lt;/li&gt;
&lt;li&gt;오늘 스프링 문서를 보면서 많은 것을 느꼈다. 오픈 소스에 기여하는 것에 굉장히 관심이 많은데 그 이유는 처음에는 단순하게 멋져보이기도 했고 학부때 예제 코드가 아닌 실제 대규모 프로젝트의 코드를 보고 싶었고 나도 개발을 해보고 싶었다. 따라서 오픈 소스에 기여를 할 때 문서가 아닌 주로 코드로만 기여하고 싶은 마음이 있었다. 하지만 오늘 완전히 그 생각이 깨졌다. 사실 문서로 기여하는 것도 굉장히 많은 지식을 가지고 있어야 가능하다는 것을 느끼게 되었다. 따라서 일단은 나와 같은 사람들이 굉장히 많은 도움을 받는 공식문서를 작성해보고 싶은 마음이 생겼다.&lt;/li&gt;
&lt;li&gt;동기와 같이 식사를 하는데, 발표를 어떻게 하면 잘할 수 있을까라는 고민을 했다. 단순하게 든 생각은 많이 해보지 않았기 때문에 그리고 평소에 내 생각을 정리해두지 않았기 때문에 말을 잘 못하는 것이라고 생각한다. 따라서 일단은 발표를 많이 해볼 수 있게 아무도 듣지 않더라도 일단 다른 사람에게 내가 아는 것을 설명해보는 연습을 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 보안을 위한 다양한 정책을 알 수 있었고, 어떠한 에러가 발생했을 때, 왜 이러한 에러를 발생시켰는지 브라우저, 운영체제, 프레임워크 설계자 관점에서 생각을 해봐야한다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;문서도 아는 놈이 작성한다. 우선 아는놈부터 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현상을 보지 말고, 원인을 파악하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예외, 에러 설계자 관점에서 이러한 예외 및 에러를 왜 발생시키게 하였는지를 고민하겠다.&lt;/li&gt;
&lt;li&gt;발표를 잘하기 위한 나의 생각은 우선 많이 해보는 것이다. 이제 곧 사내에서 자바스크립트 프로토타입과 관련해서 세미나 발표를 하는데, 발표 준비 및 실제로 연습을 많이 해보면서 발표 실력을 연마하자. 그리고 블로그에 글을 작성하듯이 유튜브에 채널을 운영 해보는 것도 좋은 생각인것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CSP(Content Security Policy) 란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP&#34;&gt;MDN - CSP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SOP(Same-origin policy) 란 무엇일까?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</guid>
      <description>&lt;p&gt;브라우저 보안 정책에 &lt;code&gt;SOP(same-origin-policy)&lt;/code&gt; 있다는 것을 알게 되었고, 어떤건지 궁금해서 찾아보았다. 마침 MDN 문서에 잘 나와있어서 이를 참조할 수 있었다.&lt;/p&gt;
&lt;h3 id=&#34;same-origin-policy동일-출처-정책&#34;&gt;Same-Origin-Policy(동일 출처 정책)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112231170-8974d980-8c79-11eb-99e5-4a9b5f85513d.png&#34; alt=&#34;sop&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SOP&lt;/code&gt;는 한 &lt;code&gt;Origin&lt;/code&gt;에서 로드된 문서 또는 스크립트가 다른 &lt;code&gt;Origin&lt;/code&gt;의 리소스와 상호 작용할 수 있는 방법을 제한하는 중요한 보안 메커니즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안을 위협하는 문서를 격리하여, 보안 위협으로부터 보호할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한마디로 말해서 웹 브라우저에서 동작하는 프로그램은 로딩된 위치에 있는 리소스만 접근 할 수 있다는 정책이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;출처origin의-정의&#34;&gt;출처(Origin)의 정의&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112231662-78789800-8c7a-11eb-8897-048e15a11d65.png&#34; alt=&#34;origin&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;두개의 URL이 존재할 때 프로토콜, 포트(지정된 경우), 호스트가 동일한 경우 두 URL의 &lt;code&gt;Origin&lt;/code&gt;이 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 표를 보면 &lt;strong&gt;&lt;a href=&#34;http://store.company.com/dir/page.html&#34;&gt;http://store.company.com/dir/page.html&lt;/a&gt;&lt;/strong&gt; 과 비교하여, 같은 &lt;code&gt;Origin&lt;/code&gt;인지 아닌지를 나타내고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상속된-출처origin&#34;&gt;상속된 출처(Origin)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112232063-47e52e00-8c7b-11eb-8f7a-918fd0885a8a.png&#34; alt=&#34;inherited origins&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;about:blank&lt;/code&gt;, &lt;code&gt;javascript:URL&lt;/code&gt;과 같은 URL이 포함된 페이지에서 실행되는 스크립트는 해당 URL에 포함된 문서의 원본을 상속합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 유형의 URL에는 원본 서버에 대한 정보가 포함되어 있지 않기 때문입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Internet Explorer의 예외&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;항상 인터넷 익스플로러는 표준을 지키지 않아서 문제가 생기는 것 같다.&lt;/p&gt;
&lt;h4 id=&#34;trust-zones&#34;&gt;Trust Zones&lt;/h4&gt;
&lt;p&gt;만약 두 도메인이 모두 신뢰도가 높은 영역 (예: 회사 인트라넷 도메인)에 있는 경우 동일한 오리진 제한이 적용되지 않는다.&lt;/p&gt;
&lt;h4 id=&#34;port&#34;&gt;Port&lt;/h4&gt;
&lt;p&gt;IE는 동일 출처 검사에 포트를 포함하지 않는다. 따라서 &lt;code&gt;https://company.com:81/index.html&lt;/code&gt;과 &lt;code&gt;https://company.com/index.html&lt;/code&gt;은 같은 오리진으로 간주되며 제한은 적용되지 않는다.&lt;/p&gt;
&lt;h3 id=&#34;출처origin를-변경하기&#34;&gt;출처(Origin)를 변경하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;일부 제한 사항이 있는 페이지는 자체 출처를 변경할 수 있다.&lt;/li&gt;
&lt;li&gt;스크립트는 &lt;code&gt;document.domain&lt;/code&gt;의 값을 현재 도메인 또는 현재 도메인의 슈퍼 도메인으로 설정할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 이 기능은 동일한 출처 정책에서 제공하는 보안 보호 기능을 약화시키고 브라우저의 출처 모델을 복잡하게 하여, 상호 운용성 문제와 보안 버그를 유발하기 때문에 더 이상 사용되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112233574-0c982e80-8c7e-11eb-9ddb-0804823875c0.png&#34; alt=&#34;Document.domain&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 문서를 보더라도, 몇몇의 브라우저가 지원을 하더라도, 지금은 표준에서 제외되었고 사용하지 않는게 좋다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 디프리케이트 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서로-다른-출처-접근cross-origin-network-access&#34;&gt;서로 다른 출처 접근(Cross-origin network access)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112234075-08b8dc00-8c7f-11eb-8c8b-293057534eff.png&#34; alt=&#34;another origin&#34;&gt;&lt;/p&gt;
&lt;p&gt;동일 출처 정책은 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 또는 &lt;code&gt;img&lt;/code&gt; 요소를 사용하는 경우와 같이 서로 다른 두 출처 간의 상호 작용을 제어한다. 이러한 상호작용은 다음과 같은 세 가지의 범주로 나누어진다.&lt;/p&gt;
&lt;h3 id=&#34;동일-출처-정책에-대한-처리&#34;&gt;동일 출처 정책에 대한 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112746418-a39c1800-8fe9-11eb-8c98-afc0d95db147.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 웹 사이트 &lt;code&gt;http://sitea.com&lt;/code&gt;에서 자바스크립트를 로딩 한 다음에 이 스크립트에서, &lt;code&gt;http://api.my.com&lt;/code&gt;을 호출한다면 동일 출처 정책에 의해서 호출한다면 호출 에러가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 해결하는 방법으로는 인프라 측면에서 프록시를 사용하는 방법이나 &lt;code&gt;JSONP&lt;/code&gt;와 &lt;code&gt;CORS(Cross Origin Resource Sharing)&lt;/code&gt;이라는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;프록시를-이용하는-방법&#34;&gt;프록시를 이용하는 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프록시를 이용하는 경우에는 간단하게 해결된다. 동일 출처 정책의 문제는 &lt;code&gt;API&lt;/code&gt; 서버와 자바 스크립트가 호스팅 되는 서버의 URL이 달라서 문제가 발생하게 된다. 이를 앞단에 &lt;code&gt;Reverse Proxy&lt;/code&gt;를 넣어서 전체 URL이 같게 만들어주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 구조가 되면, 자바 스크립트가 로딩된 사이트도 &lt;code&gt;mysite.com&lt;/code&gt;이 되고 자바스크립트에서 호출하고자 하는 &lt;code&gt;API&lt;/code&gt; URL도 &lt;code&gt;mysite.com&lt;/code&gt;이 되기 때문에 동일 출처 정책에 위배되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 간단하지만, 자사의 웹 사이트를 서비스하느 경우에만 가능하다. 그래서 자사의 서비스용 &lt;code&gt;API&lt;/code&gt;를 만드는 경우에는 괜찮지만, 파트나사나 일반 개발자에게 자바스크립트용 &lt;code&gt;REST API&lt;/code&gt;를 공개하는 경우에는 적절하지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;특정-사이트에-대한-접근-허용-방식&#34;&gt;특정 사이트에 대한 접근 허용 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CROS 방식 중 이 방식은 가장 간단한 방식으로, &lt;code&gt;API&lt;/code&gt; 서버의 설정에서 모든 소스에서 들어오는 &lt;code&gt;API&lt;/code&gt; 호출을 허용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 &lt;code&gt;HTTP&lt;/code&gt;로 &lt;code&gt;API&lt;/code&gt;를 호출하였을 때 HTTP에 요청에 응답을 주면서 HTTP 헤더에 &lt;code&gt;Request Origin&lt;/code&gt;(요청을 처리해 줄 수 있는 출처)를 명시하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;api.my.com&lt;/code&gt;에서 응답 헤더에 다음과 같이 명시해주면 &lt;code&gt;sitea.com&lt;/code&gt;에 의해서 로딩된 자바스크립트 클라이언트 요청에 대해서만 &lt;code&gt;api.my.com&lt;/code&gt;이 요청해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Access-Controll-Allow-Origin: sitea.com
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;만약에 다음과 같이 &lt;code&gt;*&lt;/code&gt;로 해주면 &lt;code&gt;Request Origin&lt;/code&gt;에 관계없이 사이트에서 로딩된 자바스크립트 요청에 대해서 처리해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;pre-flight를-이용한-세세한-cors-통제&#34;&gt;Pre-flight를 이용한 세세한 CORS 통제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt; 리소스(URL)당 섬세한 &lt;code&gt;CORS&lt;/code&gt; 통제가 필요한 경우에는 &lt;code&gt;Pre-Flight&lt;/code&gt; 호출이라는 것을 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 &lt;code&gt;REST&lt;/code&gt; 리소스를 호출하기 전에, 웹 브라우저가 &lt;code&gt;HTTP OPTIONS&lt;/code&gt; 요청을 보내면 해당 &lt;code&gt;REST&lt;/code&gt; 리소스에 대해서 가능한 &lt;code&gt;CORS&lt;/code&gt; 정보를 보내준다. (접근이 허용된 사이트, 접근이 허용된 메서드 등)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저에서는 &lt;code&gt;XMLHttpRequest&lt;/code&gt;를 특정 &lt;code&gt;URL&lt;/code&gt;로 요청하기 전에, &lt;code&gt;HTTP OPTIONS&lt;/code&gt;를 호출한다. 그러면 서버는 해당 &lt;code&gt;URL&lt;/code&gt;에 접근할 수 있는 &lt;code&gt;Origin URL&lt;/code&gt;과 &lt;code&gt;HTTP&lt;/code&gt; 메서드를 반환해준다. 이를 &lt;code&gt;Pre-flight&lt;/code&gt; 호출이라고 하는데, 이 정보를 바탕으로 해당 &lt;code&gt;URL&lt;/code&gt;에 &lt;code&gt;XMLHttpRequest&lt;/code&gt;를 보낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로는 교차 오리진 쓰기가 허용된다, 예를 들어 링크, 리디렉션 및 &lt;code&gt;form&lt;/code&gt; 제출이 있다. 일부 HTTP 요청에서는 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests&#34;&gt;preflight&lt;/a&gt; 가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112240206-402d8580-8c8b-11eb-9c2c-849a644bfdd7.png&#34; alt=&#34;preflight_correct&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;preflight&lt;/code&gt; 요청이란 일반적인 요청과 다르게, 먼저 &lt;code&gt;OPTIONS&lt;/code&gt; 메서드를 사용하여 HTTP 요청을 다른 출처(&lt;code&gt;Origin&lt;/code&gt;) 리소스로 전송하여 실제 요청이 안전한지 확인하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;교차 사이트 요청은 사용자 데이터에 영향을 미칠 수 있으므로 &lt;code&gt;preflight&lt;/code&gt;을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버는 이 &lt;code&gt;URL&lt;/code&gt;에 대한 접근 권한을 반환한다, &lt;code&gt;CORS&lt;/code&gt; 접근이 가능한 &lt;code&gt;Origin&lt;/code&gt; 사이트를 반환하고 사용할 수 있는 메서드를 반환한다. 그리고 &lt;code&gt;Pre-flight&lt;/code&gt; 호출은, &lt;code&gt;Access-Control-Max-Age&lt;/code&gt;에 정의된 &lt;code&gt;86400&lt;/code&gt; 초 동안 유효하다. (한번 &lt;code&gt;Pre-flight&lt;/code&gt; 호출을 하고 나면, 이 시간 동안은 다시 &lt;code&gt;Pre-flight 호출을 할 필요가 없다&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 &lt;code&gt;CORS&lt;/code&gt; 설정은 &lt;code&gt;API&lt;/code&gt; 호출 코드에서 직접 구현할 수 도 있고 로드 밸런서 역할을 하는 &lt;code&gt;HAProxy&lt;/code&gt;나 &lt;code&gt;Nginx&lt;/code&gt; 같은 리버스 프록시 설정을 통해서 간단하게 처리할 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;API&lt;/code&gt; 단에서 구현이 필요하더라도, &lt;code&gt;HTTP&lt;/code&gt; 헤더를 직접 건드리지 않아도 스프링 등의 프레임워크에서 이미 &lt;code&gt;CORS&lt;/code&gt; 구현을 지원하고 있으므로 프레임워크를 통해서 간단하게 구현하는 것을 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;&gt;MDN - SOP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 23 Mar 2021 21:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 정리했던 블로그 글을 정해서, 남이 궁금해서 물어볼 때, 설명을 할 수 있는지 알아보기 위해, 녹화를 해보았다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 보안이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;분명히 알고 있다고 생각한 것인데도 불구하고 정리가 되지 않아 버벅거리고 힘들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;블로그에 기술적인 내용을 정리하고, 스스로 제대로 이해하고 있는지 문제를 만들어서 직접 풀어보도록 해야겠다. 그리고, 이를 스스로 녹화해보면서 다른 사람이 내 설명을 어떻게 들었는지 테스트 해본다면 좋을 것이다.&lt;/li&gt;
&lt;li&gt;저자는 보안에서, 정찰이 매우 중요한 주제임을 깨달았다고 한다. 이유는 첫 째, 공격의 우선순위를 알아야하기 때문이다. 방어가 잘된 시스템은 어떤 유형의 공격을 받더라도, 로그를 남길 것이기 때문이다. 이는 같은 공격이 두 번 다시는 통하지 않기 때문이다.&lt;/li&gt;
&lt;li&gt;과거의 해커들은 서버, 네트워크, 브라우저를 공격하는데 집중했지만, 보안성이 높아져서 요즘에는 애플리케이션 코드의 취약점을 침투하는데 집중한다.&lt;/li&gt;
&lt;li&gt;새로운 기술에는 고유한 공격면과 취약점이 있다.&lt;/li&gt;
&lt;li&gt;이는 새로운 기술을 도입하는 일이 단순히 러닝 커브 및 기술 적합성을 고려하는 것 뿐만 아니라 보안 이슈도 고려해야한다는 것을 깨닫게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;설명을 잘하기 위해서는 자주 시도해보고, 피드백을 받는 것이 중요하다. 따라서 자주 설명하는 연습을 하자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;글로 정리하고 끝내는 것이 아니라, 내가 제대로 알고 있는지 동료에게 제대로 설명할 수 있는지를 테스트하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP 및 네트워크 계층 및 RFC 791 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft.html</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft.html</guid>
      <description>&lt;h3 id=&#34;네트워크-통신&#34;&gt;네트워크 통신&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112009913-2ba59c00-8b6a-11eb-96f4-c8e28e12bb05.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 통신은 관점에 따라 &lt;code&gt;OSI 7&lt;/code&gt; 모델과 &lt;code&gt;TCP/IP&lt;/code&gt; 모델 두가지로 설명할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OSI 7&lt;/code&gt; 모델은 1984년에 &lt;code&gt;ISO&lt;/code&gt; (국제 표준화 기술)에 의해 표준화되었고, 통신이 이루어지는 과정을 단계별로, 파악할 수 있도록 7 개의 계층인 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구분되어 있으며 네트워크 구현을 연구하고 배우기에 적합한 구조다.&lt;/li&gt;
&lt;li&gt;반면에, &lt;code&gt;TCP/IP&lt;/code&gt; 모델은 현장에 많이 사용하는 기술 위주로 4계층으로 단순화한 모델로, 실제 사용하는 프로토콜 규약은 이 모델을 따르고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네트워크-계층&#34;&gt;네트워크 계층&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;네트워크 계층은 데이터를 전송할 수 있는 여러 경로 중 가장 안전하고 빠른 경로를 찾아주는 역할을 하는 라우팅을 수행하며, 데이터를 다른 네트워크로 전달하여 인터넷을 가능하게 만들어주는 계층이다.&lt;/p&gt;
&lt;h4 id=&#34;ip-프로토콜&#34;&gt;IP 프로토콜&lt;/h4&gt;
&lt;p&gt;네트워크 계층에서 운영되는 IP 프로토콜에는 목적지 위치를 알려주는 고유한 32비트의 주소 값이 있으며, 이를 IP 주소라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112010844-036a6d00-8b6b-11eb-984e-082bf51904f7.jpg&#34; alt=&#34;addressing-design-network-host-1024x576&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP 주소는 네트워크 부분과 호스트로 구분되는데, 위의 그림과 같이 지역을 대표하는 부분을 네트워크, 지역별 사용자 PC에 할당하는 것을 호스트라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;rfc-791&#34;&gt;RFC 791&lt;/h4&gt;
&lt;p&gt;더 자세히 알아보고 싶은 마음에 RFC 791 문서를 살펴보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112071041-5e738280-8bb2-11eb-80a8-472ff7e6aef9.png&#34; alt=&#34;Screen Shot 2021-03-23 at 8 32 38 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 문서는 개요 및 동기 그리고, 범위, 인터페이스에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 패킷을 교환을 통해 상호 연결된 시스템에서 사용하도록 설계 되었다.&lt;/li&gt;
&lt;li&gt;이러한 시스템을 &lt;code&gt;catenet&lt;/code&gt; 이라고 부른다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 데이터그램(&lt;code&gt;datagram&lt;/code&gt;)이라는 데이터 블록들을 소스에서부터 목적지까지 전송한다.&lt;/li&gt;
&lt;li&gt;여기서 말하는 소스 및 목적지는 고정된 길이의 주소로 식별되는 호스트다.&lt;/li&gt;
&lt;li&gt;또한 인터넷 프로토콜은 작은 패킷을 다루는 네트워크를 위해 긴 데이터그램을 조각화하여 나누거나 및 작게 나누어진 데이터그램을 재조립을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;범위&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 특별히 범위를 한정하여 다음과 같은 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;상호 연결된 네트워크 시스템을 통해서 소스에서 목적지까지 비트 패키지(데이터그램)을 전달하는데 필요한 기능이다.&lt;/li&gt;
&lt;li&gt;호스트 간의 프로토콜에서 일반적으로 볼 수 있는 엔드 투 엔드 데이터 신뢰성, 흐름 제어, 시퀀싱, 그리고 기타 서비스를 강화하는 메커니즘은 없다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 지원 네트워크의 서비스를 활용하여 다양한 서비스 유형과 품질을 제공할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;인터페이스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 프로토콜은 네트워크 환경에서 호스트 대 호스트 프로토콜에 의해서 호출된다.&lt;/li&gt;
&lt;li&gt;이 프로토콜은 인터넷 데이터그램을 다음 게이트웨이 또는 대상 호스트로 이동하기 위해 로컬 네트워크 프로토콜을 호출한다.&lt;/li&gt;
&lt;li&gt;예를 들어, TCP 모듈이 네트워크 모듈을 호출하여, TCP 세그먼트(TCP 헤더 및 사용자 정보를 포함)를 사용한다.&lt;/li&gt;
&lt;li&gt;TCP 세그먼트는 데이터 그램의 일부이다.&lt;/li&gt;
&lt;li&gt;TCP 모듈은 인터넷 헤더의 주소와 기타 매개변수를 인수로 네트워크 모듈에게 제공한다.&lt;/li&gt;
&lt;li&gt;그러면 네트워크 모듈은 데이터 그램을 만들고 데이터그램을 전송하기 위해서 로컬 네트워크 인터페이스를 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc791&#34;&gt;RFC 791&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>최근에 애플리케이션 보안에 관심을 가지게 된 이유</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0.html</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0.html</guid>
      <description>&lt;p&gt;최근에 내가 웹 애플리케이션 보안에 대해서 굉장히 무관심함을 알게 됨과 동시에 데이터베이트 연결이 끊어지는 네트워크 통신과 관련된 장애가 있었다.&lt;/p&gt;
&lt;p&gt;장애의 이유를 알지 못하니까 굉장히 답답함과 동시에 문제를 해결할 수 없었다. 따라서 디버깅을 하듯이 네트워크 패킷을 분석해서 원인을 알아 낼 수 있으면 굉장히 좋을 것 같다는 생각을 함과 동시에 내가 주도하면서 진행하는 토이 프로젝트가 보안에 대해서 굉장히 견고한 애플리케이션이 되었으면 하는 마음이 있다.
따라서, 앞으로 웹 애플리케이션 보안에 대해서 공부하고 견고한 시스템을 구축해나갈 생각이다.&lt;/p&gt;
&lt;p&gt;책에서는 다루는 대부분의 내용이 네트워크 공격을 패킷 단위로 분석하고 있다. 실제로도 공격 대응을 위한 분석 단계에서 패킷을 분석하는 빈도가 상당히 높다고 한다. 나는 보안 전문가보다는 웹 애플리케이션 개발자에 가깝기 때문에 실무적으로 패킷을 분석해서 보안 위협을 감지하는 일은 없을 확률이 높지만, 네트워크에 대해서 내부 원리까지 깊게 이해하는 것이 목표이므로, 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;p&gt;첫 장에서는 인터넷 통신의 표준 프로토콜인 &lt;code&gt;TCP/IP&lt;/code&gt;의 계층별 헤더의 구조에 대해서 패킷 단위로 소개하고 있고, 주로 네트워크 공격에 사용되는 네트워크 계층의 &lt;code&gt;IP&lt;/code&gt; 프로토콜과 전송 계층의 &lt;code&gt;TCP&lt;/code&gt;, &lt;code&gt;UDP&lt;/code&gt; 프로토콜의 구조에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;책에서는 한 번에 모든 개념을 숙지하기 보다는, 필요할 때, 찾아보며 각 헤더의 구조를 조금씩 명확히 새기는 것을 권장하고 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 22 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아커스 이슈 구현을 하는데, 전체적인 흐름 및 구현 위치는 파악을 하였으나, 자료구조를 정확히 파악하지 못해서, 어디서부터 손대야할지 감이오지 않고, 깊은 이해를 하기 힘들었다.&lt;/li&gt;
&lt;li&gt;대학교 동기들과 토이프로젝트를 시작했다.&lt;/li&gt;
&lt;li&gt;회사에서 일하면서 소프트웨어 스펙을 정하고 어떤 것을 만들지 구체화 하는 과정이 중요하다는 것을 깨달았기 때문에, 지루하기는 하지만 작성하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 주관해서 이끌어 가는 일이 힘들것이라고 예상했지만 생각보다 많은 공수가 들었다.&lt;/li&gt;
&lt;li&gt;그래도 처음이 가장 힘들것이라고 생각하고 프로세스가 정립되면 쉬워질 것이다.&lt;/li&gt;
&lt;li&gt;흐름을 대략적으로 파악하고나서, 흐름을 관통하는 자료구조를 파악할 필요를 느끼게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 이끌어 가는 과정은 힘들지만 재미있기도 하다.&lt;/li&gt;
&lt;li&gt;프로젝트를 구현하고 있는, 자료구조를 제대로 파악하지 못하면 이해를 할 수 없고, 더 이상 나아갈 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 이끌어 가는 만큼 내가 솔선 수범을 보이고, 모든 일을 다 하려고 하지말고 어떻게 일을 하는지 방식을 공유하고 일을 나누자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;혼자서 할 수 있는 일은 한정적이다. 같이 일을 할 수 있는 방식을 공유하고 일을 나누자.&lt;/li&gt;
&lt;li&gt;개략적인 모듈의 인터페이스 시작점 및 흐름을 파악했다면 그 흐름을 관통하고 있는 자료구조에 대해서 공부를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 21 Mar 2021 17:15:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩을 하면서, 사소한 실수가 발견되었고 재배포를 해야하는 상황이 되었다.&lt;/li&gt;
&lt;li&gt;내가 아는 것을 다른사람에게 설명하는데 생각보다 말이 잘 나오지 않았고, 더듬더듬 말하고 있었다.&lt;/li&gt;
&lt;li&gt;오랜만에 코딩 테스트 문제를 풀어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들에게 미안하기도 했고, 시간이 많이 소모되었다.&lt;/li&gt;
&lt;li&gt;다른 사람에게 쉽게 설명할 수 없으면 제대로 아는 것이 아니라는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;남들이 꺼려하는 일을 먼저 나서서 하려고 하는 자세가 동료들에게 신뢰를 줄 수 있을 것같다.&lt;/li&gt;
&lt;li&gt;문제의 난이도가 생각보다 높지 않아서 그런지는 몰라도 매우 재미있었다.&lt;/li&gt;
&lt;li&gt;취업 준비를 할 때, 코딩 테스트 문제를 푸는 것과 직장에 다니는 입장에서 코딩 테스트 문제를 푸는 느낌이 달랐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 사소한 실수가 다른 사람들의 시간을 많이 소모시키는 것을 알 수 있었다.
꼼꼼하게 확인하여 다른 사람들에게 피해를 끼치는 일이 없도록 하자.&lt;/li&gt;
&lt;li&gt;어떤 개념을 제대로 배웠는지 확인하려면 내가 배운 내용을 다른 사람에게 설명을 해보자.&lt;/li&gt;
&lt;li&gt;배우는 속도에 집착하기 보다는 하나라도, 제대로 알고 있는지, 남에게 설명할 수 있는지를 확인하자.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션을 구성하는 부분을 전체적으로 공부해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;보안에 대해서는 나의 일이 아니고, 보안 전문가의 일이라고 생각했던 경향이 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;앞으로 토이프로젝트를 할 때는 기능도 신경을 많이 쓰지만 보안에 대한 점도 많은 공부를 하고 신경을 쎠서 공부를 해야할 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 설계에 대한 부분을 소흘히 한 것 같다. 어떻게 하면 좋은 &lt;code&gt;API&lt;/code&gt;를 설계할 수 있을지에 대해서 공부를 하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;하나라도 제대로 공부하는 것이 중요하기는 하지만, 서버 및 브라우저의 내부 원리에 대해서 깊게 공부할 필요를 느끼게 되었다. 사실 &lt;code&gt;DevOps&lt;/code&gt; 팀에서 인프라 관리를 하기는 하지만, 이러한 부분도 잘 알아야지 좋은 개발자가 될 것 같다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 풀면서 코드부터 구현하는 것보다 내가 어떻게 구현할지를 미리 생각하고 나서 코드를 작성하니까 훨씬 재미있고 문제도 잘 풀리는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 했던 일을 다른 동료들에게 공유하려고 노력하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꼼곰히 코딩하는 습관을 들이자.&lt;/li&gt;
&lt;li&gt;말을 잘 할 수 있도록 평소에 발표를 연습해야겠다.&lt;/li&gt;
&lt;li&gt;어떤 일을 하다보니 생활 리듬이 깨지는 경우가 있는데 이를 주의해야겠다.&lt;/li&gt;
&lt;li&gt;하루에 조금씩이라도 운동하는 습관을 들이거나 주말에 어떤 스포츠 배워야겠다는 생각을 했다. 장기적으로 보았을 때 스트레스 관리를 잘 하는 것이 멀리 갈 수 있는 방법일 것이다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 풀 때 다양한 예외 사항 및 제약 조건을 미리 생각해야하는데 다양한 예외 케이스에 대한 고려를 더 잘하려고 노력해야할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 커밋하기 전에, 오타는 없는지 꼼꼼히 확인하자.&lt;/li&gt;
&lt;li&gt;다른 사람들 앞에서 내가 알고 있는 내용을 설명하자.&lt;/li&gt;
&lt;li&gt;보안도 애플리케이션의 한 요소라고 생각하고 열심히 공부하자.&lt;/li&gt;
&lt;li&gt;토이프로젝트를 잘 진행하고 계속 유지보수를 하면서 발전시켜나가자.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 20 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오랜만에 코딩 테스트 문제를 풀어봤다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;직장을 구하기 전에는 코딩 테스트가 그저 스트레스였는데, 오랜만에 풀어보니까 매우 재미있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;재귀를 활용해서 푸는 문제가 있었는데 재귀를 이용하니까 너무 시간이 오래 걸렸다. 따라서 메모이제이션을 공부하고 이를 이용해서 풀 수 있는지 생각을 해봐야할 것 같다.&lt;/li&gt;
&lt;li&gt;추가로 다이나믹 프로그래밍을 이용해서 문제를 푸는 방법 및 &lt;code&gt;DFS&lt;/code&gt; &lt;code&gt;BFS&lt;/code&gt; 문제를 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 평소에 풀어보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제 풀면서 코드를 작성하기 전에 어떻게 풀지, 시간 복잡도 및 공간 복잡도에 대해서 생각을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy 세션(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft.html</link>
      <pubDate>Fri, 19 Mar 2021 16:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft.html</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 19 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 REST DOCS를 이용해서 문서화하는 법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 애플리케이션 보안에 대해서 더 많이 배우기 위해서 다음과 같은 책을 구매했다.&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=263537948&#34;&gt;웹 애플리케이션 보안&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번에 GC 및 JVM에 대해서 더 자세히 알고 싶어서 책을 구매 하였다. &lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝이야기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버와 브라우저에 대해서 앞으로 더 깊게 공부를 해야겠다는 마음을 먹었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 채우기 위해서 더 열심히 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;자바독을 작성할 때는, 문장이 자연스럽게 읽히는 형태로 만들어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111706690-0bce5980-8886-11eb-85c0-9030bdc9cdd7.png&#34; alt=&#34;Screen Shot 2021-03-19 at 7 37 24 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 사진을 보면, &lt;code&gt;Returns&lt;/code&gt; 항목에 중복되어서 &lt;code&gt;Returns&lt;/code&gt; 라는 문장으로 시작하는데 이는 별로 좋지 않다.&lt;/li&gt;
&lt;li&gt;블로그에, 코드를 첨부할 때, GIST를 이용하면 더 좋을 것 같다. &lt;a href=&#34;https://gohugo.io/content-management/shortcodes/&#34;&gt;GIST&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서화에 대해서 더 많은 생각을 해봐야 할 것 같다.&lt;/li&gt;
&lt;li&gt;내가 세운 목표를 달성하기 위해서 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 가치있게 사용하기 위해서 노력하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 18 Mar 2021 22:11:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 회사에서 배포를 기다리고 문제가 생겼을 때, 대응하기 위해서 대기하는 시간이 많았고, 이때 평소에 궁금했던 것과 현재 프로젝트에 적용하면 좋을 기술들을 찾아보고 정리하였다.&lt;/li&gt;
&lt;li&gt;같은 솔루션을 진행하는 선배에게 프로젝트에 트랜잭션 처리를 위해서 조사를 하고 있다고 솔직하게 말하고 공부를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션에 대해서 공부하게 되었는데, &lt;code&gt;SQLAlchemy&lt;/code&gt; 에서 트랙잭션을 사용하느 법과 세션마다 고립 레벨을 설정하는 법에 대해서 배우게 되었다.&lt;/li&gt;
&lt;li&gt;하지만, 현재 프로젝트에 어떻게 적용하면 좋을지 조금 막막했다. 따라서 데이터베이스를 잘 아는 선배들에게 물어봐야겠다.&lt;/li&gt;
&lt;li&gt;솔직하게 말하니까, 나도 몰래 딴짓하는 기분도 안들고 선배가 이해해줘서 고마웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션을 어떻게 설계해야할지에 대해서 고민을 할 필요가 있을 것 같다.&lt;/li&gt;
&lt;li&gt;분산 트랜잭션 처리에 대해서도 조금 알게 되었는데, &lt;code&gt;2PC&lt;/code&gt;, &lt;code&gt;SAGA&lt;/code&gt; 패턴등 재미있는 기술들이 많이 있었다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서 고립 수준에 따라서 발생하는 이상 현상들 (&lt;code&gt;Dirty Read&lt;/code&gt;, &lt;code&gt;Non Repetable Read&lt;/code&gt;, &lt;code&gt;Phantom Read&lt;/code&gt;)에 대해서 알게 되었고, 데이터베이스의 고립 수준 유형에 대해서 알게 되었다. (&lt;code&gt;Read Uncommited&lt;/code&gt;, &lt;code&gt;Read Commited&lt;/code&gt;, &lt;code&gt;Repetable Read&lt;/code&gt;, &lt;code&gt;Serializable&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;아직 데이터베이스에 대해서 모르는 것이 많은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들이 꺼려하는 일을 먼저 나서서 하려고 노력할 필요가 있을 것 같다.&lt;/li&gt;
&lt;li&gt;최근에 생활 리듬이 깨진 것 같다 빨리 정상화 시키도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들이 꺼려하는 일을 시키지 않아도 나서서 하여, 동료들에게 신뢰를 얻고 같이 일하고 싶은 개발자가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy에서 트랜잭션 사용법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95.html</link>
      <pubDate>Thu, 18 Mar 2021 13:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95.html</guid>
      <description>&lt;p&gt;회사에서 이슈 진행을 하다가, 트랜잭션를 이용하여 처리해야하는 부분을 발견하였다.
따라서 &lt;code&gt;SQLAlchemy&lt;/code&gt;에서는 트랜잭션을 어떻게 사용하는지 정리해보도록 하겟다.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션-관리하기&#34;&gt;트랜잭션 관리하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111575492-ce1ff100-87f1-11eb-9999-bef313b83749.png&#34; alt=&#34;Screen Shot 2021-03-18 at 1 56 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새롭게 생성된 세션은 &lt;code&gt;begin()&lt;/code&gt; 상태이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin()&lt;/code&gt; 상태에서 &lt;code&gt;Session&lt;/code&gt;은 아직 어떠한  &lt;code&gt;Connection&lt;/code&gt; 및  &lt;code&gt;Transactional&lt;/code&gt;과 연관되지 않았다.&lt;/li&gt;
&lt;li&gt;그러한 다음에, &lt;code&gt;Session&lt;/code&gt; 은 데이터베이스 커넥션 요청을 수신한다.&lt;/li&gt;
&lt;li&gt;일반적으로, 이것은 &lt;code&gt;Engine&lt;/code&gt;을 이용하여, 특정 &lt;code&gt;SQL&lt;/code&gt; 문을 수행해야하는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;특정 &lt;code&gt;SQL&lt;/code&gt;문의 수행은 &lt;code&gt;Session.query()&lt;/code&gt;, &lt;code&gt;Session.execute()&lt;/code&gt; 통해 이루어지고  &lt;code&gt;Session.commit()&lt;/code&gt;, &lt;code&gt;Session.flush()&lt;/code&gt;를 할 때 보류된 변경 사항을 비우고 커밋하면서 발생합니다.&lt;/li&gt;
&lt;li&gt;이러한 요청이 수신되면, 새로운 엔진 각각이 세션에서 유지되고 관리하는 트랜잭션 상태와 연결이 된다.&lt;/li&gt;
&lt;li&gt;첫 번째, 엔진이 작동하면 세션은 &lt;code&gt;begin&lt;/code&gt; 상태를 떠나서, &lt;code&gt;transactional&lt;/code&gt; 상태로 전환되었다고 할 수 있다.&lt;/li&gt;
&lt;li&gt;각각의 엔진에 대해서 연결이 되어 있으며, 이러한 연결은 &lt;code&gt;Engine.contextual_connect()&lt;/code&gt; 메서드를 통해서 획득된다.&lt;/li&gt;
&lt;li&gt;롤백 또는 커밋 후에 트랜잭션 상태가 완료되면 모든 트랜잭션 및 연결 리소스를 해제하고, &lt;code&gt;begin&lt;/code&gt; 상태로 돌아간다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin&lt;/code&gt; 상태로 돌아가면, 다시 새로운 &lt;code&gt;SQL&lt;/code&gt; 문을 내보내는 새 요청이 수신될 때 새로운 &lt;code&gt;Connection&lt;/code&gt; 및 &lt;code&gt;Transaction&lt;/code&gt; 객체를 다시 호출합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 위의 라이프 사이클을 보여주는 예제이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;engine = create_engine(&amp;quot;...&amp;quot;)
Session = sessionmaker(bind=engine)

# 새로운 세션, 어떤 커넥션도 사용중이지 않다.
session = Session()
try:
    # 첫 번째 쿼리를 수행하면, 커넥션을 엔진으로 부터 획득하고
    # 트랜잭션이 시작된다.    
    item1 = session.query(Item).get(1)

    # 두 번째 쿼리이다. 같은 커넥션과 트랜젝션이 사용된다.
    item2 = session.query(Item).get(2)

    # 아직 반영되지 않은 변경 사항이 생성된다.
    item1.foo = &#39;bar&#39;
    item2.bar = &#39;foo&#39;
    
    # 커밋을 수행한다.
    # 아직 반영되지 않은 변경사항이 모두 `flush` 된다.
    # 트랜잭션이 커밋되고, 연결 객체가 닫치고 사라진다.
    # DBAPI 연결이 커넥션 풀로 반환된다.
    session.commit()
except:
    # 롤백시에도, 커미과 동일한 상태 종료가 진행된다.
    session.rollback()
    raise
finally:
    # 세션을 닫는다, 이렇게 하면 남아 있는 모든 객체가 영구적으로 삭제되며, 기존 SessionTransaction 상태가 재설정 된다.
    # 일반적으로 이러한 단계는 필수는 아니지만,
    # commit() 또는 rollback() 자체에 예기치 않은 내부 오류가
    # 발생한 경우 close()는 유효하지 않은 상태가 제거되도록 한다.
    session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;savepoint-사용하기&#34;&gt;SAVEPOINT 사용하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;기본 엔진에서 지원하는 경우, &lt;code&gt;SAVEPOINT&lt;/code&gt; 트랜잭션은 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Session = sessionmaker()
session = Session()
session.add(u1)
session.add(u2)

session.begin_nested() # establish a savepoint
session.add(u3)
session.rollback()  # rolls back u3, keeps u1 and u2

session.commit() # commits u1 and u2
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt;는 여러 번 호출 될 수 있으며, 각 호출에 대해서 고유한 식별자가 있는 새로운 SAVEPOINT를 발행합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각의 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 호출에 대해서, &lt;code&gt;Session.rollback()&lt;/code&gt;또는, &lt;code&gt;Session.commit()&lt;/code&gt;을 수행 해야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 반환 값이 컨텍스트 매니저에 의해서 사용되는 경우 예를 들어서 &lt;code&gt;with&lt;/code&gt; 문에서 &lt;code&gt;rollback&lt;/code&gt; 및 &lt;code&gt;commit&lt;/code&gt;은 컨텍스트를 종료할 때, 컨텍스트 관리자가 실행하므로 명시적으로 추가해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드는 &lt;code&gt;Session.begin()&lt;/code&gt;을 덜 사용하기 위해서 사용하며 컨텍스트 매니저로 작동하는 &lt;code&gt;SessionTransaction&lt;/code&gt;을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 레코드를 삽입할 때, 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for record in records:
    try:
        with session.begin_nested():
            session.merge(record)
    except:
        print(&amp;quot;Skipped record %s&amp;quot; % record)
session.commit()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;트랜잭션-격리-수준-설정--dbapi-autocommit&#34;&gt;트랜잭션 격리 수준 설정 / DBAPI AUTOCOMMIT&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111587615-d08c4600-8805-11eb-8a03-8f3379b7a441.png&#34; alt=&#34;Screen Shot 2021-03-18 at 4 20 02 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 &lt;code&gt;DBAPI&lt;/code&gt;는 설정할 수 있는 트랜잭션 격리 수준의 개념을 지원한다.&lt;/li&gt;
&lt;li&gt;전통적으로 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;, &lt;code&gt;READ COMMITED&lt;/code&gt;, &lt;code&gt;REPEATABLE READ&lt;/code&gt;, 및 &lt;code&gt;SERIALIZABLE&lt;/code&gt;의 네 가지 수준이 있다.&lt;/li&gt;
&lt;li&gt;이는 일반적으로 새로운 트랜잭션을 사용하기 전에, &lt;code&gt;DBAPI&lt;/code&gt; 연결에 적용되며 대부분의 DBAPI는 SQL문이 처음 생성될 때, 트랜잭션을 암시적으로 시작한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;는 &lt;code&gt;create_engine&lt;/code&gt; 수준과, &lt;code&gt;Connection.execution_options()&lt;/code&gt; 수준 모두에서 플래그를 사용하여 엔진 별 또는 연결 별로 설정 가능한 격리 모드를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;세션-메이커-및-엔진-전체에-대한-고립-수준-설정&#34;&gt;세션 메이커 및 엔진 전체에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;전역 적으로 특정 고립 수준으로 &lt;code&gt;Session&lt;/code&gt; 또는 &lt;code&gt;Session Maker&lt;/code&gt;를 설정하려면 첫 번째 기술은 모든 경우에 특정 격리 수준에 대해서 엔진을 설정한 다음에, 세션 메이커의 연결 소스로 사용하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(
    &amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;,
    isolation_level=&#39;REPEATABLE READ&#39;
)

Session = sessionmaker(eng)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서로 다른 격리 수준을 가진 두 개의 엔진이 있는 경우 유용한 다른 옵션은 &lt;code&gt;Engine.execution_options()&lt;/code&gt; 메서드를 사용하는 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(&amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;)

autocommit_engine = eng.execution_options(isolation_level=&amp;quot;AUTOCOMMIT&amp;quot;)

transactional_session = sessionmaker(eng)
autocommit_session = sessionmaker(autocommit_engine)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 &lt;code&gt;eng&lt;/code&gt;과 &lt;code&gt;autocommit_engine&lt;/code&gt;은 동일한 연결 풀을 공유합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AUTOCOMMIT&lt;/code&gt; 모드는 &lt;code&gt;autocommit_engine&lt;/code&gt;에서 연결할 때 따로 설정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;각각의-세션에-대한-고립-수준-설정&#34;&gt;각각의 세션에 대한, 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;생성자를 직접 사용하거나, 세션 메이커가 생성한 호출 가능한 객체를 호출 할 때, &lt;code&gt;bind&lt;/code&gt; 인자로 바로 전달 할 수 있다.
예를 들어, &lt;code&gt;transactional_session&lt;/code&gt;에서 세션을 만들고, &lt;code&gt;autocommit_engine&lt;/code&gt;을 전달할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session = transactional_session(bind=autocommit_engine)
# work with session
session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;각각의-트랜잭션에-대한-고립-수준-설정&#34;&gt;각각의 트랜잭션에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;격리 수준과 관련된 주요한 주의 사항은 트랜잭션이 이미 시작된 연결에서 설정을 안전하게 수정할 수 없다는 것이다.&lt;/p&gt;
&lt;p&gt;데이터베이스는 진행중인 트랜잭션의 격리 수준을 변경할 수 없으며 일부 &lt;code&gt;DBAPI&lt;/code&gt; 및 &lt;code&gt;SQLALchemy&lt;/code&gt; 언어에서는 이러한 영역에서 일관적이지 않은 동작이 있다.&lt;/p&gt;
&lt;p&gt;따라서 원하는 격리 수준을 가진 엔진 앞쪽에 바인딩 된 세션을 사용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;그러나 연결 단위의 격리 수준은 트랜잭션이 시작될 때 &lt;code&gt;Session.commection()&lt;/code&gt; 메서드를 사용하여 영향 받을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy.orm import Session

sess = Session(bind=engine)
with sess.begin():
    sess.connection(execution_options={&#39;isolation_level&#39;: &#39;SERIALIZABLE&#39;})

# commits transaction.  the connection is released
# and reverted to its previous isolation level.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위에서 먼저, 생성자 또는 세션 메이커를 사용하여 세션을 생성한다. 그런 다음에 트랜잭션이 시작되기 전에 연결에 전달되는 실행 옵션을 제공하는 &lt;code&gt;Session.connection()&lt;/code&gt;을 호출하여 트랜잭션 시작을 명시적으로 설정한다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 17 Mar 2021 22:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자투리 시간이 굉장히 많았음에도 불구하고, 시간을 가치있게 사용하지 못했다.&lt;/li&gt;
&lt;li&gt;신규 개발을 거의 하지 않고, 유지보수만 하였더니 &lt;code&gt;API&lt;/code&gt; 설계에 대한 감이 완전히 죽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;평소에는 시간이 없다고 불평하였는데, 예상하지 못하게 시간이 비어있을 경우에는 내가 시간을 제대로 활용하지 못했다.&lt;/li&gt;
&lt;li&gt;업무상 많이 다루지 않는 기술을 조금 놔버렸던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예상하지 못하게 자투리 시간을 활용할 수 있도록 항상 고민을 해야겠다.&lt;/li&gt;
&lt;li&gt;업무상 많이 다루지 않는 기술이라고 하더라도, 중요하게 여기고 평상시에 토이프로젝트를 많이 만들면서 시행착오를 거쳐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 애플리케이션을 다루는 기술의 깊이를 전체적으로 끌어올려야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;를 만들 때, 보안에 대해서 별로 중요하게 생각하지 않았던 것 같다. 하지만 현대 애플리케이션에서 보안은 굉장히 중요하고, 토이프로젝트를 하면서 &lt;code&gt;API&lt;/code&gt;
를 설계해보고 어떻게 하면 좋은 &lt;code&gt;API&lt;/code&gt;를 만들 수 있을까에 대한 고민을 꾸준하게 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 가치 있게 사용하려고 노력하고, 평소에 자투리 시간이 생기면 어떤 일을 해야할지에 대해서 미리 계획할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 16 Mar 2021 12:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 내가 정말 아는 것이 없구나라는 것을 깨닫게 되었다.&lt;/li&gt;
&lt;li&gt;내가 아는 것도 없고 설명도 잘 못한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 통해서, 개인의 역량에 모든 것을 맡기지 않는 방법도 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어렴풋이 들어봤던 것 같은데, 설명하려고 애를 쓰니까 굉장히 힘들었다.&lt;/li&gt;
&lt;li&gt;내가 어떤 것을 안다고 생각하는 기준이 다른 사람에 비해서 터무니 없이 낮고, 얕았다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 한다고 해서, 대충짜도 된다고 생각하지 말고, 다른 사람에게 내가 작성한 의도와 왜 이렇게 작성했냐고 물어보았을 때 항상 대답할 수 있게 알고 작성하자.&lt;/li&gt;
&lt;li&gt;자신감을 가지고 싶다면, 내 자신에게 떳떳해야 한다.&lt;/li&gt;
&lt;li&gt;말을 잘하는 방법에 대해서 고민을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;잘 모를때는 모른다는 것을 인정하고, 배우는 자세를 가지자.&lt;/li&gt;
&lt;li&gt;기본으로 돌아가서, 다시 처음부터 배운다는 생각으로 공부를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람에게 어떤 개념을 설명하려는 연습을 하자.&lt;/li&gt;
&lt;li&gt;어떤 것을 배우고 나서, 내가 이것을 정말로 설명할 수 있는지 녹화를 하자.&lt;/li&gt;
&lt;li&gt;어떤 것을 배우고 나면 무조건 말로 이것을 설명을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;글로만 정리하는 것이 아닌 정말로 어떠한 개념을 이해하고 이를 말로 설명할 수 있도록 노력하자.&lt;/li&gt;
&lt;li&gt;배우는 속도에 집착하지 말고, 하나라도 제대로 아는 것에 집중을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 15 Mar 2021 07:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Javadoc&lt;/code&gt;을 영어로 작성할 때에는, 3인칭 단수로 작성한다.&lt;/li&gt;
&lt;li&gt;자바독을 많이 읽어보면서 어떻게 작성했는지 알아보는 것이 좋다.&lt;/li&gt;
&lt;li&gt;코딩을 하면서, 부주의한 실수를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 보면 별것 아니라고 생각을 할지 모르겠지만, 다른 사람들의 시간을 많이 낭비하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 사소한 실수로 인해서, 다른 사람들의 시간을 낭비시키지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 작성하고 나서, 실수를 한 것이 없는지 꼼꼼히 살펴보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 커밋하기 전에, 오타는 없는지 꼼꼼히 확인하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 14 Mar 2021 20:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h1 id=&#34;커뮤니케이션-및-협업-능력&#34;&gt;커뮤니케이션 및 협업 능력&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;업무를 할 때, 상황 설명 및 커뮤니케이션을 조리있게 하지 못하고 이로 인해서 협업에 여려움을 느끼고 있었다. 어떻게 하면 내가 말을 좀 더 조리있게 잘하고 다른 사람들이 이해할 수 있을까라는 고민을 하던 중에, 다음과 같은 프레임워크를 알게 되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Situation,_task,_action,_result&#34;&gt;Situation, task, action, result&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;쉽게 말하면서 어떤 상황 및 이야기를 할 때, 다음과 같은 순서에 따라서 말을 하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;ituation: 어떠한 상황에서&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt;ask: 어떤 업무(Task) 하거나 또는 목표(target)를 달성해야 했는지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;ction: 그래서 본인이 왜, 무엇을, 어떻게 했으며&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;esult: 결과는 어땠는지, 그 결과로 얻은 성과는? 또는 실패했다면 그로부터 배운것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111066661-7d637c00-8503-11eb-88f3-1cc486a963e6.png&#34; alt=&#34;STAR&#34;&gt;&lt;/p&gt;
&lt;p&gt;원래는 면접관이 직무에 필요한 특정 능력에 대한 모든 관련 정보를 수집하기 위한 방법이지만, 내가 했던 작업 및 상황 설명을 할 때, 이에 맞춰서 말을 하다보면 보다 상대방이 내가 무슨 이야기를 하는지 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;p&gt;이제부터 작성하는 회고부터 &lt;strong&gt;STAR&lt;/strong&gt; 프레임워크에 맞춰 글을 작성하려는 노력을 해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111066795-31fd9d80-8504-11eb-9d50-b64839651a6f.jpg&#34; alt=&#34;8997383833_2&#34;&gt;&lt;/p&gt;
&lt;p&gt;그리고 추가적으로 대화법에 대한 책을 읽으면서 나의 대화법에 잘못된 부분이 없는지 살펴보고 개선하도록 해야겠다. 아침마다 조금씩 읽으면서 대화법을 조금씩 개선해나갈 생각이다.&lt;/p&gt;
&lt;h1 id=&#34;코딩하기-전에-미리-설계하기&#34;&gt;코딩하기 전에 미리 설계하기&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;어떤 일을 처리할 때, 코드 레벨에서부터 분석하는 자세가 잘못된 것 같다. 우선 어떤 방향으로 가야할지, 동료들과 토의를 한 다음에, 그리고 현재 작업하는 프로젝트를 가장 잘 아는 사람에게 검토를 받는것이 일을 하는데 들이는 시간을 많이 줄여준다는 것을 알게 되었다.
처음에 잘못된 설계를 한 것을 발견하여 여태까지 코딩한 작업들이 모두 물거품이 되었는데 이러한 일을 최소화 하려면 잦은 토의와 어떠한 방향이 더 나은 방향인지를 끊임없이 고민하는 것이 정답인 것 같다.&lt;/p&gt;
&lt;h1 id=&#34;실수를-인정하기&#34;&gt;실수를 인정하기&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;내가 나의 실수를 인정하지 못하고 다른 사람이 잘했던 일을 쉽게 칭찬하지 못하는 단점을 발견했다. 내가 무슨 잘못이나 실수를 했을 때, 피하고만 싶어하는 이유를 좀 더 살펴보고 어떤 말을 하기 전에 생각을 좀 더 오래 한다음에 말을 하도록 하는 연습을 해야겠다.
이번주에 같은 기능을 개발하는 것이지만, 나는 변경 사항이 많고 수정할 부분이 많게 코딩을 하였지만 같은 동료는 변경사항을 최소한으로 하고 기존에 동작하던 부분을 최대한 건드리지 않고 코딩을 하는 방식으로 하였다. 이러한 부분은 칭찬을 할 만 하고 내가 여태까지 작업했던 시간보다 훨씬 적은 시간으로 기능이 완성되었을 뿐 만 아니라 사이드 이펙트에 대한 부분도 고려하지 않아도 될 것이다.
또한 코딩을 할 때, 코드만 볼 것이 아니라 전체적인 상황, 문맥을 고려하여 개발하는 자세를 가져야겠다.
내가 개선할 점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실수를 했을 때, 숨기고 싶어하는 경향이 있다. 이러한 점을 고쳐야겠다.&lt;/li&gt;
&lt;li&gt;코드레벨부터 보려고 하지 말고 먼저 왜 이러한 기능이 필요한지에 대한 상황을 파악하고, 그 다음에 전체적인 기능, 그리고 어떻게 구현하면 좋을지 생각을 하고 그 다음에 코드레벨에서 어떻게 구현할지 생각을 해야겠다.&lt;/li&gt;
&lt;li&gt;기존의 소스코드를 의심하기 전에, &lt;code&gt;URS&lt;/code&gt; 문서를 보면서 스펙에 이러한 기능이 존재하는지 먼저 파악을 하자.&lt;/li&gt;
&lt;li&gt;업무를 하는데, 도메인 지식이 사실 코딩 지식보다 중요할 수 있다는 사실을 깨달았다. 따라서 도메인 부터 제대로 파악하기 위해서 노력하자. 짜투리 시간이 날때마다 도메인 지식을 익히기 위해서 노력하고 이를 구글 &lt;code&gt;KEEP&lt;/code&gt;을 이용해서 키워드 별로 정리를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;중요한-결정은-최대한-나중에&#34;&gt;중요한 결정은 최대한 나중에&amp;hellip;&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111067099-db915e80-8505-11eb-8a57-abb936bd0edd.png&#34; alt=&#34;110481786-479d4c80-812b-11eb-9297-6c700c1b528c&#34;&gt;&lt;/p&gt;
&lt;p&gt;잘못된 설계를 하지 않는 방법에 대한 고민을 하였고 트레이너 분들에게 질문을 하였을 때, 기계인간 님은 처음부터 다시 만들 생각을 하고 만든다고 하셨다.&lt;/p&gt;
&lt;p&gt;또한 중요한 결정을 최대한 나중으로 미룰 수 있는 것이 좋다고 하셨다. 왜냐하면 중요한 결정을 성급하게 내리고 나중에 실수를 했다는 것을 깨달아 버리면 그때는 다시 만들어야하기 때문이다.&lt;/p&gt;
&lt;h1 id=&#34;코드숨&#34;&gt;코드숨&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;이번주에는 업무적으로 바쁘기도 했고, 컨디션도 별로 안좋았는데, 회사에서 안좋은일까지 겹쳤다. 따라서 과제를 수행하기 어려웠는데, 컨디션을 위해서 한 주만 쉬자라는 마음으로 자기합리화를 했다. 사실 다음주가 마감일이라서 가장 바쁘기는 하겠지만 그래도 최대한 짜투리 시간을 활용해서라도 과제를 마무리 할 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 13 Mar 2021 23:40:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 회사에서 일한 모습을 곰곰히 생각을 해보았다.&lt;/li&gt;
&lt;li&gt;운동을 배우면 좋다는 이야기를 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;업무중에 사소한 거짓말을 하거나 오해의 소지를 가질 수 있는 말을 하는 것 같다.&lt;/li&gt;
&lt;li&gt;도메인 지식을 완전히 이해하지 못하다보니까, 업무를 할당 받아도 목적을 잘 이해하지 못하는 것 같다.&lt;/li&gt;
&lt;li&gt;나도 요즘에 체력이 많이 줄어든 것 같은데 운동을 배워야겠다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사소한 것이라도 동료들에게 명확하게 말하며, 순간의 실수를 만회하려고 거짓말을 해서는 안된다.&lt;/li&gt;
&lt;li&gt;솔루션의 도메인 적인 지식을 배우고 기록할 필요가 있다. 예를 들어서 &lt;code&gt;Due Date&lt;/code&gt;, &lt;code&gt;Due Days&lt;/code&gt;를 잘 모르고 있었는데 평상시에 관심을 가지고 업무를 익히려고 노력해야겠다.&lt;/li&gt;
&lt;li&gt;운동을 배우면서 스트레스 및 체력 관리를 하는 것이 길게 보았을 때 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 내가 하려고 했던 일을 명확히 하려고 노력하고, 도중에 뭔가 잘못 생각하거나 착각한게 있으면 바로 솔직하게 말하고 정정하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들과 같이 할 수 있는 운동을 알아봐야겠다.&lt;/li&gt;
&lt;li&gt;운동을 하면서, 일과 취미를 같이 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>객체지향 5원칙 (SOLID)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid.html</link>
      <pubDate>Sat, 13 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid.html</guid>
      <description>&lt;p&gt;회사에서 객체지향 및 SOLID 원칙에 대해서 설명하는 세미나를 진행하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dongwooklee96/java-chap02-assignment&#34;&gt;사내 세미나 과제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;객체지향-5원칙-solid-원칙&#34;&gt;객체지향 5원칙 (SOLID) 원칙&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;srp-single-responsiblity-principle---단일-책임-원칙&#34;&gt;SRP (Single Responsiblity Principle) - 단일 책임 원칙&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 클래스는 하나의 책임만 가져야 한다.&lt;/li&gt;
&lt;li&gt;어떤 변화 (요구 사항등의 변화)에 의해서 클래스를 변경해야하는 이유는 오직 하나여야 한다.&lt;/li&gt;
&lt;li&gt;나머지 4원칙의 기초가 되는 원칙으로 SRP만 잘 지키면 다른 책임의 변경으로 인한 연쇄 작용을 방지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ocp-open-closed-principle---개방-폐쇄-원칙&#34;&gt;OCP (Open-Closed Principle) - 개방, 폐쇄 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫쳐있어야 한다.
&lt;ul&gt;
&lt;li&gt;변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 극대화 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다.&lt;/li&gt;
&lt;li&gt;새로운 기능이 추가되는 경우, 기존에 제공하던 클래스 (또는 메서드)를 수정하는 것이 아니라 새로운 클래스 (또는 메서드)를 추가해서 기능을 확장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lsp-the-liskov-subsitution-principle---리스코프-치환-원칙&#34;&gt;LSP (The Liskov Subsitution Principle) - 리스코프 치환 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다.
&lt;ul&gt;
&lt;li&gt;슈퍼 클래스가 들어갈 자리에 서브 클래스를 넣어도, 원래대로 잘 작동해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;상속의 오용을 방지하게 하는 원칙&lt;/li&gt;
&lt;li&gt;슈퍼 클래스와 서브 클래스의 동작이 일관성 있게 동작해야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;isp-interface-segregation-principle---인터페이스-분리-원칙&#34;&gt;ISP (Interface Segregation Principle) - 인터페이스 분리 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;한 클래스는 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조함.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UserService&lt;/code&gt;, &lt;code&gt;BoardService&lt;/code&gt; (X)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UserCreateService&lt;/code&gt;, &lt;code&gt;BoardCreateService&lt;/code&gt; (O)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dip-dependency-inversion-principle---의존성-역전의-원칙&#34;&gt;DIP (Dependency Inversion Principle) - 의존성 역전의 원칙&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;변화하기 쉬운 것, 자주 변화하는 것 보다 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고차원 모듈은 주로 변화하지 않음, 저 차원 모듈에 주로 자주 변화함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구체적인 구현 클래스 보다 추상화된 인터페이스에 의존하라, 구체적이며 변동성이 크다면 절대로 이름을 언급하지 마라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>사내 세미나 과제 피드백 CH10 - Future, ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture.html</link>
      <pubDate>Sat, 13 Mar 2021 11:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture.html</guid>
      <description>&lt;p&gt;회사에서 자바 비동기 처리 및 &lt;code&gt;Future&lt;/code&gt;, &lt;code&gt;CompletableFuture&lt;/code&gt;에 대해서 세미나를 진행하였다.&lt;/p&gt;
&lt;p&gt;과제를 진행하면서, 비동기 프로그래밍 및 자바에서 비동기 프로그래밍을 어떻게 사용하는지 생각해 볼 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dongwooklee96/java-chap10-assignment&#34;&gt;사내 세미나 과제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111016625-5a957280-83f2-11eb-847c-b5e8deaf3ac7.png&#34; alt=&#34;Screen Shot 2021-03-13 at 11 50 40 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;친절하게 피드백을 해주셨기 때문에, 내가 &lt;code&gt;ComputableFuture&lt;/code&gt;를 잘못사용하고 있다는 사실을 알게 되었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java8&#34; data-lang=&#34;java8&#34;&gt;repository.retrieveCategories().parallelStream()
                .map(category -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category)))
                .collect(Collectors.toList())
        .parallelStream()
        .map(CompletableFuture::join)     // (1)
        .flatMap(Collection::parallelStream)
        .collect(Collectors.toList())
        .parallelStream()
        .map(book -&amp;gt; CompletableFuture.runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
        .collect(Collectors.toList())
        .forEach(CompletableFuture::join); // (2)
        executors.shutdown();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 코드는 내가 처음에 제출한 코드이다. 문제점을 보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드에서 &lt;code&gt;join&lt;/code&gt;을 사용한 곳이 2개정도 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt;은 현재 &lt;code&gt;Thread&lt;/code&gt;를 블록킹 하여 결과를 기다리는 연산이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;ComputableFuture&lt;/code&gt;는 이러한 &lt;code&gt;join&lt;/code&gt; 없이 &lt;code&gt;CompletionStage&lt;/code&gt;라는 약속을 기반으로 &lt;code&gt;Non blocking&lt;/code&gt; 기반의 비동기 처리를 할 수 있게 도와준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 나는 이러한 특징을 이해하지 못하고, &lt;code&gt;join&lt;/code&gt;을 남발하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 스트림의 중간 연산 단계에서 &lt;code&gt;join&lt;/code&gt;을 호출하면, 게으른 연산을 하는 특성으로 인해서 순차적인 &lt;code&gt;blocking&lt;/code&gt;이 걸릴 수 있다. 따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stream&lt;/code&gt;으로 변환할 때, &lt;code&gt;parallelStream&lt;/code&gt;은 조심해서 사용을 해야한다. &lt;code&gt;parallelStream&lt;/code&gt; 작업을 멀티코어에서 병렬처리 하는 것은 일반적으로 데이터가 많을 때 유리하다. 데이터가 적으면 오히려 분할하는데 시간이 더 걸린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이러한 최적화는 여러번 수행해보면서 반드시 측정을 기반으로 선택이 되어야한다. 그러한 경우가 아니라면 &lt;code&gt;stream&lt;/code&gt;도 충분하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;꼭 필요한 곳이 아니라면, &lt;code&gt;join&lt;/code&gt; 연산은 최종적으로 &amp;ldquo;동기&amp;quot;가 필요한 곳에서 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 피드백을 받은 부분을 개선한 결과는 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final List&amp;lt;CompletableFuture&amp;lt;List&amp;lt;Book&amp;gt;&amp;gt;&amp;gt; futures
            = repository.retrieveCategories().stream()
            .map(category -&amp;gt; supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category), executors))
            .collect(toList());

        final List&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; updateFutures
            = futures.stream()
            .map(future -&amp;gt; future.thenCompose(books -&amp;gt; allOf(
                books.stream()
                    .map(book -&amp;gt; runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
                    .toArray(CompletableFuture[]::new)
            )))
            .collect(toList());
        updateFutures.forEach(CompletableFuture::join);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ComputableFuture&lt;/code&gt;로 작업을 처리한 후에, 최종적으로 한꺼번에  &lt;code&gt;join&lt;/code&gt; 을 해주고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 12 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현상보다는 원인을 분석할 수 있어야 할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 성급하게 기존 소스코드에  문제가 있다고 생각  했는데, 사실 그게 아니였고  &lt;code&gt;URS&lt;/code&gt; 스펙 문서를 보면서, 도메인 로직을 모르고 있어서 발생한 문제인 것을 알게 되었다. 도메인 지식을 무시하지 말고, 코딩 실력보다 사실 업무를 하는데 있어서는 도메인 로직이 중요하다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;도메인 로직을 코드 상에서 드러낼 수 있도록 하는 것이 중요함과 동시에, 그렇지 못하다면 직접 검증하는 자세가 필요하다.&lt;/li&gt;
&lt;li&gt;개인의 성장도 물론 중요하지만, 그보다는 팀의 성장이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;나를 이해하주는 팀원들에게 고마웠다, 내가 보답할 수 있는 방법은 밝은 모습을 보여주는 것과 열정 있는 모습을 보여주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;때로는 무언가를 바꾸고 싶으면 그만큼의 희생이 따른 다는 것을 느끼게 되었다. 나를 조금은 내려 놓을 필요를 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 부터, 동료를 위해서 배우는 사람이 되도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 11 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 다른 사람의 소스 코드를 내 마음대로 수정했다가, 조심해달라는 이야기를 들었다.&lt;/li&gt;
&lt;li&gt;기존의 소스 코드가 잘못되어 있더라도, 최소한의 영향을 주는 방향으로 코딩하는 것이 좋을 수도 있다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상대방의 입장에서는 기분이 나쁠 수도 있는데, 화내지 않고 말해줘서 고마웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다른 사람의 소스코드를 고칠 때는, 의견을 물어보고 고치도록하고, 어떠한 부탁을 할 때는 최대한 감정을 들어내지 않고 말하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상황에 따라 다르지만, 때로는 최소한의 영향을 주는 소스 코드를 만들도록 노력해야겠다. 현재는 테스트 코드를 도입하기 힘들지만, 만약 기존의 구조를 바꾼다면 책임을 질 수 있게 그만한 테스트 코드가 있어야 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 코드만 보지 말고 전체적인 상황, 문맥, 그림을 보도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에서 말을 안하다 보니까 말을 잘 못해지는 것 같다. 따라서 다른 사람들과 말을 많이 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항상 코드를 작성하기 전에, 문제가 무엇인지 내가 어떻게 문제를 해결할지 생각을 하고 나서 코딩을 진행하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 다른 사람에게 싫은 소리를 할 때는, 최대한 감정을 배제하고 말하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>스프링 시큐리티 아키텍처 (미완성)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1.html</link>
      <pubDate>Thu, 11 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1.html</guid>
      <description>&lt;h2 id=&#34;인증authentication과-인과authorization&#34;&gt;인증(Authentication)과 인과(Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110706470-3f343700-823b-11eb-83e4-103013be399a.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 26 53 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어플리케이션 보안은 두가지의 독립적인 문제로 나뉜다.&lt;/li&gt;
&lt;li&gt;바로 인증(&lt;code&gt;authentication&lt;/code&gt;)과 인가(&lt;code&gt;authorization&lt;/code&gt;)이다.&lt;/li&gt;
&lt;li&gt;인증은 (&lt;code&gt;who are you?&lt;/code&gt;) 이고, 인가는 (&lt;code&gt;what are you allowed to do?&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링 시큐리티는 인증과 인과를 분리하도록 설계된 아키텍처를 가지고 있으며, 두 가지 모두에 대한 전략과 확장 할 수 있는 포인트가 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인증-authentication&#34;&gt;인증 (Authentication)&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인증을 위한, &lt;code&gt;AuthenticationManager&lt;/code&gt; 라는 인터페이스를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;authenticate&lt;/code&gt; 라는 메서드를 제공하는데, 다음과 같은 3가지 일을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;입력이 유효한 주체를 나타내는지 확인할 수 있는 경우, &lt;code&gt;Authentication(authentication=true)&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력이 잘못된 주체를 나타내는 것으로 판단되는 경우에는, 예외를 던집니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약, 결정할 수 없는 경우에는, &lt;code&gt;null&lt;/code&gt;을 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationException&lt;/code&gt; 예외는 런타임 예외이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 응용 프로그램의 스타일이나 목적에 따라 응용 프로그램에서 일반적인 방식으로 처리됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프로그래머가 이러한 예외를 처리하지 않습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110708504-1f524280-823e-11eb-86b2-b33bbe5d09d4.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 48 00 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Authentication Manager&lt;/code&gt;의 가장 일반적으로 사용되는 구현은 &lt;code&gt;ProviderManager&lt;/code&gt;로, &lt;code&gt;AuthenticationProvider&lt;/code&gt; 인스턴스 체인을 지정합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationProvider&lt;/code&gt;는 &lt;code&gt;AuthenticationManager&lt;/code&gt;와 비슷하지만, 함수를 호출하는 사람에게, &lt;code&gt;Authentication&lt;/code&gt; 타입을 질의할 수 있는 메서드를 추가적으로 지원합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProviderManager&lt;/code&gt;는 선택적인 부모 요소를 가질 수 있으며, 모든 &lt;code&gt;ProviderManager&lt;/code&gt;가 &lt;code&gt;null&lt;/code&gt;을 반환하는 경우에 이를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상위의 &lt;code&gt;ProviderManager&lt;/code&gt;를 사용할 수 없는 경우에, &lt;code&gt;AuthenticationException&lt;/code&gt; 예외가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경우에 따라서, 애플리케이션은 접근 권한을 그룹으로 만들어야할 때가 있는데, 그룹 별 권한을 &lt;code&gt;AuthenticationManager&lt;/code&gt;에 위임한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;때때로, 각가의 &lt;code&gt;ProviderManager&lt;/code&gt;는, 상위 요소를 공유한다. 상위 요소는 글로벌 리소스의 일종으로 모든 프로바이더의 예외나 상황을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;authenticationmanager-커스터마이징&#34;&gt;AuthenticationManager 커스터마이징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 시큐리티는 응용 프로그램에 설정된 인증과 관련된 관리자 기능을 빠르게 구성할 수 있도록 몇가지 기능을 제공합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 사용되는 헬퍼는 &lt;code&gt;AuthenticationManagerBuilder&lt;/code&gt;를 사용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

   ... // web stuff here

  @Autowired
  public void initialize(AuthenticationManagerBuilder builder, DataSource dataSource) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser(&amp;quot;dave&amp;quot;)
      .password(&amp;quot;secret&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;@Bean&lt;/code&gt; 메서드로 &lt;code&gt;@Autowired&lt;/code&gt;되므로, &lt;code&gt;AuthenticationManager&lt;/code&gt;를 빌드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인가-authorization&#34;&gt;인가 (Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/guides/topicals/spring-security-architecture&#34;&gt;스프링 시큐리티 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CSRF 란 무엇일까?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</link>
      <pubDate>Wed, 10 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html</guid>
      <description>&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110636756-fc00a680-81ef-11eb-8940-ee638da62fc2.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 28 45 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF(Cross-Site Request Forgery)&lt;/code&gt;는 신뢰할 수 있는 사용자를 가장하여 웹 사이트에 원치않는 명령을 보내는 공격입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, 다른 곳으로 이동하기 위해 사용하는 링크 뒤에 있는 &lt;code&gt;URL&lt;/code&gt;에 악의적인 매겨변수를 포함시킴으로써 다음을 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;https://www.example.com/index.php?action=delete&amp;amp;id=123&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 도메인에 수정 권한이 있는 사용자의 경우 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소가, 사용자 모르게 동작을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심지어, 요소가 &lt;code&gt;https://www.example.com&lt;/code&gt;에 없는 경우에도 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF&lt;/code&gt;를 방지하는 방법은 &lt;code&gt;RestfulAPI&lt;/code&gt; 구현 및 시큐어 토큰을 추가하는 등 많은 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;위키-백과&#34;&gt;위키 백과&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;설명이 조금 부족해서 위키백과를 찾아보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110638080-77168c80-81f1-11eb-90a1-af13554352bb.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 39 18 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사이트 간 요청 위조, 원 클릭 공격 또는 세션 라이딩이라고 한다.&lt;/li&gt;
&lt;li&gt;웹 응용프로그램이 신뢰하는 사용자로서 무단 명령을 제출하는 웹 사이트의 악의적인 공격 유형이다.&lt;/li&gt;
&lt;li&gt;악의적인 웹 사이트가 이러한 명령을 전송할 수 있는 방법은 여러가지가 있다. 예를들어, 특수하게 조작된 이미지 태그, 숨겨진 양식 및 &lt;code&gt;JavaScript XMLHttpRequest&lt;/code&gt;는 사용자의 동작에 따라서 작동되기도 하지만 전혀 알아차리지 못하게 이루어지기도 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XSS(Cross-site-scripting)&lt;/code&gt;과의 차이점은 &lt;code&gt;XSS&lt;/code&gt;는 특정 사이트에 대해서 사용자가 가지는 신뢰정보를 이용하는데 반해서, &lt;code&gt;CSRF&lt;/code&gt;는 사용자의 브라우저에 있는 신뢰 정보를 이용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110639854-8a2a5c00-81f3-11eb-9cbb-06198496bc29.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 54 10 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF&lt;/code&gt; 공격에서 공격자의 목표는 무고한 피해자가 악의적으로 조작된 웹 공격을 대상자가 액세스 권한을 가진 웹 사이트에 몰래 제출하도록 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자의 웹 브라우저에 저장된 쿠키에 의해 인증된 사용자는 자신도 모르게 사용자를 신뢰하는 사이트로 &lt;code&gt;HTTP&lt;/code&gt; 요청을 전송하여 원치 않는 작업을 발생시킬 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저는 특정 도메인에서 사용하는 쿠키를 해당 도메인으로 보내는 웹 요청에 보이지 않게 포함시킵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 속성 때문에, 웹 사이트에 로그인 할 때, 생성된 쿠키를 이용해 공격합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 브라우저를 통해서 실수로 요청을 제출한 경우 자동으로 포함된 이 쿠키로 인해서 위조된 요청이 웹 서버에 실제로 나타나며 데이터 반환, 세션 상태 조작, 피해자 계정 변경 등 적절하게 요청된 모든 작업을 수행한다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저는 특정 도메인에서 사용하는 쿠키를 해당 도메인으로 보내는 웹 요청에 보이지 않게 포함시킵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 속성 때문에, 웹 사이트에 로그인 할 때, 생성된 쿠키를 이용해 공격합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 브라우저를 통해서 실수로 요청을 제출한 경우 자동으로 포함된 이 쿠키로 인해서 위조된 요청이 웹 서버에 실제로 나타나며 데이터 반환, 세션 상태 조작, 피해자 계정 변경 등 적절하게 요청된 모든 작업을 수행 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예방법&#34;&gt;예방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110640493-379d6f80-81f4-11eb-83f4-b25ba743308a.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 59 01 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;대부분의 &lt;code&gt;CSRF&lt;/code&gt; 방지 기술은, 웹 응용 프로그램이 허가되지 않은 요청을 탐지할 수 있도록 요청해 추가 인증 데이터를 포함시킴으로서 작동한다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&#34;&gt;MDN - CSRF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-site_request_forgery&#34;&gt;위키백과 - CSRF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스프링의 세 가지 특징</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95.html</link>
      <pubDate>Wed, 10 Mar 2021 08:00:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95.html</guid>
      <description>&lt;h1 id=&#34;스프링의-세-가지-특징&#34;&gt;스프링의 세 가지 특징&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;회사에서 하는 세미나에서, 자바 세미나가 끝나고 이어서 스프링 세미나를 시작하였다.&lt;/p&gt;
&lt;p&gt;세미나를 진행하면서, 강조했던 스프링의 세 가지 특징에 대해서 설명한 부분을 정리해보겠다.&lt;/p&gt;
&lt;h2 id=&#34;1-ioc--di-dl&#34;&gt;1. IoC / DI, DL&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;스프링 프레임워크는 DL (Dependency Look-up)과 DI(Dependency Injection)를 통해서 IoC (Inversion of Control)을 구현합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 진행하면서, 많은 라이브러리를 사용할 것이다.&lt;/li&gt;
&lt;li&gt;특정 라이브러리에서 원하는 기능을 사용하려면 &lt;code&gt;new&lt;/code&gt; 를 통해서 객체를 생성해야하는데, 이 객체를 생성하기 위해서는 다른 객체를 생성해야하는 등 복잡한 의존 관계가 발생하고 사용자는 파악하기 힘들다.&lt;/li&gt;
&lt;li&gt;따라서 스프링 프레임워크는 이러한 객체에 대한 생성과 객체간의 의존관계에 대한 관리를 개발자가 스프링에게 위임하게 된다.&lt;/li&gt;
&lt;li&gt;개발자는 스프링이 요구하는 대로 설정만 하면, 설정에 따라서 &lt;code&gt;Bean&lt;/code&gt;을 생성하여 컨테이너에 담고 &lt;code&gt;Bean&lt;/code&gt;간의 의존관계를 파악(&lt;code&gt;Dependency Look-up&lt;/code&gt;)하여 주입 (&lt;code&gt;Dependency Injection&lt;/code&gt;)해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;POJO (Plain Java Object)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링에서 생성되어 관리되는 POJO 기반의 객체를 우리는 &lt;code&gt;Spring Bean&lt;/code&gt;이라고 한다.&lt;/li&gt;
&lt;li&gt;여기서 &lt;code&gt;POJO&lt;/code&gt;는 단순 &lt;code&gt;getter/setter&lt;/code&gt;만으로 구성되어 있으며 단순히 &lt;code&gt;new&lt;/code&gt;를 통해서 생성 가능한 형태를 말한다.&lt;/li&gt;
&lt;li&gt;핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있으며 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-aop-aspect-oriented-programming&#34;&gt;2. AOP (Aspect Oriented Programming)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110551571-16e40400-8179-11eb-87cd-901053f4404b.png&#34; alt=&#34;image2021-3-8_18-35-52&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AOP는 관점지향 프로그래밍을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 프로젝트는 고유한 핵심 기능 외에 트랜잭션, 보안처리(인증, 인가), 로깅 등의 공통 기능을 반드시 포함할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;별다른 정책이 없다면, 우리는 매번 프로젝트에서 똑같은 로직을 계속해서 개발할 것이고 버그가 발생하면 여기저기서 수정 작업을 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOP는 어플리케이션의 기능을 핵심 기능과 공통 기능을 각각 종단 관심사와 횡단 관심사로 분리하고 공통 기능을 적절히 끼워넣을 수 있게 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;psa-portable-service-abstraction&#34;&gt;PSA (Portable Service Abstraction)&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;환경의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있는 환경을 제공하려는 추상화 구조를 말한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스프링은 언어가 아닌 기술(구현체의 기술)에 얽메이는 것에 큰 반감을 가짐 (&lt;code&gt;EJB&lt;/code&gt;, &lt;code&gt;Servlet&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링에서 동작할 수 있는 라이브러리들은 &lt;code&gt;POJO&lt;/code&gt; 형태로 되어 있음&lt;/li&gt;
&lt;li&gt;대표적인 추상화의 예
&lt;ul&gt;
&lt;li&gt;JPA의 구현체(&lt;code&gt;Hibernate&lt;/code&gt;, &lt;code&gt;Eclipse Link&lt;/code&gt;)를 추상화하는 &lt;code&gt;Spring Data JPA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mybatis&lt;/code&gt;를 추상화하는 &lt;code&gt;Spring-mybatis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spring Transaction Manager&lt;/code&gt;, &lt;code&gt;Spring Cache Manager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;서비스가 구동되는 환경(&lt;code&gt;Web MVC&lt;/code&gt;, &lt;code&gt;Web Flux&lt;/code&gt;)에 대해서도 추상화를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;버전에 따라서 라이브러리 혹은 프레임워크의 내부 API의 설계나 인터페이스가 달라지더라도, &lt;code&gt;Sping&lt;/code&gt;에서 적절히 감싸 추상화를 하기 때문에 우리의 소스코드는 변경될 일이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 10 Mar 2021 07:07:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 강의를 들었다.&lt;/li&gt;
&lt;li&gt;회사에서 조금 동료와 트러블이 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;강의를 들으면서, 내가 바꿀 부분에 주석으로 표시하고 진행을 하는 것을 보고 나도 배워야겠다는 생각을 했다. 왜냐하면, 내가 어떤 것을 하고 있는지 까먹을 때가 많이 때문이다.&lt;/li&gt;
&lt;li&gt;설명도 들어보지 않고, 감정부터 앞세워서 굉장히 당황스럽고 나도 화가 났다.&lt;/li&gt;
&lt;li&gt;이럴 때는 어떻게 대응 해야하는지 모르겠다. 그냥 좋은게 좋은거라고 넘어가야할까? 아니면 같이 화를 내는것이 맞을까?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능 개선이나, 유지보수를 할 때, 주석으로 변경되어야하는 범위를 먼저 체크하고 나서 실제 기능 개발을 시작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 내가 코드 레벨부터 보는 안좋은 습관이 있는데, 주석으로 전체적인 변경 범위 및 파악을 하면 나의 안좋은 습관을 고칠 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드레벨부터 바로 구현하려고 하지말고, 내가 수정해야할 범위 및 내가 해야할 일들을 미리 주석에 작성해두는 것도 방법이다.&lt;/li&gt;
&lt;li&gt;오늘 일을 하는데, 구현을 완료하고 이제 리펙터링을 해야지라고 마음을 먹고 있었는데, 조금 하기가 귀찮아서 미룰려고 했다. 내가 이러한 생각을 하게 된 이유를 생각해보니, 기능이 구현되는 것을 일이 끝났다고 생각 해서 그런 것 같다. 따라서 작업의 단위가 테스트까지는 힘들더라도, 최소한 리펙터링까지는 모두 마쳐야 일이 끝날 것이라고 생각하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 코드를 작성하기 전에, 문제가 무엇인지 내가 어떻게 문제를 해결할지 생각을 하고 나서 코딩을 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 09 Mar 2021 15:22:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사에서 동료가 나에게 한 말  조금 화가났다.&lt;/li&gt;
&lt;li&gt;코드숨 시큐리티 강의를 들었다.&lt;/li&gt;
&lt;li&gt;회사 세미나에서 스프링에 대한 주제로 세미나를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그 순간에는 뭐라고 한 소리 할까라고 생각을 했지만, 집에와서 다시 생각해보니까 안하길 잘한 것 같다.&lt;/li&gt;
&lt;li&gt;그리고 퇴근 하기전에 오해가 풀려서 다행이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 되고 싶은 개발자는 같이 일하고 싶은 개발자라는 것을 명심해야겠다.&lt;/li&gt;
&lt;li&gt;감정에 휩쓸리지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110481786-479d4c80-812b-11eb-9297-6c700c1b528c.png&#34; alt=&#34;Screen Shot 2021-03-09 at 10 47 13 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중요한 결정을 나중으로 미룰 수 있는 것이 바로 실력이다.&lt;/li&gt;
&lt;li&gt;중요한 결정을 너무 빨리 내려서 중요한 부분을 먼저 만들어버리면, 망했구나&amp;hellip; 라고 고민을 하기 시작할 것이다.&lt;/li&gt;
&lt;li&gt;아예 처음부터 다시 만들 생각을 하고, 만드는 습관이 들면 중요한 결정을 나중에 내리는 연습도 할 수 있다.&lt;/li&gt;
&lt;li&gt;그렇게 하다보면, 내가 지금 하고 있는 작업을 다시 만드려면 얼마나 힘들까라는것이 예측이 되고, 그런 결정을 나중에 내릴 수 있도록 인터페이스 같은 것으로 추상화를 해둔다.&lt;/li&gt;
&lt;li&gt;이런 식으로 한번 결정하면 다시 바꾸기 어려운 것들을 추상화를 해두거나, 아예 안만들거나 하는 식으로 미뤄가면서 개발을 한다.&lt;/li&gt;
&lt;li&gt;이건 어려운 것이고, 이런식으로 계속 미루는 스킬이 대단하다면 개발 실력이 엄청난 것이라 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의사소통 능력 및 소통을 잘 할 수 있도록 더 노력을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;말이 조금 느리더라도, 또박또박 논리적으로 말하자. 횡설수설하지 말자.&lt;/li&gt;
&lt;li&gt;중요한 부분을 나중에 결정할 수 있게 미루는 방법에 대해서 고민을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>mariadb 유니크 인덱스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4.html</link>
      <pubDate>Tue, 09 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4.html</guid>
      <description>&lt;h2 id=&#34;유니크-인덱스&#34;&gt;유니크 인덱스&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110399859-ed17d800-80b9-11eb-933e-d71a182abcb7.png&#34; alt=&#34;unique&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유니크 키는 유일해야하지만, 널을 허용할 수 있다.&lt;/li&gt;
&lt;li&gt;테이블을 생성한 후 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 또는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 명령을 사용하여, 고유 키를 추가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE Employees ADD UNIQUE `EmpCode`(`Employee_Code`);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;CREATE UNIQUE INDEX HomePhone ON Employees(Home_Phone);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/getting-started-with-indexes/#unique-index&#34;&gt;mariadb-unique-index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 08 Mar 2021 15:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 구현하다가 설계가 잘못되었다는 사실을 발견하고, 이를 고치기 위해서 다시 설계를 하고 여태까지 작업한 내용을 거의 다 버리게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 새로운 테이블 설계를 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 오늘 생각하고 배운 것들을 코드숨에서 의견을 나누어 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다시 설계를 할 때, 뭔가 시간을 많이 사용하지 못하는 것 같다. 어색하기도 하고 막상 동료랑 같이 이야기를 하다보니까 뽀죡한 수가 떠오르지 않았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동료들과 해결책을 생각할 때, 그냥 말로만 하고 흘러가니까 나중에 남는 것이 없었다. 따라서, 이야기만 할 것이 아니라 말했던 내용들을 글로 남기고 이를 기록하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 할 때, 동료와 신뢰를 쌓는 것이 굉장히 중요하다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일도 훨씬 잘되고, 내가 진행 한 것을 공유하는 것이 편했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새로운 테이블을 설계할 때, 이름을 짓는 것이 굉장히 어려웠다. 따라서 일단 이 테이블을 만들게 된 이유 및 이 테이블의 역할이 무엇인지를 생각했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론적으로는 문제가 무엇인지 명확하게 이해하지 못해서 발생한 것들이 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버스에서 그냥 시간을 보내는게 아까웠는데, 코딩 테스트 문제의 해결책을 생각하면서 가는 것이 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;설계를 꼼꼼히 검증하고, 유연한 설계를 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;동료들에게 신뢰를 쌓으려면, 내가 노력해야한다.&lt;/li&gt;
&lt;li&gt;변수명, 함수명, 클래스 명을 짓을 때 어려운 이유는 역할과 필요한 목적을 잘 정의하지 못했기 때문이다. 따라서 어떤 클래스, 메서드의 역할에 대해서 정의를 해보고 이름을 짓는 방법을 사용하는 것이 어떨까 하고 생각을 해보았다.&lt;/li&gt;
&lt;li&gt;나의 문제는 문제를 제대로 이해하지 못하는 것에서 온다. 어떻게 하면 문제를 더 잘 이해할 수 있을지를 고민하자.&lt;/li&gt;
&lt;li&gt;출 퇴근 시간에 코딩 테스트 문제를 정하고 이를 구글 킵에 메모를 하는 것이다. 그렇게 한 후에 내가 생각한 문제 풀이를 적어두고 구현은 시간이 날 때하는 것이다.&lt;/li&gt;
&lt;li&gt;내가 정말로 어떤 것을 알고 있다면, 그것을 말로 누군가에게 설명할 수 있을 정도가 되어야겠다고 생각했다.&lt;/li&gt;
&lt;li&gt;오늘 주간 보고를 하는데, 내가 한주동안 진행한 일도 제대로 설명하지 못했다. 따라서 주간보고 때 내가 진행한 일들을 논리정연하게 설명할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110323001-4c90cc00-8057-11eb-9cc3-4642f328db50.png&#34; alt=&#34;Screen Shot 2021-03-08 at 9 34 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현실적으로 설계가 완벽하게 되기는 힘들다는 의견이 있었고, 미쳐 생각하지 못하는 부분은 필연적으로 나타나게 된다. 따라서 피드백 주기를 짧게 하고, 공유를 자주하는 문화가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;피드백 주기를 짧게 하고, 공유를 어떻게 하면 잘 할 수 있을지 고민을 해봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 실험을 자주하되, 실험은 비용을 동반하기에 유연한 설계를 통해서 변경이 쉽도록 만드는 것이 최선이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;잦은 공유, 회고를 통한 개선, 코드숨에서 실천하는 것을 팀에서 하나씩 실천해보도록 노력해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제를 막는 것보다 최대한 빨리 문제를 발견해서 적은 비용으로 새로 만드려고 한다. 테스트를 먼저 작성하는 것도 구현 전에 문제점을 찾아내서 수정하려는 노력의 일환이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수정하기 좋은 코드는 작성하지 않은 코드이다. 그리고 변경은 피할 수 없는 숙명이라고 생각하면 좋은 설계 = 쉽게 변경할 수 있는 구조라는 접근이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불확실성이 높고 변화가 빠른 요즘은 적응할 수 있는 능력이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;후회&amp;quot;는 사람마다 조직마다 기준이 다르다. 따라서 &amp;ldquo;우리는 언제 후회할까?&amp;ldquo;를 놓고 함게 논의를 해보면 좋은 방법이 나올 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일하는 방법을 조직 내에서 찾아서 합의를 이루는 게 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불분명한 &lt;code&gt;BEST&lt;/code&gt; 대신에 명확한 &lt;code&gt;Better&lt;/code&gt;을 추구하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한번에 답을 내지 말고 계속 개선하려고 하는 것이 방법이 될 수 있다. (일일신 우일신)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동료들에게 신뢰를 쌓기 위해서는 솔직해지고, 실수를 인정하자.&lt;/li&gt;
&lt;li&gt;동료들에게 신뢰를 쌓기 위해서는 동료에게 관심을 가지고 동료의 일을 남일 처럼 여기지 말고 내일처럼 여기자.&lt;/li&gt;
&lt;li&gt;문제를 명확하게 이해하고 내가 정확히 이해하고 있는지 스스로 검증하는 프로세스가 필요하다.&lt;/li&gt;
&lt;li&gt;코드가 복잡해 질때, 문제를 정의하지 못하는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동료들에게 신뢰를 쌓을 수 있도록 노력하자.&lt;/li&gt;
&lt;li&gt;클래스, 메서드, 변수의 역할에 대해서 글로 정리 해보자. 그렇다면 이름을 명확하게 작성할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;문제를 정확히 이해하고 있는지 스스로에게 물어보고 테스트를 해보자.&lt;/li&gt;
&lt;li&gt;출퇴근 시간에 코딩 테스트를 정하고 해결책을 생각해보자!&lt;/li&gt;
&lt;li&gt;내가 배운 것들을 남에게 말로 설명할 수 있는지 스스로 테스트해보자.&lt;/li&gt;
&lt;li&gt;나는 알고 있다고 스스로 착각하고 있는 일들이 많은 것 같다. 따라서 스스로를 테스트해보자. 또한 어떻게 테스트 할 수 있는지 생각해보자.&lt;/li&gt;
&lt;li&gt;문제 해결의 시작은 명확히 어떤점이 문제인지를 정의하는 것이다. 따라서 코딩을 하면서 부딪치는 문제들을 마주치면 어떤 점이 문제인지를 명확히 정의하고 이를 풀어가려고 노력해보자.&lt;/li&gt;
&lt;li&gt;한번에 좋은 방법을 선택하려고 하지 말고, 계속 개선하려는 마음을 가지고, 유연한 설계를 하려고 노력하는 것이 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8.html</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8.html</guid>
      <description>&lt;h2 id=&#34;mediatypeapplication_json_utf8&#34;&gt;MediaType.APPLICATION_JSON_UTF8&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257472-75767a00-7fe1-11eb-82e2-0f1db1ca3886.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 39 39 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257431-38aa8300-7fe1-11eb-8389-34b865de421b.png&#34; alt=&#34;deprecated&#34;&gt;&lt;/p&gt;
&lt;p&gt;테스트 코드를 작성하다가, &lt;code&gt;MediaType.APPLICATION_JSON_UTF8&lt;/code&gt; 부분이 &lt;code&gt;Deprecated&lt;/code&gt; 된 것을 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 &lt;code&gt;Deprecated&lt;/code&gt; 되었는지 알아보고 &lt;code&gt;API&lt;/code&gt; 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257623-11a08100-7fe2-11eb-93fc-771900030db8.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 44 02 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 주석을 읽어보니 이유는 다음과 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 &lt;code&gt;UTF-8&lt;/code&gt; 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 이제는 &lt;code&gt;APPLICATION_JSON_UTF8&lt;/code&gt;을 사용하는 것 보다는 그냥 &lt;code&gt;APPLICATION_JSON&lt;/code&gt; 을 사용하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258251-fe42e500-7fe4-11eb-8fb8-06b332bf7b95.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 04 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 링크에 나와있듯이, &lt;code&gt;Content-Type&lt;/code&gt;을 &lt;code&gt;application/json&lt;/code&gt;으로 명시를 해도 인코딩이 깨진다고 버그 리포팅을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;charset=utf-8&lt;/code&gt;로 명시했을 때는 동작하지만 &lt;code&gt;charset&lt;/code&gt; 은  &lt;code&gt;application/json&lt;/code&gt;에 명시되어있지 않고 무시 되어야 한다고 문제를 제기하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rfc4627&#34;&gt;RFC4627&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258583-a7d6a600-7fe6-11eb-8654-5aa39d132d55.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 16 46 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258530-6b0aaf00-7fe6-11eb-969c-b32776e629cd.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 15 10 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인코딩 부분을 살펴보면, &lt;code&gt;JSON&lt;/code&gt; 타입은 유니코드로 인코딩 되어야 하며 디폴트로 &lt;code&gt;UTF-8&lt;/code&gt;이 적용된다는 부분을 살펴볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;느낀점&#34;&gt;느낀점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 나였으면 그냥 내가 잘못 한 거구나라고 하면서 &lt;code&gt;charset&lt;/code&gt; 옵션을 주고 스펙까지 확인해볼 생각을 하지 않을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 점은 나도 배워야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4627&#34;&gt;RFC4627&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>네이버 신입 공채 체크 포인트 및 준비해야할 것들</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4.html</link>
      <pubDate>Sun, 07 Mar 2021 22:15:14 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110241534-b7c59a00-7f94-11eb-8b8c-3038b005cff4.png&#34; alt=&#34;Screen Shot 2021-03-07 at 10 29 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;네이버에서 신입을 뽑을 때 고려하는 부분을 알 수 있을 것 같아서 읽어보았다. 물론 다른 기업들도 이러한 점을 고려해서 신입을 뽑을 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://campaign.naver.com/recruit2020/checkpoint/&#34;&gt;2020신입개발공채체크포인트!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네이버가-강조하는-세가지의-키워드&#34;&gt;네이버가 강조하는 세가지의 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;기본기!&lt;/li&gt;
&lt;li&gt;커뮤니케이션!&lt;/li&gt;
&lt;li&gt;성장가능성!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본기&#34;&gt;기본기&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;기술 생태계가 빠르기 때문에, 의욕만 앞서 모두 다 경험해보겠다는 태도는 그다지 효율적인 접근 방법이 아니다.
따라서 이럴 수록 기본기에 충실해야만 새로운 기술 흐름에 압도되지 않고, 스스로의 방향성과 페이스로 앞으로 나갈 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 기술을 배웠다거나, 사용할 수 있다고 어필을 하는 것 보다는 기본기가 탄탄하다는 인상을 주는 것이 유리할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 자료구조, &lt;strong&gt;운영체제&lt;/strong&gt;, 알고리즘, &lt;strong&gt;네트워크&lt;/strong&gt;, &lt;strong&gt;데이터베이스&lt;/strong&gt; 관련된 블로그 포스팅을 하고 면접 때 이러한 기본기에 대한 답변을 잘 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기초를 많이 깊게 공부하는 것이 네이버를 입사하는데 많은 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 다음과 같은 부분도 함께 본다고 했다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 너비보다 깊이.
2. 끝까지 파본 경험 
3. 창업자형 개발
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;면접&#34;&gt;면접&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;틀린답이라도 왜 그러한 답을 냈는지 설명하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;문제를 해결하기 위한 자신의 노력을 어필하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;모르면 찾으면 되고, 질문하면 되지만 끝까지 파고들고자 하는 마음가짐이 없으면 확실한 결과물을 만들어내지 못한다!&lt;/li&gt;
&lt;li&gt;공부를 하려는 사람을 많이 뽑으려고 했다.&lt;/li&gt;
&lt;li&gt;문제를 접근하는 방식에 있어서 어떤 식으로 접근하려고 하는지를 많이 보았다.&lt;/li&gt;
&lt;li&gt;1차 면접이 끝났다고, 거기서 안주하지 말고 어떤 점들을 더 보강하면 되는지를 생각을 해라.&lt;/li&gt;
&lt;li&gt;전산 기초 과목에 대한 학습을 충분히 하는 것을 추천한다. &lt;strong&gt;단순히 외우지 말고 이해해야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&amp;lsquo;왜?&amp;lsquo;라고 스스로에게 질문하고 답을 찾아봐야한다. 왜 이런 개념이 나왔는지, 왜 이 개념이 더 좋은지, 한번 깊이 생각을 해보는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;잘 모르겠으면 솔직히 이야기를 하라! 그러면 면접관들이 힌트를 줄 것이다.&lt;/li&gt;
&lt;li&gt;정답을 맞추는 능력 이상으로 답을 유추해 가는 사고력 또한 굉장히 중요하기 때문이다.&lt;/li&gt;
&lt;li&gt;본인이 해결해왔던 문제를 어떤 식으로 대하고, 접근했고, 치열하게 고민하고, 솔루션을 도출했는지를 중점적으로 물어본다.&lt;/li&gt;
&lt;li&gt;성공했으면 성공한 대로, 실패했으면 실패한대로 의미가 있기 때문이다.&lt;/li&gt;
&lt;li&gt;개발을 정말 좋아하고 기저의 원리를 이해하는데, 많은 노력을 들였는지를 물어본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110243042-14788300-7f9c-11eb-80d1-a4f252ce7cda.png&#34; alt=&#34;Screen Shot 2021-03-07 at 11 22 52 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;최대한 구체적이고&amp;rdquo;, &amp;ldquo;솔직할 것이다.&amp;rdquo; 왜냐하면 개발자의 핵심 역량은 &lt;strong&gt;설계 역량&lt;/strong&gt;, &lt;strong&gt;논리적 사고&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;커뮤니케이션&#34;&gt;커뮤니케이션&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;문제를 잘 듣고 이해하며, 자신이 생각한 답을 명확하고 간결하게 커뮤니케이션 할 수 있는지를 본다.&lt;/li&gt;
&lt;li&gt;협업에 대한 것을 강조해서 질문을 한다.&lt;/li&gt;
&lt;li&gt;여러가지 해결책들이 존재하는 질문을 던지게 되고, 아래 항목정도를 살펴본다.
&lt;ul&gt;
&lt;li&gt;문제를 어떤 수준에서 이해하고, 본인의 전문성/인사이트를 보여주는지&lt;/li&gt;
&lt;li&gt;면접관이 면접자의 의견과 방향이 다른 해결책을 제시했을 때, 다른 해결책에 대해서 어떻게 반응하는지, 수렴하여 시너지가 나는 새로운 방향을 제시하는지&lt;/li&gt;
&lt;li&gt;면접관이 면접자의 해결책의 안되는 이유를 여러가지 나열 했을 때, 이것들을 어떻게 정리하고 일이 되게 만드는 방향에 집중하는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 부분은 어떻게 키워야 할지 조금 막막하다. 지금도 노력하고 있지만 가장 부족한 부분이 커뮤니케이션 부분이라고 생각하기 때문이다.&lt;/p&gt;
&lt;h2 id=&#34;지원서&#34;&gt;지원서&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;화려한 문체나 거창한 커리어보다는, 개발에 대한 나만의 열정과, 노력들을 보여주는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;개발을 정말로 좋아하는지를 많이 본다.&lt;/li&gt;
&lt;li&gt;이수한 컴퓨터공학 관련 과목, 기술적 문제를 해결한 경험, 에너지를 집중해 끝가지 파고 들었던 경험을 적는 것이 좋다.&lt;/li&gt;
&lt;li&gt;개발자로서 개선해보고 싶은 네이버 서비스등도 미리 생각하면 좋다.&lt;/li&gt;
&lt;li&gt;포기하지 않고 끝까지 몰입해본 경험, 세상의 불편을 개발로 풀고자 시도했던 경험 등 개발자로서 성장 의지를 보여줄 수 있는 본인만의 스토리가 있다면 잘 녹여서 적어라&lt;/li&gt;
&lt;li&gt;내가 무엇을 할 수 있는지가 명확히 드러나는 지원서를 선호한다.&lt;/li&gt;
&lt;li&gt;어떤 프로젝트를 했었고, 그 프로젝트에서 어떤 역할을 했고, 내가 만든 산출물이 어떤 것이고, 기술적으로 어떤 고민을 했었는지 등이 나와 있는 지원서의 경우 더 자세히 보게 된다.&lt;/li&gt;
&lt;li&gt;지원서에 개인 &lt;code&gt;GITHUB URL&lt;/code&gt;을 작성한 지원자의 경우, 꼭 들어가서 본다.&lt;/li&gt;
&lt;li&gt;소스코드를 통해서 지원자의 개발 역량을 파악할 수 있을 뿐더라, &lt;code&gt;GITHUB&lt;/code&gt;를 운영하고 공유할 정도라면 어느 정도 수준이 있는 개발자일 것이라는 기대를 하기 때문이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GITHUB&lt;/code&gt;는 생각보다 많은 정보를 준다. 소스 코드를 지속적으로 업로드 하고, 관리하고 공유하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;지원서에서는 &amp;lsquo;결과&amp;rsquo;보다는 &amp;lsquo;무엇을 했는지&amp;rsquo; 강조하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;학과 공부에서 배운 것 뿐만 아니라 새로 알게 된 경험에 관한 이야기도 좋다.&lt;/li&gt;
&lt;li&gt;협업에 대해서 이야기 하고 싶다면 갈등, 조정, 협의, 합의 등에 이르게 된 과정을 설명하는게 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;네이버가 왜 이러한 점을 면접때 보는지 생각하면 업무에 도움이 되고 성장할 수 있는 개발자를 뽑으려고 하기 때문이다. 따라서 앞으로 내 업무 능력을 키워가는데도 도움이 될 것이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그리고 일을 하면서 만나는 문제들을 끝까지 파보자라는 자세를 가지고 접근하며 이와 내가 문제를 어떤 식으로 대하고, 접근했고, 치열하게 고민했고, 파봤고, 솔루션을 도출한 과정을 적으려면 실제로 그러한 자세로 일을 해야한다.&lt;/p&gt;
&lt;p&gt;너무 많아서 다 정리하지는 못했다. 하지만 어떤 기업을 지원하더라도, 지원서를 작성하기 전에, 이 사이트에 들려서 내가 작성한 글이 적합한지에 대한 고민을 해봐야 할 것이다.&lt;/p&gt;
&lt;h2 id=&#34;코딩-테스트&#34;&gt;코딩 테스트&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110243118-5d303c00-7f9c-11eb-9bdd-c9aa327aa421.png&#34; alt=&#34;Screen Shot 2021-03-07 at 11 24 31 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://campaign.naver.com/recruit2020/checkpoint/&#34;&gt;naver 2020 신입개발공채 체크포인트!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture.html</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture.html</guid>
      <description>&lt;h2 id=&#34;computablefuture란&#34;&gt;ComputableFuture란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Future를 외부에서 완료시킬 수 없다.&lt;/li&gt;
&lt;li&gt;작업을 취소하거나, &lt;code&gt;get()&lt;/code&gt;에 타임아웃을 설정할 수 없다.&lt;/li&gt;
&lt;li&gt;블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다.&lt;/li&gt;
&lt;li&gt;예외처리용 &lt;code&gt;API&lt;/code&gt;를 제공하지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비동기로-작업-실행하기&#34;&gt;비동기로 작업 실행하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;비동기로 작업을 실행하는 방법은 두가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runAsync()&lt;/code&gt;: 리턴값이 없는 경우 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;supplyAsync()&lt;/code&gt;: 리턴 값이 있는 경우 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음은 &lt;code&gt;ComputableFuture&lt;/code&gt;를 사용한 예제이다. &lt;code&gt;get()&lt;/code&gt;을 호출 했을 때 실행되게 된다.
자바 &lt;code&gt;API&lt;/code&gt;를 살펴보면 &lt;code&gt;supplyAsync()&lt;/code&gt;메서드는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110235572-1e868b80-7f74-11eb-9235-e71a182b912b.png&#34; alt=&#34;runAsync&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환한다. &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;에서 실행중인 태스트에 의해서 비동기적으로 실행된다.&lt;/li&gt;
&lt;li&gt;역시 새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환하지만 차이점은 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스크를 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;ForkJoinPool&lt;/code&gt;을 사용하지 않는다면 다음과 같이 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스트가 처리되도록 할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }, executorService).thenRunAsync(() -&amp;gt; {
            System.out.println(Thread.currentThread().getName());
        }, executorService);
        future.get();
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;콜백-제공하기&#34;&gt;콜백 제공하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenApply(Function)&lt;/code&gt;: 리턴값을 받아서 다른 값으로 바꾸는 콜백&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenAccept(Consumer)&lt;/code&gt;: 리턴값을 또 다른 작업으로 처리하는 콜백 (리턴 없이)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenRun(Runnable)&lt;/code&gt;: 리턴 값을 받지 않고 다른 작업을 처리하는 콜백&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;조합하기&#34;&gt;조합하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCompose()&lt;/code&gt;: 두 작업이 서로 이어서 실행하도록 조합하기&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCompose(Main::getWorld);

        System.out.println(future.get());
    }

    private static CompletableFuture&amp;lt;String&amp;gt; getWorld(String message) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return message + &amp;quot; World&amp;quot;;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCombine()&lt;/code&gt;: 두 작업을 독립적으로 실행하고 둘다 종료했을 때, 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; world = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;World&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCombine(world, (h, w) -&amp;gt; h + &amp;quot; &amp;quot; + w);
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음과 같이 두 작업이 각각 실행하여, 둘다 종료되었을 때, 콜백이 실행되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allOf()&lt;/code&gt;: 여러 작업을 모두 실행하고 모든 작업 결과에 콜백 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anyOf&lt;/code&gt;: 여러 작업중에 가장 빨리 끝난 하나의 결과에 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;예외-처리&#34;&gt;예외 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exceptionally(Funciton)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).exceptionally(ex -&amp;gt; {
            System.out.println(ex);
            return &amp;quot;Error&amp;quot;;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handle(BiFunction)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).handle((result, ex) -&amp;gt; {
            if (ex != null) {
                System.out.println(ex);
                return &amp;quot;ERROR!&amp;quot;;
            }
            return result;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 07 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h2 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;한 주간에 있었던 일과 생각을 정리해보았습니다.&lt;/p&gt;
&lt;h2 id=&#34;jwt-토큰에-대해서-알게-되었다&#34;&gt;JWT 토큰에 대해서 알게 되었다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 과제를 하면서 JWT 토큰에 대해서 조사를 해보았다.&lt;/li&gt;
&lt;li&gt;JWT 토큰에 대해서 들어본적은 기억은 있었지만, 로그인을 할 때 사용한다 정도로만 알고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110233686-e0d03580-7f68-11eb-8721-07699d334efc.png&#34; alt=&#34;Screen Shot 2021-03-07 at 5 16 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과제를 제출하기 전에, 내가 사용하는 라이브러리에 대해서 최소한의 조사를 하고 PR을 하자는 목표를 가지고 조사를 하게 되었다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RFC&lt;/code&gt; 문서까지 읽고 공부를 했으면 더 좋았을 것 같다. 따라서 투두 리스트에 넣어두고 시간이 되는대로 읽고 정리하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;커뮤니케이션&#34;&gt;커뮤니케이션&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;적극적으로 내가 어떤 일을 어디까지 진행했고, 어떤 일을 하려고 하는지 이야기 하였다. 일부러 조금 오버해서 &lt;code&gt;TMI&lt;/code&gt; 일정도로 동료들에게 내가 하고있는 일을 이야기했다.&lt;/li&gt;
&lt;li&gt;동료들이 알아주는 것 같아서 기뻣다.&lt;/li&gt;
&lt;li&gt;하지만, 말하다보니 생각이 완전히 정리되지 않을 때가 많다고 느꼈다.&lt;/li&gt;
&lt;li&gt;따라서 이야기를 하기 전에 미리 할 이야기를 정리하고 얘기를 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 잘 하려면 소프트 스킬이 중요하다는 사실을 깨닫게 되었다.&lt;/li&gt;
&lt;li&gt;회사를 다니기 전에는 커뮤니케이션 능력의 중요성에 대해서 간과하고 있었다.&lt;/li&gt;
&lt;li&gt;따라서 소프트 스킬 능력을 키우기 위해서 많이 노력해야겠다.&lt;/li&gt;
&lt;li&gt;개발자 뿐만 아니라, 업무와 연관된 모든 사람들에게 내가 여태까지 어떤일을 진행하고 있고 현재 어떤 업무를 하고 있는지 적극적으로 알려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;고쳐야-할점&#34;&gt;고쳐야 할점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;내가 발견한 사실 및 해결책이 나올 것 같을 때, 흥분해서 성급하게 짐작해서 말하는 습관이 있다. 이를 고치도록 해야겠다. 예를 들어서 비슷한 예외가 많이 발생하여 이번에도 이 예외가 발생하고 있다고 말했는데 다시 확인해보니 아니였다.&lt;/li&gt;
&lt;li&gt;이때의 부끄러운 기억을 간직하고 다시는 같은 실수를 반복하지말고 때로는 시간이 조금 걸리더라도 정확하게 확인하는 습관을 들이자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;잘한-점&#34;&gt;잘한 점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이슈를 진행하면서 내가 모르는 옵션이나, 기능이 나올 때 공식문서를 찾아보고 있다.&lt;/li&gt;
&lt;li&gt;최근에는 &lt;code&gt;groupby&lt;/code&gt; 함수를 사용할 일이 있었는데, 공식 문서를 보지 않고 사용했으면 버그를 발생시킬 수 있는 일이 있었다. 왜냐하면 파이썬의 &lt;code&gt;groupby&lt;/code&gt; 함수는 SQL 문과 달리 사용하기전에 키로 한번 정렬을 해주어야 하기 때문이다. 아마도 문서를 읽어보지 않았더라면 버그가 발생했을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;라인-신입-개발자-채용이라는-글을-읽고-느낀점&#34;&gt;라인 신입 개발자 채용이라는 글을 읽고 느낀점&amp;hellip;&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;라인 신입 개발자 채용이라는 기술 블로그에 있는 글을 읽고 정리를 했다. &lt;a href=&#34;https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/&#34;&gt;라인 개발자 입사기를 읽고 느낀점&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;코딩 테스트를 준비는 꾸준히 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;이번 기회에 운영체제, 자료구조, 네트워크, 데이터베이스와 같은 컴퓨터공학 기초 지식들을 블로그에 틈틈히 정리를 해야겠다.&lt;/li&gt;
&lt;li&gt;포트폴리오에서는 내가 얼마만큼 알고 있는지보다는, 내가 얼마만큼 고민 했다는 것을 어필하라고 했다.&lt;/li&gt;
&lt;li&gt;프로젝트를 할 때, 문제 발생 - 문제 원인 파악 - 해결책 적용 - 결과 라는 절차를 두고 프로젝트 문제 과정을 서술했다고 했고 좋은 방법인것 같다.&lt;/li&gt;
&lt;li&gt;코드숨에서 이제 곧 프로젝트를 할 텐데, 이러한 점을 놓치지 않아야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;오랜만에-주고-받았던-메일을-보면서-많은-것을-느낄-수-있었다&#34;&gt;오랜만에 주고 받았던 메일을 보면서 많은 것을 느낄 수 있었다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/&#34;&gt;DBMS를 분석하는 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;회사 코드를 작성하면서 내가 코드 레벨부터 확인하려는 습관이 있는데 시간이 오래걸리고 놓친 부분이 많아서 코드를 수정하는 일이 많았는데, 이를 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;회사-코드에-클래스-주석-메서드-주석을-적고-있다&#34;&gt;회사 코드에, 클래스 주석, 메서드 주석을 적고 있다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 과제를 하면서 자신감이 생겨서 클래스 주석 및 메서드 주석을 회사 코드에 작성하였다.&lt;/li&gt;
&lt;li&gt;다만, DRY 원칙에 어긋나지 않고 제대로 작성을 하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;li&gt;더 나아가서, 중복된 코드를 제거하고 테스트 코드까지 작성할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;코드숨&#34;&gt;코드숨&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이번주에는 딴짓도 많이 하고(블로그에 쓰고 싶은 글이 많아 손이 근질근질 해서 블로그에 글을 많이 작성했다.) 시간도 부족해서 강의에 집중하지 못했다.&lt;/li&gt;
&lt;li&gt;게다가 회사 세미나 과제를 부랴부랴 하느라 시간이 부족했다.&lt;/li&gt;
&lt;li&gt;이번주에는 많이 부족했지만 리프레시 했다고 생각하고 다음주에는 열심히 과제를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future.html</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future.html</guid>
      <description>&lt;h2 id=&#34;callable과-future&#34;&gt;Callable과 Future&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;과 &lt;code&gt;Runnable&lt;/code&gt;의 차이점은 작업의 결과를 받을 수 있다는 사실이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198342-24f20600-7e95-11eb-827d-e423468801e7.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 &lt;code&gt;Future&lt;/code&gt;에 대해 설명한 API 주석이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기식 계산의 결과를 나타냅니다.&lt;/li&gt;
&lt;li&gt;계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다.&lt;/li&gt;
&lt;li&gt;결과는 계산이 완료된 경우에만 메서드 &lt;code&gt;get&lt;/code&gt;을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다.&lt;/li&gt;
&lt;li&gt;또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.&lt;/li&gt;
&lt;li&gt;작업이 완료되면 이를 취소할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get---결과를-가져오기&#34;&gt;get() - 결과를 가져오기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198530-8d8db280-7e96-11eb-9b45-45b9bae25d57.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;은 오버로딩 된 두가지 메서드를 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계산이 완료될 때까지 기다린 다음에 결과를 검색한다.&lt;/li&gt;
&lt;li&gt;최대 지정된 시간까지 기다렸다가 사용 가능한 경우 결과를 검색합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Future&amp;lt;String&amp;gt; helloFuture = executorService.submit(hello);
        System.out.println(&amp;quot;Started!&amp;quot;);

        helloFuture.get(); // blocking call

        System.out.println(&amp;quot;End!!&amp;quot;);
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음과 같은 경우에는 터미널에 &lt;code&gt;Started!&lt;/code&gt; 라는 글씨가 적히고 나서, 2초간 대기를 한 후에 &lt;code&gt;End!!&lt;/code&gt; 라는 글씨가 찍히게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;타임아웃(최대로 기다릴 시간)을 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isdone-iscancelled---작업-상태-확인하기&#34;&gt;isDone(), isCancelled() - 작업 상태 확인하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198688-a64a9800-7e97-11eb-8f77-8bd8a28d5757.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isDone&lt;/code&gt;은 작업이 완료되었으면 참을 반환하고 아닌 경우에는 거짓을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isCancelled&lt;/code&gt;는 작업이 완료된 경우 참을 반환한다. 작업이 정상적으로 종료되거나, 예외 또는, 취소된 경우도 역시 참으로 반환된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cancel---작업-취소하기&#34;&gt;cancel() - 작업 취소하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199234-d3e51080-7e9a-11eb-9fb7-1ff63519640f.png&#34; alt=&#34;작업 취소&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작업을 취소할 때 사용한다.&lt;/li&gt;
&lt;li&gt;작업이 이미 완료되었거나, 취소되었거나, 다른 이유로 취소할 수 없는 경우에는 실패한다.&lt;/li&gt;
&lt;li&gt;이 메서드가 실행된 후에 &lt;code&gt;isDone()&lt;/code&gt;는 항상 참을 반환한다.&lt;/li&gt;
&lt;li&gt;일반적으로 작업이 이미 정상적으로 완료되었기 때문에, 작업을 취소할 수 없는 경우에는 거짓을 반환하고 그렇지 않으면 참을 반환한다.&lt;/li&gt;
&lt;li&gt;성공적으로 취소했으면, 참 아니면 거짓을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;invokeall과-invokeany의-차이점&#34;&gt;invokeAll()과 invokeAny()의 차이점&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;invokeall&#34;&gt;invokeAll&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199536-2d017400-7e9c-11eb-8b43-33862e419425.png&#34; alt=&#34;invokeAll&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;태스크를 실행하고 모두 완료되거나 시간 초과가 만료될 때, 상태 및 결과를 저장하고 있는 &lt;code&gt;Future&lt;/code&gt; 목록을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future.isDone&lt;/code&gt;은 반환된 목록의 각 요소에 대해서 적용됩니다.&lt;/li&gt;
&lt;li&gt;반환시에 완료되지 않은 태스크는 취소됩니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정한 컬렉션이 수정되면 메서드의 결과가 정의되지 않습니다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 가장 오래걸리는 작업만큼 시간이 소요된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = executorService.invokeAll(Arrays.asList(hello, java, dongwook));

        for (Future&amp;lt;String&amp;gt; f : futures) {
            System.out.println(f.get()); // Hello, Java, Dong Wook 순서대로 출력된다.
        }
        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;invokeany&#34;&gt;invokeAny&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199641-adc07000-7e9c-11eb-8c91-a79c559268e2.png&#34; alt=&#34;invokeAny&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성공적으로 완료된 태스크의 결과를 반환합니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정된 컬렉션이 수정되면 이 메서드의 결과가 정의되지 않는다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 제일 짧게 걸리는 작업만큼 시간이 걸린다.&lt;/li&gt;
&lt;li&gt;이 역시 또한 블록킹 콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        String futures = executorService.invokeAny(Arrays.asList(hello, java, dongwook));

        System.out.println(futures); // Dong Wook
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 06 Mar 2021 15:14:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파이썬 AOP라는 글을 읽어보았다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사 세미나 과제를 했다. (자바 동시성 및 &lt;code&gt;ComputableFuture&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;인터셉터에 대해서 배우게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아직 스트림 연산에 대해서 완전히 이해를 하지 못한 것 같다.&lt;/li&gt;
&lt;li&gt;객체의 본질적인 역할과 관심사의 분리를 해주는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤한 기능을 도입할 때, 프로젝트에 정말로 필요한 기능인가를 생각해보고 프로젝트에 필요한 부분만 선택하는 능력이 필요하다는 것을 느꼈다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 다양한 관점에서 생각을 해보고 이를 목록으로 정리하여 내가 선택한 이유를 정리하는 것을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 설명할 때, 나는 주로 ~~ 했을 때 ~~ 한다라고 작성하였지만 ~~하면 ~~ 한다라는 패턴으로 작성하는 것이 좋을 것 같다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228193-9340d200-7f42-11eb-937a-900cce6a64af.png&#34; alt=&#34;Screen Shot 2021-03-07 at 12 42 09 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨트롤러나, 서비스 클래스를 설명하는 자바 독을 작성할 때는, ~~ 관련된 이라는 키워드를 사용하면 쉽게 설명할 수 있다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228587-a99c5d00-7f45-11eb-920e-50d322cc79d7.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 04 29 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 클래스를 설명하는 자바 독은 ~~ 작업을 제공한다. 이렇게 적는 것이 더 바람직하다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228608-cb95df80-7f45-11eb-855e-7335dcafaed9.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 05 23 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나는 기존에 ~~를 얻는다. 이렇게 작성을 했는데, ~~를 리턴한다와 같이 행동에만 집중해서 자바 문서를 작성하는 것이 좋을 것이다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228567-807bcc80-7f45-11eb-8b1c-c2015bcededa.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 03 18 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인증과 인가의 차이점에 대해서 배웠다. 그리고 서버와 클라이언트 사이의 인증과 인가에 대한 관점 차이를 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication -&amp;gt; 로그인 -&amp;gt; Token (인증)&lt;/li&gt;
&lt;li&gt;Authorization &amp;lt;- Token (인가)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication = 로그인 (인증)&lt;/li&gt;
&lt;li&gt;Token -&amp;gt; Authentication (인증)&lt;/li&gt;
&lt;li&gt;User -&amp;gt; Role -&amp;gt; Authentication (인가)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;중복과 테스트 코드에 대해서 고민을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번주에 코드숨 과정에 집중하지 못했다.&lt;/li&gt;
&lt;li&gt;작은 부분이라도 최선을 다해야겠다.&lt;/li&gt;
&lt;li&gt;일의 우선순위를 정하고 이를 꼭 지키도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다음주부터는 코드숨 과정에 완전히 집중할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://labs.brandi.co.kr/2020/01/07/yangjh.html&#34;&gt;http://labs.brandi.co.kr/2020/01/07/yangjh.html&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>파이썬에 AOP 적용하기라는 글을 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</link>
      <pubDate>Sat, 06 Mar 2021 14:50:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;내가 현재 맡고 있는 솔루션에는 일일이 데이터베이스를 열어주고 쿼리를 실행하고 데이터베이스를 닫아주는 과정을 거치고 있었다. 매우 비효율적이고 중복된 코드가 많아져 이를 수정하고자 하였다. 따라서, 어떻게 수정할까 고민하는 과정에서 스프링에 있는 &lt;code&gt;AOP&lt;/code&gt; 개념이 파이썬에도 있을 것이라고 확신하고 검색을 했다.  그러던 중에, 브랜디 개발 블로그에서 좋은 글을 발견하여 이를 읽고 느낀점을 적어보았다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197088-69c56f00-7e8c-11eb-8350-146a7c2cbed8.png&#34; alt=&#34;Screen Shot 2021-03-06 at 2 58 11 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 관점에서 고려해보는 모습이 인상 깊었다.&lt;/li&gt;
&lt;li&gt;나도 물론 최선의 방법을 생각해보려고 고민을 해보지만, 이렇게까지 다양한 과점을 고려해보지는 않은 것 같다. 따라서 이와 같은 점을 배우도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197130-cde83300-7e8c-11eb-98ca-f47d669044bd.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 01 03 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현을 할 때, 요구사항을 명확히 정리해서 어떤 부분의 만족 시켜야하는지 조건을 상세하게 나열하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 회사에서 요구사항을 명확히 이해하지 못해서 자꾸 실수를 하는 일이 있었는데, 이와 같이 요구사항을 명확히 글로 작성하면 실수할 일이 적어지고 내가 빠뜨린 부분이 없나 쉽게 확인할 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197183-2d464300-7e8d-11eb-827d-03141a27e467.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 03 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 시간의 제약 때문에 때로는 완벽하게 구현을 하지 못할 수 도 있다. 그래도 앞으로 개선할 방향 및 고민을 해야하는 부분을 기록해두면 나중에 여유가 생기거나 문제가 생겼을 때, 어떤 부분을 고민하고 해결해야하는지 쉽게 알 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글쓴이가 생각하는 불변의 원칙은 &amp;lsquo;정확한 요구사항을 지키는 것&amp;rsquo; 이다. 좋은 개발 방법론이나, 라이브러리가 있지만 정말로 우리 프로젝트에 필요한 기능인가를 항상 염두해야한다고 했다. 정말 맞는 것 같고, 프로젝트에 좋은 기능이라고 생각하면 무조건 도입을 해야한다고 생각하던 때가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 정말로 우리 프로젝트에 필요한 기능인가를 고민하고 필요한 기능만 구현하는 안목이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://labs.brandi.co.kr/2020/01/07/yangjh.html&#34;&gt;파이썬 프로젝트에 AOP 도입하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 itertools 모듈의 group by 함수</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98.html</link>
      <pubDate>Sat, 06 Mar 2021 13:15:35 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98.html</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;회사에서 이슈를 처리 하다가, 키 값을 기준으로 하위 리스트를 처리할 일이 있었다.
자바였으면  &lt;code&gt;groupingBy()&lt;/code&gt;를 이용하여 쉽게 처리를 할 수 있다는 생각을 하고 있었던 참에 파이썬도 이와같은 함수를 지원하지 않을까라는 생각이 들어서 검색을 해보니 비슷한 함수가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110194923-8d81b880-7e7e-11eb-818d-fc66c7f4a6a0.png&#34; alt=&#34;Screen Shot 2021-03-06 at 1 18 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;연속된 키와 그룹을 반환하는 이터레이터를 만든다.&lt;/li&gt;
&lt;li&gt;인자중에, 키는 각 요소의 키 값을 계산하는 함수이다.&lt;/li&gt;
&lt;li&gt;일반적으로 해당 항목은 동일한 키 함수에 대해서 이미 정렬되어야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;키 함수의 값이 변경될 때마다 중단하거나 새 그룹을 생성하기 때문에 동일한 키 함수를 이용하여 데이터를 정렬해줘야한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;그렇기 때문에 입력 순서에 관계없이 공통 요소를 집계하는 SQL의 GROUP BY와는 다르다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이터레이터가 진행될 때마다, 이전 그룹은 사라지므로 만약 필요하다면 리스트로 저장해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 &lt;code&gt;groupby&lt;/code&gt;를 사용한 예제이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import groupby

things = [(&amp;quot;animal&amp;quot;, &amp;quot;bear&amp;quot;), (&amp;quot;animal&amp;quot;, &amp;quot;duck&amp;quot;), (&amp;quot;plant&amp;quot;, &amp;quot;cactus&amp;quot;), (&amp;quot;vehicle&amp;quot;, &amp;quot;speed boat&amp;quot;), (&amp;quot;vehicle&amp;quot;, &amp;quot;school bus&amp;quot;)]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(&amp;quot;A %s is a %s.&amp;quot; % (thing[1], key))
    print(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;키 값으로 튜플의 첫 번째 값을 사용하여 정렬 하였고, 키 값에 따른 그룹이 생성될 때마다 이를 출력한 것이다.&lt;/p&gt;
&lt;h4 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 말했듯이 사용하기 전에, 키 값을 기준으로 정렬이 된 리스트인지, 그리고 보장을 하지 못한다면 정렬을 해줘야하는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# [k for k, g in groupby(&#39;AAAABBBCCDAABBB&#39;)] --&amp;gt; A B C D A B
# [list(g) for k, g in groupby(&#39;AAAABBBCCD&#39;)] --&amp;gt; AAAA BBB CC D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;정렬을 해주지 않으면 위와 같은 형태로 만들어 지게 된다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/itertools.html#itertools.groupby&#34;&gt;itertools - groupby 파이썬 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/773/how-do-i-use-itertools-groupby&#34;&gt;group by 예제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 05 Mar 2021 07:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기계인간님의 DRY 원칙에 대해서 쓴 글을 읽었다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;기계인간님의 디미터 법칙에 관한 글을 읽었다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DRY 원칙은 모든 곳에 적용할 수 있을 것이다. (코드, 테스트, 문서화) 그리고 내가 DRY 원칙을 잘 지키고 있는지 생각하면 그렇지 못한 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실용주의 프로그래머에서는 중복을 4가지로 분리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;강요된 중복 : 개발자들은 다른 선택이 없어 보인다. 환경이 중복을 요구하는 것 처럼 보인다.&lt;/li&gt;
&lt;li&gt;부주의한 중복 : 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.&lt;/li&gt;
&lt;li&gt;참을성 없는 중복 : 중복이 쉬워보이기 때문에, 개발자들이 게을러져서 중복을 하게 된다.&lt;/li&gt;
&lt;li&gt;개발자간의 중복 : 한 팀에 있는 (혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 코드내의 주석이 너무 많거나 상세하더라도 DRY 원칙을 위반할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;코드에는 주석이 있어야하지만, 너무 많은 것은 너무 적은 것만큼이나 좋지 않다. &lt;strong&gt;일반적으로 주석은 왜 이렇게 되어 있는지 목적을 논해야한다.&lt;/strong&gt; 코드가 이미 어떻게 되어 있는지 보여주기 때문에 이에 대해 주석을 다는 것은 사족이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라. 이렇듯 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다. 다른 프로그래머들이 그만큼 어휘를 사용하기 쉬워진다. &lt;strong&gt;추상화 수준을 높였으므로, 구현이 빨라지고 오류가 적어진다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디미터 법칙이란 긴 객체 구조의 경로를 따라서 멀리 떨어져 있는 간접적인 (낯선) 객체에 메세지를 보내는 (또는 이야기하는) 설계는 피하라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Don&#39;t talk to Strangers&lt;/code&gt; 패턴은 메서드 내에서 어떤 객체에 메시지를 보내야 하는가에 대한 제약을 가한다. 메서드 안에서는 다음의 객체들에게만 메시지를 보내야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;this(또는 self) 객체&lt;/li&gt;
&lt;li&gt;메서드의 매개변수&lt;/li&gt;
&lt;li&gt;this의 속성&lt;/li&gt;
&lt;li&gt;this 속성인 컬렉션의 요소&lt;/li&gt;
&lt;li&gt;메서드 내에서 생성된 객체&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;중복의-유형과-제거-방법&#34;&gt;중복의 유형과 제거 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 뻔한 유형은 똑같은 코드가 여러 차례 나오는 중복이다. 프로그래머가 미친듯이 마우스로 긁어다 여기저기로 복사한 듯이 보이는 코드이다. 이러한 중복은 간단한 함수로 교체한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 미묘한 유형은 여러 모듈에서 일련의 &lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;문으로 똑같은 조건을 거듭 확인하는 중복이다. 이러한 중복은 다형성으로 대체해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더더욱 미묘한 유형은 알고리즘이 유사하나 코드가 서로 다른 중복이다. 중복은 중복이므로, &lt;code&gt;TEMPLATE METHOD&lt;/code&gt; 패턴이나, &lt;code&gt;STRATEGY&lt;/code&gt; 패턴으로 중복을 제거한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디자인 패턴은 대다수가 중복을 제거하는 잘 알려진 방법에 불과하다. &lt;code&gt;OOP&lt;/code&gt;, &lt;code&gt;BDNF&lt;/code&gt; 역시 마찬가지이고, 또한 구조적 프로그래밍도 마찬가지이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여태까지 주석을 코드의 목적을 위해서 적기 보다는 과정을 설명하기 위해서 적었던 것 같다.&lt;/li&gt;
&lt;li&gt;코드에서 중복된 부분이 많음에도 불구하고, 그냥 무심코 지나간 적이 많았던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;중복을 최대한 줄이도록 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 하면서 중복된 코드가 보인다면 제거하려고 시도하겠다.&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 중복을 줄이면 저절로 소프트웨어가 좋은 설계대로 구현이 될 것 같다. 나는 처음에는 좋은 설계로 소프트웨어를 작성해야지라고 생각을 했지만 사실, 좋은 설계를 한다는 것 자체가 추상적이다. 구체적인 방법은 코드에 중복을 줄여야지, 테스트 코드를 작성해야지 같은 구체적인 행동을 통해서 좋은 설계가 나온다는 생각을 했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/dry-principle/&#34;&gt;https://johngrib.github.io/wiki/dry-principle/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/law-of-demeter/&#34;&gt;https://johngrib.github.io/wiki/law-of-demeter/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>테크니컬 라이팅 4대 원칙이라는 글을 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</link>
      <pubDate>Thu, 04 Mar 2021 18:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</guid>
      <description>&lt;h3 id=&#34;테스트-코드-및-메서드-주석에-대한-고민&#34;&gt;테스트 코드 및 메서드 주석에 대한 고민&lt;/h3&gt;
&lt;p&gt;코드를 작성하면서 테스트 코드에 어떤 테스트라는 것을 어떻게 명확하게 표현할까, 그리고 모듈 및 클래스, 메서드 주석을 달면서 어떻게 작성해야 좋은 문서가 될까? 라는 고민을 하고 작성하였지만 여전히 어렵기만 했다. 그런던 중에서 카카오 기술 블로그에서 도움이 될 만한 글을 발견하였다.&lt;/p&gt;
&lt;h4 id=&#34;테크닐컬-라이팅의-4대-원칙&#34;&gt;테크닐컬 라이팅의 4대 원칙&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109958056-21da0700-7d29-11eb-8f4f-779e11801b92.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;명확성&#34;&gt;명확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;테크니컬 라이팅의 첫 번째 원칙은 명확성이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;명확성이란 핵심어나 핵심 문장이 모호하게 사용되지 않고, 대상 독자가 기술 문서를 읽을 때, 내용의 모호함이나 혼란 없이 한번에 이해하도록 하는 글이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 문서를 읽을 때, 독자 입장에서 이해가 가지 않아 특정 부분을 몇 번이고 다시 읽게 된다면, 이는 명확성이 떨어지는 글이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성이 떨어지는 이유는 대부분의 경우 대상 독자를 제대로 파악하지 못해서 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자라면 모두 아는 내용인데 적어야할까?&amp;rdquo; 라는 의문이 생기더라도 모두 적어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자들이라면 다 안다&amp;quot;라는 생각은 굉장히 주관적일 수 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대학생들이나 외부의 초급 개발자들도 쉽게 따라 할 수 있을 정도의 상세한 문서여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959088-6023f600-7d2a-11eb-9a7f-cfb1012115e6.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 44 05 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;간결성&#34;&gt;간결성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간결성이란 특정 독자가 기술적인 내용을 신속하고 정확하게 이해할 수 있도록 미사여구나 감탄사 등을 사용하지 않고, 쉬운 단어와 간결한 문장을 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문장을 길고 복잡하게 복문으로 써야 더 있어보이고, 더 많은 정보를 담게 될 것이라는 생각은 금물이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기술 문서에서는 &amp;ldquo;~는 ~입니다.&amp;rdquo; 라는 형식의 단문을 사용할 때 더욱 명확하고 가독성이 높은 글을 작성할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959559-040da180-7d2b-11eb-8d7a-a0ad03e6e701.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959668-2a334180-7d2b-11eb-924d-1945a49faf98.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 49 40 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;정확성&#34;&gt;정확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;독자가 필요로 하는 정보를 기술적 오류 없이 정확하게 제공하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성과, 간결성이 떨어지지만 정확성이 확보된 기술문서라면, 독자들은 시간이 많이 걸린다고 해도 해당 문서를 이해할 수 있지만 반대의 경우에는 잘못된 정보를 전달하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959933-7da58f80-7d2b-11eb-9144-7ca86c041707.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 51 58 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;일관성&#34;&gt;일관성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서에 용어, 표현, 그리고 어조 등을 일관성 있게 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 한번 언급된 단어를 다른 방식으로 언급하는 것은 독자에게 큰 혼란을 줄 수 있고, 결과적으로 문서의 신뢰도와 가독성이 저하된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;정리&#34;&gt;정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;짧게 써라&amp;quot;라고 시작하는 문장은 테크니컬 라이팅 대 원칙중 &amp;ldquo;간결성&amp;quot;을 &amp;ldquo;명료하게 써라&amp;quot;는 &amp;ldquo;명확성에 해당한다&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;그림처럼 써라&amp;quot;라는 문장은 독자가 어떤 시스템이나 기능의 아키텍처를 보다 쉽게 이해할 수 있도록 논리적으로 기술하거나 개발 시나리오나 개발 흐름 등의 시각 자료를 활용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakaoenterprise.com/102&#34;&gt;테크니컬 라이팅 4대 원칙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 04 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 &lt;code&gt;PM&lt;/code&gt; 분이 맡은 일을 언제까지 끝낼 수 있는지 공유를 해주면 일정 조율을 하기 편할 것 같다는 말씀을 하셨다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하면서, 전체적인 기능을 보고 코드를 보면서 어떻게 구현할지 생각하지 않고, 코드부터 보면서 어떻게 구현할지 생각을 했다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하면서 메서드 주석 및 클래스 주석을 작성하려고 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여태까지 팀 안에서 개발자들과의 소통만 생각했었는데, &lt;code&gt;PM&lt;/code&gt; 분과의 소통 하는 방법에 대해서도 생각을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;우리 팀장님은 나이나 실력이 어리다고 무시하지 않고 모두 똑같이 존중을 해주시는 것 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DBMS&lt;/code&gt; 개발자분이 말씀하셨던 것 처럼, 모듈이 어떤 기능을 하는 지 먼저 파악하고 그 다음에, 코드를 보면서 어떻게 구현할지를 생각하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;하지만, 이 모듈 및 클래스 그리고 메서드가 어떤 역할을 하는지 몰라서 작성하지 못했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발자 뿐만 아니라, &lt;code&gt;PM&lt;/code&gt;, &lt;code&gt;QA&lt;/code&gt; 분들간에 내가 무엇을 하고있는지 그리고 언제까지 할 수 있을지를 공유하는것이 중요하다.&lt;/li&gt;
&lt;li&gt;나도 다른 사람들을 한결같이 존중해야겠고, 이러한 자세를 배우려고 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;나는 앞으로 코딩을 할 때, 뭐든지 여태까지 해왔던 것에서 반대로 진행을 해야겠다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;코드를 보기 전에 기능을 파악하기&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;설계를 하기전에 테스트를 작성하기&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;구현을 하기전에 어떻게 구현할지 단계별로 생각하기&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코드 레벨부터 보게 된다면 많은 시행착오를 거치게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;너무 스트레스 받지 않으면서 일을 하고 있다.&lt;/li&gt;
&lt;li&gt;코드에 문서화를 시도하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발자 뿐만 아니라, 모든 분들과 소통을 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;li&gt;문서화를 어떻게 하면 잘 할 수 있는지 살펴보도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;앞으로 다른 모든 직군분들과 소통하려고 노력을 할 것이다.&lt;/li&gt;
&lt;li&gt;문서화를 어떻게 하면 더 잘할 수 있을지 고민하고 남들이 내가 작성할 코드를 보았을 때, 명확하게 이해할 수 있도록 할 것이다.&lt;/li&gt;
&lt;li&gt;개발을 하기전에, 전체적인 기능 및 구현이 어떻게 되어있는지 그리고 어떻게 돌아가는지를 먼저 파악할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>DBMS를 분석하는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</link>
      <pubDate>Wed, 03 Mar 2021 23:32:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html</guid>
      <description>&lt;h3 id=&#34;kcd-2020&#34;&gt;KCD 2020&lt;/h3&gt;
&lt;hr&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/CgxiNF6xigY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;막 오픈소스 컨트리뷰톤을 끝마치고, 오픈소스 개발에 재미를 붙였을 때, KDC 2020이라는 세미나가 열렸다. 오픈소스 데이터베이스 큐브리드에 기여하기라는 제목의 세션을 보았을 때, 오픈소스 DBMS를 개발한다는 부분이 신기했고, 궁금한 점이 있어서 메일을 보내게 되었는데, 친절하게도 아주 장문의 답장을 해주셨다.&lt;/p&gt;
&lt;h3 id=&#34;메일&#34;&gt;메일&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109822109-ffd57b80-7c79-11eb-878d-337a28318428.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 41 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;내가 보낸 메일을 다시 보니까, 많이 부끄럽다;;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109821623-82117000-7c79-11eb-9da5-7f9b3f2d2864.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 37 57 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;매우 유용한 조언을 해주셨고, 실제로 많은 도움이 되었다. 이를 요약하자면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드 레벨에서부터 접근하면 분석하기 쉽지 않다. 특히 DBMS는 여러가지 큰 개념이 모두 함께 유기적으로 동작하기 때문에 (&lt;code&gt;SQL&lt;/code&gt;, &lt;code&gt;Query Rewrite/Optimization&lt;/code&gt;, &lt;code&gt;Index&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞에서 말한 각 모듈들은 코드상으로는 &lt;code&gt;DBMS&lt;/code&gt; 마다 모두 다르게 구현되어 있을 것이다. 따라서 추상적인 개념을 코드로 된 구현체로 최대한 맵핑해보려는 시도를 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어, &amp;ldquo;SQL 파서 모듈은 SQL을 읽어서 파싱 트리라는 구조를 만든다&amp;quot;와 같은 개념들은 DBMS 마다 같지만 코드상으로는 다르게 구현되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQL 파서 모듈과 같이, 각 모듈을 처음부터 코드를 읽어가면서 맨땅부터 이해하는 것은 쉽지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간이 충분하다면 한줄 한줄 분석하면서 파악할 수는 있겠지만 거의 불가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 그 모듈이 어떻게 돌아가는지에 대한 맥락을 먼저 잡아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 현업에서 일을 할 때 도 마찬가지라는 것을 명심해야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;모듈을-분석하는-법&#34;&gt;모듈을 분석하는 법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;1. 개략적인 모듈의 모양을 파악하기 위해서, 모듈의 인터페이스 또는 API나 시작점을 먼저 찾아본다.
2. 모듈을 관통하는 주요 자료구조가 있다면 파악해둔다, (SQL 파서의 경우에는 `파싱트리`) 그 자료구조를 바탕으로 다른 엮여 있는 자료구조나 기능 구현을 파악해나간다.
3. 분석하고 있는 모듈과 관련해서 다른 사람이 이전에 개발했던 기능, 기능/개선, 버그 수정사항에 대한 기록이 있으면 좋다. 
  - 버그 트래킹 시스템이 있으면 먼저 찾아보고, 코드를 보다가 이해되지 않는 부분이 있으면 `git blame`기능으로 어떤 맥락으로 그 코드가 추가되었는지를 찾아보면 좋다.
  - 찾아보았던 기능 개발/개선 기록을 검토하면서 코드 분석을 하다보면 가끔 이전 개발자가 예외 사항들을 놓치는 경우가 있는데 분석한 부분을 잘 이해했다면 기여할 수 있다.
  - 개발자 메뉴얼이나 자료구조/모듈 간의 구조를 그려주는 문서들이 있으면 더 이해가 빠르다. (e.g. https://doxygen.postgresql.org/)
4. 1 ~ 3번을 반복하면서 모듈들을 하나씩 이해해 가다 보면 모듈간에 어떻게 엮여 있는지 개략적으로 알아갈 수 있다. 확실히 코드를 분석하려면 어떤 새로운 기능을 개발하거나 큰 버그를 고친다면 더 자세히 이해할 수 있는 것 같다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 알려주신 개발자 분이 위의 방법대로 한 단계씩 분석을 하면서 각 부분을 접근하고 계신다고 하셨다.
그리고 분석하는 도중에 어떤 버그가 보여서 이건 버그라고 확신할 때 커미터에게 자신이 궁금한 점을 물어보면서 토론을 해보는 것도 좋다고 생각한다고 하셨다.&lt;/p&gt;
&lt;h4 id=&#34;마무리&#34;&gt;마무리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;아쉽게도 현재는 오픈소스 활동을 재개하고 있지 않다. 사실 다시 오픈 소스 활동을 재개하고 싶지만, 현업에서 일을 하다보니 부족한 점이 너무 많아서 부족한 부분을 채우느라 다시 시작할 엄두를 못내고 있다.&lt;/p&gt;
&lt;p&gt;하지만 이번 글을 쓰면서 감사함을 느꼈고 이에 보답하기 위해서라도 오픈 소스 컨트리뷰션을 조만간 다시 재개할 수 있도록 노력을 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doxygen.postgresql.org/&#34;&gt;postgres doxygen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>우아한 테크 코드 지원 후기 및 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 03 Mar 2021 23:15:14 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109818546-707a9900-7c76-11eb-857b-2ee77f773bf0.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 15 58 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에 우아한 테크코스에 지원을 하여 코딩 테스트를 본 적이 있었다. 비록 탈락했지만 다음에 더 잘할 수 있도록 피드백을 주셨다.&lt;/p&gt;
&lt;h3 id=&#34;코딩-테스트&#34;&gt;코딩 테스트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트의 경우 알고리즘 역량이나 풀이 속도도 중요하지만, 문제를 명확하고 꼼꼼히 이해하는 능력이 가장 중요하다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그래머에게 속도가 빠름도 중요하지만, 그 보다는 요구사항을 명확히 이해해 버그없는 프로그래밍을 구현하는게 더 중요하다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;자기소개서&#34;&gt;자기소개서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자기소개서는 구체적으로 쓰는 것이 좋다. 어떤 내용을 학습했다는 결과 위주의 내용이 아니라, 어떤 내용을 학습하는데 어떤 어려움이 있었고, 어떻게 극복했다와 같이 구체적인 사례를 들어서 공감을 얻는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자기소개서에서 얻고 싶은 가장 큰 부분은 여러분이 생각에만 그치지 않고 행동으로 얼마나 실행했는지를 보고 싶은 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;누구나 생각을 할 수는 있지만 이를 실행으로 옮겨 일정 수준의 성취를 만들기란 쉬운 것이 아니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작은 성취라도 만들어가는 과정에서 깨달음들을 보여준다면, 합격률이 조금은 높아질 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>라인 개발자 입사기를 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</link>
      <pubDate>Wed, 03 Mar 2021 21:49:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90.html</guid>
      <description>&lt;h1 id=&#34;지원서-작성할-때-참고할-부분&#34;&gt;지원서 작성할 때, 참고할 부분&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109811374-1a095c80-7c6e-11eb-9077-d4d5a18b0768.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 16 05 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;대외 활동을 했다는 사실 그 자체보다는 그 활동에서 배우고 얼마나 성장했는지를 위주로 적자&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무엇을 했는지가 중요한 것이 아니다, 무엇을 얻었고, 배웠는지를 위주로 작성하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 활동을 하더라도, 자신의 성장을 연결하는 것이 중요하다, 자신의 성장을 감춰두고 혼자만 아는 것 보다는 어떠한 방식으로도 그것을 드러내서 어필하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;신입-개발자가-아닌-경우&#34;&gt;신입 개발자가 아닌 경우&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109811905-bdf30800-7c6e-11eb-844c-0ec338e53c4f.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 20 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스스로 공부해 왔던 내용과, 더불어 내가 어떤 개발자가 되고 싶은지 목표를 설정&lt;/li&gt;
&lt;li&gt;지금 근무하는 곳에서 책임감을 가지고 근무하는 모습이 중요하다.&lt;/li&gt;
&lt;li&gt;이직을 준비하더라도 현재 다니고 있는 직장에 집중하고 최선을 다하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;코딩-테스트-준비&#34;&gt;코딩 테스트 준비&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;선택한 하나의 알고리즘을 난이도 별로 풀어보았다.&lt;/li&gt;
&lt;li&gt;특히 구현, 자료구조 부분은 다른 문제와 연계되는 경우가 많아서 더욱 집중적으로 풀어보았다.&lt;/li&gt;
&lt;li&gt;채용을 준비할 때는 취업을 준비하기전에 풀었던 문제의 절반정도를 풀면서 연습을 했다.&lt;/li&gt;
&lt;li&gt;코딩 테스트라는 과정은 단기간에 실력을 올릴 수 없기 때문에, 매일 또는 매주 꾸준히 코딩 테스트 문제를 풀어보는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;처음 준비를 할 때는 알고리즘 공부를 위한 영상을 찾고, 해당 영상을 들으면서 그날 배웠던 알고리즘과 관련된 문제를 2~3개 정도 풀면서 준비를 했다.&lt;/li&gt;
&lt;li&gt;꾸준히 흥미를 붙여가면서 하는것이 중요하다.&lt;/li&gt;
&lt;li&gt;단기간에 바짝 공부해서 관련 내용을 익히고 문제 풀이 능력을 성장시키는 것보다는, 꾸준하게 문제의 유형과 풀이의 방식을 익히면서 체득하는 것이 많은 도움이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;서류-제출과-관련된-팁&#34;&gt;서류 제출과 관련된 팁!&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;나 자신을 잘 아는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;나&amp;rsquo;를 알아야 어필할 수 있는 포인트도 보이고, 나에게 잘 맞는 직무도 찾을 수 있다.&lt;/li&gt;
&lt;li&gt;내가 지금까지 활동했던 것을 정리해보는 것을 추천한다.&lt;/li&gt;
&lt;li&gt;어떤 경험을 했고, 어떤 일이 일어났고, 어떤 것을 배우고 얻었는지를 중점으로 작성해보는 것이다.&lt;/li&gt;
&lt;li&gt;그리고 나서 지원할 직무와 연결지어서 어떤 경험들을 추려낼지 고민하면서 서류를 작성하면 조금 더 쉬워질 것이다.&lt;/li&gt;
&lt;li&gt;내가 흥미를 느끼는 분야와 기술, 그리고 쌓아온 역량을 직무와 연결지어서 생각해보면 좋을 것이다.&lt;/li&gt;
&lt;li&gt;포트폴리오의 경우에는 진행 했던 프로젝트의 전체 구조와 내가 맡았던 역할, 사용한 기술을 중점으로 만들었다. 그리고 각각의 프로젝트에 해당하는 &lt;code&gt;Git Repository&lt;/code&gt;를 추가하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109813328-8d13d280-7c70-11eb-9fc4-5fbb310702a4.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 33 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포트폴리오를 작성할 때는, &lt;code&gt;문제 발생 - 문제 원인 파악 - 해결책 적용 - 결과&lt;/code&gt; 와 같은 순서로 프로젝트 문제 해결 과정을 서술 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분에 공감을 하는데, 포트폴리오에서 내가 보여줘야할 것은 내가 얼마만큼 알고 할 수 있는 능력이 있는지 보다는, 내가 어떤 분야를 얼마만큼 고민했다는 사실을 어필하는 것이 더 효과적일 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;포트폴리오에서는 자신의 개발 역량이나 팀으로 활동할 때의 자신의 모습을 보여줄 수 있는 것 등 자기소개서에서 드러내지 못한 부분을 보여주면 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;면접을-위해서-따로-준비한-것들&#34;&gt;면접을 위해서 따로 준비한 것들&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;CS(Computer Science) 지식과 프로젝트에서 사용한 기술들을 다시 한 번 정리하였다.&lt;/li&gt;
&lt;li&gt;운영체제, 데이터베이스, 자료구조/알고리즘, 네트워크에 대해서 정리를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;되도록 공식 개발 문서를 레퍼런스로 하여, CS 지식들을 틈틈히 정리하도록 해야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트에서 사용한 기술은 왜 그 기술을 사용했고, 어떤 장/단점을 가지고 있으며, 어떤한 원리로 동작하는지를 중점으로 준비하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;나의 포트폴리오에서 보완해야할 점이다. 왜 그 기술을 사용했는지, 그리고 어떤 장/단점을 가지고 있는지, 어떠한 원리로 동작하는지 고민을 많이하지 않았다.따라서 이러한 부분을 개선하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다른 사람들에게 자신의 포트폴리오를 보여주고 피드백을 얻는 것도 좋은 방법이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접을 위해서는 자기소개서와 포트폴리오를 다시 확인하면서 예상 질문을 확인하였고, 또한 블로그에 포스팅한 내용들을 공부하며 범위를 넓혔다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접을 보기 전에, 친구들과 모의 면접을 보거나 휴대폰으로 답변하는 모습을 촬영하면서 준비하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;답변할 때는 스스로 어필하고 싶거나 강조하고 싶은 점에 대해서는 톤을 달리하고, 시선 처리는 한곳만 바라보거나 허공을 바라보지 않게 면접관들을 번갈아 볼 수 있게 준비하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;답변할 수 있는 것은 자신있게 답변하고, 모르는 것은 모른다고 답하되 보완할 방법이나 알고 있는 비슷한 개념을 엮어 답변을 할 수 있도록 준비해라&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자신이 제출한 자기소개서, 이력서, 포트폴리오를 2 ~ 3번 정독하고 면접관들이 어떤 부분에서 궁금할지를 예측하여 자문자답하면서 내용을 정리&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접은 &amp;lsquo;어떻게&amp;rsquo;보다 &amp;lsquo;왜&amp;rsquo;라는 질문을 받았을 때 제대로 답변할 수 있도록 준비를 하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대답을 못한다고 감점은 없다, 따라서 모르면 모른다고 답변을 하고 모든 것을 후회없이 보여줄 수 있도록 준비를 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 준비를 꾸준히 하자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 관련 지식들을 꾸준히 리마인드 하고, 블로그에 잘 정리를 하자.&lt;/li&gt;
&lt;li&gt;포트폴리오는 왜 이러한 기술을 사용했고, 문제점, 및 문제를 해결한 과정이 잘 녹아들어 있어야 한다.&lt;/li&gt;
&lt;li&gt;면접은 &amp;lsquo;어떻게&amp;rsquo;보다는 &amp;lsquo;왜&amp;rsquo;라는 질문에 답을 할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;면접 질문 기반이 자기소개서 및 포트폴리오에서 나오므로 자기소개서 및 포트폴리오를 처음부터 잘 작성하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linecorp.com/ko/blog/2020-first-half-new-liners-interview/&#34;&gt;2020 상반기 LINE 신입 개발자 3인의 WOW한 입사기!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스키마를 관리하는 도구, Flyway</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway.html</link>
      <pubDate>Wed, 03 Mar 2021 20:09:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway.html</guid>
      <description>&lt;h1 id=&#34;데이터베이스-스키마-관리의-필요성&#34;&gt;데이터베이스 스키마 관리의 필요성&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;최근에 회사에서 기존에 &lt;code&gt;AWS&lt;/code&gt;에서 서비스하던 서비스를 &lt;code&gt;ALI&lt;/code&gt; 클라우드에서 제공해야하는 일이 있었다. 따라서 데이터베이스 스키마와 마스터 데이터를 새로운 클라우드 환경으로 이전을 시켜줘야 했다.&lt;/p&gt;
&lt;p&gt;비교적 규모가 큰 서비스는 아니여서, 덤프를 이용해서 간단하게 이전하였고, 데이터베이스 스키마 및 마스터 데이터를 쿼리문 형태로 만들어서 GIT으로 형상관리를 하였다.&lt;/p&gt;
&lt;p&gt;이 정도로 모든 일이 마무리 되기는 하였지만, 어딘가 부족한 느낌이 들었다. 왜냐하면 개발을 하면서 DB 스키마가 변경할 일이 있는데 그럴 때마다 쿼리문으로 테이블 스키마를 변경하고, 스키마 파일을 업데이트 해야했기 때문이다. 문제는 변경해줘야 할 환경이 &lt;code&gt;AWS&lt;/code&gt;, &lt;code&gt;ALI&lt;/code&gt; 각각 &lt;code&gt;DEV&lt;/code&gt;, &lt;code&gt;EDU&lt;/code&gt;, &lt;code&gt;STG&lt;/code&gt;, &lt;code&gt;PROD&lt;/code&gt;이 존재하므로 8 개의 환경을 업데이트 해주어야 했습니다. 그리고 메일 서버가 바라보는 테이블까지 생각하면 서비스가 조금만 더 확장된다면 엄청나게 힘들어 질 것이다.&lt;/p&gt;
&lt;p&gt;게다가 단순한 컬럼 값 추가, 삭제가 아니라 컬럼이 어떤 연산을 통해서 새로운 값을 가져야 하거나, 새로운 테이블을 만들어 기존 데이터를 옮기거나 하는 좀 더 복잡한 작업이 되면 엄청나게 복잡해 질 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 현대적인 애플리케이션 개발 환경에서는 단일 DB 스키마가 아니라, 변화를 다루는 마이그레이션 스크립트를 만들어서 사용한다. 소스 코드 저장소에 함께 포함을 시키고, 모든 환경에서 서버를 구동하기 전에 적용시키는 방법을 사용한다.&lt;/p&gt;
&lt;h1 id=&#34;flyway&#34;&gt;Flyway&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109799728-b5470580-7c5f-11eb-9f0a-6ca5e87ae745.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 32 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flyway&lt;/code&gt;는 오픈소스 데이터베이스 마이그레이션 도구이다.&lt;/li&gt;
&lt;li&gt;마이그레이션은 &lt;code&gt;SQL&lt;/code&gt; 또는 &lt;code&gt;Java&lt;/code&gt;로 작성할 수 있다.&lt;/li&gt;
&lt;li&gt;일곱 가지의 간단한 명령어로 구성되어 있다. (&lt;code&gt;Migrate&lt;/code&gt;, &lt;code&gt;Clean&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Validate&lt;/code&gt;, &lt;code&gt;Undo&lt;/code&gt;, &lt;code&gt;Baseline&lt;/code&gt;, &lt;code&gt;Repair&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;다양한 패키지 및 빌드 도구에서 지원하며 플러그인 형태로도 이용할 수 있다.&lt;/li&gt;
&lt;li&gt;많은 DBMS를 지원한다. (&lt;code&gt;MySQL&lt;/code&gt;, &lt;code&gt;Postgres&lt;/code&gt;, &lt;code&gt;H2&lt;/code&gt;, &amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이그레이션이-필요한-이유&#34;&gt;마이그레이션이 필요한 이유&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109800868-16bba400-7c61-11eb-9b83-9dff2469cf53.png&#34; alt=&#34;Environments&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션의 경우, &lt;code&gt;GIT&lt;/code&gt;과 같은 형상 관리 툴로, 재현 가능한 구조와 CI 환경을 구성할 수 있다.&lt;/li&gt;
&lt;li&gt;릴리즈 및 배포 프로세스를 잘 정의함으로써, 이를 관리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801147-6ef2a600-7c61-11eb-8058-c5086b4a1522.png&#34; alt=&#34;DbRed&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;불행하게도 애플리케이션과 데이터베이스 간의 불일치가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 여전히 많은 프로젝트가 수동으로 적용된 &lt;code&gt;SQL&lt;/code&gt; 스크립트에 의존하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스 마이그레이션은 이러한 혼란을 제어할 수 있는 좋은 방법이다. 마이그레이션은 위와 같은 문제에 대해서 다음과 같은 이점을 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 데이터베이스 다시 만들기&lt;/li&gt;
&lt;li&gt;데이터베이스가 어떤 상태인지 확인&lt;/li&gt;
&lt;li&gt;현재 버전의 데이터베이스에서 새로운 데이터베이스로 마이그레이션&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flyway-작동-원리&#34;&gt;Flyway 작동 원리&lt;/h3&gt;
&lt;p&gt;가장 간단한 경우는 &lt;code&gt;Flyway&lt;/code&gt;가 비어있는 데이터베이스를 가리킬 때입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801736-3bfce200-7c62-11eb-81eb-a3ea67e714dd.png&#34; alt=&#34;EmptyDb&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 비어있으므로, &lt;code&gt;Flyway&lt;/code&gt;는 데이터베이스를 찾지 못하고 대신 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;Flyway&lt;/code&gt;는 마이그레이션을 위해서 파일 시스템 및 응용 프로그램의 클래스 경로를 탐색하기 시작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런 다음에 마이그레이션은 버전 번호를 기준으로 정렬되고 순서대로 적용될 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801958-87af8b80-7c62-11eb-9c7d-0f55a59c44b5.png&#34; alt=&#34;Migration-1-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 마이그레이션이 적용될 때마다 스키마 기록 테이블이 업데이트 되며 이러한 이력 데이터로 특정 버전으로 쉽게 마이그레이션을 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109802186-d9581600-7c62-11eb-958a-c9726222a374.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 55 48 PM&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론&lt;/h1&gt;
&lt;p&gt;현재 진행하는 프로젝트에 도입을 해도 괜찮을 것 같고, 마치 깃을 사용하는 것 같이 특정 버전의 스키마로 쉽게 돌아갈 수 있다는 것이 편리할 것 같다. 기존에는 특정 버전의 스키마를 보려면 깃으로 특정 버전의 스키마를 조회한 다음에 도커 가상 환경에서 마이그레이션을 하고 나서 테스트를 했다. 이렇게 진행하니까 테스트를 하기 위해서 준비해야할 것도 많고 번거로웠다. 지금 당장은 괜찮을지 몰라도 나중을 위해서 우선 시험삼아서 사용해보고 좋다면 팀원에게 소개를 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://flywaydb.org/documentation/getstarted/why&#34;&gt;Flyway, documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 @classmethod와 @staticmethod 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Wed, 03 Mar 2021 08:45:13 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;p&gt;파이썬을 코딩을 하다가 &lt;code&gt;@classmethod&lt;/code&gt; 데코레이터가 붙어 있는 메서드를 볼 수 있었다. 정확히 어떤 역할을 하는지 몰라서 문서에서 찾아보았다.&lt;/p&gt;
&lt;h4 id=&#34;classmethod&#34;&gt;@classmethod&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109730703-420ca780-7bfd-11eb-9a41-47561874c29e.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 48 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드를 클래스 메서드로 변환합니다.&lt;/li&gt;
&lt;li&gt;클래스 메서드는 인스턴스 메서드가 인스턴스를 받는 것 처럼 클래스를 암시적인 첫 번째 인수로 수신한다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클래스 메서드는 다음과 같이 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;클래스 메서드는 다음과 같이 호출 될 수 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C.f()&lt;/code&gt;, &lt;code&gt;C().f()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;앞의 경우에는 클래스에서 호출 된 것이고, 뒤의 경우에는 인스턴스에서 호출 된 것이다.&lt;/li&gt;
&lt;li&gt;클래스 메서드가 상속 받은 클래스에서 호출되면 상속 받은 클래스가 첫 번째 인수로 전달된다.&lt;/li&gt;
&lt;li&gt;클래스 메서드는 &lt;code&gt;C++&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt;의 스태틱 메서드와는 다르다, 만약 앞의 경우로 스태틱 메서드를 사용하고 싶다면, &lt;code&gt;@staticmethod&lt;/code&gt; 를 사용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기까지만 봐서는 정적 메서드랑 무슨 차이인지 알기 힘들었다. 따라서 정적 메서드 관련된 문서를 확인해봤다.&lt;/p&gt;
&lt;h4 id=&#34;staticmethod&#34;&gt;@staticmethod&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109732266-3a9acd80-7c00-11eb-98b4-bd34b94a81fb.png&#34; alt=&#34;Screen Shot 2021-03-03 at 9 09 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드를 정적 메서드로 변환시켜 줍니다.&lt;/li&gt;
&lt;li&gt;정적 메서드는 암시적으로 첫 번째 인수를 받지 않습니다.&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용하는 방법은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class C:
    @staticmethod
    def f(arg1, arg2, ...): ...
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;정적 메서드는 다음과 같이 호출 될 수 있습니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C.f()&lt;/code&gt;, &lt;code&gt;C().f()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데코레이터와 마찬가지로, 정적 메서드를 &lt;code&gt;regular&lt;/code&gt; 함수 처럼 호출 할 수 있다.&lt;/li&gt;
&lt;li&gt;클래스 바디에 함수에 대한 참조가 필요하고 인스턴스 메서드로 자동 변환하지 않으려는 경우에 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class C:
    builtin_open = staticmethod(open)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;차이점&#34;&gt;차이점&lt;/h4&gt;
&lt;p&gt;얼핏봐서는 차이점을 크게 못느껴서 인터넷을 찾아본 결과 좋은 글을 볼 수 있었다. &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@classmethod&lt;/code&gt;와 &lt;code&gt;@staticmethod&lt;/code&gt;는 상속에서 차이가 난다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person:
    default= &amp;quot;아빠&amp;quot;

     def __init__(self):
        self.data = self.default

    @classmethod
    def class_person(cls):
        return cls()

    @staticmethod
    def static_person():
        return Person()

class WhatPerson(Person):
    default = &amp;quot;엄마&amp;quot;
person1 = WhatPerson.class_person()    # return 엄마
person2 = WhatPerson.static_person()   # return 아빠
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같이 &lt;code&gt;@staticmethod&lt;/code&gt;인 경우에는 부모 클래스의 속성 값을 가져오지만, &lt;code&gt;@classmethod&lt;/code&gt;의 경우 cls 인자를 활용하여 클래스의 클래스 속성을 가져온다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://julien.danjou.info/guide-python-static-class-abstract-methods/&#34;&gt;The definitive guide on how to use static, class or abstract methods in Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#classmethod&#34;&gt;https://docs.python.org/3/library/functions.html#classmethod&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#staticmethod&#34;&gt;https://docs.python.org/3/library/functions.html#staticmethod&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@hckcksrl/python-%EC%A0%95%EC%A0%81%EB%A9%94%EC%86%8C%EB%93%9C-staticmethod-%EC%99%80-classmethod-6721b0977372&#34;&gt;https://medium.com/@hckcksrl/python-%EC%A0%95%EC%A0%81%EB%A9%94%EC%86%8C%EB%93%9C-staticmethod-%EC%99%80-classmethod-6721b0977372&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 03 Mar 2021 08:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 WSGI에 대해서 정리를 해보았다.&lt;/li&gt;
&lt;li&gt;오늘 &lt;code&gt;@staticmethod&lt;/code&gt;, &lt;code&gt;@classmethod&lt;/code&gt;에 대해서 조사 및 정리를 하였다.&lt;/li&gt;
&lt;li&gt;이슈를 진행하던 도중에 &lt;code&gt;@classmethod&lt;/code&gt;를 사용하는 코드를 보았고, 무슨 역할을 하는지 몰라서 찾아보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그냥 모르고 관성적으로 쓰는 것보다 이게 왜 사용되었는지 알고 생각하면서 사용하니까 훨씬 많이 배우는 느낌이고 자신감이 생긴것 같다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하다가 비슷한 예외가 많이 발생하여, 이러한 예외가 발생하고 있다고 말했는데 실제로는 그러한 예외가 호출되지 않고 다른 예외가 호출되었다.&lt;/li&gt;
&lt;li&gt;요즘 공식 문서를 읽고 정리하는 것에 재미를 붙였다. 글을 읽고 요약하는 것도 좋지만, 실제 개발을 하면서 이를 생각하는지 또는 내가 진정으로 문제에 대해서 고민을 하는 것이 더 중요할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것이 있으면 그냥 넘어가지말고 고민해야할 것이 있으면 충분히 고민하자.&lt;/li&gt;
&lt;li&gt;모르는 것이 있으면 추측을 해서 말하지 말고 확실히 눈으로 확인하고 말하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소통을 하려고, 내가 진행한 내용을 공유하려고 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;버그나 문제점을 발견할 때, 확인을 제대로 하지 않고 말하는 경향이 있다. 이러한 점을 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;내가 발견한 사실 및 곧 해결책이 나올 것 같으면 흥분해서 상대방에게 성급하게 말하는 경향이 있다. 이를 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;공유를 할 때 내용이 정리가 되지 않은 상태에서 말을 하려고 하니 횡설수설 한다.&lt;/li&gt;
&lt;li&gt;내가 한 작업을 공유 하려는 행동이지만 상대방에게는 집중을 방해하는 것일 수도 있을 것 같다. 따라서 사내 채팅으로 내가 진행한 내용을 간단하게 공유하고 필요하다면 화면 녹화로 내가 무엇을 했는지 알려주는 방식도 고려해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것이 있으면 끝까지 알아볼 것이고, 내가 작성한 코드에 당위성을 부여할 것이다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때, 흥분하지 말고 그럴 때 위험한 신호라고 생각하고 한번 더 생각하고 한번 더 검토하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>WSGI</title>
      <link>https://dongwooklee96.github.io/post/2021/03/02/wsgi.html</link>
      <pubDate>Tue, 02 Mar 2021 14:39:13 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/02/wsgi.html</guid>
      <description>&lt;h1 id=&#34;플라스크와-wsgi&#34;&gt;플라스크와 WSGI&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109603667-7896e380-7b65-11eb-8e62-961951e0c969.png&#34; alt=&#34;Screen Shot 2021-03-02 at 2 42 04 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;플라스크 문서를 살펴보다가 다음과 같은 문장을 보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플라스크는 &lt;code&gt;Jinja&lt;/code&gt; 템플릿 엔진과 &lt;code&gt;Werkzeug WSGI&lt;/code&gt; 툴킷에 의존하고 있다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109604060-37530380-7b66-11eb-8217-e8c8a95ae4ec.png&#34; alt=&#34;Screen Shot 2021-03-02 at 2 47 21 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;가 무엇을 하는 툴인지 몰라서 검색을 해본 결과 다음과 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Werkzeug&lt;/code&gt;는 포괄적인 &lt;code&gt;WSGI&lt;/code&gt; 웹 애플리케이션 라이브러리이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt; 응용 프로그램을 위한 단순한 유틸리티에서 시작하였지만, 현재는 가장 진보한 &lt;code&gt;WSGI&lt;/code&gt; 유틸리티 라이브러가 되었다.&lt;/li&gt;
&lt;li&gt;플라스크는 &lt;code&gt;Werkzeug&lt;/code&gt;를 감싸 &lt;code&gt;WSGI&lt;/code&gt;의 세부사항을 처리하는 동시에 강력한 애플리케이션을 위한 더 많은 구조와 패턴을 제공한다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;는 다음을 포함하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에 있는 스택 트레이스와 코드를 검사할 수 있는 디버거를 포함한다.&lt;/li&gt;
&lt;li&gt;헤더, 쿼리 인자, 폼 데이터, 파일 및 쿠키와 상호 작용할 수 있는 요청 객체이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;플라스크는 내부적으로 &lt;code&gt;Werkzeug&lt;/code&gt;로 구현되어 있고, &lt;code&gt;Werkzeug&lt;/code&gt;는 &lt;code&gt;WSGI&lt;/code&gt;를 구현하는 라이브러리이다.
그렇다면 자연스럽게 &lt;code&gt;WSGI&lt;/code&gt;가 무엇인지 궁금하였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109774010-38a62e00-7c43-11eb-9a90-3e95c3090c30.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 09 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt;는 웹 서버 게이트웨이 인터페이스이다.&lt;/li&gt;
&lt;li&gt;웹 서버가 웹 애플리케이션과 통신하는 방법과 웹 애플리케이션을 연결하여 하나의 요청을 처리하는 방법을 설명하는 규격 입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt;는 &lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/&#34;&gt;PEP 3333&lt;/a&gt;에 설명되어 있는 파이썬 표준이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문서의 양이 방대하므로 지금 모두 설명하는 것보다는 따로 나중에 관련된 페이지를 만들어서 공부를 해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109775165-81aab200-7c44-11eb-8455-d5db0d39f127.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 18 38 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이썬은 다양한 웹 애플리케이션 프레임워크가 있고 웹 프레임 워크의 선택이 사용가능한 웹 서버 선택을 제한할 수 있고 그 반대의 경우도 마찬가지이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 대조적으로, 자바의 서블릿 API를 지원하는 웹 서버에서 자바 웹 애플리케이션 프레임워크로 작성된 애플리케이션을 실행할 수 있게 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프레임워크 선택과 웹 서버 선택을 분리함으로써, 사용자는 자신에게 맞는 조합을 선택할 수 있고, 프레임워크와 서버 개발자는 원하는 분야에 집중할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이 &lt;code&gt;PEP&lt;/code&gt; 문서는 웹 서버와 웹 애플리케이션 또는 프레임워크 사이의 단순하고 보편적인 인터페이스인 파이썬 웹 서버 게이트웨이 인터페이스를 제안하는 문서이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WSGI&lt;/code&gt;의 목표는 새로운 웹 프레임워크를 만드는 것이 아니라 기존 서버, 애플리케이션 또는 프레임워크의 쉬운 상호 연결을 촉진하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;wsgi-개요&#34;&gt;WSGI 개요&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109776796-52954000-7c46-11eb-93eb-f622fd14dccf.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 31 36 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WSGI 인터페이스는 서버, 게이트웨이 측면과 애플리케이션, 프레임워크 측면이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 측에서 응용 프로그램이 제공하는 &lt;code&gt;Callable&lt;/code&gt; 객체를 호출한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 객체의 제공 방법은 서버 또는 게이트웨이에 따라서 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;순수한 서버/게이트웨이 및 애플리케이션/프레임워크 외에도, 이 규격 양쪽을 모두 구현하는 &amp;ldquo;중간 소프트웨어&amp;rdquo; 컴포넌트를 만들 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 규격에서 &lt;code&gt;Callable&lt;/code&gt; 이라는 용어는 &lt;code&gt;__call__&lt;/code&gt; 메서드를 가지는 함수, 메서드, 클래스, 그리고 인스턴스를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;필요에 따라 적절한 구현 기술을 선택하는 것은 &lt;code&gt;Callable&lt;/code&gt;을 구현하는 서버, 게이트웨이 또는 애플리케이션에 달려 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반대로 &lt;code&gt;Callable&lt;/code&gt;을 호출하는 서버, 게이트웨이 또는 응용 프로그램은 &lt;code&gt;Callable&lt;/code&gt; 타입에 종속되지 않아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 서버와 프레임워크를 분리하기 위해서 생겨났다.&lt;/li&gt;
&lt;li&gt;WSGI는 웹 서버와 애플리케이션이 통신하는 방법과 요청을 처리하는 방법을 설명한 규약이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://flask.palletsprojects.com/en/1.1.x/&#34;&gt;https://flask.palletsprojects.com/en/1.1.x/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://palletsprojects.com/p/werkzeug/&#34;&gt;https://palletsprojects.com/p/werkzeug/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 02 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 강의를 들엇다. (JWT 토큰에 대해서 알게 되었다.)&lt;/li&gt;
&lt;li&gt;오늘 회사에서 일을 할 때, 적극적으로 의사소통을 하려고 노력하였다.&lt;/li&gt;
&lt;li&gt;플라스크 관련된 문서를 정리해보았다.&lt;/li&gt;
&lt;li&gt;퇴근하는 길에, 라인 개발자 채용 관련 QnA 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;적극적으로 의사소통을 하니, 동료들과 소통이 더 잘되는 느낌이였다.&lt;/li&gt;
&lt;li&gt;라인 채용 유튜브 영상을 보니, 컴퓨터공학 기반 지식과 알고리즘 그리고 코딩테스트를 중요하게 여기는 것 같았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소통하려는 의지만 있어도 동료들이 알아차리고 좋게 봐주는 것 같다.&lt;/li&gt;
&lt;li&gt;소트프 스킬 또한 하드 스킬 못지 않게 중요하다는 것을 알게되었다.&lt;/li&gt;
&lt;li&gt;회사를 다니기 전에는 회사에서 소통하는 능력이 얼마나 중요한지를 모르고 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 잘 보기 위해서는 자료 구조 및 알고리즘이 중요하고, 면접을 잘 보기 위해서는 운영체제, 자료구조, 데이터베이스 등 컴퓨터공학 기반 지식이 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;업무에 있어서는 TMI형 인간이 되는 것이 좋다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 했던 일을 상대방에게 전달을 하려고 노력하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 공부를 하다가 매번 흐지부지 되는데, 꾸준히 노력하는것이 중요할 것 같고 TDD를 접목하여 두마리 토끼를 잡을 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꾸준하게 블로그 글을 작성하면서 컴퓨터 공학 기반 지식 및 웹 개발을 하는데 기반 지식들을 갈고 닦아야겠다.&lt;/li&gt;
&lt;li&gt;코딩 테스트 공부를 꾸준하게 하여, 필요할 때 능력 발휘를 못하는 일이 없도록 해야겠다.&lt;/li&gt;
&lt;li&gt;어학 능력을 키워서 개발자로서 성장하는데 제약이 없도록 하겠다.&lt;/li&gt;
&lt;li&gt;업무에 있어서는 TMI형 인간이 되자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces.html</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces.html</guid>
      <description>&lt;h1 id=&#34;executor-interfaces&#34;&gt;Executor Interfaces&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;, 태스크를 관리하는 인터페이스 입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt;는 &lt;code&gt;Executor&lt;/code&gt;의 하위 인터페이스이며 태스트와 &lt;code&gt;Exector&lt;/code&gt;의 라이프 사이클을 관리하는 기능을 포함하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;는 &lt;code&gt;ExecutorService&lt;/code&gt;의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executor-인터페이스&#34;&gt;Executor 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109464198-a159a300-7aa9-11eb-87f8-85c69935a454.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 16 49 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465577-bf280780-7aab-11eb-98d3-3fd65c0177ec.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 32 36 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt; 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executorservice-인터페이스&#34;&gt;ExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465963-542b0080-7aac-11eb-929c-517e84df5f5c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 36 24 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.submit(() -&amp;gt; {
            System.out.println(&amp;quot;Thread &amp;quot; + Thread.currentThread().getName());
        });

        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다음작업이 들어올 때가지 계속 대기를 하기 때문에 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;showdown()&lt;/code&gt; 메서드를 사용하여 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shutdown-과-shutdownnow의-차이점&#34;&gt;shutdown() 과 shutdownNow()의 차이점&lt;/h4&gt;
&lt;p&gt;메서드 주석을 읽어본 결과 다음과 같은 차이가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109467219-35c60480-7aae-11eb-920c-201a60fb2a75.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt; 메서드는 이전에 제출된 태스트가 실행이 되고 더 이상 새로운 태스크는 수락하지 않으며 작업을 종료하기 시작한다. 하지만 &lt;code&gt;shutdownNow()&lt;/code&gt; 메서드는 실행 중인 작업이 종료될 때까지 기다리지 않고 실행중인 작업 처리를 중단 하려는 보장을 할 수 없다고 되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scheduledexecutorservice-인터페이스&#34;&gt;ScheduledExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465999-61e08600-7aac-11eb-892d-ee3b46714715.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 37 15 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt; 인터페이스는 지정한 지연시간 후에 실행 또는 호출 가능한 태스크를 실행하는 기능을 지원한다.&lt;/li&gt;
&lt;li&gt;지정된 태스크를 정의된 간격으로 반복적으로 실행하는 &lt;code&gt;scheduledWithFixedDelay&lt;/code&gt; 및 &lt;code&gt;ScheduledAtFixedRate&lt;/code&gt;를 정의합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰레드-풀&#34;&gt;쓰레드 풀&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109468299-bcc7ac80-7aaf-11eb-8e93-2e15be786920.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 패키지의 Executor 구현은 대부분은 워커 쓰레드로 구성된 쓰레드 풀을 사용한다. 이러한 종류의 스레드는 &lt;code&gt;Runnable&lt;/code&gt; 및 &lt;code&gt;Callable&lt;/code&gt;로 각각 존재하며 여러가지 태스크를 실행하는데 종종 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;워커 쓰레드를 사용하면 스레드 생성으로 인한 오버헤드가 최소화 된다. 스레드 개체는 상당한 양의 메모리를 사용하며, 대규모 애플리케이션에서는 많은 스레드 개체를 할당 및 할당 해제하면 상당한 메모리 관리 오버헤드가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 유형의 쓰레드 풀은 쓰레드의 개수가 고정되어 있고 이 유형의 풀에서는 항상 지정된 수의 스레드가 실행되며, 스레드가 동작할 때 갑자기 종료되면 새로운 스레드로 교체되어 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;태스크는 큐를 통해서 풀에 제출되며 풀에 있는 스레드보다 많은 태스크가 있을 때는 잠시 큐에서 대기한다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;runnable-과-callable의-차이&#34;&gt;Runnable 과 Callable의 차이&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469393-4d52bc80-7ab1-11eb-89d4-24e040a2161c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 스레드에 의해서 실행되도록 설계된 모든 클래스에 의해 구현되어야 한다.&lt;/li&gt;
&lt;li&gt;클래스는 &lt;code&gt;Run()&lt;/code&gt; 메서드를 정의해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469486-6fe4d580-7ab1-11eb-886c-bdddc2d8fa90.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과를 반환하고 예외를 발생시킬 수 있는 작업이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 인터페이스는 다른 스레드에 의해서 잠재적으로 실행될 수 있다는 점에서 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스와 유사하지만 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 결과를 반환하지 않으며 선택한 예외를 발생시킬 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;forkjoin-프레임워크&#34;&gt;Fork/Join 프레임워크&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109471877-c1429400-7ab4-11eb-91fa-723f310cf9b9.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 37 04 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포크/조인 프레임워크는 여러 프로세서를 활용할 수 있도록 지원하는 &lt;code&gt;ExecutorService&lt;/code&gt; 인터페이스의 구현이다.&lt;/li&gt;
&lt;li&gt;반복적으로 작은 조각으로 쪼개 질 수 있는 작업을 위해서 고안이 되었다.&lt;/li&gt;
&lt;li&gt;다른 &lt;code&gt;ExecutorService&lt;/code&gt; 구현과 마찬가지로 포크/조인 프레임워크도 쓰레드 풀에 있는 워커 쓰레드에게 작업을 할당한다.&lt;/li&gt;
&lt;li&gt;포크/조인 프레임워크는 워크 스틸링 알고리즘을 사용하는 점에서 차이가 있고 할 일이 부족한 워커 쓰레드는 작동중인 다른 쓰레드에서 작업을 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html</guid>
      <description>&lt;h1 id=&#34;동시성이란-concurrency&#34;&gt;동시성이란? (Concurrency)&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성-프로그래밍이란&#34;&gt;동시성 프로그래밍이란?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109454793-6438e500-7a98-11eb-9454-cc8af1cbfb76.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 13 30 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다.
유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다. 워드 프로세서 조차도 텍스트 서식을 변경하거나 디스플레이를 업데이트 하는 작업이 아무리 바쁘더라도 키보드 및 마우스 이벤트에 항상 응답을 할 준비가 되어있어야 합니다. 이러한 작업을 수행할 수 있는 소프트웨어를 동시성 소프트웨어라고 합니다.
자바 플랫폼은 동시성 프로그래밍을 지원하도록 처음부터 설계되었습니다. 자바 버전 5.0부터 자바는 높은 수준의 동시성 API를 포함하고 있습니다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&#34;프로세스와-쓰레드&#34;&gt;프로세스와 쓰레드&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109455687-7d429580-7a9a-11eb-9d1f-8155d55cbbf2.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 29 04 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성 프로그래밍에서는 두가지의 기본 실행 단위가 있다. 자바에서는 동시성 프로그래밍은 주로 쓰레드와 관련이 있지만, 프로세스 역시 중요하다. 컴퓨터 시스템에서 일반적으로 많은 프로세스와 스레드가 있다. 이는 단일 코어 시스템에서도 마찬가지이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109456633-99dfcd00-7a9c-11eb-886e-52f965f26b10.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 44 12 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;프로세스&#34;&gt;프로세스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 자체적으로 포함된 실행 환경이 있다. 일반적으로 프로세스에서는 개인적인 리소스 공간이 존재하고 특히 각각의 프로세스에는 자체적인 메모리 공간을 가집니다.&lt;/li&gt;
&lt;li&gt;대부분의 자바 가상 머신 구현은 단일 프로세스로 실행된다. &lt;code&gt;Java&lt;/code&gt;는 &lt;code&gt;ProcessBuilder&lt;/code&gt; 를 이용하여 추가적인 프로세스를 생성할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;쓰레드&#34;&gt;쓰레드&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 때때로 경량 프로세스라고 불리우며, 프로세스와 쓰레드 모두 실행 환경을 제공하지만 새로운 쓰레드를 만드는데 필요한 리소스가 새 프로세를 만드는 것보다 적은 비용이 든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 프로세스 내에 존재하며 모든 프로세스에는 최소한 한 개의 쓰레드가 있다. 쓰레드는 프로세스의 메모리, 열린 파일 및 자원을 공유합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 자원 공유는 쓰레드 간의 소통에 효율적이지만 잠재적으로 문제를 일으킬 수 있습니다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;자바에서-쓰레드를-사용하는-방법&#34;&gt;자바에서 쓰레드를 사용하는 방법&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;자바에서 쓰레드를 사용할 수 있는 방법에는 크게 3가지가 있다.&lt;/p&gt;
&lt;h4 id=&#34;1-thread를-상속-받는-방법&#34;&gt;1. Thread를 상속 받는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();

        System.out.println(&amp;quot;Hello&amp;quot;);
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-runnable을-구현하는-방법&#34;&gt;2. Runnable을 구현하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3-람다를-사용하는-방법&#34;&gt;3. 람다를 사용하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;쓰레드의-주요-기능&#34;&gt;쓰레드의 주요 기능&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&#34;sleep&#34;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460950-d0b9e100-7aa4-11eb-86c8-29276cda855f.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 59 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep&lt;/code&gt; 은 스레드가 지정된 기간 동안 실행을 일시 중단 하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InterruptedException&lt;/code&gt;은 스레드가 슬립된 상태에서 다른 스레드가 현재 스레드를 인터럽트 시킬 떄 발생된다.&lt;/li&gt;
&lt;li&gt;위의 예제에서는 쓰레드가 1초동안 슬립 되었다가 다시 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;interrupt&#34;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460917-ba138a00-7aa4-11eb-85d3-0ad70e163bdf.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 22 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            while (true) {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    System.out.println(&amp;quot;interrupt!&amp;quot;);
                    return;
                }
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        Thread.sleep(3000L);
        thread.interrupt();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;interrupt()&lt;/code&gt; 메서드를 호출 했을 때 &lt;code&gt;InterruptedException&lt;/code&gt; 예외가 발생하고 예외 처리 구문이 실행된다.&lt;/li&gt;
&lt;li&gt;스레드가 인터럽트 되었을 때, 처리하는 방식은 프로그래머가 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460851-a10ad900-7aa4-11eb-8f02-8d5812cd1f80.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 41 37 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
        });
        thread.start();

        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        thread.join();
        System.out.println(thread + &amp;quot; is finished&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt;을 사용하면 스레드가 다른 스레드가 끝날 때까지 기다려준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;과 마찬가지로 &lt;code&gt;join()&lt;/code&gt;은 인터럽트가 되면  &lt;code&gt;InterruptedException&lt;/code&gt;을 호출하면서 종료 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 01 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 공부를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정답을 맞추는 것 뿐만 아니라, 더 좋은 방법은 없는지 생각을 해보는 것이 중요하다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;더 좋은 방법이 없는지 생각해보는 것은 실제로 코딩을 할 때, 지금보다 나은 방법이 없는지 꾸준히 고민하게 해주는 습관을 기를 수 있게 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 문제를 풀 때, 입력 값을 받는 코드를 넣으면 테스트 하기 불편해진다. 따라서 입력 값은 모두 매개변수로 따로 빼면 테스트 하기 편해진다. 그리고 가장 나중에 입력 값을 넣어주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩을 할 때, 내가 작성한 코드보다 더 나은 방법은 없는지 끊임없이 고민을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
      <description>&lt;h1 id=&#34;그리디-알고리즘&#34;&gt;그리디 알고리즘&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;현재 상황에서 좋아 보이는 것만을 선택하는 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 문제가 있을 때 단순 무식하게 탐욕적으로 푸는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;여기서 탐욕적이라는 말은 &amp;lsquo;현재 상황에서 지금 당장 좋은 것을 고르는 방법&amp;rsquo;을 의미한다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 유형&amp;rsquo; 이라는 특징이 있다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘 유형의 문제는 매우 다양하기 때문에, 암기한다고 해서 항상 잘 풀수 있는 것은 아니다.&lt;/li&gt;
&lt;li&gt;많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;문제-1-거스름돈&#34;&gt;문제 1: 거스름돈&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한이 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def solve(money):
    ret = 0
    if money &amp;gt;= 500:
        ret += money // 500
        money %= 500

    if money &amp;gt;= 100:
        ret += money // 100
        money %= 100

    if money &amp;gt;= 50:
        ret += money // 50
        money %= 50

    if money &amp;gt;= 10:
        ret += money // 10
        money %= 10

    return ret
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;from problem import solve


def test_solve1():
    assertMoney(1300, 5)
    assertMoney(1260, 6)
    assertMoney(500, 1)
    assertMoney(260, 4)
    assertMoney(200, 2)
    assertMoney(150, 2)
    assertMoney(110, 2)
    assertMoney(100, 1)
    assertMoney(90, 4)
    assertMoney(80, 4)
    assertMoney(60, 2)
    assertMoney(50, 1)
    assertMoney(40, 4)
    assertMoney(10, 1)
    assertMoney(0, 0)


def assertMoney(money, count):
    assert (solve(money), count)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;코드를 보면 화폐의 종류 만큼 반복을 수행해야하는 것을 알 수 있다. 따라서 화폐의 종류가 &lt;code&gt;K&lt;/code&gt;개라고 할 때, 위 소스 코드의 시간 복잡도는 &lt;code&gt;O(K)&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토를 해야한다.&lt;/li&gt;
&lt;li&gt;어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고 문제를 해결할 수 있는 탐욕적인 해결책이 있는지 고민을 해보자.&lt;/li&gt;
&lt;li&gt;만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 그때는 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결 할 수 있는지를 재차 고민해보는 것도 한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h4 id=&#34;출근-방식의-변화&#34;&gt;출근 방식의 변화&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;이번주에는 새벽까지 할 일을 하고 아침에 늦게 출근하느 방식에서 벗어나 차라리 일찍 일어나서 일찍 출근하고 일찍 취침하는 방식을 택했다. 무엇보다 마음에 드는 것은 활용할 수 있는 시간이 훨씬 많아진 것이다. 새벽에 출근을 하니까 교통이 막히자 않아서 전에는 버스를 타고 1시간 20분 걸리던 거리가 40분 만에 도착할 수 있었다. 그리고 남는 시간에 개인적인 공부를 하니 시간 확보를 하는데 많은 도움이 되었다.
또한 회사에서 회식을 하더라도, 끝까지 가지 말고 아홉시나 열시쯤에는 헤어져서 집에 가야지 생활 패턴을 유지할 수 있을 것이다.&lt;/p&gt;
&lt;h4 id=&#34;테스트-코드&#34;&gt;테스트 코드&lt;/h4&gt;
&lt;hr&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/anH8Y8vAz2Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;빌 에반스가 성공한 사람들은 놀랍게도 어떤일을 잘하기 위해서 현실적인 관점을 가지고 접근한다고 했는데, 나 역시 추상적으로 코딩을 잘해야지 보다는 테스트 코드를 작성하면서 코드의 구조를 깔끔하게 만든다던지, 객체간의 의존성을 줄여야지 같은 현실적은 방법을 생각하기로 하였고, 현재 우선적으로 실력을 늘리기 위해서 생각한 방법은 테스트 코드를 먼저 작성하면서 내가 어떻게 코드를 만들어갈지를 생각하는 것이다.&lt;/p&gt;
&lt;h4 id=&#34;코드-숨&#34;&gt;코드 숨&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;코드 숨 강의를 들으면서, 도메인 객체를 외부와 소통하는 용도로 사용하는 것이 아니라, 외부랑 소통하는 용도의 새로운 객체를 만들어서 이를 이용해서 통신을 하는 것을 배울 수 있었다.
또한 이를 더욱 편리하게 하기 위해서, 맵퍼를 사용하는데 &lt;code&gt;DozerMapper&lt;/code&gt;라는 것을 사용해서 객체간의 변환을 쉽게 하는 방법에 대해서 배울 수 있었다.
그리고 예외 처리를 어디서 해야 좋을지에 대한 이야기를 해주셨는데, 꼭 컨트롤러에서 해주어야한다는 고정 관념을 가질 필요가 없고, 핵심은 서비스/컨트롤러 입장에서 외부에 공개되어야 하는 예외 상황이란 무엇이며 외부에 알리지 않고 조용히 처리할 예외는 무엇인지를 적절하게 구분하고 사용하는 것이 중요하다라는 사실을 알게 되었다.&lt;/p&gt;
&lt;h4 id=&#34;경력-관리&#34;&gt;경력 관리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109415964-f1c7f680-79fe-11eb-870e-53947fa7dfc8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;저번주에, 네이버 채용공고를 작성해보면서 내가 어떤 부분이 부족한지 생각을 해보는 시간을 가지고 실제로 제출까지 해봤다. 서류 합격을 기대하지는 않았지만 놀랍게도 합격을 해서 코딩 테스트를 보라고 메일이 왔다. 하지만 평소에 코딩 테스트를 준비한 적이 없어서 코딩 테스트를 보기 조금은 막막 했다. 이를 통해서 준비를 평소에 해야지 기회를 잡는 다는 사실을 다시 한번 깨닫게 되었다. 따라서 현재 이직할 마음이 별로 없더라도, 코딩 테스트 및 이직 준비는 꾸준하게 해두어야겠다는 생각이 들었다. 그리고 지금부터라도 공부한 내용들을 모두 기술 블로그에 정리를 해야겠다는 생각을 했고 여태까지 공부한 내용들도 깃허브 및 블로그로 옮겨야겠다.&lt;/p&gt;
&lt;h4 id=&#34;pr을-날릴-때는-코드에-대한-명확한-이유와-설명&#34;&gt;PR을 날릴 때는 코드에 대한 명확한 이유와 설명&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109415477-4e75e200-79fc-11eb-8ec8-9b5e5f496d4c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드숨에서 PR을 날릴 때, 잘 짜여진 연극이라고 생각할지는 모르겠지만, 현재 사용하고 있는 라이브러나 코드를 사용한 이슈를 남에게 설득 시키려는 것 처럼 글을 작성하라고 하셨는데, 곰곰히 생각해보니 회사에서 내가 새롭게 추가하려는 라이브러리에 대한 정확한 설명없이 내가 도입을 하려고 했던 적이 많은 것 같다. 따라서 앞으로 코드를 작성하고 PR을 날릴 일이 있으면 내가 코드를 이렇게 작성한 이유 및 만약 라이브러리를 도입하려고 한다면 도입하려는 이유 및 도입했을 때 장점 같은 것을 상세하게 적어 동료들을 설득 시킬 수 있어야 된다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트레스-관리&#34;&gt;스트레스 관리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;이번주에 팀장님이랑 매월마다 진행하는 면담을 실시 했는데, 팀원 분들이 나를 많이 걱정 해주신다는 사실을 알게 되었다. 최근에 팀원분들이 내가 많이 스트레스를 받아하는 것 같다고 하셨는데, 실제로 이번주에 스트레스를 많이 받기는 했지만 그게 다른 사람들이 눈치를 챌 정도인건 정말로 몰랐다. 따라서 스트레스를 해소할 수 있는 취미나 운동을 해보는게 어떻겠냐고 물어보셨다. 나도 그 부분에 어느정도 동의를 하였고 따라서 회사에서 받은 스트레스를 해소할 수 있는 취미나 운동을 알아봐야겠다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>개발자 채용 프로세스</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html</link>
      <pubDate>Sat, 27 Feb 2021 22:56:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html</guid>
      <description>&lt;h1 id=&#34;개발자-채용-프로세스&#34;&gt;개발자 채용 프로세스&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;개발자 채용 프로세스는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;서류 검토&lt;/li&gt;
&lt;li&gt;코딩 테스트&lt;/li&gt;
&lt;li&gt;기술 면접&lt;/li&gt;
&lt;li&gt;인성 면접&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트는 주로 알고리즘 문제를 출제하므로, 알고리즘을 열심히 공부하고 연습했다면 합격할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 기술 면접에서는 알고리즘 외에도 컴퓨터구조, 운영체제 등 컴퓨터공학 전반에 대한 다양한 지식에 관해서 질문하므로 공부해야할 범위가 상당히 넓다.&lt;/li&gt;
&lt;li&gt;또한 아무리 실력이 좋더라도 성실성과 팀원으로서 잘 어울릴 수 있는지 그리고 커뮤니케이션 능력 또한 무시할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접의-대표-유형&#34;&gt;기술 면접의 대표 유형&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;알고리즘-문제-풀이와-질의-응답-형식&#34;&gt;알고리즘 문제 풀이와 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트를 치른 내용을 토대로 면접을 진행하며 알고리즘 역량이 제대로 갖추었는지를 평가한다.&lt;/li&gt;
&lt;li&gt;알고리즘의 원리를 완전히 자기것으로 만들 수 있어야한다.&lt;/li&gt;
&lt;li&gt;자료구조와 알고리즘에 대한 이해가 바탕이 되어야한다.&lt;/li&gt;
&lt;li&gt;단순히 알고리즘의 시간 복잡도를 평가하는 것만으로는 부족하고, 실제로 서로 다른 알고리즘을 비교하여 &amp;lsquo;특정한 상황&amp;rsquo;에서 무엇이 더 좋을지를 설명할 수 있어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;포트폴리오-질의-응답-형식&#34;&gt;포트폴리오 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;투입될 개발 프로젝트에 필요한 지식을 가지고 있는지 물어볼 때 주로 이용되는 유형이다.&lt;/li&gt;
&lt;li&gt;개발 경험에 가중치를 부여하는 회사는 포트폴리오를 상당히 중요하게 본다.&lt;/li&gt;
&lt;li&gt;이를 대비해 공부하면서 만든 토이 프로젝트를 정리하여 포트폴리오로 만들어두면 좋다.&lt;/li&gt;
&lt;li&gt;다른 사람들이 보기 편하게 문서화를 하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;만약 팀 프로젝트라면 본이이 맡은 역할 및 이슈를 해결하면서 배운 내용 등을 문서에 담도록 하자.&lt;/li&gt;
&lt;li&gt;또한 전체 소스코드를 깃 허브에 올리고 이력서에 깃허브 주소를 첨부하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;AWS, GCP에 배포하는 형식으로 포트폴리오를 제출해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;컴퓨터-공학-질의-응답-형식&#34;&gt;컴퓨터 공학 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기술 면접 때 컴퓨터공학에 대한 전반적인 지식을 질문하기도 한다.&lt;/li&gt;
&lt;li&gt;운영체제, 컴퓨터아키텍처, 개발 방법론 등에 대한 이해가 있어야 개발할 수 있는 분야도 있기 때문이다.&lt;/li&gt;
&lt;li&gt;예를 들어서 서버 개발을 할 때는 멀티 스레딩, 메모리 관리 등을 알아야한다.&lt;/li&gt;
&lt;li&gt;또한 어느 분야든 네트워크에 대한 지식이 필요하다. 예를 들어서 웹 개발 직군에 지원한다면 (GET, POST 방식의 차이나) TCP, UDP, HTTP, HTTPS의 개념과 원리에 대해서 알고 있어야 한다.&lt;/li&gt;
&lt;li&gt;데이터베이스 관련 직군이라면 데이터베이스의 정규화, 인덱스, NoSQL 등 다양한 데이터베이스 관련 내용에 대해서 물어볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접-준비&#34;&gt;기술 면접 준비&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 잘 풀었다고 해서, 기술 면접을 쉽게 통과할 수 있다고 생각을 하면 안된다.&lt;/li&gt;
&lt;li&gt;기업에서 원하는 직원은 문제를 풀어 &amp;lsquo;정답 판정&amp;rsquo;을 받는 지원자가 아니라, 어떤 방법으로 문제에 접근하여 어떠한 알고리즘을 사용했는지를 논리 정연하게 설명할 수 있는 지원자를 원한다.&lt;/li&gt;
&lt;li&gt;회사에서 같이 일할 사람을 뽑는 과정이므로 논리적으로 말로 정리하는 능력도 매우 중요하다.&lt;/li&gt;
&lt;li&gt;이러한 능력은 하루 아침에 생기는 것이 아니므로, 평소에 기술 블로그나 깃허브 저장소를 운영하며 능력을 키워갈 수 있다. 또한 글로도 논리적인 풀이 능력을 확인할 수 있으므로 채용시에 장점이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접의-어려움&#34;&gt;기술 면접의 어려움&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;면접관마다 중요하게 생각하는 개발자의 자질이 다들 수 있어서, 기술 면접을 &amp;lsquo;완벽&amp;rsquo;하게 대비하는 일은 불가능하다.&lt;/li&gt;
&lt;li&gt;어떤 면접관은 (개발자) 수학과 알고리즘의 원리를 중요하게 생각해서 업무에서 필요한 알고리즘 원리에 초점을 맞추어 질문을 할 수 있는 반면에, 다른 면접관은 프레임워크나 라이브러리를 다룬 경험을 중요하게 생각하여 관련 경험을 주로 물어볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;인성-면접-질문-리스트&#34;&gt;인성 면접 질문 리스트&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;다음은 대표적인 인성 면접 질문 리스트이다. 아무것도 모르는 것보다는 이러한 유형으로 질문을 받을 수 있다는 것을 알고 미리 자신만의 대답을 질문하는 것이 좋을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;개발하면서 가장 행복했던 일은 무엇인가요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 질문은 개발자로서의 열정을 느낀 경험을 물어보는 질문이다. 개발하면서 행복감을 느꼈던 순간이나, 보람을 느꼈던 경험을 이야기하면 좋다. 채용자는 같이 일할 만한 사람인지를 확인하고자 이러한 질문을 한다. 따라서 자신이 개발하면서 얼마나 행복감을 느끼는지, 어떨 때 기쁜지 등을 설명하면서 개발을 좋아한다는 점을 알리면 좋다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자신이 가장 열정적으로 참여했던 프로젝트가 있다면 이야기해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 질문에는 자신이 열정적으로 참여했던 프로젝트를 소개하고, 누구와 함께 했는지, 자신이 맡은 역할이 무엇이었는지를 답하면 된다. 특히 프로젝트에서 자신이 기여한 파트를 구체적으로 언급하고 그 과정에서 겪었던 어려운 점을 어떻게 해결하여 실력 향상을 이룰 수 있었는지에 대해서 설명할 수 있을 정도로 준비를 하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;회사에 대해 궁금한 점이 있다면 말해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;면접은 단순히 회사에 채용되는 과정이 아니라, 여러분 또한 회사를 선택하는 입장이라는 점을 기억하자. 따라서 회사에 대하여 궁금한 점이 있다면 질문할 수 있도록 사전에 회사에 대해 알아보고 면접에 임하자.&lt;/p&gt;
&lt;p&gt;1차원적으로 궁금한 것을 물어보는 것보다는 자신의 개발자로서의 성향 중에서 &amp;lsquo;긍정적인 성향&amp;rsquo;을 드러낼 만한 질문을 하는 것이 좋다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>코딩 테스트 출제 경향 및 준비 방향</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5.html</link>
      <pubDate>Sat, 27 Feb 2021 22:28:35 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5.html</guid>
      <description>&lt;h1 id=&#34;최신-출제-경향과-준비-방향&#34;&gt;최신 출제 경향과 준비 방향&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;정확한 알고리즘을 사용하여 얼마나 빠르게 많은 문제를 풀었는지를 토대로 순위를 매긴다.&lt;/li&gt;
&lt;li&gt;기업은 코딩 테스트를 통해서 취업 준비생들에게 뛰어난 프로그래밍 실력을 원하는 것이 아니라, 기초 알고리즘에 기반하는 문제들이 출제된다.&lt;/li&gt;
&lt;li&gt;가장 출제 빈도가 높은 문제는 그리디, 구현(implementation), DFS/BFS를 활용한 탐색 문제이다.&lt;/li&gt;
&lt;li&gt;또한 상대적으로 높은 사고력을 요구하는 다이나믹 프로그래밍이나, 그래프 이론 문제도 출제된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 카카오 기술 블로그에 언급된 코딩 테스트 문제 난이도에 대한 내용이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ACM-ICPC 같은 어려운 알고리즘 설계 능력을 겨루는 문제가 아닌, 업무에서 있을만한 상황을 가정하여 독창적이고 다양한 분야의 문제를 출제했고 난이도 또한 비교적 쉬운 수준으로 조정하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다양한 케이스를 고려해야 안정적으로 만점을 받을 수 있는 문제들이 주로 출제 된다.&lt;/li&gt;
&lt;li&gt;위와 같은 경우 테스트 코드를 활용하면 안정적으로 구현을 할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;시간이 촉박하기 때문에, 평상시 프로그램을 개발하거나 학교 과제용 문제 풀이에 비하면 심리적으로 부담이 되는 편이다.&lt;/li&gt;
&lt;li&gt;따라서 연습해두지 않으면 평소의 문제 해결 기량에 비하여 좋은 성과가 나오지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;알고리즘 역량을 벗어나 REST API, JSON 등의 원리를 이해하고 있어야 풀 수 있는 문제들도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>이것이 코딩 테스트다</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4.html</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4.html</guid>
      <description>&lt;h1 id=&#34;내가-코딩-테스트를-준비하는-이유&#34;&gt;내가 코딩 테스트를 준비하는 이유&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;당장 구직하지 않더라도, 이러한 준비를 미리 해두어야 좋은 기회를 잡을 수 있다.&lt;/li&gt;
&lt;li&gt;대기업이나, 누구나 가고 싶은 기업에는 코딩 테스트가 존재한다.&lt;/li&gt;
&lt;li&gt;항상 서류에서 통과가 되더라도, 코딩 테스트에서 떨어지곤 했는데 이번에는 떨어지지 않고 면접까지 가는 것이 목표이다.&lt;/li&gt;
&lt;li&gt;대기업 면접을 통해서 합격하지 못하더라도 내가 미쳐 생각하지 못했던 부분과, 부족한 부분을 배울 수 있는 기회로 삼고 싶은데 코딩 테스트때문에 면접까지 갈 수가 없기 때문에 배울 기회가 없다.&lt;/li&gt;
&lt;li&gt;물론 코딩 테스트를 통해서 테스트 코드를 작성하는 법과 사고력을 키울 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;코딩-테스트를-공부하는-팁&#34;&gt;코딩 테스트를 공부하는 팁&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;문제를 많이 풀고, 복기하는 방법이 실력향상에 많은 도움이 되었다.&lt;/li&gt;
&lt;li&gt;복기한 내용을 깃허브에 기록으로 꼭 남기자, 이 기록은 코딩 테스트 직전에 훌륭한 요약집이 된다.&lt;/li&gt;
&lt;li&gt;상대적으로 어려운 알고리즘을 만나면, 한번에 완벽하게 이해하려 하지 말고 여러 번 읽어 체화시키려고 해야한다.&lt;/li&gt;
&lt;li&gt;총 3번에 걸쳐 읽고, 각 시간을 30, 20, 10 시간으로 쪼개서 점점 더 속도를 올리는 방법을 권한다.&lt;/li&gt;
&lt;li&gt;나는 추가적으로 테스트 코드를 작성하면서 문제를 풀려고 한다, 테스트 코드를 작성하는 실력도 높히고 놓치는 부분이 없는지 확인할 수 있어 TDD를 적용하면서 코딩 테스트를 준비하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;시간 복잡도 분석은 문제 풀이의 핵심이다.&lt;/li&gt;
&lt;li&gt;알고리즘 문제 풀이에 능숙한 숙련자들은 문제를 해석하기 전에 먼저 조건을 보기도 하는데 문제의 조건부터 확인하면 문제를 풀기 위해 얼마나 효율적인 알고리즘을 작성해야하는지 눈치챌 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시간과-메모리-측정&#34;&gt;시간과 메모리 측정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;파이썬에서는 쉽게 프로그램 수행 시간과 메모리 사용량을 측정할 수 있다.&lt;/li&gt;
&lt;li&gt;알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다.&lt;/li&gt;
&lt;li&gt;실질적으로 알고리즘의 소요 시간을 확인해야 자신이 제대로 알고리즘을 작성하고 있는지 체크할 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
start_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#75715e&#34;&gt;# 측정 시작&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# 프로그램 소스 코드...&lt;/span&gt;

end_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#75715e&#34;&gt;# 측정 종료&lt;/span&gt;
print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;end_time &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; start_time&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 수행 시간 출력&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;자신이 설계한 알고리즘의 성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;facts (사실, 객관)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;오늘 개발 블로그를 만들었다.&lt;/li&gt;
&lt;li&gt;오늘 회사에 일찍 일어나서, 출근을 하였다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 3장까지 읽었다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;블로그 서비스를 이용하는 것보다는 많은 시간이 들었다.&lt;/li&gt;
&lt;li&gt;아직 많은 기능이 필요하지만, 실제로 그 기능이 필요할 때 까지는 최대한 늦추도록 해야겠다.&lt;/li&gt;
&lt;li&gt;일찍자고, 일찍 일어나는 것이 늦게까지 개발을 하다가 늦게 일어나는 것 보다 효율이 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;하지만, 회사에 출근을 했을 때, 무엇을 해야할지 계획을 세우지 않아서 조금 헤메였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;findings (배운 점)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;직접 개발 블로그를 만드니까, 조금 더 애정이 가는 것 같다.&lt;/li&gt;
&lt;li&gt;일찍자고 일찍일어나니까 활용할 수 있는 시간이 훨씬 늘어난 기분이다.&lt;/li&gt;
&lt;li&gt;테스트 코드에도 순서가 있다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;테스트 코드의 중복을 제거할 때, 가독성을 해치지 않는지를 고려하고 조심스럽게 중복된 부분을 제거해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 앞으로, 일찍 자고 일찍 일어나는 생활 패턴을 지킬 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>테스트 코드를 작성하는 순서</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html</guid>
      <description>&lt;h3 id=&#34;테스트-코드를-작성하는-순서&#34;&gt;테스트 코드를 작성하는 순서&lt;/h3&gt;
&lt;p&gt;테스트 코드를 작성하는 것도 무작성 작성하는 것보다는 순서를 지켜가면서 작성하는 것이 훨씬 좋다.&lt;/p&gt;
&lt;h4 id=&#34;테스트는-다음과-같은-순서를-따르면서-작성-해야한다&#34;&gt;테스트는 다음과 같은 순서를 따르면서 작성 해야한다.&lt;/h4&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;쉬운 경우에서, 어려운 경우로 진행&lt;/li&gt;
&lt;li&gt;예외적인 경우에서, 정상적인 경우로 진행&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;한번에 완벽한 코드를 만들면 좋겠지만, 모두가 슈퍼 개발자인 것은 아니다. 보통의 개발자는 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고
나중에 버그를 잡기 위해 많은 시간을 허비하게 된다. 당연히 테스트 통과 시간도 길어진다.&lt;br&gt;
그 뿐만 아니라, 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름도 자주 끊기게 된다.&lt;br&gt;
중간에 화장실도 다녀오고 커피도 마시게 된다. 자리에 돌아오면 이전까지 했던 흐름을 이어가 기 위한 시간도 필요하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;따라서 테스트를 코드를 작성할 때, 순서에 유의해서 작성 해야 한다 가장 구현하기 쉬운 경우부터 시작하고, 보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다. 그래야만 점진적으로 구현을 완성해갈 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한번에 구현하는 시간이 짧아지면 디버깅 할 때에 유리하다.&lt;/li&gt;
&lt;li&gt;작성한 코드가 많지 않고 작성 시간도 짧으면 머리속에 코드에 대한 내용이 생생하게 남아있기 때문에, 디버깅할 때 문제의 원인을 쉽게 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 문장을 읽고 나서 &amp;ldquo;내가 지금 작성하고 있는 코드를 어떻게 하면 가장 빨리 실행할 수 있을까&amp;rdquo; 라는 생각이 들었고
가장 빠르게 실행 시킬 수 있는 방법은 테스트 코드를 작성하는 것이라는 결론을 내릴 수 있었다.&lt;/p&gt;
&lt;h4 id=&#34;예외-상황을-먼저-테스트해야-하는-이유&#34;&gt;예외 상황을 먼저 테스트해야 하는 이유&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;다양한 예외 상황은 복잡한 &lt;code&gt;if-else&lt;/code&gt; 블록을 동반하기 때문에 예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면, 코드의 구조를 뒤집거나 코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다.&lt;/li&gt;
&lt;li&gt;TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;완급-조절&#34;&gt;완급 조절&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;처음에 테스트 코드를 작성할 때, 어려운 것 중 하나는 한 번에 얼마만큼의 코드를 작성할 것인가이다.&lt;/li&gt;
&lt;li&gt;다음의 순서를 시키면서 TDD를 진행하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;값 비교를 이용해서 정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;다양한 테스트를 추가하면서 구현을 일반화 시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;뻔한 구현이라도 위 단계를 거쳐서 연습하는 것과 바로 구현하는 것과는 차이가 있다.&lt;/li&gt;
&lt;li&gt;테스트를 만들고 통과시키는 과정에서 구현이 막힐 때가 있다. 이럴 때 위 단계를 이용해서 TDD를 연습한 개발자는 조금씩 기능을 구현해 나갈 수 있는 반면에 그렇지 못한 개발자는 구현에 실패하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;지속적인-리팩토링&#34;&gt;지속적인 리팩토링&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트를 통과한 후에는 리펙토링을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 중복은 대표적인 리팩토링 대상이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드가 길어지면 메서드 추출과 같은 기법을 사용해서, 메서드 이름으로 코드의 의미를 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDD를 진행하는 과정에서 지속적으로 리펙토링을 진행하면 코드 가독성이 높아진다. 코드 가독성이 높아지면 개발자는 빠르게 코드를 분석할 수 있어 변경할 코드를 빠르게 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 변경의 어려움을 줄여주어 향후 유지보수에 도움이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  테스트 대상 코드에서 상수를 변수로 바꾸거나 변수 이름을 추출하는 것과 같은 작은 
  리펙토링은 발견하면 바로 실시하는데 반해서 메서드 추출과 같이 메서드의 구조에
  영향을 주는 리펙토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 후에 진행한다.

  구현 초기에는 아직 구현의 전반적인 흐름을 모르기 때문에, 메서드 추출과 같은 
  리펙토링을 진행하면 코드 구조를 잘못 잡을 가능성이 있기 때문이다. 코드 구조를 잘못 잡으면
  테스트를 통과 시키는 과정에서 코드가 복잡해지거나 구현을 더는 진행하지 못하고 막힐 수 있다.
  이런 상황이 오면 구현을 멈추고 메서드 추출 리팩토링을 되돌려야 한다. 
  리팩토링을  취소해서 코드를 원상 복구한 뒤에 다음 테스트를 진행하고
   코드의 의미나 구조가 더 명확해지면 그때 다시 리펙토링을 실시한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=233614629&#34;&gt;테스트 주도 개발 시작하기, (최범균, 가메출판사)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 26 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들의 PR을 참고해보았다. (&lt;a href=&#34;https://github.com/CodeSoom/spring-week5-assignment-1/pull/10&#34;&gt;https://github.com/CodeSoom/spring-week5-assignment-1/pull/10&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들의 PR에서 내가 경험해보지 못한 많은 것을 배울 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예외처리에 어떤 정보를 추가하는 것은, 디버깅하는 사람과 모니터링을 하는 사람들을 위한 서비스 정보라는 것을 알게 되었고, 이러한 사람들을 위해서 적절한 예외와 정보를 알려줘야겠다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;예외를 반드시 컨트롤러에서 처리를 하지 않아도 된다는 것을 배울 수 있었다. 어떤 예외는 레이어를 넘나들고, 어떤 예외는 다른 레이어에 공개되지 않도록 조용이 처리해야한다.&lt;/li&gt;
&lt;li&gt;다른 사람들은 PR을 굉장히 정성스럽게 적고, 다른 사람들이 보기 좋게 적는 것을 확인하였다. 따라서 나도 이러한 점을 본받을 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;li&gt;핵심은 서비스/컨트롤러 입장에서 외부에 공개되어야 하는 예외 상황이란 무엇이며 외부에 알리지 않고 조용히 처리할 예외는 무엇인지를 적절하게 구분해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 25 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 일찍 출근하였다.&lt;/li&gt;
&lt;li&gt;버스로 출퇴근하면서 경제 유튜브를 시청하였다.&lt;/li&gt;
&lt;li&gt;어제 퇴근하면서 버클리에서 하는 데이터베이스 강의를 들었다.&lt;/li&gt;
&lt;li&gt;기계인간님이 코드숨 과정을 진행할 때, 자신의 PR에 dozer-mapper를 소개하고, 자신이 생각하는 장점을 같이 기입하면 좋을 것 같다고 하셨다.&lt;/li&gt;
&lt;li&gt;오늘 목표를 정했다. 1. LMS에서 함수 하나를 정해서 작게라도 테스트 코드를 작성하기&lt;/li&gt;
&lt;li&gt;슬랙에 요청만 하고 확인하지 않았다.&lt;/li&gt;
&lt;li&gt;최근에 스트레스 관리를 못해서 회사에서 감정 컨트롤을 하지 못해 회사에서 하루종
일 우울한 모습을 보였다.&lt;/li&gt;
&lt;li&gt;무언가를 물어볼 때, 말을 조리있게 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다행히도 버스를 놓치지는 않았지만 이전보다 여유를 부리는 느낌이다.&lt;/li&gt;
&lt;li&gt;강의는 영어로 진행되었지만, 생각보다 해석하는데 어려움이 없었다. 계속 퇴근할 때 틈틈히 공부를 하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 PR을 할 때, 왜 이렇게 사용했는지, 왜 이런 라이브러리를 사용했는지 물어보는 경우가 많은데 이러한 방식을 미리 연습하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;오늘 우리팀분들과 회사 사람들을 만난것을 행운이라고 생각을 한다.&lt;/li&gt;
&lt;li&gt;팀원 분들 및 솔루션 사람들이 걱정을 많이 해주는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;물어보기 전에, 물어볼 내용을 정리하는 것이 중요할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;부자가 되려면 G, R을 높여야하는데, G는 자신의 몸값이고, R은 재테크이다. 나는 아직은 몸값을 높이고, 능력을 높이는데 많은 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;앞으로 PR을 날릴 때, 자신의 코드에 대해서 이렇게 만든 이유와 만약 라이브러리를 도입했다면, 이 라이브러리를 도입한 이유에 대해서 논리적으로 설득시키는 형식으로 PR을 작성해야겠다.&lt;/li&gt;
&lt;li&gt;슬랙에 요청드렸더라도 주도적으로 확인을 해야한다!&lt;/li&gt;
&lt;li&gt;회사에서 일을 잘하는 것도 중요하지만, 감정 관리 및 스트레스 관리 같은 기본적인 예의를 지켜야겠다.&lt;/li&gt;
&lt;li&gt;모르는 것이 있을 때, 글로 한번 정리를 한 다음에 상대방에게 물어보는게 좋을 것  같다. 상대방이 시간을 내주는것이 당연하게 아니기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회고를 빠지지 않고 작성했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들에게 더 친절하게 하고, 분위기를 띄우려고 노력해야겠다.&lt;/li&gt;
&lt;li&gt;최소한 우울한 모습 및 다른 사람들을 처지지 않게 해야겠다.&lt;/li&gt;
&lt;li&gt;웃으면서 다른 사람들에게 다가가는 연습을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람의 시간도 귀하다는 것을 알고, 물어볼 것을 미리 적고 정리를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 24 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 이력서를 간단하게 작성을 시도해보았다.&lt;/li&gt;
&lt;li&gt;아침에 과제를 바로 하거나, 이력서 관련 분석을 해야겠다.&lt;/li&gt;
&lt;li&gt;더 많은 일을 하면서 더 빠르게 하기(&lt;a href=&#34;http://agile.egloos.com/1762301&#34;&gt;http://agile.egloos.com/1762301&lt;/a&gt;) 라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;간단한 쿼리문을 작성해보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;경력 기술서를 간단하게 적고 있는데, 회사에서 했던일이 무엇인지 잘 생각이 나지 않는다.&lt;/li&gt;
&lt;li&gt;어떤 일을 할 때, 작은 규모의 일을 하고 그 다음에 같은일을 좀 더 큰 규모로 하면 더 쉽다는 것이다.&lt;/li&gt;
&lt;li&gt;조인에 대해서 내가 잘 이해하지 못하고 있는 것 같다. 따라서 부족한 부분을 채우고 공부를 할 필요성을 느끼고 있다.&lt;/li&gt;
&lt;li&gt;어떤 변경 사항이 있을 때, 데이터의 변경 사항을 보고나서 어떤 영향을 주는지 확인을 해야겠다.&lt;/li&gt;
&lt;li&gt;조금 더 꼼꼼하게 일을 처리해야겠다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OKR을 보면서 경력 기술서에 적을 내용을 생각해보고, 추가적으로 대외 활동을 많이 참여하거나, 오픈소스 컨트리뷰션을 많이 해야겠다.&lt;/li&gt;
&lt;li&gt;링크그인을 꾸준히 관리해야겠다.&lt;/li&gt;
&lt;li&gt;알고리즘 문제를 풀거나, 이력서를 작성하거나, 테스트 코드를 작성할 때, 작은 것을 만들고 큰 것을 이어서 만드는 연습을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;데이터를 조인할 때, 방향 선정을 잘 해야하는 필요성을 느끼게 되었다. 그리고 INNER, OUTER JOIN에 대하여 대략적으로 알게 되었다.&lt;/li&gt;
&lt;li&gt;오라클 문법이 아닌, 다른 ANSI가 아닌 방법으로 조인을 하는 법을 보았다.&lt;/li&gt;
&lt;li&gt;버그같은 기능이라도 URS를 먼저 확인해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;조인에 대해서 확실하게 공부를 하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Tue, 23 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 일찍 출근해서, 아침에 과제를 하였다.&lt;/li&gt;
&lt;li&gt;테스트를 먼저 작성하다보니, 미완성인 클래스들을 우선 만들어주어야하는 경우가 있었다.&lt;/li&gt;
&lt;li&gt;오늘 퍼블리싱 세미나에 참석했다.&lt;/li&gt;
&lt;li&gt;스마트한 시간관리, 인생관리 습관이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 자본주의를 살면서 느낀 것은 하이 리턴을 바랄 려면 하이 리스크를 감당할 줄 알아야하는 것과, 시간은 곧 돈이고 모든 서비스는 어떻게 보면 다른 사람들의 시간을 아껴주는데서 발생한다는 것이다. 따라서 다른 사람들이 어떤 일에 시간이라는 자원을 많이 들이는지 그리고 내가 어떻게 하면 그 시간을 줄여줄 수 있는지에 대해서 고민을 하자.&lt;/li&gt;
&lt;li&gt;한번에 한 가지 일만 하는 것이 중요한 것 같다. 예를 들면 어떤 테스트 코드를 작성하지라고 고민하다가 테스트 함수 이름을 어떻게 짓는것이 바람직한가?와 같은 문제들 말이다. 따라서 한 번에 한 가지 일만 할 수 있게 다른 것들을 미뤄두다가 한 번에 비슷한 일들을 처리하는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;테스트주도 개발 시작하기라는 책에서 배웠던 것 처럼, 우선 미완성된 클래스들을 테스트 코드 패키지 않에 넣어두었다가 어느정도의 테스트가 완성되고 기능이 완성되었다고 생각하면 이를 실제 소스코드 경로에 올리는 선택이 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;항상 개발을 하면서 웹 프론트 레이아웃 잡는 것을 어려워 했는데, 이번 기회에 배울 수 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;일찍 출근을 하니, 하루를 더 길게 사용하는 느낌이 들었고, 시간을 소중히 여기는 마음도 생기게 되었다.&lt;/li&gt;
&lt;li&gt;오늘 회사 팀원이랑 같이 식사를 할 떄, 이직준비를 어떻게 했나고 물어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;도메인 객체를 외부와 소통하는 용도로 사용하면 안되고, 외부랑 소통하는 용도의 객체를 만들어주어야한다는 것을 배우게 되었다.&lt;/li&gt;
&lt;li&gt;DTO 같은 경우에는 직접 도메인 모델을 알면 안된다.&lt;/li&gt;
&lt;li&gt;원래 메서드 체이닝을 함부로 사용하면 안된다는 사실을 알게 되었고, 패턴 같은 경우에는 목적에 맞게 사용하는 것이 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;이직 준비는 꾸준히 해야하는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;개발 블로그를 꾸준하게 작성하고 배운것을 기록해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;내가 회사에서 했던 일들을 프로젝트 단위로, 기록을 해야겠다.&lt;/li&gt;
&lt;li&gt;우선 저녁에 할 일을 미리 정하고 실제로 하는 연습부터 하라고 했다. 따라서 오늘 부터 이를 연습할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이직 준비를 날마다 하면서, 내가 어떤 것을 공부해야하는지 어떤 부분을 채워야하는지 생각할 것이다.&lt;/li&gt;
&lt;li&gt;시간을 아껴서 사용할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Mon, 22 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 일찍 자고, 일찍 출근하여 개발 공부를 하였다.&lt;/li&gt;
&lt;li&gt;오늘 퇴근하는 길에, 라인 개발자 공고를 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근 시간이 훨씬 빨라진 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;하루가 길게 느껴졌고, 코드숨 강의를 여유롭게 들을 수 있었다.&lt;/li&gt;
&lt;li&gt;나도 저런곳에서 한번 일해보고 싶은 마음이 있었다.&lt;/li&gt;
&lt;li&gt;요즘 배우고 있는 TDD를 코딩 테스트를 풀면 일석이조의 효과를 누릴 수 있겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;빌 에반스가 성공한 사람들은 놀랍게도 현실적인 관점을 가지고 있다는 말을 했다. 그리고 대다수의 사람들은 대가의 피아노 연주를 보고 자신이 무엇을 하는지도 모르고 따라하려고만 노력한다고 했다. 이 이야기를 나의 관점에서 대입해서 본다면, 나는 잘 작성된 코드만 보고 어떻게 이렇게 좋은 구조로 코드를 작성했을까? 어쩜 저렇게 깔끔하게 코드를 작성했을까라고만 생각을 했다. 하지만 현실적으로 나도 저렇게 작성하려고 노력한다고 해도 그저 내가 뭘하는지 모르는 채로 흉내만 낼 뿐이다. 따라서 나도 현실적인 관점으로 대가처럼 코딩하는 방법중에 하나는 어떻게 테스트를 할 수 있을까? 라는 의문을 가지는 것이다. 나도 저렇게 의존성을 줄이고, 분기문을 줄이고, 관심사를 분리해서 짜야지라는 것 보다는 하나씩 테스트 코드를 작성하고, 그리고 레거시 코드를 테스트 하면서 접근해야지가 현실적이라는 말이다. 조금 생각이 정리가 안되서 정확한 의미를 글로 전달하지 못한 것일 수도 있지만 실제 현업에서 시간이 날때마다 기존의 소스를 어떻게 테스트 할까? 어떻게 문서화를 다른 사람들을 고려해서 만들까? 하는 현실적인 관점에서 노력을 한다면 저절로 좋은 소프트웨어 및 좋은 코드를 작성할 수도 있겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;이전에는 책을 보면 끝까지 다 읽어야지, 진정으로 책을 읽은 것이라고 생각 했다 그렇기 때문에, 책의 분량에 집착을 하게 되었고 따라서 제대로 지식을 습득하지 못했음에도 그냥 넘어간적도 많았다. 그렇게 되자 후반에는 이해가 되지 않아서 읽어도 읽지 않은 상태로 시간만 낭비를 많이 한 것 같다. 따라서 이제는 내가배우고 싶은 기술이 있으면 그 기술 스택을 사용해서 간단한 토이프로젝트를 만들어보는 식으로 공부를 할 것이다. 따라서 책에서 필요한 부분만 취하고 심화적인 내용이 나오기 전까지는 다시 책을 볼 일이 없고 차라리 테스트 코드와 코딩을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;채용 공고를 보니, 개발도 잘해야 하지만, 외국어로 의사소통이 가능한 사람을 구하고 있었다.&lt;/li&gt;
&lt;li&gt;링크드인에서 바로 지원을 할 수 있었다.&lt;/li&gt;
&lt;li&gt;일찍 자고, 일찍 일어나는게 코드숨 강의를 하는데 많은 도움이 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;원하는 포지션에 채용 공고가 올라왔을 때, 기회를 잡을 수 있게 꾸준하게 준비를 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;나는 개발 블로그에 글을 꾸준히 작성하여, 나중에 이직할 때 특별히 어필을 하지 않고, 나의 능력을 보여줄 것이다.&lt;/li&gt;
&lt;li&gt;쓸데없는 약속을 잡지 않고, 만약 회식을 하게 된다고 하더라도 무조건 아홉 시 이전에는 나오자.&lt;/li&gt;
&lt;li&gt;내가 맡고 있는 솔루션들을 보면서, 어떻게 테스트를 해야할지 그리고 남는 시간에 테스트코드를 작성해보자. 무조건!!!!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sun, 21 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;백기선님의 유튜브 영상을 보았다. (&lt;a href=&#34;https://www.youtube.com/watch?v=iua0nrfh4_Q&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=iua0nrfh4_Q&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;이직관련해서 좋은 영상들을 많이 보았다.
&lt;ul&gt;
&lt;li&gt;개발자가 이직하는 방법 (전략) (&lt;a href=&#34;https://www.youtube.com/watch?v=W5Nx4Bq7Y-4&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=W5Nx4Bq7Y-4&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;개발자 취업의 비밀 (역시사지)(&lt;a href=&#34;https://www.youtube.com/watch?v=PWl9dmwnzoo&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=PWl9dmwnzoo&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;네이버 FINANCIAL에 지원을 해보았다.(&lt;a href=&#34;https://recruit.navercorp.com/naver/job/detail/developer?annoId=20005127&amp;amp;classId=&amp;amp;jobId=&amp;amp;entTypeCd=&amp;amp;searchTxt=&amp;amp;searchSysComCd=&#34;&gt;https://recruit.navercorp.com/naver/job/detail/developer?annoId=20005127&amp;amp;classId=&amp;amp;jobId=&amp;amp;entTypeCd=&amp;amp;searchTxt=&amp;amp;searchSysComCd=&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;자기 회고를 했던 일과 느낀점을 나열하고 있었다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때 세심하게 주의를 기울이지 않는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단지 회고를 할 때 내가 했던일, 느낀점, 자기 선언을 나열하는 형식보다는 알아보기 쉽게 하는 능력이 부러웠다.&lt;/li&gt;
&lt;li&gt;이력서를 다시 작성하고 보니, 나의 부족한 점이 무엇인지 알 수 있었다.&lt;/li&gt;
&lt;li&gt;이번에 내가 작성한 코드를 다른 사람이 고치는 것을 확인하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;백기선님이 프레임워크를 분석하는 방법은 프레임워크가 흘러가는 로그 메시지를 볼 수 있게 만들도 분석을 해본다고 했다.&lt;/li&gt;
&lt;li&gt;가고 싶은 기업이 있으면 매달 한 두군데에 실제로 지원을 해보면서, 부족한 점을 채워나간다. 그리고 많이 자극을 받을 수 있다고 했다.&lt;/li&gt;
&lt;li&gt;구글에서 일하고 있는 어떤 개발자는 구글에서 일하기 전에 4, 5년을 계속 지원한 끝에 일을 할 수 있다는 사실을 알게 되었고, 누구나 가고 싶은 한번에 되지 않는다는 당연한 사실을 알게 되었고, 꾸준하게 자신을 갈고 닦아야한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;오히려 꾸준하게 이직 준비를 하는 것이 자기 일을 보다 열심히 할 수 있다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;취업 준비를 할 때, 역시사지로 내가 회사의 팀장이라고 생각을 해보고 어떤 사람이 필요한지를 생각하면서 이력서를 작성하면 많은 도움이 될 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때, 조금만 주의를 기울이면 이러한 부끄러운일이 발생하지 않을 것 같다. 따라서 나중에 부끄럽지 않으려면 계속 고민을 해야할 것 같다. 내가 작성하는 이 코드가 최선인지에 대해서 말이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 매달 나중에 가보고  싶은 회사에 지원을 해볼 것이다. 그리고, 회고를 통해서 내가 어떤 부분이 부족한지, 알고 이를 채워나갈 수 있을 것이다!&lt;/li&gt;
&lt;li&gt;내가 작성하는 코드가 최선인지 항상 주의를 기울이며, 최대한 많은 고민을 하고 작성할 것이다.&lt;/li&gt;
&lt;li&gt;나중에 겪을 창피함에 비하면 지금 최선의 방법을 고민하는 것은 아무것도 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Sat, 20 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 TDD로 과제를 하기 위해서 회사에 나왔다.&lt;/li&gt;
&lt;li&gt;오류 메시지가 나왔을 때, 아샬님은 어떤 오류 메시지가 발생하였는지 꼼꼼하게 읽어 보고 개선을 하지만, 나는 그냥 대충 읽어본다는 사실을 발견하였다.&lt;/li&gt;
&lt;li&gt;매일 회고를 작성하니까, 주간 회고를 더 상세하고 의미 있게 작성할 수 있었다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 2장까지 읽어보았다.&lt;/li&gt;
&lt;li&gt;회고를 작성하는 것도 좋지만, 내가 지난 회고를 보고 다시 리마인드 할 수 있게 만드는 것도 생각을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서 과제를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커뮤니케이션 부분에서 좋은 동료가 되어야겠다는 생각을 했다. 기술적으로 많이 아는 것도 중요하지만, 커뮤니케이션이 잘되는 그리고 같이 일하고 싶은 개발자가 되기 위해서 노력을 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;에러 메시지를 읽는 것이 때로는 힘들더라도, 무조건 읽는 연습을 해야겠다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서, 테스트를 먼저 작성하기 때문에, IDE 에러를 마주할 때가 굉장히 많았다. 처음에는 이러한 에러가 상당히 불편하고, 당장 에러를 없애고 싶었다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서, 놀랍게도 테스트를 작성함과 동시에 내가 어떤 것을 만들지에 대한 설계도 같이 진행하고 있었다.&lt;/li&gt;
&lt;li&gt;IDE 에러를 하나씩 지워가면서 코딩을 하는 것이 상당히 재미있었다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 읽으면서 느낀 점인데, 한가지 방법 뿐만이 아니라, 항상 여러가지의 대안을 생각해두고 그 중에서 고르고 있었다. 이를 보면서 나도 앞으로 개발을 하면서, 한가지 방법 뿐만이 아니라 다른 방법도 생각해보면서 그 중에서 고르도록 해야겠다.&lt;/li&gt;
&lt;li&gt;책을 읽을 때 욕심을 내서 제대로 이해하지도 못했는데 무조건 읽기만 하는 경우가 많았다. 따라서 내가 이해할 수 있는 범위까지 읽고나서, 충분히 이해를 했다고 생각되면 그때 계속 읽는 것이 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD는 테스트를 작성하는 것 뿐만 아니라, 코드를 작성하기 전에 어떤 것을 개발하고, 어떤 매개변수를 주어야하고 결과가 어떻게 나와야하는지에 대한 요구사항을 설계하는 느낌을 받았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Fri, 19 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 친구랑 같이 졸업 사진을 찍었다.&lt;/li&gt;
&lt;li&gt;졸업 사진을 찍으면서 많은 이야기를 할 수 있었다.&lt;/li&gt;
&lt;li&gt;개발 관련된 이야기를 하면서 많은 것을 생각해 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;개발자 이종립님이 코드에 작성한 주석을 바탕으로 문서화를 할 수 있다는 것을 알려주었다.&lt;/li&gt;
&lt;li&gt;성공의 단계에 이르는 빌 에반스의 연습 방법이라는 영상을 보았다. (&lt;a href=&#34;https://youtube.com/watch?v=anH8Y8vAz2Q&amp;amp;feature=share&#34;&gt;https://youtube.com/watch?v=anH8Y8vAz2Q&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;나 혼자 독단적으로 판단해서 과제를 진행하던 것을, 초기화 시켰다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;교수님이 추천한 곳으로 취직한 얘들은 별로 좋은 조건에 취업을 하지 못했다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;교수님이 추천한 곳의 조건이 압도적으로 좋지 않다면 다른 곳을 알아보는 것이 훨씬 낫다는 생각을 했다. 엄청 좋다고 해도 자기 힘으로 포트폴리오도 만들고, 채용 사이트에 지원을 해보고 실제 면접을 보는것이 좋을 것이다. 단기적으로는 교수님이 추천을 해주었을 때 취직을 쉽게 할 수 있을지는 모르겠지만, 스스로 취업을 하기 위해서 노력해본 적이 없다면 나중에 이직을 할 때 어려움을 겪을 수 있다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;파이썬에도 주석을 다는 것을 추천하지만, 이렇게까지 해야하나라는 생각을 가지고 있었다. 하지만, 문서를 코드에 작성하는 것이 관리하기도 쉽고 문서를 자동으로 만들어주는 도구까지 있다면 사용하지 않을 이유가 없다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;사람은 자신이 속해있는 집단에 영향을 많이 받는 다는 생각을 하였다. 따라서 좋은 영향력을 가진 사람들과 같이 일을 할 수 있도록 이직을 해야겠다는 생각을 했다. 또한 나도 다른 사람들에게 좋은 영향을 줄 수 있는 좋은 개발자가 되어야겠다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;빌 에반스 영상을 보면서 나도 배워야할게 있다고 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람의 도움에 의존하지 말고, 쉽고 편한 길이 무조건 좋은면만 있지는 않다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;자신이 어느 단계에 있는지 정확히 알고, 진실되고 현실적이며 정확하게 수행해야하는것이 실력 향상에 실질적인 도움이 된다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;나는 큰 문제를 하나로 뭉뚱그려서 커다란 문제로 생각하는 경향이 있다. 이러한 큰 문제들을 작게 쪼개고 해결해나가려는 생각을 해야한다.&lt;/li&gt;
&lt;li&gt;실력이 부족한데 한 번에 모든 것을 해야한다. 따라서 하나의 덩어리 같은 문제점을 작게 쪼개고 이를 해결하려는 자세가 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;성공한 사람들은 모두 현실적인 관점을 가지고 있다고 했다. 이는 하나의 큰 문제점을 이렇게 하면 언젠가는 해결되겠지라는 마음을 가지고 있기 보다는 실제로 잘게 쪼개고 어떻게 하면 내가 이를 해결할 수 있을까라는 마음을 가지는 것이다.&lt;/li&gt;
&lt;li&gt;대가들이 작성한 코드를 보고 이를 바로 흉내내력는 시도를 하는 것 보다는 어떻게하면 저렇게 실력을 높일 수 있는지를 현실적으로 생각해보는 것이 나에게 도움이 될 것이다.&lt;/li&gt;
&lt;li&gt;기계 인간님이, 코드숨에서 과제를 하는 것은 혼자만의 작업이 아니고, 회사에서 리뷰 받는 것을 연습하는 것도 있지만, 회사 동료들과 함께 코드에 대해서 의견을 나누고, 함께 완성하는 과정을 연습하는 것이라고도 하셨다. 이러한 피드백을 받고 조금 뜨끔했던 것이, 회사에서 그냥 나 혼자 생각하고 진행하는 것들이 너무 많았던 적이 많다. 안좋은 습관이라서 빨리 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 문제점을 어떻게하면 작게 쪼갤 수 있을까 고민을 하며, 이를 하나씩 정확하게 해결해 나갈 것이다.&lt;/li&gt;
&lt;li&gt;쉬운 방법이 아니라, 어렵더라도 올바른 길을 선택할 것이다.&lt;/li&gt;
&lt;li&gt;함수, 메서드, 클래스, 모듈 및 테스트에도 문서화를 위한 코드를 작성할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Thu, 18 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;요즘 출퇴근 하면서 30대 방구석 이야기라는 유튜브 채널을 시청하고 있다.&lt;/li&gt;
&lt;li&gt;개발 이야기 및 삶에 대한 좋은 자세를 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;이슈를 볼 때 현상에 집중하는 것 보다 빠르게 본질을 파악하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드에 대해서 근거와 논리가 있어야한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;오늘 내가 작성한 코드에 대해서 왜 이렇게 작성하였는지, 질문이 들어왔다. 우연하게 내가 작성한 코드가 올바른 이유를 가지고는 있었지만 의도했다고는 말을 하지 못하겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 이러한 자세를 가지고 일을 하고 살아가고 싶다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;최근에 회의를 할 때, 대충 이야기를 들은게 찔린다. 사소한 일에도 최선을 다하면서 몰입하는 자세를 배워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;항상 느끼는 것은 있는데 이를 실천하는 빈도는 많이 떨어지는 것 같다. 따라서 이를 강제할 수 있는 프로세스를 세우는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드 그리고 옵션값을 제대로 알고 사용했을 때 참 기분이 좋은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;면접을 볼 때 내가 얼마만큼 알고 있는지를 어필하는 것 보다는 얼마만큼 생각을 해보았는지를 알려주는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;포트폴리오를 작성할 때도 내가 어떤 고민을 했는지 포트폴리오에 녹여내면 나를  어필할 수 있는 좋은 무기가 될 것이다.&lt;/li&gt;
&lt;li&gt;자기소개서를 작성할 때, 한문장 한문장 고쳐가면서 최선을 다하는 것은 후회를 하지 않기 위한 좋은 자세이다. 더 이상 미련을 갖지 않게 해준다.&lt;/li&gt;
&lt;li&gt;면접을 볼 때 내가 잘났다를 어필하는 것 보다는 내가 과연 같이 일하기 좋은 사람인가를 생각을 해보고, 역시사지로 생각을 해보면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;이슈를 해결할 때, 이슈 내용이 잘 이해되지 않으면 PM과 논의를 하여 문제를 이해하고 본질을 빠르게 파악하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;자신이 어떤 것을 알거나 배웠다고 어필하는 것보다 학습하는데 어떤 어려움이  있었는데, 극복을 한 내용을 적는 것이 더 공감을 받을 수 있다.&lt;/li&gt;
&lt;li&gt;자기소개서에서 얻고 싶은 가장 큰 부분은, 생각에만 그치지 않고 얼마나 행동으로 이를 실천했는지, 또 얼마만큼의 성취를 만들었는지 어필하는 것이 더 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 사소한 일에도 집중 및 최선을 다하면서 모든 일에 몰입을 할 것이다.&lt;/li&gt;
&lt;li&gt;일을 하면서 배울 수 있는 것을 최대한 끌어내면서 내가 어떤 것을 배울 수 있는지, 고민을 해봐야하는지 생각을 하며 고민을 하는 내용을 기록할 것이다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드, 그리고 옵션값 하나하나 이유를 가지고 코딩을 할 것이다. 따라서 내가 작성한 코드를 커밋할 때는 이렇게 작성한 이유, 그리고 이렇게 옵션을 준 이유를 무조건 적기로 하자!&lt;/li&gt;
&lt;li&gt;가장 빠르게 실행할 수 있는 코드를 작성할 것이다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</link>
      <pubDate>Wed, 17 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0.html</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좋은 유튜브 채널을 찾았다. (&lt;a href=&#34;https://www.youtube.com/channel/UCyCFnxi_hBaLvL6pV_zVILQ&#34;&gt;https://www.youtube.com/channel/UCyCFnxi_hBaLvL6pV_zVILQ&lt;/a&gt;) 면접을 보면서 공부한 내용을 정리하면 좋을 것 같다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 네트워크 관련한 문제로 골머리를 앓고 있는데, 네트워크 패킷 분석에 대해서 조금 알아둔다면 이러한 상황에 잘 대처를 할 수 있을 것 같다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아샬님의 강의를 보다가 느꼈는데, 실제 인터페이스와 서비스, 그리고 인터페이스를 상속받는 클래스와의 의존성을 간단히 확인하고 계셨다. 그 방법은 메서드를 변경해보는 것이다. 그러자 인텔리제이에서 에러를 알아서 표시를 해주었고, 자연스럽게 의존하고 있는 부분이 들어났다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아샬님은 프로그래밍을 구현할 때, 어떤 것 부터 구현하는 편인지 질문이 있었다. 그러자 딱히 구분을 두는 편은 아니고, 프로그램이 가능한 실행될 수 있는 상태로 빠르게 만든다고 했다. 나도 이를 배워야겠다.
구체적인 방법은 다음과 같다. 1-5분 내에 무조건 실행 가능한 상태를 만들고, 1-3분 내에 여러 번 확인하며 개선하는 작업을 지속하려면 어떻게 해야하는지를 고민해보라고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트의 목적이 의존 관계를 들어내는데 사용할 수도 있다. 예를 들어서, 스프링의 경우 서비스 코드에서, verify()를 사용하여 repository에서 어떤 메서드가 호출되는지 명시할 수 있는데, 이와같은 경우가 의존관계를 명시하는 좋은 예시이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
