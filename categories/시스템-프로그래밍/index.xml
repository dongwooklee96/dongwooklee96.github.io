<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>시스템 프로그래밍 on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html</link>
    <description>Recent content in 시스템 프로그래밍 on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sat, 24 Jul 2021 01:09:24 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>스트림과 관련된 시스템 콜</title>
      <link>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</link>
      <pubDate>Sat, 24 Jul 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/24/%EC%8A%A4%ED%8A%B8%EB%A6%BC%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C.html</guid>
      <description>&lt;h3 id=&#34;스트림과-관련된-시스템-콜&#34;&gt;스트림과 관련된 시스템 콜&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에서 바이트 열을 읽는 &lt;code&gt;read&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;스트림에서 바이트 열을 쓰는 &lt;code&gt;write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;새로운 스트림을 생성하는 &lt;code&gt;open&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;사용 완료한 스트림을 닫는 &lt;code&gt;close&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-디스크립터&#34;&gt;파일 디스크립터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스에서 파일을 읽거나, 쓸 때 혹은 다른 프로세스와 데이터를 주고 받을 때 스트림을 사용한다고 했다. 그렇다면, 우리가 만든 프로그램에서 스트림을 사용하려면 어떻게 해야할까?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 위해서 &lt;strong&gt;파일 리스크립터(file desriptor)&lt;/strong&gt; 라는 것을 사용하는데, 커널이 스트림을 열 때 부여하는 번호이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커널이 만들어준 스트림의 번호(파일 디스크립터)를 알아야 스트림을 본격적으로 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력-표준-출력-표준-에러-출력&#34;&gt;표준 입력, 표준 출력, 표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보통 셸을 통해서 프로세스가 생성되는 경우, 세 개의 스트림이 기본으로 생성되며, 이에 대한 파일 디스크립터 값이 미리 할당된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 새 개의 스트림이란 &lt;strong&gt;표준 입력(standard input)&lt;/strong&gt;, &lt;strong&gt;표준 출력(standard output)&lt;/strong&gt;, &lt;strong&gt;표준 에러 출력(standard error output)&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이들 스트림은 각각 파일 디스크립터 0번, 1번, 2번에 할당된다. 이 값에 대한 매크로도 준비되어 있는데 각각 &lt;code&gt;STDIN_FILENO&lt;/code&gt;, &lt;code&gt;STDOUT_FILENO&lt;/code&gt;, &lt;code&gt;STDERR_FILENO&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-입력과-표준-출력&#34;&gt;표준 입력과 표준 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 입력과 표준 출력을 잘 활용하면 리눅스 명령어를 조합하여 고도의 작업을 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 명령어를 파이프로 연결하여 데이터를 처리하는 것이 가능한 것도 각 명령어가 표준 입력에서 데이터를 읽어들이고, 처리 결과를 표준 출력에 쓰게 되어 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우의 &amp;lsquo;표준&amp;rsquo;은 &amp;lsquo;디폴트&amp;rsquo;에 가까운 의미이다. 표준 입력은 프로그램의 디폴트 입력 소스이며, 표준 출력은 디폴트 출력지라는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러개의 리눅스 명령어를 조합할 수 있는 것도 각 리눅스 명령어가 표준 입력에서 데이터를 읽고, 표준 출력에 쓰는 약속을 했기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-에러-출력&#34;&gt;표준 에러 출력&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표준 에러 출력은, 에러 메시지를 출력하기 위해서 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 표준 출력은 파이프라인을 통해서 다른 프로그램의 표준 입력에 연결된다. 따라서 에러 메시지를 표준 출력으로 내보내면 사람이 에러 발생을 알기 어렵게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 여분의 스트림을 준비해서 일반 메시지는 파이프라인을 통해 표준 출력으로 내보내고, 에러 메시지는 표준 에러 출력으로 출력하도록 한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;파일 디스크립터&lt;/th&gt;
&lt;th&gt;매크로&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDIN_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준입력, 기본 입력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDOUT_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 출력, 기본 출력 스트림&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;STDERR_FILENO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;표준 에러 출력, 별도 메시지 출력용&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;스트림-읽기-및-쓰기&#34;&gt;스트림 읽기 및 쓰기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 데이터를 읽고 쓰기 위해서 &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; 라는 시스템 콜을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스트림에서 바이트 열을 읽기 위해서 사용하는 시스템 콜이 &lt;code&gt;read()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;read2&#34;&gt;&lt;code&gt;read(2)&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t read(int fd, void *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 파일 디스크립터 번호인 &lt;code&gt;fd&lt;/code&gt;에 해당하는 스트림에서 바이트 열을 읽는 시스템 콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt;로 바이트 수를 읽어서 &lt;code&gt;buf&lt;/code&gt;에 기록한다. &lt;code&gt;buf&lt;/code&gt;의 크기는 &lt;code&gt;bufsize&lt;/code&gt;로 할당하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;는 읽기 작업이 완료되면 읽어들인 바이트 수를 반환한다. 그리고 파일의 끝에 도달한 경우에는 0을 반환하고, 중간에 에러가 발생한 경우에는 -1을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bufsize&lt;/code&gt; 바이트 수 보다 적은 바이트를 읽는 경우도 많으므로 반환값을 체크하도록 코딩해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C언어 문자열에는 임의의 바이트 열을 저장할 수 있지만, 일반적으로 문자열의
끝에는 &#39;\0&#39;을 넣는 것이 관례이다. API 중에도 문자열의 끝에 &#39;\0&#39;이 있다고
전체하는 것과 그렇지 않은 것이 있어서 사용에 주의 해야한다. 
예를 들어, 문자열의 끝에 &#39;\0&#39;이 있다고 전제하는 API에 &#39;\0&#39;로 끝나지 
않는 문자열을 전달하면 문제가 될 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;read&lt;/code&gt;의 경우에는 읽어들인 데이터의 끝에 &lt;code&gt;\0&lt;/code&gt;가 있다고 전제하지 않는 &lt;code&gt;API&lt;/code&gt;이다. 따라서 &lt;code&gt;read(2)&lt;/code&gt;를 통해서 읽어 들인 문자열의 끝에 &lt;code&gt;\0&lt;/code&gt;이 있다고 생각하고 코드를 작성해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;printf()&lt;/code&gt;의 경우에는 문자열의 끝에 &amp;lsquo;\0&amp;rsquo;이 들어가 있다고 전제하는 &lt;code&gt;API&lt;/code&gt; 이므로, &lt;code&gt;read(2)&lt;/code&gt;로 읽은 문자열을 그대로 &lt;code&gt;printf()&lt;/code&gt;로 전달하면 안된다. 이는 보안상의 취약점이 될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;write2&#34;&gt;&lt;code&gt;write(2)&lt;/code&gt;&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;스트림에 바이트 열을 쓸 때는 시스템 콜 &lt;code&gt;write()&lt;/code&gt;를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t write(int fd, const *buf, size_t bufsize);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;는 인자로 지정한 &lt;code&gt;bufsize&lt;/code&gt; 바이트만큼, &lt;code&gt;buf&lt;/code&gt;의 내용을 &lt;code&gt;fd&lt;/code&gt;로 지정한 파일 디스크립터의 스트림에 쓴다. 반환값의 데이터 타입인 &lt;code&gt;ssize_t&lt;/code&gt;는 부호 있는 정수를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정상적으로 쓴 바이트 수를 반환하고 에러가 발생한 경우에는 &lt;code&gt;-1&lt;/code&gt;를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;가 &lt;code&gt;bufsize&lt;/code&gt;로 지정한 바이트 수만큼 쓸 수 없는 상황은 비교적 드물지만, 발생한 여지는 충분히 있다. 정확한 처리가 필요한 경우에는 반환값을 체크하도록 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스트림이란&#34;&gt;스트림이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스트림은 파일 디스크립터로 표현되고, &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 읽고 쓸 수 있다. 예를 들면, 파일을 &lt;code&gt;open()&lt;/code&gt;하면 &lt;code&gt;read()&lt;/code&gt;나 &lt;code&gt;write()&lt;/code&gt;를 통해서 파일의 내용을 읽거나 쓸 수 있는데, 이것이 바로 스트림이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;같은 맥락에서 파이프라인이나, 소켓도 스트림으로 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-열기&#34;&gt;파일 열기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;프로세스가 만들어 질 때부터 사용할 수 있는 스트림으로는 표준 입력, 표준 출력, 표준 에러 출력이 있다. 이번에는 이 이외의 스트림을 만드는 방법에 대해서 알아보자.&lt;/p&gt;
&lt;h4 id=&#34;open2&#34;&gt;&lt;code&gt;open(2)&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;파일을 읽고 쓰는 스트림을 만들려면 시스템 콜 &lt;code&gt;open()&lt;/code&gt;을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open()&lt;/code&gt;은 첫 번째 인자 &lt;code&gt;path&lt;/code&gt;로 지정한 경로의 파일에 대한 스트림을 만들고, 그 스트림을 가리키는 파일 디스크립터를 반환한다. 이러한 과정을 흔히 파일을 연다라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 인자인 &lt;code&gt;flags&lt;/code&gt;에서는 파일을 어떤 모드로 열 것인지 비트 연산자를 사용하여 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;파일을 열 때 사용할 수 있는 &lt;code&gt;flag(1)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;flag&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;쓰기 전용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O_RDWR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;읽고 쓰기&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;close2&#34;&gt;&lt;code&gt;close(2)&lt;/code&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;사용이 끝난 스트림은 &lt;code&gt;close()&lt;/code&gt;로 닫는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int close(int fd);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;close&lt;/code&gt;는 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt;에 연결된 스트림을 해제한다. 이러한 처리를 파일을 닫는다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오류 없이 닫히면 &lt;code&gt;0&lt;/code&gt;, 에러가 발생하면 &lt;code&gt;-1&lt;/code&gt;를 반환한다. 일반적으로 &lt;code&gt;close()&lt;/code&gt;함수를 호출하는 코드는 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;if (close(fd) &amp;lt; 0) {
  /* 에러 처리 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료되면 사용하던 모든 스트림을 커널이 파기 하기 때문에, &lt;code&gt;close()&lt;/code&gt;를 하지 않아도 시스템에 이상이 생기지 않을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 사용이 완료된 스트림은 반드시 종료시켜주는 것이 좋다. 프로세스가 동시에 사용할 수 있는 스트림의 개수에 제한이 있기도 하고, 스트림의 반대편에 프로세스가 &lt;code&gt;close()&lt;/code&gt; 할 대까지 기다리고 있을 수도 있다. 모든 리소스는 사용이 완료되었을 때 닫아주는 것이 바람직하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=173499011&#34;&gt;모두를 위한 리눅스 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>커맨드라인 인자</title>
      <link>https://dongwooklee96.github.io/post/2021/07/22/%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%EC%9D%B8%EC%9E%90.html</link>
      <pubDate>Thu, 22 Jul 2021 00:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/22/%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%EC%9D%B8%EC%9E%90.html</guid>
      <description>&lt;h3 id=&#34;커맨드-라인-인자&#34;&gt;커맨드 라인 인자&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char* argv[]) {
  int i;
  printf(&amp;quot;argc=[%d]\n&amp;quot;, argc);
  for (i = 0; i &amp;lt; argc; i++) {
    printf(&amp;quot;argv[%d]=%s\n&amp;quot;, i, argv[i]);
  }
  exit(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;는 실행 인자에 대한 정보를 담고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argc&lt;/code&gt;는 실행 인자의 개수를 담고 있고, &lt;code&gt;argv&lt;/code&gt;는 실행 인자의 내용을 문자열 배열 형태로 담고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argv[0]&lt;/code&gt;에는 실행할 때 입력한 명령어가 들어가는데, 예를 들어서 &lt;code&gt;./hello&lt;/code&gt; 라는 명령어를 실행하면 &lt;code&gt;argv[0]&lt;/code&gt;에 &lt;code&gt;./hello\0&lt;/code&gt;이라는 값이 들어간다. 따라서 &lt;code&gt;argc&lt;/code&gt;는 언제나 1 이상이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126514030-9633c6d5-1a59-40ab-a450-ead604263969.png&#34; alt=&#34;Screen Shot 2021-07-22 at 12 16 25 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로그램을 실행할 때의 이름이 &lt;code&gt;argv[0]&lt;/code&gt;에 항상 들어있는 것과, 실행 인자를 늘리면 &lt;code&gt;argc&lt;/code&gt;도 증가하는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/126514473-f311278c-30db-4700-82d4-81f2caf18a28.png&#34; alt=&#34;Screen Shot 2021-07-22 at 12 18 59 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;추가적으로, 실행인자를 &amp;ldquo;&amp;ldquo;로 묶어서, 감싼 부분을 하나의 실행 인자로 묶어 주는 효과를 낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; 같은 와일드 카드(&lt;code&gt;glob&lt;/code&gt;) 패턴을 이용하여 파일 이름의 집합을 인자로 넘겨줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;glob&lt;/code&gt; 패턴을 문자 그대로 사용하고 싶은 경우에는 위와 같이 큰 따옴표로 주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (2) - 프로세스 (2)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</link>
      <pubDate>Sun, 04 Jul 2021 01:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/04/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-2.html</guid>
      <description>&lt;h3 id=&#34;posix_spawn-계열-함수&#34;&gt;posix_spawn 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn(pid_t *restrict pid, const char *restrict path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);

int posix_spawnp(pid_t *restrict pid, const char *restrict file, cosnt posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *restrict attrp, char *const argv[restrict], char *const envp[restrict]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞서 언급했듯이 &lt;code&gt;fork-exec&lt;/code&gt;는 부모 프로세스의 자원을 선택적으로 복제할 수 없으므로, 성능상의 문제와 추가적인 코딩이 복잡해지는 문제가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, &lt;code&gt;posix_spawn&lt;/code&gt; 계열에서는 부모 프로세스의 자원을 선택적으로 복제하거나, 다룰 수 있는 통합 인터페이스가 제안되었는데 이를 가능하게 하는 것이 바로 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;file_actions&lt;/code&gt;, &lt;code&gt;attrp&lt;/code&gt; 인수 부분에 &lt;code&gt;NULL&lt;/code&gt;을 지정하면, &lt;code&gt;fork-exec&lt;/code&gt;와 동일한 작동, 즉 부모 프로세스의 자원을 모두 복제한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawn&lt;/code&gt;도 기본적으로는 부모 프로세스가 열었던 파일은 모두 상속 받는다. 만약 추가로 열어야하는 파일이 있거나, 기존에 열은 파일을 닫아야 할 필요가 있는 경우에는 &lt;code&gt;file_actions&lt;/code&gt; 매개변수를 이용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawn_file_actions_t-구조체-조작&#34;&gt;posix_spawn_file_actions_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_destroy(posix_spawn_file_actions_t *file_actions);
int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict file_actions, int fildes, const char *restrict path, int oflag, mode_t mode);
int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes);
int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;spawn.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
	int ret_err = 0;
	pid_t pid_child;
	char buf_err[64];
	posix_spawn_file_actions_t posix_faction; /* file action struct */
	char *argv_child[] = { &amp;quot;forkexec_child&amp;quot;, NULL };
	printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());

	if((ret_err = posix_spawn_file_actions_init(&amp;amp;posix_faction)) != 0) { /* init */
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_init :%s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	if ((ret_err = posix_spawn_file_actions_addopen(&amp;amp;posix_faction, 3,
					&amp;quot;pspawn.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0664 )) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_addopen: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	ret_err = posix_spawn(&amp;amp;pid_child,
			argv_child[0],
			&amp;amp;posix_faction,
			NULL,
			argv_child,
			NULL);

	if ((ret_err = posix_spawn_file_actions_destroy(&amp;amp;posix_faction)) != 0) {
		strerror_r(ret_err, buf_err, sizeof(buf_err));
		fprintf(stderr, &amp;quot;Fail: file_actions_destory: %s\n&amp;quot;, buf_err);
		exit(EXIT_FAILURE);
	}
	printf(&amp;quot;Parent[%d]: Wait for child(%d)\n&amp;quot;, getpid(), (int)pid_child);
	(void)wait(NULL);
	printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;메모리를 해제하는 부분을 유의해서 보자, 예제에서는 한번 실행되고 곧바로 종료되기 때문에, 해제하지 않아도 메모리 누수를 신경 쓸 필요가 없지만, 연속적으로 실행되는 실무 프로그램에서는 민감한 문제이므로, 꼭 메모리 해제에 신경을 써야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;posix_spawnattr_t-구조체-조작&#34;&gt;posix_spawnattr_t 구조체 조작&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int posix_spawnattr_init(posix_spawnattr_t *attr);
int posix_spawnattr_destroy(posix_spawnattr_t *attr);

int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt; 구조체는 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt;로 초기화를 한 뒤에 사용해야만 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 사용이 끝난 구조체는 &lt;code&gt;posix_spawnattr_destroy()&lt;/code&gt;로 메모리를 해제해야 누수가 발생하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 메모리를 해제한 후에, 다시 사용할 필요가 있다면, 다시 &lt;code&gt;posix_spawnattr_init()&lt;/code&gt; 로 초기화를 한 후에 사용하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;posix_spawnattr_t&lt;/code&gt;에는 &lt;code&gt;EUID&lt;/code&gt;, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러를 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이중에서 &lt;code&gt;EUID&lt;/code&gt; 설정을 제외한 나머지 기능들은 해당 속성의 &lt;code&gt;on/off&lt;/code&gt;를 의미하는 플래그를 설정하고 개별적으로 속성을 등록하는 함수를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (1) - 프로세스 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</link>
      <pubDate>Sat, 03 Jul 2021 11:12:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-1.html</guid>
      <description>&lt;h3 id=&#34;프로세스&#34;&gt;프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전통적인 프로세스를 복제하는 방법은 &lt;code&gt;fork&lt;/code&gt;를 사용하는 방법이다. 이때 복제할 프로세스를 부모 프로세스라고 하고, 새롭게 복제된 프로세스를 자식 프로세스라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스를 복제하는 이유는 멀티 태스킹을 위해서이다. 싱글 스레드에서, 3개의 태스크, &lt;code&gt;A, B, C&lt;/code&gt;를 실행하는 구조를 멀티 프로세스 구조로 바꾸면 3개의 복제된 자식 프로세스에 일임하는 형식으로 분리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복제된 프로세스는 부모 프로세스와 독립적으로 작동하기 때문에, 복수개의 CPU가 설치된 경우에는 매우 뛰어난 응답성과 성능을 보여줄 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 복제된 프로세스 사이에 데이터를 주고 받는 구조이고, 데이터 통신 처리에 비용이 크다면 오히려 성능 하락이 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 복제가 많이 쓰이는 경우로, 셸(&lt;code&gt;SHELL&lt;/code&gt;)이 있다. 셸에서 &lt;code&gt;ls&lt;/code&gt; 명령을 실행한다고 가정할 때, 셸은 명령어를 받아들인 후에, &lt;code&gt;fork&lt;/code&gt;를 하여 자식 프로세스를 만든다. 그 후에 바로 &lt;code&gt;exec&lt;/code&gt;를 호출하여 &lt;code&gt;bin/ls&lt;/code&gt; 프로그램 이미지로 교체하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;확장된-프로세스-실행-방법&#34;&gt;확장된 프로세스 실행 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 프로세스 실행 방법이 있는데, 이 방법은 기존의 &lt;code&gt;fork-exec&lt;/code&gt;를 대체할 수 있는 기능으로서 더 가볍고 빠른 실행을 위해서 제안되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 &lt;code&gt;fork-exec&lt;/code&gt; 구조에서는 &lt;code&gt;fork&lt;/code&gt;에서 부모 프로세스를 복제할 때, 모든 정적 정보를 복제한다. 예를 들어서 부모 프로세스의 힙 메모리, 정적 메모리, IPC 자원 ID, 열린 파일, 시그널 마스크 등이 포함된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 &lt;code&gt;fork&lt;/code&gt;를 하고 나서, 곧바로 &lt;code&gt;exec&lt;/code&gt;를 호출하는 경우에는 대부분 부모 프로세스의 열린 파일이나, &lt;code&gt;IPC&lt;/code&gt; 자원을 사용하지 않는 경우가 많다. 따라서 사용하지 않는 자원을 복제하는 오버헤드가 존재한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 한두 개의 프로세스가 저런 오버헤드를 가진다고 해도 시스템에 큰 문제가 없지만, 대형 시스템에서 엄청난 수의 프로세스가 실행되거나, 실시간 처리가 중요한 서비스라면 더더욱 큰 문제가 될 수 있다. 따라서 &lt;code&gt;posix_spawn&lt;/code&gt;에서는 부모 프로세스의 자원 중 6가지(&lt;code&gt;열린 파일, 프로세스 그룹 ID, 유저 및 그룹 ID, 시그널 마스크, 스케줄링&lt;/code&gt;)의 자원을 선택적으로 복제 및 관리할 수 있도록 디자인 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fork&#34;&gt;fork()&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; 호출이 성공하면 프로세스가 복제되어 2개가 되고, 리턴값으로 정수인 &lt;code&gt;pid_t&lt;/code&gt; 타입을 리턴한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 리턴 값은 3가지의 반환 형태를 가지며 각각에 따라서 처리 방법을 다르게 코딩해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0 -&amp;gt; 자식 프로세스에게 리턴되는 값
양수 -&amp;gt; 부모 프로세스에게 리턴되며, 자식 프로세스의 PID를 의미한다.
-1 -&amp;gt; 에러, 복제 실패
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 다음과 같이 0인 경우에는, 자식 프로세스가 실행할 부분을 코딩하고 양수인 부분은 부모 프로세스가 실행할 부분으로 코딩한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 &lt;code&gt;fork()&lt;/code&gt;를 사용하면 하나의 소스코드에 부모와 자식 프로세스의 코드가 같이 들어가게 된다. 그리고 부모 프로세스에는 자식 프로세스의 종료를 기다리기 위해서 &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;waitpid&lt;/code&gt;를 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;switch (ret = fork()) {
  case 0:
    do_child(); /* 자식 프로세스인 경우에 실행될 코드 */
    break;
  case -1: /* 에러가 난 경우 */
    do_errorcatc();
    break;
  default: /* 양수는 부모 프로세스이며 ret에 자식 프로세스의 PID가 저장됨 */
    do_parent();
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 위와 같이 부모 프로세스가 실행할 부분과, 자식 프로세스가 실행할 부분을 나누어서 코딩할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의할 점은 &lt;code&gt;fork()&lt;/code&gt; 를통해서 자식 프로세스가 분기하는 구조를 제대로 만들지 않으면 이상한 현상이 발생할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int main() {
  int i = 0;
  pid_t ret;

  for (i = 0; i &amp;lt; 3; i++) {
    ret = fork();
    printf(&amp;quot;[%d] PID(%d) PPID(%d)\n&amp;quot;, i, getpid(), getppid());
#ifndef OMIT_SWITCH
    switch (ret) {
      case 0:
        pause();
        return 0;
      case -1:
        break;
      default:
        break;
    }
#endif
  }
  wait(NULL);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 코드를 보면, 전처리기 분기문 처리가 되어있어, &lt;code&gt;OMIT_SWITCH&lt;/code&gt; 매크로가 정의되어 있지 않는다면, 같이 빌드되는 부분이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DOMIT_SWITCH _Wall -o fork_omit_swich fork_process.c 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위와 같이 매크로를 같이 빌드하면, 전처리기 분기문 처리가 빌드되지 않는다. 그리고 나서 프로그램을 실행하면 다음과 같은 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/124343414-2d213e80-dc06-11eb-93b1-7e6ba63954b7.png&#34; alt=&#34;result&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;총 7개의 프로세스가 실행되는 것을 확인할 수 있는데, 부모 프로세스에서 총 3개의 자식 프로세스를 생성하고, 또한 그 자식 프로세스들이 자식 프로세스를 생성하는 구조로 이루어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;exec3-계열-함수&#34;&gt;exec(3) 계열 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열 함수는 현재 실행중인 프로세스의 이미지를 새로운 프로세스 이미지로 대체한다. 즉 쉽게 이야기하면 현재 프로세스에 실행중인 프로그램 파일을 로딩한다는 의미이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스 이미지가 대체되면 프로세스의 실행코드는 교체되지만, 기본적인 &lt;code&gt;PID&lt;/code&gt;, &lt;code&gt;PPID&lt;/code&gt;, 파일 기술자등 프로세스의 정보는 유지된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; 계열의 첫 번째 인수는 실행되어야 하는 프로그램 파일로서절대 경로나 상대 경로를 사용할 수 있다. 만일 경로가 생략되고 파일 명만 넣으면 &lt;code&gt;execl, execle, execv, execve&lt;/code&gt;는 현재 작업 디렉터리에서 실행되어야 하는 프로그램 파일을 찾고, &lt;code&gt;execlp, exevcp&lt;/code&gt;는 환경 변수에 등록된 디렉터리를 검색하여 실행되어야 하는 프로그램 파일을 찾는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;execl&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;arg&lt;/code&gt; 라는 이름을 쓰고, &lt;code&gt;execv&lt;/code&gt;로 시작하는 함수는 &lt;code&gt;argv&lt;/code&gt;를 사용하는 것을 알 수 있다. 이들의 차이는 execl&lt;code&gt;계열은 실행할 파일의 인수 목록을 리스트로 받기 때문에 가변 인수 리스트를 가진다. 따라서 인수 리스트의 마지막을 알아내기 위해서 맨 끝은&lt;/code&gt;NULL`로 끝내야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;execl 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
execlp(&amp;quot;ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;execv 계열을 사용한 예&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execv(&amp;quot;/bin/ls&amp;quot;, argv_exec);

char *argv_exec[] = {&amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL};
execvp(&amp;quot;ls&amp;quot;, argv_exec);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;이 경우에는 기존의 환경변수는 모두 초기화되고 새로 넣은 환경 변수 벡터가 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
  if (execl(&amp;quot;/bin/ls&amp;quot;, &amp;quot;ls&amp;quot;, &amp;quot;-al&amp;quot;, NULL) == -1) {
    perror(&amp;quot;excel&amp;quot;);
  }
  printf(&amp;quot;+ arfter execl\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 예제는 작동에는 문제가 없지만, 설계상의 의문이 있는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;왜냐하면, &lt;code&gt;execl&lt;/code&gt; 실행되면서 &lt;code&gt;ls&lt;/code&gt;로 프로세스 이미지를 교체하기 때문에 이후 &lt;code&gt;+ after execl&lt;/code&gt; 메시지는 화면에 출력될 일이 없기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상속되지-않는-파일-기술자&#34;&gt;상속되지 않는 파일 기술자&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로는 &lt;code&gt;exec&lt;/code&gt;는 부모 프로세스의 파일 기술자를 복제한다.&lt;/li&gt;
&lt;li&gt;하지만, 부모 프로세스가 &lt;code&gt;fork&lt;/code&gt;를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플레그를 지정하면 &lt;code&gt;exec&lt;/code&gt;가 실행될 때 해당 파일 기술자는 닫히게 된다. 이를 &lt;code&gt;close-on-exec&lt;/code&gt;라고 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;forkexec_parent.c&lt;/em&gt;*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
  pid_t pid_child;
  printf(&amp;quot;Parent[%d]: Start\n&amp;quot;, getpid());
  int fd = open(&amp;quot;forkexec.log&amp;quot;, O_WRONLY | O_CREAT | O_APPEND, 0644);

  if (fd == -1) {
    perror(&amp;quot;FAIL: open&amp;quot;);
    exit(EXIT_FAILURE);
  }

  dprintf(fd, &amp;quot;Parent[%d]: Open log file(fd=%d)\n&amp;quot;, getpid(), fd);

#ifdef APPLY_FD_CLOEXEC
  int ret_fcntl;
  if ((ret_fcntl = fcntl(fd, F_SETFD, FD_CLOEXEC)) == -1) {
    perror(&amp;quot;FAIL: fcntl(F_SETFD, FD_CLOEXEC)&amp;quot;);
    exit(EXIT_FAILURE);
  }
#endif

  /* fork-exec code */
  char *argv_exec[] = {&amp;quot;fork_exec_child&amp;quot;, (char*) NULL};

  switch ((pid_child = fork())) {
    case 0: /* child process */
      execv(argv_exec[0], argv_exec);
      break;
    case -1: /* error */
      perror(&amp;quot;FAIL: FORK&amp;quot;);
      break;
    default: /* parent process */
      wait(NULL);
      break;
  }
  printf(&amp;quot;Parent[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;forkexec_child.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Start\n&amp;quot;, getpid());
  dprintf(3, &amp;quot;Child[%d]: fd(3): Test fd.\n&amp;quot;, getpid());
  close(3);
  dprintf(STDOUT_FILENO, &amp;quot;Child[%d]: Exit\n&amp;quot;, getpid());
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음은 부모 프로세스에서, 파일을 생성하고 기록하고 있다. 그리고 나서, 자식 프로세스에서 파일 디스크립터를 받고 종료하는 코드이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;생성된 파일을 살펴보면 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Parent[5935]: Open log file(fd=3)
Child[5936]: fd(3): Test fd.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;하지만, 부모 프로세스를 하기 전에 특정 파일 기술자에 &lt;code&gt;fcntl&lt;/code&gt;로 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그를 지정하면, 해당 파일 기술자는 닫히게 된다. 따라서 이를 위해서 &lt;code&gt;APPLY_FD_CLOEXEC&lt;/code&gt; 매크로를 정의하고 빌드를 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -DAPPLY_FD_CLOEXEC -o forkexec_parent_fdcloexec forkexec_parent.c
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Parent[6014]: Open log file(fd=3)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매크로를 정의하고 나서는, 부모 프로세스가 자식 프로세스에게 파일 기술자를 상속하지 않으므로, &lt;code&gt;forkexec.log&lt;/code&gt; 파일에 자식 프로세스에는 기록되지 않았음을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론적으로는 &lt;code&gt;fork-exec&lt;/code&gt;를 이용할 때, 자식 프로세스가 사용하지 않는 파일이 복제되는 오버헤드를 피하고 싶다면 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그 사용을 고려하는 것이 좋다. 하지만 더 근본적인 방법으로는 &lt;code&gt;fork-exec&lt;/code&gt; 대신에 &lt;code&gt;posix_spawn&lt;/code&gt;을 사용하는 것이 더 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;system-함수&#34;&gt;system 함수&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system&lt;/code&gt; 함수는 셸을 실행시켜서 명령어를 실행하는 기능으로서, &lt;code&gt;fork-exec&lt;/code&gt;를 간단하게 구현한 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 중요한 차이가 있는데, &lt;code&gt;system&lt;/code&gt;은 실행 명령어가 작동되는 동안에 부모 프로세스가 잠시 정지되고, 자식 프로세스의 정지, 종료 상태를 통보해주는 &lt;code&gt;SIGCHILD&lt;/code&gt;도 블록되고 종료 시그널인 &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGQUIT&lt;/code&gt; 시ㅋ그널도 무시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 중요 시그널이 블록킹 되어, 종종 부모 프로세스가 무한 대기 상태에 빠지는 경우가 발생할 수 있으므로, 정말로 간단한 경우가 아니라면 &lt;code&gt;fork-exec&lt;/code&gt;로 구현하는 것을 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 시스템 네트워크 프로그래밍 (0) - 서문</title>
      <link>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</link>
      <pubDate>Sat, 03 Jul 2021 11:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/07/03/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-0-%EC%84%9C%EB%AC%B8.html</guid>
      <description>&lt;h3 id=&#34;서문&#34;&gt;서문&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;책의 서문에서는 코딩이란 예술의 경지이기 때문에 반복해서 사용함으로써 익숙해지고, 좋은 경험을 토대로 새로운 것을 깨닫게 해준다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 수 많은 이론을 머리에 채워넣었다고 하더라도, 절대적으로 코딩을 해본 경험이 적다면, 반쪽 짜리 프로그래머가 될 수 밖에 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이론만 배우고 끝나는 것이 아니라, 실제로 코딩을 하면서 손에 익을 때까지 코딩을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;리눅스의-표준-및-역사&#34;&gt;리눅스의 표준 및 역사&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리눅스가 표준 안을 가지기 전까지, 많은 파생된 버전이 있었다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에일리어싱과-restric-포인터&#34;&gt;에일리어싱과 RESTRIC 포인터&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 어떤 한 공간에 대해 복수개의 접근 경로가 있는 경우를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에일리어싱은 C언어에서, 중요한 역할을 담당하고 있으며, 가독성 향상이나, 형변환을 위해서 사용되지만 때때로, 최적화를 방해하거나, 문제를 일으킬 소지가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몇몇 함수들은 인수로 받아들이는 주소가 에일리어싱 되었을 때 오류를 방지하기 위해 미리 검사하는 행위 때문에 성능 저하가 발생하기도 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서, 함수 인수가 다른 곳에서 참조하지 않음을 보장해준다면 내부적으로 병렬처리를 하거나, 에일리어싱에 대한 검사를 하지 않아도 되므로 상당히 효율적으로 함수를 설계할 수 있고 이를 위해서 &lt;code&gt;restrict&lt;/code&gt; 포인터가 도입되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;restrict&lt;/code&gt; 포인터는 &lt;code&gt;restrict&lt;/code&gt; 포인터가 가리키는 객체를 다른 공간에서 에일리어싱 하지 않도록 강제를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void *memcpy(void *dest, const void *src, size_t n);
void *memcpy(void *restrict s1, const void *restrict s2, size_t n);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서, 상위에 있는 &lt;code&gt;memcpy&lt;/code&gt; 함수는 과거에 사용되던 함수의 원형이고, 아래쪽 &lt;code&gt;memcpy&lt;/code&gt;는 C99 이후에, 적용되는 함수의 원형이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새롭게 적용된 &lt;code&gt;memcpy&lt;/code&gt; 에서는 사용자가 &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;의 접근이 비순차, 비동기적으로 진행되거나 병렬처리 될 수도 있음을 암시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int *p_num, *p_alias;
p_num = (int *) malloc(sizeof(int) * 100);
p_alias = p_num + 20; /* 에일리어싱 되었음 */
memcpy(p_num, p_alias, sizeof(int) * 50);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 코드에서 &lt;code&gt;p_num&lt;/code&gt;, &lt;code&gt;p_alias&lt;/code&gt;는 에일리어싱 되었으므로, &lt;code&gt;restict&lt;/code&gt; 포인터 룰을 위반한 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 사이드 이펙트의 발생 가능성이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=82732834&#34;&gt;Advanced! 리눅스 시스템 네트워크 프로그래밍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
