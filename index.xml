<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 개발자 이동욱</title>
    <link>https://dongwooklee96.github.io/</link>
    <description>Recent content in Home on 개발자 이동욱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 12 May 2021 09:00:36 +0900</lastBuildDate><atom:link href="https://dongwooklee96.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 12 May 2021 09:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;를 효율적으로 사용하는 방법에 대한 글을 읽었다. &lt;a href=&#34;https://blog.linewalks.com/archives/7428&#34;&gt;SQLAlchemy 2.0 Style 소개&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구글 엔지니어들이 어떤 문화와, 프로세스 도구를 이용해서 개발을 하는가에 대한 책을 다운 받았고, 블로그 요약을 보았다. &lt;a href=&#34;http://docs.likejazz.com/software-engineering-at-google/&#34;&gt;https://abseil.io/resources/swe-book&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 칠판 도구, 프로그램을 알게 되었다. &lt;a href=&#34;https://excalidraw.com/&#34;&gt;프로젝트를 하거나 문제를 풀 때 유용할 것 같다.&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마크다운 기반 발표 자료를 만드는 프로젝트를 알게 되었다. (Slidev)(&lt;a href=&#34;https://sli.dev/themes/use.html&#34;&gt;https://sli.dev/themes/use.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQLAlchemy 2.0 스타일로, 천천히 변경을 해야겠고, 리포지토리 형태를 변경해야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 동시에, 현재 프로젝트에서 사용하면 좋을 디자인 패턴을 소개하고 이를 적용하는 방안을 발표하는 자료를 만들어야겠다. &lt;a href=&#34;https://medium.com/zigbang/%EC%A7%81%EB%B0%A9%EC%97%90%EC%84%A0-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-a359044f5565&#34;&gt;직방에선 디자인-패턴을어떻게 이용하는가&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 11 May 2021 23:27:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서, 일이 굉장히 잘 풀렸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;도커의 내부 원리에 대해서, 공부하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스의 아키텍처에 대해서 공부하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;미리 풀리퀘를 날리고, 거기에 구현할 계획을 세우고 체크 박스로 하나씩 요구사항을 체크하면서 개발을 하다보니, 실수도 적어지고 내가 무엇을 해야할지 빠르게 파악할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만 어떻게 구현할지에 대한 계획에 대한 고민을 좀 더 체계적으로 해야하는 필요성을 느낄 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여태까지, 도커의 명령어만 사용하면서 아키텍처에 대해서는 제대로 이해하지 못하고 있었다는 사실을 깨닫게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117834051-d0fb0780-b2b1-11eb-99b0-015dc1f2bc18.png&#34; alt=&#34;1_c3AiZFHuib7FUGyINzkEag&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리눅스가 하는 일을 보면, 크게 두 가지가 있는데 하나는 애플리케이션 자원 관리(&lt;code&gt;PID&lt;/code&gt;, &lt;code&gt;ROOT&lt;/code&gt;, &lt;code&gt;PORT&lt;/code&gt;)이고, 다른 하나는 하드웨어 자원 관리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 독립된 리눅스 환경을 보장 받는 컨테이너라는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스는 커널안에 있는 자원을 &lt;code&gt;namespace&lt;/code&gt; 라는 기능을 통해서 애플리케이션 자원을 독립화 시킬 수 있으며, 하드웨어 자원은 &lt;code&gt;cgroup&lt;/code&gt;을 이용하여 독립화 시킨다. 따라서 도커는 리눅스의 이 두 기능을 이용하여 독립된 컨테이너 환경을 만드는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117834866-7ada9400-b2b2-11eb-977b-780c586a69b0.png&#34; alt=&#34;도커네트워크&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker0&lt;/code&gt;가 내부적으로 브릿지 역할을 한다. 그리고 컨테이너간의 통신은 가상 네트워크 인터페이스인 &lt;code&gt;veth&lt;/code&gt;를 통해서 이루어 지고, 내부적으로는 두 개의 &lt;code&gt;namespace&lt;/code&gt;를 이어주는 것이라고 보면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너 각각의 &lt;code&gt;eth0&lt;/code&gt; 인터페이스를 통해서 통신을 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 하나의 컨테이너와 다른 컨테이너가 통신을 할 때, &lt;code&gt;docker0&lt;/code&gt;를 통하게 되어 다른 컨테이너로 통신이 이루어지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117835910-356a9680-b2b3-11eb-8d99-c960496207f4.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;는 쿠버네티스 안에서, 모든 로깅에 정보를 기록한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API server&lt;/code&gt;는 컨테이너를 늘리는 명령어를 비롯한 모든 명령어들을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스케줄러는 여러 서버가 있을 때, 어떤 노드에 명령어를 실행할지를 정해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POD&lt;/code&gt;은 논리적으로 애플리케이션의 묶음이고, 기본적으로 여러개의 &lt;code&gt;POD&lt;/code&gt;이 하나의 애플리케이션을 구성하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;집중하다 보면, 너무 오래 앉아있는데 일어날때마다 어지럽게 된다. 따라서, 일정 시간마다 일어나서 체력 분배를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 및 클라우드에 대한 지식 및 데브옵스 지식을 배우는 것이 전체적인 개발 스킬을 늘려줄 수 있을 것이다. 열심히 공부하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 10 May 2021 22:43:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117670538-f3721f80-b1e2-11eb-808b-a0ad9ba19199.jpeg&#34; alt=&#34;Unknown&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사에서 업무를 하는데, 굉장히 생산성이 안좋았다.&lt;/li&gt;
&lt;li&gt;복싱을 하니까, 굉장히 기분이 상쾌해졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;딱히 집중을 못한 것도 아닌데, 굉장히 많은 시간을 들였음에도 생산성이 높지 못했다.&lt;/li&gt;
&lt;li&gt;어느정도 코딩하기 전에 설계를 했지만, 분석하는데 많은 시간을 들이지 않아서 결국에는 다른 방식으로 구현을 바꾸느라 굉장히 많은 시간을 소모했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩하기 전에, 계획하는 습관을 들이는 이유가 구현을 하다가, 잘못된 것을 깨닫고 다시 되돌아가지 않기 위해서 하는 것이다. 많은 시간을 소모함으로써, 이를 깨닫게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 코딩하기 전에, 분석을 충분히 하고 고민을 해봐야하는 부분이 있었음에도 불구하고 코딩을 하고 있지 않는다는 불안감에 대충 어떤 방향으로 코딩을 할 것이라는 것만 적고 바로 생각이 떠오른 대로 구현을 하였다. 하지만 오늘 많은 비용을 치렀고, 뭔가 잘못되고 있다는 생각이 들때, 붙잡고 있지 말고 이것이 옳은 길이가 한번 더 생각을 해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;주말에는 늦잠을 자거나 피곤하다는 핑계로 운동을 하지 않는데 아침에 일찍 일어나거나 저녁에 꼭 운동을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복싱 도장에서는 유산소 운동을 위주로 하는데, 주말에 근력 운동 위주로 밸런스를 맞춰야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;알고리즘 실력이나, 구현 능력이 부족하다고 느껴질 때가 있다. 따라서 매일 한 문제씩 알고리즘 사이트에서 문제를 풀어보는 것도 재미있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞으로 코딩을 하기 전에 계획을 할 때, 시간을 정해놓고 (예: 5분) 충분히 생각을 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발을 하다가, 뭔가가 잘못되었다는 것을 느끼면 당장 코딩을 중단하고 생각을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/09/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 09 May 2021 19:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/09/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이력서를 한달마다 작성하면 좋다는 글을 보고 이력서를 작성해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클린 아키텍처 파이썬이라는 책을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://taetaetae.github.io/2019/01/10/spring-redirect-oom/&#34;&gt;Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기&lt;/a&gt; 라는 블로그 글을 읽었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트를 진행할 때, 자가 진단할 수 있는 항목에 대한 영상을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 발표 영상을 보고, 다시 오픈소스 기여에 대한 열정이 타올랐다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생각보다 이력서를 작성하기 쉽지 않았고, 미리 준비를 하는게 정말로 다행이라는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;파이썬을 어떻게 해야지 제대로 사용할 수 있는지 감을 잡은 것 같다.&lt;/li&gt;
&lt;li&gt;성능 분석은 블로그에 나온 대로 정도는 해야지 제대로 한것이라는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;플라스크에서, 레이어드 아키텍처로 프로젝트를 구성하는 방법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추상화를 할 때, 웹 프레임워크는 웹을 통해서 프로그램을 이용할 수 있게 해주는 것이며 분리가 잘 되어 있다면, CLI를 통해서 비즈니스 로직의 변경없이 프로그램을 사용할 수 있도록 설계해야한다는 것을 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 역시, 관계형 데이터베이스 뿐만 아니라, NoSQL도 빠르게 바꿔서 설계해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드의 문제점을 재현해보고 직접 눈으로 확인하면서 해결하는 모습이 인상 깊었다. nGrinder로 부하를 주고, Pinpoint로 모니터링을 하고 힙 덤프를 통해서 실제로 JVM에서 FULL GC가 몇 번 일어나는지 측정까지 하고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토이프로젝트를 진행할 때, 아래 항목에 유의해서 개발을 계속해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;프로젝트를 자가 진단해볼 수 있는 주요 항목이다.
실제 서비스를 공개적으로 배포하고 운영해보는 경험을 해보았다.
유저의 피드백에 따라서, 성능 및 사용성을 개선해보고 신규 기능들을 추가해보았다.
발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리 해 보았다.
코드를 지속적으로 리펙토링하고 디자인 패턴을 적용해 보았다.
위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민해보았다.
반복되는 수정이과 배포에 수반되는 작업을 자동화해보았다.
언어나 프레임워크의 기능만으로 구현할 수 없는 것들을 직접 구현해보았다.
내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선해보았다.
코드나 제품의 퀄리티를 유지하기 위한 분석 툴이나 테스틑 툴을 도입해보았다.
타인과의 협업을 효율적으로 하기 위한 고민을 해보았다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;학부때 배웠던 개념이라고 하더라도, 많이 잊어버린 기초 지식들이 많았고 이를 일하면서 틈틈히 채워나가야 하는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실무와 연결시켜서 지식을 배우니까 좀 더 기억에 오래 남을 수 있었던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;전산 컴퓨터 기초 지식을 다시 복습해보면서, 내가 어떤 부분이 부족한지 꾸준히 파악하고 채워나갈 수 있도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번주에는 주로, 나를 되돌아보는 계기가 된 것 같다. 나의 부족한 점을 채우기 위해서 많은 노력을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;engineer-skills핵심-역량&#34;&gt;Engineer Skills(핵심 역량)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이력서를 작성하면서 나를 제대로 파악하고 어떻게 나를 표현할 수 있을지 고민을 해봐야 겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;project-perfomance-프로젝트-주요-성과&#34;&gt;Project Perfomance (프로젝트 주요 성과)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번주에는 딱히 프로젝트에서 주요한 성과를 이룬게 없는 느낌이다. 다음주에 노력하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;li&gt;Engineer Skills (핵심 역량) 엔지니어를 평가하는 4가지 항목을 참고하여, 나의 핵심 역량을 작성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;올바른 프로젝트 방향성을 가지고 개발을 하고 있는가?&lt;/li&gt;
&lt;li&gt;엔지니어링 관점에서 좋은 개발을 하고 있는가?&lt;/li&gt;
&lt;li&gt;프로젝트의 방향성을 제시할 수 있는가?&lt;/li&gt;
&lt;li&gt;같이 일하면서, 더 큰일을 할 수 있는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Project Perfomance (프로젝트 주요 성과) 내가 회사에서 한 주간 어떤 성과를 내었는지를 평가하는 항목이다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>이력서를 작성할 때의 팁</title>
      <link>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81/</link>
      <pubDate>Sun, 09 May 2021 18:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/09/%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%A0-%EB%95%8C%EC%9D%98-%ED%8C%81/</guid>
      <description>&lt;h2 id=&#34;이력서를-작성하게-된-이유&#34;&gt;이력서를 작성하게 된 이유&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;일반적으로 이력서는 이직할 때, 작성하지만 나는 평소에 미리미리 준비하고 싶었다.
이력서를 작성하다 보니, 매우 형편없는 것 같아서 인터넷을 찾아보았는데 아주 좋은 글들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 글을 읽어보고 나서 내 이력서의 문제점이 자세히 보이기 시작했다.&lt;/p&gt;
&lt;p&gt;틈틈히 완성도 있는 이력서를 완성시키고 무엇보다 지금부터 이력서에 내용을 적을 활동을 해야겠다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://minieetea.com/2021/04/archives/6193?utm_source=weirdmeetup&amp;amp;utm_medium=original_link_on_post&amp;amp;utm_campaign=%EC%9E%98+%EC%A0%95%EB%A6%AC%EB%90%9C+%EC%9D%B4%EB%A0%A5%EC%84%9C%EB%B3%B4%EB%8B%A4+%EC%A4%91%EC%9A%94%ED%95%9C+%EA%B2%83&#34;&gt;잘 정리된 이력서보다 중요한 것&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baek.dev/post/2/&#34;&gt;개발자 이력서 작성 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://gwonsungjun.github.io/articles/2019-09/99con-resume&#34;&gt;이상한 모임 세미나 - 99CON &amp;lt;이력서&amp;gt; 참석 후기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/weirdx&#34;&gt;이상한 모임&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 08 May 2021 15:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 오라클 성능 고도화 SQLP 강의를 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;REDO, UNDO 로그에 대해서 배울 수 있어서 좋았다.&lt;/li&gt;
&lt;li&gt;실행 계획을 확인하는 것이 아직은 많이 어색했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;앞으로 개발을 하면서, 항상 실행 계획을 확인하는 습관을 들이고, 눈에 익숙해져야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 대해서, 나름 관심이 있다고 생각했는데 아무것도 모르고 있다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;인덱스에 대한 더 깊은 이해가 필요한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 작성한 쿼리와 인덱스가 머리속에 그림이 그려질 때까지 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>오라클 성능 고도화 강의 (1)</title>
      <link>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1/</link>
      <pubDate>Sat, 08 May 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/08/%EC%98%A4%EB%9D%BC%ED%81%B4-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%8F%84%ED%99%94-%EA%B0%95%EC%9D%98-1/</guid>
      <description>&lt;h3 id=&#34;오라클-성능-고도화-강의&#34;&gt;오라클 성능 고도화 강의&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117525284-6ec5ac80-affc-11eb-8e4f-f245c5ef8828.jpeg&#34; alt=&#34;IMG_5C71B9160877-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에, 한번 튜닝 수업을 들은 적이 있었지만, 아직 경험이 부족한 상태에서 들어서 그런지 이해가 가지 않는 부분이 많았다. 실무를 조금 해보면서, 어느정도 쿼리에 익숙해진 상태에서 강의를 들으면 어떨까라는 생각이 들어서 강의를 수강하게 되었다.&lt;/p&gt;
&lt;h3 id=&#34;sqlp-시험에-실패하는-이유&#34;&gt;SQLP 시험에 실패하는 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SQLP 시험에 실패하는 이유는 주로 글로만 학습해서 그렇다.&lt;/li&gt;
&lt;li&gt;SQLP 시험 설계는 실무 전문가임을 인정해주는 자격증이다.&lt;/li&gt;
&lt;li&gt;따라서 책으로만 학습해서 통과는 어렵고, 실무와 경험을 같이 쌓아야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-방법&#34;&gt;SQLP 시험에 합격하기 위한 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;정확히 알아야한다.&lt;/li&gt;
&lt;li&gt;상황에 따라서 답이 달라짐을 알아야한다. (DBMS 버전, 데이터 량, 데이터 분포 등등&amp;hellip;)&lt;/li&gt;
&lt;li&gt;집합적 사고를 할 줄 알아야한다. 이러한 능력은 실무에서 반복을 통해서 체화된다.&lt;/li&gt;
&lt;li&gt;모델링에 대한 이해가 같이 이루어져야한다. 따라서 모델링도 어느정도는 같이 공부를 해야한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sqlp-시험에-합격하기-위한-전략&#34;&gt;SQLP 시험에 합격하기 위한 전략&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;무조건 서술형을 다 맞춰야지 합격이 가능하다. 점수 분포가 서술형에 많은 점수가 있기 때문에 서술형을 다 맞지 않으면 합격이 힘들어진다.&lt;/li&gt;
&lt;li&gt;서술형을 먼저 풀고, 객관식을 풀고 객관식 중에서 쉬운 문제를 먼저 풀고 어려운 문제는 나중에 푼다.&lt;/li&gt;
&lt;li&gt;서술형을 답안을 작성할 때, 정확한 진단을 하고 핵심만 간결하게 그리고 절대로 길게 작성하면 안된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;chap-01-데이터베이스-아키텍처-sql-처리-과정-및-io&#34;&gt;CHAP 01. 데이터베이스 아키텍처, SQL 처리 과정 및 IO&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일단 오라클 아키텍처에 대해서, 제대로 알지 못해서 많이 당황스러웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REDO로그 및 UNDO 로그에 대해서 자세히 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버퍼 캐시 및, 버퍼 캐시 탐색 과정, 그리고 버퍼 캐시 히트율을 계산하는 방법에 대해서, 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시퀀셜 액세스와 랜덤 액세스의 원리 및 &lt;code&gt;Single Block IO&lt;/code&gt;와 &lt;code&gt;Multi Block IO&lt;/code&gt;의 차이에 대해서도 남에게 설명할 수 있을 정도로 공부를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오라클 힌트에 대해서 자세히 공부하고 힌트가 적용되지 않는 경우에 내부적으로 쿼리가 변환되는 경우가 있는데, 이러한 경우에 대해서도 들어본 기억은 있는데 확실하게 개념이 잡혀있지는 않았다. 따라서 힌트 관련해서 많은 것을 배워야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc-milti-version-concurrency-control&#34;&gt;MVCC (Milti Version Concurrency Control)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dirty Read : 다른 트랜잭션이 변경중인 데이터를 읽었는데, 그 트랜잭션이 최종 롤백 됨으로써 비일관성 상태에 놓이는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-Repetable Read : 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 값을 수정 또는 삭제 함으로써 읽은 값들이 서로 달라지는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phantom Read : 한 트랜잭션 내에서, 일정 범위의 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가함으로 인해 첫 번째 읽을 때 없던 데이터가 생기는 현상&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션이 실행 될 때, &lt;code&gt;UNDO&lt;/code&gt; 세그 먼트 헤더에 위치한 트랜잭션 테이블에서 슬롯을 할당 받는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 &lt;code&gt;UNDOO&lt;/code&gt; 레코드에는 &lt;code&gt;ITL SLOT&lt;/code&gt;이 있고, 블록에 속한 레코드 갱신을 위해서, &lt;code&gt;ITL&lt;/code&gt; 슬롯을 먼저 확보한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋이 이루어지면, 블록 클린아웃을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 클린 아웃 되지 않은 블록에 작업을 하게 되면, &lt;code&gt;SNAP SHOT TOO OLD&lt;/code&gt;가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 07 May 2021 09:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117382076-917e9500-af18-11eb-8194-2a583ab6cfa4.png&#34; alt=&#34;Screen Shot 2021-05-07 at 9 41 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큐브리드 세미나 발표에 댓글을 달았는데, 유용한 링크를 주었다. &lt;a href=&#34;https://www.cubrid.com/blog/3831726&#34;&gt;CUBRID의 개발 문화: CUBRID DBMS는 어떻게 개발되고 있을까?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.cubrid.org/dev-guide/&#34;&gt;CUBRID Developer Guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨트리뷰터에게 관심을 가져주어서 너무 좋았다. 포기하지 말고 틈틈히 소통하여, 개발을 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 하면서, 잘 모르는 부분을 그냥 넘어가는 경우가 있다. 따라서, 이 점을 유의해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 06 May 2021 08:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/PJGsPohDuoA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;포트폴리오를 작성할 때, 중점적으로 생각할 점에 대한 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 자가 진단해볼 수 있는 주요 항목이다.
&lt;ul&gt;
&lt;li&gt;실제 서비스를 공개적으로 배포하고 운영해보는 경험을 해보았다.&lt;/li&gt;
&lt;li&gt;유저의 피드백에 따라서, 성능 및 사용성을 개선해보고 신규 기능들을 추가해보았다.&lt;/li&gt;
&lt;li&gt;발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리 해 보았다.&lt;/li&gt;
&lt;li&gt;코드를 지속적으로 리펙토링하고 디자인 패턴을 적용해 보았다.&lt;/li&gt;
&lt;li&gt;위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드 오프를 고민해보았다.&lt;/li&gt;
&lt;li&gt;반복되는 수정이과 배포에 수반되는 작업을 자동화해보았다.&lt;/li&gt;
&lt;li&gt;언어나 프레임워크의 기능만으로 구현할 수 없는 것들을 직접 구현해보았다.&lt;/li&gt;
&lt;li&gt;내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 느끼고 개선해보았다.&lt;/li&gt;
&lt;li&gt;코드나 제품의 퀄리티를 유지하기 위한 분석 툴이나 테스틑 툴을 도입해보았다.&lt;/li&gt;
&lt;li&gt;타인과의 협업을 효율적으로 하기 위한 고민을 해보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>오픈 소스 분석 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Wed, 05 May 2021 17:30:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/05/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95/</guid>
      <description>&lt;h2 id=&#34;오픈-소스-분석-방법&#34;&gt;오픈 소스 분석 방법&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;머리속 한켠에는 오픈 소스 활동을 다시 하고 싶다는 생각을 가지고 있지만, 바쁘다는 핑계로 미뤄왔다. 우연히 어떤 블로그에서 &lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/#open-source%EB%9E%80&#34;&gt;오픈 소스 분석 방법&lt;/a&gt; 이라는 글을 읽고나서, 오픈 소스 개발을 하고 싶다는 생각이 들었다. 또한 오픈 소스 활동은 시간이 날때 하는 것이 아니라, 평소에 시간을 쪼개가면서, 짜투리 시간을 만들어야 가능하다는 것을 느끼게 되었다. 다음은 오픈 소스 분석하는데 좋은 팁이다.&lt;/p&gt;
&lt;h3 id=&#34;공식-문서를-통해-파악하기&#34;&gt;공식 문서를 통해 파악하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드를 분석하기 전에, 먼저 해당 솔루션에 대한 지식을 먼저 익혀야 한다. 하둡을 분석하려면, 코드를 보기 전에, 먼저 구글에서 발표한 논문을 읽어봐야 하고, &lt;code&gt;HBase&lt;/code&gt;를 분석하려면 먼저 &lt;code&gt;BigTable&lt;/code&gt; 논문을 읽어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스를 분석하기 전에, 공식 문서를 통해서 사용법을 익히면 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 나도 공감하는 내용이다. 오픈 소스라는 것이 평소에 많이 사용해보고 어떤 기능이 있는지 파악을 해야한다. 또한 이러한 기능이 생기게 된 이유 및 내부 동작 원리를 파악할 수 있으므로 공식 문서는 반드시 읽어보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자료 읽기를 먼저 해야하고, 그 뒤에 코드 분석을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아키텍처-분석-큰-숲-바라보기&#34;&gt;아키텍처 분석 (큰 숲 바라보기)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116687-9e40a300-adc9-11eb-9873-4357a112947d.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소스코드의 폴더 구성을 보면서, 대략적인 기능들과 아키텍처를 파악해볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음에는 오픈 소스의 아키텍처를 파악한 후에, 디테일한 부분으로 이동하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 모듈들이 어떤 역할을 하고 있는지 살펴보고 상호간에 어떻게 연결되어 있는지 파악하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;큰 아키텍처를 연필이나, 다이어 그램 도구로 직접 그려보면서 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분석을 할 때, 라이브러리 또는 다른 오픈 소스에 대한 지식이 필요할 때가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;디테일-분석-나무-바라보기&#34;&gt;디테일 분석 (나무 바라보기)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116755-b57f9080-adc9-11eb-8f79-d17a216cd422.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큰 숲을 파악한 후에, 디테일한 부분을 분석한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 알고리즘에 대해서는 때로는 이론 보다는 코드가 더 보기 쉬울 때가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클래스는 어떤 정보를 담고 있으며, 어디서 사용되는지, 그리고 어떤 방식으로 동작하는지 등을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 함수를 파악하려고 하지 말고, 조금씩 자신이 살펴보려는 기능과 관련된 함수 들을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디버거를 통해서, BP (&lt;code&gt;Break Point&lt;/code&gt;)를 걸어놓고 직접 실행해보면서, 코드의 흐름을 파악해보는 것도 많은 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수의 인풋(&lt;code&gt;Input&lt;/code&gt;)에는 어떤 데이터가 들어오고, 아웃풋(&lt;code&gt;Output&lt;/code&gt;)은 어떤 데이터를 반환하는지 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 통해서, 각 함수의 사용법 및 인풋, 아웃풋을 파악하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 분석을 빠르게 하기 위해서는 분석에 필요한 로그를 추가하여, 재 컴파일을 한 후에 실행을 해보면서 로그를 확인하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단순히 코드만 보면 특정 연산의 흐름이 어떻게 진행되고 있는지 파악하기 어려울 때가 많이 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수정, 실행, 확인 사이클을 최대한 짧게 만드는 것이 좋다. 코드를 분석하기 위해서는 분석에 필요한 정보를 출력하는 코드나 확인을 위한 코드를 추가한 후에 기능을 실행하여 확인해야하는 경우가 많다. 이 경우에, (수정, 실행, 확인)을 하는 사이클이 짧아질 수록 효율이 높아지고 작업 패턴이 있다면 이를 스크립트 형태로 만드는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 분석 방법에는 &lt;code&gt;Bottom Up&lt;/code&gt; 방식과, &lt;code&gt;Top Down&lt;/code&gt; 방식이 있다. 서로 장단점이 있고, 사람마다 스타일이 다르지만 여러명이서 같이 분석을 한다면 두 스타일을 섞어서 하되, 약간 더 레벨이 높은 사람을 한 명 끼워서 팀을 만들면 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;오픈-소스-활동을-지속하기-위한-팁-tip&#34;&gt;오픈 소스 활동을 지속하기 위한 팁 (TIP)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117116845-cfb96e80-adc9-11eb-94a8-9a1bbb70c697.jpg&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포기 하지 않는 것이 중요하다!!!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자신에게 질문을 많이하는 것이 중요하다. 특정 기능에 대해서 &amp;ldquo;나라면 어떻게 개발했을까?&amp;rdquo; 라고 자신에게 질문을 던지고, 머리속에 어떻게 구현할 것인지를 먼저 생각을 해본다. 처음에는 자신이 예측한 부분이 많이 틀리겠지만 코드를 많이 보고 연습을 많이 하면 이것도 얼추 많이 맞추게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분석하면서 그림 또는 문서로 정리하면 분석하는 시점에도 도움이 되지만 나중에도 도움이 된다. 이렇게 정리하면서 중간 중간에 머리속에서만 빙빙 돌던 생각 이 정리될 때가 많고 &amp;ldquo;분석이 다 된 다음에 정리해야지&amp;quot;라는 생각이면 거의 정리는 못한다고 봐도 된다. 나중에 정리하려고 생각하면 정리도 어렵고, 잘 생각나지 않으므로 분석하면 정리하는 습관을 가지자!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;혼자서 하기 힘들면, 다른 사람들과 같이 분석하는 방법이 있고, &lt;strong&gt;힘들어도 싸이클을 정하고 싸이클을 도는 것이 중요하다!!!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 경우 혼자서 하는 것보다 함께 하는 것이 낫다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오픈 소스 메인테이너의 문서 및 논문, 그리고 유튜브 영상을 보는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드를 무조건 많이 보는 것이 좋다. 코드를 인쇄하여 보는 사람들도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;당장 관심있는 부분부터 집중적으로 파악하라, 방대한 시스템을 보다 보면은 금방 지루해지고, 갈 곳을 잃어버리는 수가 많은데, 당장 필요한 부분부터 집중해서 보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;느낀점&#34;&gt;느낀점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특정 기능에 대해서 &amp;ldquo;나라면 어떻게 개발했을까&amp;rdquo; 충분히 생각을 해 본 후에, 코드를 보면서 이를 확인하는 과정을 통해서, 개발 실력을 많이 높힐 수 있을 것이라고 생각을 한다. 또한 분석하면서 재미를 느낄 수 있는 포인트가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/#open-source%EB%9E%80&#34;&gt;오픈 소스 분석 방법&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.popit.kr/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%82%98/&#34;&gt;오픈소스: 코드 분석 어떻게 하나?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 05 May 2021 16:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나의 핵심 역량 및 성취 그리고 주요 프로젝트 및 성과에 대해서 생각을 해보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API를 컨슈머를 위주로 작성하는 법에 대해서 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;유용한 블로그 글 및 좋은 소식을 들을 수 있는 사이트를 발견하였다. &lt;a href=&#34;https://awesome-devblog.netlify.app/&#34;&gt;어썸 데브 블로그&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://okky.kr/article/408595&#34;&gt;작은 오픈소스 프로그램을 분석해서 실력을 쌓아 나간 사례&lt;/a&gt; 라는 글을 읽어 보게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;libuv&lt;/code&gt;에 대해서 분석한 글을 읽어 볼 수 있었다. &lt;a href=&#34;https://blog.naver.com/pjt3591oo/222339028273&#34;&gt;https://blog.naver.com/pjt3591oo/222339028273&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;삼성에서 운영하는 오픈 소스 사이트 및 행사를 알게 되었다. 그리고 행사에 참여하게 되었다.&lt;a href=&#34;https://opensource.samsung.com/community/mine/mineArticle/10?lang=KR&#34;&gt;Circle-OpSelector를 설계하고 기능 추가 하기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;평소에 정리를 하지 않아서 막상 생각나는 것들이 없었다. 따라서 이러한 점을 고려하면서 나의 핵심 역량 및 어떤 성취를 하였는지 그리고, 내가 맡은 주요 프로젝트에서 어떤 성과를 내었는지를 항상 생각하고, 정리를 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매주마다, 나의 핵심 역량 및 회사에서 어떤 성과를 내었는지를 정리하는 시간을 가져야겠다. 이는 주간 회고에서 작성하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 회사에서 일을 하면서, 계획을 세우고 코딩을 하는 과정에서 내가 어떤 사고 과정을 거쳐서 이렇게 구현을 하게 되었는지에 대한 글을 작성해보는 것이 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API를 컨슈머 관점에서 디자인 하는 법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 채용 부분과, 토이프로젝트 부분이 많이 유용하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오랜만에 페이스북에 들어가서, 개발자 커뮤니티의 글을 읽었는데, 많은 정보가 있었다. 주기적으로 페이스북에 개발자 커뮤니티의 글을 읽고 정보를 얻어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인공지능 분야라서 잘은 모르지만, 일단 해보도록 하였다. 오픈소스 관련된 행사는 매우 드물기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실력을 어떻게 쌓을 수 있었는지에 대한 글을 읽어보았을 때, 다음의 과정을 거쳐서 실력을 쌓은 것을 확인할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 자신을 관찰하는 시간을 가졌다.
2. 자신이 가지고 있었던 과거의 사고방식의 문제점을 깨달았다.
3. 과거의 사고 방식을 버리고 새로운 사고 방식을 실천했다.
4. 배우는 과정을 일지에 기록했고, 왜(why), 어떻게(how)를 사용하여 자기 스스로 질문하고 대답하였다.
5. 위의 과정에서 자신이 생각하고 행동했던 것과 행동했던 것들이 뭐가 다른지를 관찰하여 깨달은 점을 기록하였다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117120460-53755a00-adce-11eb-931f-56dee0e7f158.png&#34; alt=&#34;사고 과정&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 진행할 때 기록하는 사고 과정을 참고 할 수 있는 내용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117120637-8cadca00-adce-11eb-980c-d2aae31de799.png&#34; alt=&#34;사고과정2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이를 통해서, 개발을 할 때 일지를 적는 것이 좋다는 것을 배우게 되었다. 또한 그냥 일지를 막 적는 것이 아니라, 리서치 한줄을 작성하더라도 그것을 &lt;strong&gt;왜 하는지 알 수 있게 작성한다.&lt;/strong&gt; 또한 &lt;strong&gt;알고자 하는 정보의 방향이나 얻을 수 있을 것이라는 효과를 미리 정하고&lt;/strong&gt; 나서 리서치를 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일이 막혀서 잘 진행이 안되는 경우에는 붙잡지 말고, 빠르게 현재 상황에서 선택할 수 있는 옵션을 만들어 내자. 어떤 문제가 잘 안풀려서 일이 진행이 되지 않는 것 보다는 이를 해결할 수 있는 옵션을 만들고 선택하는 행위를 하지 않아서 일이 진행이 되지 않는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리서치를 할 때, 내가 이러한 리서치를 왜 하는지 그리고 알고자 하는 방향 및 어떤 정보를 얻기 위해서 이러한 리서치를 하는지에 대해서 미리 정해놓고 리서치를 하자. 그렇지 않으면 검색 엔진에서 옛날 처럼 많은 시간을 소모하고 허우적 댈 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항상 모든 행동을 할 때, 내가 이러한 행동을 왜하는지 그리고 어떤 목적을 가지고 하는지에 대해서 생각을 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제가 안 풀릴때는 안풀린다고만 생각하지 말고 이를 해결 할 수 있는 옵션을 만들고 이를 하나씩 적용하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 04 May 2021 14:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 한 블로그 글을 읽었다.&lt;a href=&#34;https://taetaetae.github.io/2019/01/10/spring-redirect-oom/&#34;&gt;Spring MVC Redirect 처리중에 발생한 Out Of Memory 원인 분석하기
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;네트워크 기초에 대해서 다시 공부하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드의 문제점을 재현해보고 직접 눈으로 확인하면서 해결하는 모습이 인상 깊었다. &lt;code&gt;nGrinder&lt;/code&gt;로 부하를 주고, &lt;code&gt;Pinpoint&lt;/code&gt;로 모니터링을 하고 힙 덤프를 통해서 실제로 &lt;code&gt;JVM&lt;/code&gt;에서 &lt;code&gt;FULL GC&lt;/code&gt;가 몇 번 일어나는지 측정까지 하고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;허브, 브릿지, 스위치에 대해서 알게 되었고, 각각 어느 계층에서 동작하는지를 파악하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/117107370-6ed76980-adbc-11eb-9796-c8e589c83733.png&#34; alt=&#34;Screen Shot 2021-05-05 at 4 09 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;허브(L2) : 단순 브로드 캐스트를 하는 통신 장비이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브릿지(L2) : 컴퓨터와 컴퓨터간의 통신할 수 있는 통신 연결 장비이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스위치 (L2) : 여러 컴퓨터간의 통신 연결 장비를 말한다. (오류 검사, 빠른 속도, 멀티 포트 브릿지) 기능이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;라우터 (L3) : 네트워크 통신 데이터(패킷)을 네트워크 주소를 기준으로 도착지에 전달하는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;게이트웨이에 대해서 배웠는데, 이는 캐시와 같이 상대적인 개념이라는 것을 알게 되었다. 게이트웨이의 역할을 서로 다른 네트워크를 연결하는 역할로써, L3 레이어에서는 라우터가 될 수 있고 L2 레이어 관점에서는 스위치가 될 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 서브넷팅에 대한 개념에 대해서도 배울 수 있었고, &lt;code&gt;IPv4&lt;/code&gt;에 대해서도 배웠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NAT&lt;/code&gt;에 대해서 배웠으며, 사설 IP 주소와 공인 IP 주소를 테이블을 이용하여 맵핑 해준다는 것을 배웠다. 분명히 학부 네트워크 수업때 들었던 내용이지만 생소한 내용이 많았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;학부때 배웠던 개념이라고 하더라도, 많이 잊어버린 기초 지식들이 많았고 이를 일하면서 틈틈히 채워나가야 하는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;실무와 연결시켜서 지식을 배우니까 좀 더 기억에 오래 남을 수 있었던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전산 컴퓨터 기초 지식을 다시 복습해보면서, 내가 어떤 부분이 부족한지 꾸준히 파악하고 채워나갈 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 03 May 2021 16:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 클린 아키텍처 파이썬이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 디자인에서 중요한 컨셉중에 관심사의 분리와 제어의 역전이 중요하다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;추상화를 할 때, 웹 프레임워크는 웹을 통해서 프로그램을 이용할 수 있게 해주는 것이며 분리가 잘 되어 있다면, &lt;code&gt;CLI&lt;/code&gt;를 통해서 비즈니스 로직의 변경없이 프로그램을 사용할 수 있어야한다.&lt;/li&gt;
&lt;li&gt;데이터베이스 역시, 관계형 데이터베이스 뿐만 아니라, &lt;code&gt;NoSQL&lt;/code&gt;도 빠르게 바꿔서 사용할 수 있도록 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 02 May 2021 22:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/05/02/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;숫자 야구를 구현하는 간단한 과제를 하였다.&lt;/li&gt;
&lt;li&gt;오픈 소스 분석 방법이라는 블로그 글을 읽었다.&lt;/li&gt;
&lt;li&gt;회사에서 성능 개선 이슈를 맡아서 진행을 하였다.&lt;/li&gt;
&lt;li&gt;회사에서 진행하고 있는 솔루션에서 개선해야할 점들을 발표 자료로 만들어서, 발표를 해보았다.&lt;/li&gt;
&lt;li&gt;파이썬으로 클린 아키텍처를 만드는 방법에 대해서, 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;장기적으로 보았을 때, 체력과 건강이 중요하기 때문에, 복싱 도장에 등록을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아직 함수나, 클래스를 나누는 연습이 많이 부족한 것을 느낄 수 있었다.&lt;/li&gt;
&lt;li&gt;회사에서 코딩을 할때, 계획을 세우고 이 계획을 꾸준히 변경하면서 코딩을 해야겠다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;시간이 없다는 핑계로 오픈 소스 활동을 하고 있지 않은데, 다른 사람들이 바쁜 와중에도 매일매일 조금씩이라도 소스 코드를 보면서, 기여를 하려는 것을 보고 많은 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;성능 개선 이슈를 진행할 때, 코드에 역할에 대해서 이해를 하지 않고 해결하려고 했던 것 같다. 따라서 앞으로는 무조건 성능을 개선하기 전에 이 코드들이 각자 어떤 역할을 하고 있는지를 먼저 파악해야겠다.&lt;/li&gt;
&lt;li&gt;내가 말하고 싶은 점들을 말 할 수 있어서 좋았고, 다른 사람들의 의견을 들을 수 있어서 좋았다.&lt;/li&gt;
&lt;li&gt;책은 PDF 형태로, 무료로 저자가 공개하였는데, 그 이유는 자신도 다른 사람들이 무료로 공개한 정보로 부터 많은 도움을 받았고 이 책을 쓸 수 있었다고 했기 때문에 무료로 공개했다고 했다. 굉장히 멋있었고 나도 이 저자처럼 나중에 책을 집필해서, 다른 사람들에게 무료로 공개할 수 있으면 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 주도 개발 방법을 사용해서 코딩을 해야겠다는 생각이 들었고, 의존성 분리가 잘 되어있지 않은 모듈에 대해서는 우선 테스트 코드를 기존의 코드를 신경쓰지 않고 작성을 한 후에, 테스트 코드가 돌아가도록 작성해보는 것도 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 내가 알고 있는 것을 공유하고 다른 사람들의 생각을 듣는 것이 매우 재미있고 배울점이 많았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;테스트 코드, 클래스, 메서드 주석을 나중에 작성하려는 마음을 먹지 말고, 무조건 먼저 작성을 하고 나서, 구현을 하자 절대로 나중에는 작성하지 않는다!&lt;/li&gt;
&lt;li&gt;회사에서 외주를 위한 API 문서를 작성하고 있는데, 기존에 있는 API 문서가 관리 되지 않아, 작업하기 많이 힘든데, 문서를 작성하면 이를 관리하여 유용한 문서가 될 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계획을 세우는 것은 계획대로 실천하기 위해서 세우는 것보다, 계획을 계속 수정하면서 방향을 잡는 것이다. 따라서 계획이 쓸데 없는 것으로 생각하지 말자.&lt;/li&gt;
&lt;li&gt;배운 것을 남들에게 공유하고, 발표를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 30 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 복싱 도장에 등록을 했다.&lt;/li&gt;
&lt;li&gt;오늘은 하루종일 API 문서만 작성했다.&lt;/li&gt;
&lt;li&gt;요즘에는 내가 배운 것들을 어떻게 공유하지라는 상상을 하곤 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;맨날 앉아만 있어서 그런지, 몸이 무겁고 작은일에도 짜증이 나고 만사가 귀찮기도 했는데 운동을 배우면서, 건강해지고 코딩도 잘 할 수 있으면 좋겠다. 공부할 시간도 없다는 핑계로 여태까지 미뤄왔는데 지금이라도 해야겠다&lt;/li&gt;
&lt;li&gt;문제를 해결하기 위해서, 줌을 하듯이 확대 축소를 할 수 있어야한다. 때로는 아키텍처만 파악하고 나서, 필요한 부분을 돋보기로 보듯이 확대해서 문제를 해결해나가자.&lt;/li&gt;
&lt;li&gt;내가 설계한 API도 아니고, 문서화도 잘 되어있지 않아서, 굉장히 힘들었다. 다음에 이러한 일이 없으려면 어떻게 API를 설계해야하는지 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들에게 공유를 하자라는 마음으로, 공부를 하고 자료를 만들다보니 더 배우는 게 많았고 머리에도 오래 남는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서화를 할 때, 나중에 내가 작성한 코드나 설계한 API를 사용할 사람을 생각하는 마음으로 작성하고, 때로는 귀찮다고 커밋 메시지를 대충 적을 때도 있는데, 이를 개선해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;운동을 꾸준히 하여 , 몸과 마음을 건강하게 할 것이다.&lt;/li&gt;
&lt;li&gt;다른 개발자들을 배려하면서, 개발을 하자 현재는 혼자 개발을 할 지라도, 나중에 언제든지 다른 개발자들이 내 소스 코드를 이용하여 개발을 이어나간다는 생각을 하고, 배려하면서 코딩하자.&lt;/li&gt;
&lt;li&gt;내가 배운 것을 적극적으로 공유하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 29 Apr 2021 10:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클린코드를 플라스크에서 작성하는 법에 대한 책을 읽고 공부하였다.&lt;/li&gt;
&lt;li&gt;모바일 개발 외주를 주기 위해서, API 문서를 정리하였다. 제대로 작성하는 법에 대해서 주말에 공부하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우연히, 우아한 테크 코스 영상을 보았는데, 이를 보면서 블로그에 정리하고 실제로 녹화를 해보면서 발표 연습을 하자라는 마음을 먹었던게 기억이 났다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해야할 일을 일일 회고에는 많이 기록을 해두었는데, 막상 기억이 나지 않을 때가 있으므로, 따로 투두 리스트를 정리해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 비슷한 일로, 백기선님의 자바 강의를 듣고, 이를 기술 블로그에 정리하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파이썬으로 작성하는 클린 아키텍처 및 어떻게 테스트 코드를 작성하는 법에 대해서 배울 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출퇴근을 하는데, 많은 시간이 소모되고 있다. 따라서, 앞으로는 일찍 출근을 하여서, 이를 최대한 줄일 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;건강 관리를 지금 부터 해야지, 나이들어서도 계속 공부나 자기 개발을 할 수 있을 것 같다. 따라서 지금부터 운동을 배우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>마크다운으로 슬라이드 쇼 만드는 방법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft/</link>
      <pubDate>Wed, 28 Apr 2021 11:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%9C%BC%EB%A1%9C-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C-%EC%87%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-draft/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기존에 슬라이드 쇼를 만드는데, 콘텐츠에 집중하기 보다는 부가적인 요소에 집중할 때가 많았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 발표 자료는 사실, 슬라이드 디자인이 크게 영향을 미치지 않는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프레젠테이션을 만들때 드는 비용을 많이 줄여줄 수 있다고 생각을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 웹에서 동작하기 때문에, 커스터 마이징을 할 수 있고 더 실험적인 동작을 할 수 있을 것 같다. (예제 코드를 실행해보기)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아래에 비슷한 툴들이 많이 있다. 따라서 이를 통해서 슬라이드를 만들어보면 좋을 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark.show/#/&#34;&gt;MarkShow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://news.hada.io/topic?id=4136&#34;&gt;마크다운으로 슬라이드 쇼 만들기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jxnblk/mdx-deck#presenter-mode&#34;&gt;MDX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marpit.marp.app/markdown&#34;&gt;Marpit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 28 Apr 2021 09:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네이버에서 &lt;a href=&#34;https://d2.naver.com/news/7591059&#34;&gt;NDTI&lt;/a&gt;라는 맞춤 채용 제안을 확인할 수 있었다. 재미있고 좋은 아이디어인 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지도 서비스를 구축하는데 도움이 되는 라이브러리 및 도구를 발견하였다. 토이 프로젝트를 하는데 많은 도움이 될 것 같다. &lt;a href=&#34;https://news.hada.io/topic?id=4135&#34;&gt;OPEN STREET MAP으로 나만의 지도시스템 만들기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDD를 하는 이유 중에, 테스트를 하면서 미리 설계를 같이 하고 이를 검증해볼 수 있다는 점도 있지만 무엇보다 좋은 점은 구현을 먼저하면 테스트 코드를 귀찮아서 작성하지 않는다는 점이다. 또한 문서화도 마찬가지인데 메서드를 설명하는 코드나 클래스를 설명하는 코드를 작성할 때, 미리 클래스나 메서드를 설명하는 주석을 먼저 작성하면 나중에 귀찮아서 작성하지 않아도 되는 장점이 있고 메서드 주석을 작성하면서 내가 작성하려는 메서드의 목적과 좋은 메서드 이름을 지을 수 있는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이전에 계획을 먼저 세우고 코딩을 하려고 하였지만, 구현하면서 계획이 자주 바뀌어 결국에는 원래대로 돌아가고 말았다. 하지만, 기능 구현은 기능 구현을 하면서 언제든지 바뀔 수 있다는 점을 간과한 것 같다. 또한 처음부터 모든 기능 목록을 완벽하게 정리해야한다는 것도 부담을 가지게 된 것 중에 하나인 것 같다. 따라서 처음부터 모든 기능 목록을 정리해야하는다는 부담을 가지기 보다는 기능을 구현하면서 문서를 계속 업데이트하는 방향으로 가자. 너무 학교 과제물을 제출하던 습관이 들어, 회사에서도 한번 만들면 끝이라고 생각하는데 이러한 생각은 학교에서까지만 가지고, 현실에서는 계속 꾸준하게 고쳐가는 것이 중요하다고 생각을 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구조 개선을 해야한다고 외치기만 하면서, 구체적으로 어떤 부분을 어떻게 고쳐야겠다고 정리하여 &lt;code&gt;PM&lt;/code&gt;에게 구체적으로 말해본 적이 없었던 것 같다. 따라서, 제안을 하기 위해서는 구현하면서 개선해야할 점이 보이면, 틈틈히 정리를 해두고 구체적으로 어필을 해야겠다. 여태까지 구체적인 방향을 제시하지도 않으면서 불평만 하지 않았는지 되돌아봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;learning-배운점&#34;&gt;Learning (배운점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계획을 세우고 코딩을 하되, 이 계획은 언제든지 바뀔 수 있다는 것을 명심하자. 죽어있는 계획 보다는 계속해서 살아있는 문서를 만들려고 노력하자. 또한 기능 목록을 메서드 설계나 구현과 같이 너무 상세하게 적으려고 하지 않는다. 따라서 정상적인 부부도 중요하지만, 예외적인 상황도 기능 목록에 정의한다. 특히 예외사항은 시작하는 단계에서 모두 찾기 힘들기 때문에, 기능을 구현하면서 계속해서 추가해나가도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로젝트를 진행하면서 개선할 점이 보이면, 틈틈히 정리를 해두고 다음 이관에 처리할 일감화를 시켜서 &lt;code&gt;PM&lt;/code&gt; 분들에게 나의 의견을 제시하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;계획을 먼저 세우고 코딩을 할 때, 계획은 항상 변화한다는 것을 명심하면서 이를 수정하면서 코딩을 해야겠다. 죽은 계획이 아니라, 살아있는 계획을 세우는 것을 목표로 하자. 참고로 이 부분은 &lt;code&gt;PULL REQUEST&lt;/code&gt;를 할 때, 토의를 할 텐데 이 부분에서 논의를 같이 하면 될 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나중에, 테스트 코드를 지우더라도, 먼저 테스틑 코드를 작성하고 이를 구현하는 연습을 하자, 그리고 메서드를 작성하기 전에 메서드 주석을 먼저 작성하고 이로부터 메서드의 목적과 좋은 이름을 도출해내자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 네트워크 도구 (테스트, 추적, 모니터링 명령어)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4/</link>
      <pubDate>Wed, 28 Apr 2021 00:12:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EC%A0%81-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%AA%85%EB%A0%B9%EC%96%B4/</guid>
      <description>&lt;h3 id=&#34;hping3&#34;&gt;hping3&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;hping3 -S www.daum.net -p 80
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP/UDP, ICMP 및 다양한 종류의 패킷을 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 빠른 주기로 패킷을 보내고 싶다면 &lt;code&gt;--fast&lt;/code&gt; 옵션을 줄 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iptables&#34;&gt;iptables&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이 명령어는 특정 IP 주소의 요청을 막을 수 있는 명령이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# localhost의 UDP 요청을 차단하는 규칙을 추가하였다.
iptables -I OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

# iptables 설정을 확인해본다.
iptables -L -n

# 다른 터미널에서 실제 요청을 보내보지만 응답이 오지 않는다.
hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast

# 위의 설정을 삭제한다.
iptables -D OUTPUT -s localhost -d localhost -p udp --sport 7000 --dport 8000 -j DROP

iptables -L -n

# 요청이 정상적으로 보내짐을 확인할 수 있다.

hping3 --udp 127.0.0.1 -s 7000 -p 8000 --fast
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 도구를 사용하는 것은 내부적으로 커널의 기능을 사용하는 것이고, 리눅스 커널 안에 넷 필터(&lt;code&gt;NET FILTER&lt;/code&gt;) 라는 기능을 이용하여 구현하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정이 늘어날수록 점점 느려진다는 단점이 있어서, 요즘에는 &lt;code&gt;BPF&lt;/code&gt;라는 툴을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nslookup&#34;&gt;nslookup&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;도메인 이름을 IP 주소로 변환해주는 명령어이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270076-bd33a980-a7b9-11eb-83fc-a8ffaef46022.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 08 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이와 비슷한 도구로 &lt;code&gt;dig&lt;/code&gt; 라는 도구가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270202-dccad200-a7b9-11eb-9f82-fa515cebecdd.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 36 45 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;nmap&#34;&gt;nmap&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;포트 스캔을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270489-18fe3280-a7ba-11eb-8d79-95571243f764.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 38 40 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어 및 결과는 &lt;code&gt;localhost&lt;/code&gt;에 열려있는 포트들을 터미널에 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iftop&#34;&gt;iftop&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116270960-89a54f00-a7ba-11eb-9c44-38576b8ffebf.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 41 42 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bmon&#34;&gt;bmon&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271227-c113fb80-a7ba-11eb-8473-232acc8656c2.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 42 55 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 I/O 트래픽 모니터링을 도와주는 툴이다.&lt;/li&gt;
&lt;li&gt;특이한 점은 TUI 그래픽으로 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dstat&#34;&gt;dstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116271795-47304200-a7bb-11eb-9aea-bbeba62def27.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 47 14 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 형태로 시스템 정보와 같이 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ss&#34;&gt;ss&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272077-8fe7fb00-a7bb-11eb-869c-6110b9b5a938.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 49 12 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;소켓의 리시브 큐와 센드 큐를 모니터링 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116272413-d76e8700-a7bb-11eb-9726-d953b812550b.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 50 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 옵션으로 현재 소켓 상태를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>가상 파일 시스템(VFS)이란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Wed, 28 Apr 2021 00:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/28/%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9Cvfs%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;가상-파일-시스템virtual-file-system&#34;&gt;가상 파일 시스템(Virtual File System)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116267696-9c6a5480-a7b7-11eb-86f3-ca2a38093928.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 20 52 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;리눅스가 하는 일을 생각해보면 크게 하드웨어 자원 관리 및 소프트웨어의 자원을 관리한다고 생각을 해볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스는 이러한 자원을 파일로써 관리하게 되며 모든 것이 가상 파일 시스템을 통해서 접근하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;NGINX&lt;/code&gt; 같은 웹 서버 프로그램이 시스템 자원을 요청할 때, 시스템 콜을 호출하게 되며 (open, read, write) 이러한 자원은 가상 파일 시스템(VFS)를 통해서 자원에 접근하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MSS 그리고 MTU (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft/</link>
      <pubDate>Tue, 27 Apr 2021 23:44:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/mss-%EA%B7%B8%EB%A6%AC%EA%B3%A0-mtu-draft/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116261520-b0f81e00-a7b2-11eb-96dd-03ae4f909358.png&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mss-maximun-segment-size&#34;&gt;MSS (Maximun Segment Size)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262109-3aa7eb80-a7b3-11eb-8648-27d4cdfb5779.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 48 40 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSS는 TCP 상에서 전송할 수 있는 사용자의 데이터(&lt;code&gt;payload&lt;/code&gt;) 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP 헤더를 제외한 데이터의 크기이다.&lt;/li&gt;
&lt;li&gt;MSS는 TCP(L4) 계층에서 데이터의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;위의 사진을 보면, TCP 헤더를 제외한 데이터 부분을 MSS라고 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mtu-maximun-transmission-unit&#34;&gt;MTU (Maximun Transmission Unit)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116262489-8bb7df80-a7b3-11eb-8254-7a56a5d13018.png&#34; alt=&#34;Screen Shot 2021-04-27 at 11 51 49 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTU는 네트워크에서 전송 될 수 있는 최대 패킷의 크기를 말한다.&lt;/li&gt;
&lt;li&gt;MTU는 IP(L3) 계층에서 패킷이라고도 불리운다.&lt;/li&gt;
&lt;li&gt;MTU에서 IP 헤더와 TCP 헤더를 제외하면 그것이 바로 MSS가 된다.&lt;/li&gt;
&lt;li&gt;MTU를 패킷이라고 부른다.&lt;/li&gt;
&lt;li&gt;참고로 L2는 프레임이라는 용어로 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;설정된-mtu-크기를-확인하는-방법&#34;&gt;설정된 MTU 크기를 확인하는 방법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116263219-27e1e680-a7b4-11eb-90c7-995a0ef1d0e5.png&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ip link&lt;/code&gt; 라는 명령어를 치면 현재 리눅스 환경에서 설정된 MTU 값을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;MTU 값이 1500 BYTES 으로 잡혀 있는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;패킷을-보내고-이를-트레이싱-해보자&#34;&gt;패킷을 보내고 이를 트레이싱 해보자&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;패킷을 보내기 위해서 &lt;code&gt;ping&lt;/code&gt; 이라는 도구를 통해서 구글 DNS 서버 (8.8.8.8)에 요청을 보내보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ping -M do -s 68 8.8.8.8&lt;/code&gt; 이 명령어는 서버에 68 바이트를 보내는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264144-03d2d500-a7b5-11eb-8d04-05da9a3b3b39.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 02 18 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사진을 보면 데이터는 68바이트를 보냈지만 실제로는 96 바이트가 전송된 것을 확인할 수 있다. 이유는 데이터에 헤더 부분이 포함되었기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추가로 &lt;code&gt;ping -M do -s 1500 8.8.8.8&lt;/code&gt; 명령어로 패킷의 최대 크기인 1500 MTU 만큼 데이터를 전송해본다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116264626-6926c600-a7b5-11eb-9487-b472c8c1264a.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 05 06 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러가 발생하는 것을 확인해볼 수 있는데, 그 이유는 헤더가 포함되었기 때문이다. 하지만 이 에러는 커널 레벨에서 발생한 것은 아니고 &lt;code&gt;ping&lt;/code&gt; 도구에서 발생시킨 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 확인해보기 위해서, &lt;code&gt;ping&lt;/code&gt; 보다 많은 기능을 지원하는 &lt;code&gt;hping3&lt;/code&gt; 도구를 이용해서 테스트 해보겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f icmp -Y &amp;quot;ip.dst == 8.8.8.8 or ip.src == 8.8.8.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용해서 패킷을 캡처하고 아래 명령어를 다른 터미널에서 입력을 해본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo hping3 -d 2000 --icmp 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/116265856-61b3ec80-a7b6-11eb-9333-e8b070648840.png&#34; alt=&#34;Screen Shot 2021-04-28 at 12 12 05 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 결과를 확인해 볼 수 있다. 자세히 살펴보면, 패킷이 정상적으로 전송이 된 것을 확인해볼 수 있지만 서버로 부터 응답이 오지 않는 것을 확인할 수 있다. 이로서 구글 도메인 서버에 요청할 수 있는 최대 패킷 크기는 1500 bytes 라는 것을 확인할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 2000 바이트를 데이터로 전송을 하였는데 MTU는 최대 1500 바이트이다. 따라서 패킷이 쪼개져서 전송되고 있다는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>데이트 타임 및 표준 규격에 대해서 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft/</link>
      <pubDate>Tue, 27 Apr 2021 18:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EA%B7%9C%EA%B2%A9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ISO_8601&#34;&gt;ISO 8061 - WIKI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2822&#34;&gt;RFC 2822&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 27 Apr 2021 13:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UUG0h7torbs&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;출근길에, 소프트웨어 엔지니어를 평가하는 4가지 항목이라는 영상을 보았다.&lt;/li&gt;
&lt;li&gt;기존에 느리게 동작하던 코드를 개선하였다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zzsza.github.io/development/2020/07/19/opensource-analysis/&#34;&gt;오픈 소스 분석 방법&lt;/a&gt; 이라는 블로그 글을 읽었다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ohgyun.com/798&#34;&gt;강연: 호갱노노 이렇게 만듭니다&lt;/a&gt; 이라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;오늘 사내 메신저에서 이해하지도 못했는데, 대충 이해했다고 생각하여 넘어갔지만, 실제로는 다른 이야기였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;성능 개선을 할 때, 코드를 이해하지 못해서 이 부분이 필요한 부분인지를 미쳐 파악하지 못했던 것 같다. 따라서, 사실 필요없는 부분 이었음에도 불구하고, 필요하다고 생각하여 어려웠던 것이다. 따라서 성능 개선을 할 때는 코드를 이해하도록 하고, 병목이 걸리는 부분이 필요한 부분인지를 먼저 파악해야할 것 같다.&lt;/li&gt;
&lt;li&gt;제대로 이해하지 못한 것을 대충 넘어가지 말고, 이해가 되지 않았다면 다시 되물어보거나 질문을 하는 자세를 가지자.&lt;/li&gt;
&lt;li&gt;오픈 소스 분석 방법이라는 글을 읽고, 다시 오픈 소스에 대한 열정이 타올랐고, 분석하는 구체적인 방법이 나와있어서 좋았다.&lt;/li&gt;
&lt;li&gt;기술 블로그를 읽다가 호갱 노노라는 회사를 알게 되었는데 내가 생각하는 개발자가 주도적인 회사인 것 같아서 너무 좋았다. 특히 개발자가 기획하는 회사라는 것이 너무 마음에 들었다. 평소에 개발자가 기획에 참여하지 못하고 어느 순간 어떤 방향으로 이미 결정이 되었을 때 같이 고민을 해보고 싶었지만 그러지 못해서 아쉬웠던 나의 마음을 알아주는 것 같았다.&lt;/li&gt;
&lt;li&gt;그리고 직군을 따로 나누지 않은 것도 너무 마음에 든다. 특히 서버 개발자가 데이터 처리나, 인프라에 접근할 수 있다는 것이 단점으로 생각되는 사람도 있겠지만 나는 장점으로 생각이 된다. 왜냐하면 내가 개발하는 서비스 위에 올라가는 환경을 알고 싶고 더 개선하고 싶은 마음이 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것을 그냥 얼렁뚱땅 넘어가지 말고, 모르면 모른 상태로 확실히 하거나 아니면 알려고 해야겠다. 모르는 것을 안다고 착각하면서 살지 말자.&lt;/li&gt;
&lt;li&gt;엔지니어를 평가하는 4가지 항목이라는 영상을 보았다. 평가하는 항목 중에는 다음과 같은 항목이 있다. (1.프로젝트 임펙트: 새로 개발한 기능이 올바른 방향으로 갈 수 있게 하는 것이 프로젝트 임펙트이다. 2.엔지니어링 엑설런스 : 새로운 기술을 도입해서 서버가 더 안정적으로 되었다. 또는 어떤 문제를 해결한 것을 말한다. 3.디렉션 : 방향을 제시할 수 있는가? 우리가 장기적으로 가야하는 방향을 제시할 수 있는 사람을 원한다. 4. 피플: 커뮤니케이션 문제 뿐만 아니라, 다른 팀들과 같이 일할 수 있는가? 다른 사람들과 더 큰일을 할 수 있는가?)&lt;/li&gt;
&lt;li&gt;위의 항목들 중에서 엔지니어링 엑설런스 능력을 주니어 프로그래머 시절에 무조건 실력을 쌓아야한다고 생각을 한다.&lt;/li&gt;
&lt;li&gt;또한 동시에 방향을 제시할 수 있는 사람이 되면 더할 나위 없이 좋을 것이다. 이관을 분기마다 하고 회고를 하는데, 이때 프로젝트를 경험하면서 공유하면 좋을 점들을 발표할 수 있는 기회가 있다. 이때 발표 자료와 내가 이야기하고 싶은 점들을 잘 이야기하면, 팀에게 좋은 방향을 제시할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;그리고 내가 가장 부족하다고 생각되는 점 중에하나가 바로 피플이다. 다른 팀들과 아직은 점접이 많이 없고 선배가 소통을 주로 하기 때문에 큰 장애는 없는데 이제 곧 연차가 쌓이면 이러한 능력도 무시할 수 없을 것이다. 회사에서 대인 관계가 좋은 사람들을 보고 배울점을 배워야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;성능 개선을 할 때 기본인 이 코드가 과연 필요한 부분인지를 생각하고, 코드를 어떻게 개선할까 생각하기에 앞서서 현재 코드를 제대로 이해하고 있는지를 먼저 파악해야겠다.&lt;/li&gt;
&lt;li&gt;내가 개발자로서 이루고 싶은 목표중에 오픈 소스 메인컨트리뷰터가 되는 목표가 있었는데, 관심있고 좋아하는 프로젝트를 꾸준히 살펴보고 사용하면서 내가 기여하는 자세를 평소에 길러야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 26 Apr 2021 23:30:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;과제를 끝냈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 한 번 더 느낄 수 있었다.&lt;/li&gt;
&lt;li&gt;객체지향적인 코딩 실력이 부족한 것을 느낄 수 있었고, 자바 실력을 더 키워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 미리 계획을 세우고 코딩을 하면서 내가 놓친 부분이 있지 않는지 생각을 하면서 코딩을 해야겠다.&lt;/li&gt;
&lt;li&gt;기존 회사 소스코드 의존성 때문에 테스트 코드를 작성하기 힘들다는 핑계를 대면서 테스트 코드를 작성하는 것을 미루었는데, 지금부터라도 테스트 코드를 작성하려고 노력하면서 좋은 설계를 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD 방식으로 개발을 하면서, 코딩 실력을 늘리려고 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;코딩을 하기 전에, 미리 계획을 세우고 계획대로 코딩을 하는 연습을 지금부터 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 기회에 부족함을 느끼고 성장했다고 생각을 하자.&lt;/li&gt;
&lt;li&gt;내가 너무 건방졌던 것 같다. 따라서 지금부터라도 회사에서 코딩을 하기 전에 미리 계획을 세우고 코딩을 하는 연습을 하자.&lt;/li&gt;
&lt;li&gt;또한, 어떻게 방식으로 코딩을 하는 것 보다 무엇을 방식으로 코딩을 하는 연습을 한다면 실력을 더 빨리 키울 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 25 Apr 2021 22:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/25/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근 시간에 개발 유튜브 영상을 시청하였다.&lt;/li&gt;
&lt;li&gt;코드를 작성할 때, 더 빨리 자주 실패하라는 문구를 잊어버린 느낌이었다.&lt;/li&gt;
&lt;li&gt;정신이 없다는 핑계로, 동료가 물어보는 질문에 생각하지 않고 답변을 해버려서 잘못된 정보를 전달하였다.&lt;/li&gt;
&lt;li&gt;파라미터에 여러가지 인자를 많이 전달하지 말라는 유튜브 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발 유튜브 영상중에 하나가 코딩을 할 때, 어떻게에 집중해서 코딩을 하지 말고 무엇을에 집중해서 코딩을 하라는 것이었다. 내가 작성한 코드를 뒤돌아보았을 때 어떻게 코딩을 할지 집중해서 코딩된 것이 많았던 것 같다. 따라서 코딩을 하는 의도를 드러낼 수 있게 무엇을에 집중해서 코딩을 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;코딩을 잘하려면, 많이 배우는 것도 중요하지만 많이 해보는 것 또한 중요하다. 따라서 토이 프로젝트를 계속 해나가야한다.&lt;/li&gt;
&lt;li&gt;아무리 바뻐도 확인을 하고, 순간 헷갈린다면, 확인해보고 답변을 준다는 식으로 말하거나, 바쁘다고 말하고, 지금 상태를 상대방에게 이야기하자.&lt;/li&gt;
&lt;li&gt;현재 회사 소스코드에 이러한 코딩이 많이 되어있는데, 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 방식으로 코딩하는 것은 절차지향 방식으로 코딩을 하는 것이고, 무엇을에 집중해서 코딩을 하는 것은 함수형에 가깝게 코딩을 하는 것이다.&lt;/li&gt;
&lt;li&gt;많이 해보고, 많은 실패로부터 배우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 의식적으로, 내가 구현에 집중해서 코드를 작성하고 있지는 않은가 되돌아봐야겠다.&lt;/li&gt;
&lt;li&gt;파이썬 코드를 공부하면서, 대충 구현하지 말고, 언어에서 정석이 있는지 찾아고보고 항상 더 좋은 방법이 있는지를 생각하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 좋은 코드에 대해서 생각을 하고, 현재 바뻐서 그냥 지나쳤던 코드라도, 메모를 해두고, 고쳐야할 코드라는 것을 표시하자.&lt;/li&gt;
&lt;li&gt;어떻게 하면, 코드를 더 좋은 구조로 개선시키킬 수 있는지 고민을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 23 Apr 2021 23:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클린 파이썬이라는 책을 읽었다.&lt;/li&gt;
&lt;li&gt;배포날이 다가오니까, 야근을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확실히 베스트 프랙티스를 보니까, 그동안 작성되었던 코드들의 개선사항이 눈에 보였다.&lt;/li&gt;
&lt;li&gt;아직은 회사 생활을 할만하다고 느끼지만, 구조를 개선하려는 노력이 없어서 아쉽고, 코드가 망가지는 것을 볼 때마다 가슴이 아프다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 하면, 코드를 깔끔하게 개선할 수 있고, 구조를 더 좋게 만들 수 있을지를 고민해봐야겠다.&lt;/li&gt;
&lt;li&gt;다른 회사에서는 이러한 상황에 처해있을 때, 어떻게 변화를 하는지 알아봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;불편함에 익숙해지지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 22 Apr 2021 22:00:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/MIYwej-VodE&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;오늘 출근을 할 때, 프로그래밍 왕초식 시리즈중에 하나인 왕파라미터를 사용하지 말자라는 영상을 보았다.&lt;/li&gt;
&lt;li&gt;오늘은 회사에서 코딩을 할 때, 비교적 일이 잘 풀린 편인 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에서 코드를 작성할 때, 위와 같은 왕파라미터를 사용하는 경우를 많이 보았고  이 경우에, 파이썬에서 지원하는 네임드 튜플을 사용하면 좋겠다는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;이제 마지막 이슈만을 남겨 놓고 있다. 이 이슈를 잘 처리하여 문제 없이 이관을 할 수 있으면 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍 언어를 사용할 때, 제대로 된 정석을 사용하려고 노력하고, 조금씩 코드를 발전시켜 나가자.&lt;/li&gt;
&lt;li&gt;틈틈히 파이썬 공부를 하면서, 최대한 파이썬 언어의 특징을 살려서 개발을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 코드를 대충 작성하지 않고, 사소한 부분이라도 가능한 최선을 다해서 작성할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 21 Apr 2021 23:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 정신이 없어서 생각하지 않고 동료에게 잘못된 정보를 전달하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아무리 바뻐도, 확인을 완전히 하고 전달을 해야겠다.&lt;/li&gt;
&lt;li&gt;구현을 할 때 일정을 고려해서 코딩하는 것과 정석대로 구현하는 것의 균형을 잡기 어렵다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;최대한 기존 소스 코드에 영향을 주지 않는 방향으로 구현을 해야하는 것인지 아니면, 과감하게 구현해야할때는 언제인지가 궁금했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아무리 바쁘더라도, 제대로 확인을 하고 정보를 전달하고 헷갈린다면 확인해보고 알려준다고 말을 하자.&lt;/li&gt;
&lt;li&gt;상대방이 무엇을 원하는지 이해가 되지 않는다면 이해가 되지 않는다고 말하자, 그냥 내가 이해한게 맞겠지라고 생각하고 말하면 안될 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확인을 하고, 정보를 전달하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신과정 추적해보기 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</link>
      <pubDate>Tue, 20 Apr 2021 23:51:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95-%EC%B6%94%EC%A0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-draft/</guid>
      <description>&lt;h3 id=&#34;추적-과정&#34;&gt;추적 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;추적하기 전에 클라이언트와 서버 코드를 컴파일 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;client.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define MAXLINE 1024

int main(int argc, char **argv) {
        struct sockaddr_in serveraddr;
        int server_sockfd;
        int client_len;
        char buf[MAXLINE];

        if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                perror(&amp;quot;error : &amp;quot;);
                return 1;
        }
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
        serveraddr.sin_port = htons(4000);

        client_len = sizeof(serveraddr);

        if(connect(server_sockfd, (struct sockaddr*)&amp;amp;serveraddr, client_len) == -1) {
                perror(&amp;quot;connect error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        read(0, buf, MAXLINE);
        if(write(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;write error : &amp;quot;);
                return 1;
        }
        memset(buf, 0x00, MAXLINE);
        if(read(server_sockfd, buf, MAXLINE) &amp;lt;= 0) {
                perror(&amp;quot;read error: &amp;quot;);
                return 1;
        }
        close(server_sockfd);
        printf(&amp;quot;server:%s\n&amp;quot;, buf);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;server.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

#define BUFF_SIZE 1024

int main(void){
   int server_socket;
   int client_socket;
   int client_addr_size;
   struct sockaddr_in server_addr;
   struct sockaddr_in client_addr;
   char buff_rcv[BUFF_SIZE+5];
   char buff_snd[BUFF_SIZE+5];

   server_socket = socket(PF_INET, SOCK_STREAM, 0);
   if(-1 == server_socket){
      printf( &amp;quot;server socket 생성 실패n&amp;quot;);
      exit( 1);
   }

   memset(&amp;amp;server_addr, 0, sizeof(server_addr));
   server_addr.sin_family     = AF_INET;
   server_addr.sin_port       = htons(4000);
   server_addr.sin_addr.s_addr= htonl(INADDR_ANY);

   if(-1 == bind(server_socket, (struct sockaddr*)&amp;amp;server_addr, sizeof(server_addr))){
      printf( &amp;quot;bind() 실행 에러n&amp;quot;);
      exit(1);
   }

   while(1){
      if(-1 == listen(server_socket, 5)){
         printf( &amp;quot;대기상태 모드 설정 실패n&amp;quot;);
         exit(1);
      }

      client_addr_size  = sizeof( client_addr);
      client_socket     = accept( server_socket, (struct sockaddr*)&amp;amp;client_addr, &amp;amp;client_addr_size);

      if (-1 == client_socket){
         printf( &amp;quot;클라이언트 연결 수락 실패n&amp;quot;);
         exit(1);
      }

      read (client_socket, buff_rcv, BUFF_SIZE);
      printf(&amp;quot;receive: %s\n&amp;quot;, buff_rcv);

      sprintf(buff_snd, &amp;quot;%ld : %s&amp;quot;, strlen(buff_rcv), buff_rcv);
      write(client_socket, buff_snd, strlen(buff_snd)+1);          // +1: NULL까지 포함해서 전송
      close(client_socket);
   }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 소스 코드를 복사하여, 파일을 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gcc -pg -g -o client client.c
gcc -pg -g -o server server.c
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;그리고 위의 명령어를 통해서 컴파일을 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uftrace&#34;&gt;UFTRACE&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115418135-35d3bc80-a234-11eb-898d-50f3f8eb093e.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 57 42 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고 나서는 &lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;ufrace&lt;/a&gt;를 이용하여 함수를 추적할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UFTACE는 C/C++로 작성된 프로그램의 실행을 추적하고 분석하는 도구이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/namhyung/uftrace&#34;&gt;uftrace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP 통신에 대해서 알아보자...</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</link>
      <pubDate>Tue, 20 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/tcp-%ED%86%B5%EC%8B%A0%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90.../</guid>
      <description>&lt;h3 id=&#34;tcp-transmission-control-protocol&#34;&gt;TCP (Transmission Control Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115409556-cf976b80-a22c-11eb-9c4c-c2f61110b0e2.png&#34; alt=&#34;tcp&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP는 응용 프로그램이 데이터를 교환할 수 있는 네트워크 대화를 설정하고 유지하는 방법을 정의하는 표준이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 IP 네트워크를 통해서 통신하는 호스트에서 실행되는 애플리케이션 간에 신뢰할 수 있고, 순서가 정해져있으며, 오류를 체크하고 전송할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;월드 와이드 웹, 이메일, 원격 관리, 파일 전송과 같은 주요 인터넷 애플리케이션은 전송 계층의 일부인 TCP에 의존한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/TLS 또한 TCP 위에서 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP는 인터넷 프로토콜 (IP)과 작동하여 컴퓨터가 서로 데이터 패킷을 보내는 방법을 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-맺는-과정&#34;&gt;연결을 맺는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411131-2d788300-a22e-11eb-8557-0eb3e42d1096.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN: 클라이언트가 서버에 SYN를 전송한다. 클라이언트는 세그먼트의 시퀀스 번호를 임의의 값으로 설정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN-ACK: 응답으로 서버는 SYN-ACK로 응답을 한다. 수신된 시퀀스 보다 많은 숫자로 설정 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACK: 마지막으로 클라이언트가 서버에 다시 ACK를 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정을 통해서 서버와 클라이언트는 연결을 맺으며 &lt;code&gt;3 Way HandShake&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;직접 확인하기&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo tshark -i enp0s3 -f &amp;quot;tcp port 80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위의 명령어를 입력하여 포트 번호 80의 TCP 패킷들을 필터링 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이어서 다른 터미널에서 &lt;code&gt;curl www.google.com&lt;/code&gt; 으로 구글 서버에 요청을 날린다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414010-a2e55300-a230-11eb-8c2d-07636049b212.png&#34; alt=&#34;today&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정상적으로 연결이 맺어진 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연결을-끊는-과정&#34;&gt;연결을 끊는 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115411888-d58e4c00-a22e-11eb-82d0-c47393198d7f.png&#34; alt=&#34;520px-TCP_CLOSE svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 종료하는 과정은 &lt;code&gt;4 Way HandShake&lt;/code&gt; 라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연결이 끊겼음에도 클라이언트에서 &lt;code&gt;TIME WAIT&lt;/code&gt;을 하는 이유는 지연되거나 유실된 패킷이 뒤늦게 전송되는 경우가 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;확인해보기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115414505-0c656180-a231-11eb-98de-cdabc90dba20.png&#34; alt=&#34;4way&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 했던 것과 같이 패킷을 캡처링 했을 때, 실제로 위와 같은 과정으로 커넥션을 끊는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-헤더-구조&#34;&gt;TCP 헤더 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115412590-6bc27200-a22f-11eb-85e4-619fcac22d79.png&#34; alt=&#34;header&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서 전송하는 SYN 패킷과 ACK 패킷은 TCP 헤더에서 위치에 해당하는 비트가 켜져서 전송된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-연결이-맺음과-끊어짐에-따른-소켓의-변화&#34;&gt;TCP 연결이 맺음과 끊어짐에 따른 소켓의 변화&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415800-294e6480-a232-11eb-85f8-ad556e694641.png&#34; alt=&#34;1920px-Tcp_state_diagram_fixed_new svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;연결을 맺고 끊을 때마다 소켓의 내부 상태가 변하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트에서 요청을 보내기 위해서 소켓을 생성할 때 파일 디스크립터가 생성되며 연결을 끊고 싶을 때 파일을 닫게 되며, FIN 패킷을 날리게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/115415367-d07ecc00-a231-11eb-86cb-2b5c569c07f1.png&#34; alt=&#34;Screen Shot 2021-04-20 at 11 40 13 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;watch -n0.6 &amp;quot;netstat -atnp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위는 watch 명령어를 통해서 0.6초마다 netstat의 결과를 모니터링 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고, CURL을 통해서 서버에 요청을 날리면 클라이언트 소캣의 상태를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34;&gt;Transmission Control Protocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 20 Apr 2021 17:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;더 빨리 자주 실패하자라는 원칙을 잊어버린 느낌이었다.&lt;/li&gt;
&lt;li&gt;최근에 시청하였던 왕 파라미터 금지라는 소프트웨어 원칙을 파이썬에서 네임드 튜플을 이용하여 지킬 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 할 때 자꾸 생각만 하고 코딩을 하지 않는 것 같다. 따라서 의도적으로라도 코딩을 계속하려는 노력을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 코딩을 해야한다. 완벽한 구조는 계속 만들어가는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지금 당장 완벽한 코딩을 하려고 하지 말고, 계속 발전시켜나가자! 때로는 무식하더라도 토이프로젝트 만큼은 구현하면서 생각을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 19 Apr 2021 12:01:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/4xg4OeGzGIw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
 출근 시간에 위의 영상을 시청하였다.&lt;/p&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한번도 무엇과 어떻게에 대해서 생각을 하면서 코딩한 적이 없는데, 신선한 충격이었고, 가독성을 높히기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;무엇을 할지와 어떻게 할지는 다르다는 것을 알게 되었고, 가독성을 위해서 무엇을 할지에 대해서 생각을 하면서 코딩을 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 의식적으로 무엇을 하려고 하는지 생각을 하면서 코딩해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가독성 있는 코딩을 하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 18 Apr 2021 20:02:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/18/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기대했던 결과가 나오지 않아서 조금 실망하기는 했다.&lt;/li&gt;
&lt;li&gt;졸업 작품으로 했던 프로젝트를 다시 만들어가고 있다.&lt;/li&gt;
&lt;li&gt;네트워크에 대한 기반 지식이 부족한 것을 알게 되었서, 관련된 공부를 하면서 기본기를 쌓고 있다.&lt;/li&gt;
&lt;li&gt;자바스크립트 프로토타입에 대해서 세미나 준비 및 세미나를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그래도 내가 어떤 점이 부족하고, 채워가야하는지 시야가 넓어져서 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;평소에 발표 연습을 많이 하고, 녹화하면서 안좋은 습관들을 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;다시 한번 복습하며서, 부족한 점을 채워나가고 있다.&lt;/li&gt;
&lt;li&gt;세미나때 너무 빨리 끝나지 않을까 걱정을 했는데, 생각보다 반응이 좋고, 질문을 많이 해주셔서 딱 맞게 끝난 것 같다.&lt;/li&gt;
&lt;li&gt;발표를 하기 전에는 스트레스를 많이 받았는데, 발표가 끝나니 재미있었고 아쉬웠다. 다음에도 기회가 있으면 발표를 해야겠다고 느꼈고, 공유하면 좋을 점들을 평소에 PPT로 만들어서 혼자서 영상을 제작하거나, 직접 발표를 해도 되겠다고 물어봐도 좋을 것이다.&lt;/li&gt;
&lt;li&gt;토이프로젝트를 하면서, 문제를 겪은 점과 이를 해결하는 과정을 PPT로 만들고 공유하는 것도 재미있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표하는 것에 대해서 너무 내 자신을 과대평가 했던 것 같다.&lt;/li&gt;
&lt;li&gt;요즘 할일을 미루는 습관 및 시간을 가치있게 사용하지 못하고 있는데, 이러한 점을 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본기가 튼튼한 개발자가 될 것이다. 그리고 현재 부족한 기본기는 네트워크인데, 이를 제대로 알기 위해서 노력해야겠다.&lt;/li&gt;
&lt;li&gt;발표를 잘하는 개발자가 되어서, 나중에 컨퍼런스에서 발표를 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SHADOW DOM 이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Thu, 15 Apr 2021 22:07:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/15/shadow-dom-%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM&#34;&gt;Using shadow DOM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 15 Apr 2021 18:23:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자바스크립트 세미나 발표를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많이 부족한 세미나 발표였음에도 불구하고 열심히 들어주셔서 고마웠다.&lt;/li&gt;
&lt;li&gt;세미나를 하기 전에는 많은 걱정을 하였지만, 막상 하고 나니까 속이 후련하고 다음에 한 번 더 하고 싶은 마음이 생겼다.&lt;/li&gt;
&lt;li&gt;사람들의 호응이 많을 때, 발표자로서 힘이 나는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;확실히 문서를 기반으로 발표를 하는 것 보다는 프레젠테이션으로 발표를 하는게 더 효과가 좋은 것 같았다.&lt;/li&gt;
&lt;li&gt;발표를 할 때, 사람들의 궁금증을 이끌어 낼 수 있도록 프레젠테이션을 작성하고 역으로 질문을 하는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;평소에 정리한 내용을 발표할 수 있도록 블로그 글을 프레젠테이션 형식으로 만들어보는 것도 재미있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;발표준비가 제대로 되어있지 않을 때 발표를 하면서 헷갈리고, 자신감이 떨어지게 된다. 따라서 제대로 아는 부분을 발표하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발표를 하기 전에, 연습을 많이 안했던 것 같다. 막상 발표할 때 연습대로 되지 않는 것은 알지만, 그래도 연습을 하면서 발표 실력을 늘릴 수 있도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 연습을 많이 하고, 평소에 관심있던 주제로 프레젠테이션을 만들고 공유하는 연습을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;이제 토이 프로젝트에 집중해서 내가 만들고 싶은 소프트웨어를 만들어봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>디바운스란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft/</link>
      <pubDate>Wed, 14 Apr 2021 18:54:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/14/%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;디바운스란&#34;&gt;디바운스란?&lt;/h3&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>DNS란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:15:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/dns%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;dnsdomain-name-system&#34;&gt;DNS(Domain Name System)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;내가-활용중인-dns-ip-주소-확인하기&#34;&gt;내가 활용중인 DNS IP 주소 확인하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567743-7bc9d700-9cae-11eb-82f9-9dcf503ef717.png&#34; alt=&#34;dns&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 내가 사용하고 있는 &lt;code&gt;DNS&lt;/code&gt; 서버의 &lt;code&gt;IP&lt;/code&gt; 주소를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568053-c4819000-9cae-11eb-8d25-3a8be64a3411.png&#34; alt=&#34;dns-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에 명령어를 통해서 나온 주소를 구글에 검색하면, 어떤 &lt;code&gt;DNS&lt;/code&gt; 서버를 사용하는지 대략적으로 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns-동작과정-추적하기&#34;&gt;DNS 동작과정 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568459-1b876500-9caf-11eb-8ffb-d43a61af1ffe.png&#34; alt=&#34;dns-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114568479-1e825580-9caf-11eb-8d1e-4165d8c43077.png&#34; alt=&#34;dns-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위와 같은 과정을 통해서, DNS 서버에 요청하고, 도메인 주소를 통해서 &lt;code&gt;IP&lt;/code&gt; 정보를 받아오는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114569074-a4060580-9caf-11eb-9311-dff133504ae0.png&#34; alt=&#34;flush&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemd-resolve --flush-caches
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;DNS 캐시 정보를 지우고 싶다면 위의 명령어를 입력하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ARP란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 23:01:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/arp%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;arpaddress-resolution-protocol&#34;&gt;ARP(Address Resolution Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;L2(데이터 링크 계층) 통신 프로토콜이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IP&lt;/code&gt; 네트워크 주소를 데이터 링크 프로토콜에서 사용하는 하드웨어 주소(Mac ADDRESS)에 맵핑하기 위해서 사용하는 프로토콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565725-84211280-9cac-11eb-9fa7-fef4c8b44361.png&#34; alt=&#34;arp&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arp -n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 명령어를 통해서, ARP 테이블을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;arp-패킷-추적하기&#34;&gt;ARP 패킷 추적하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566386-2ccf7200-9cad-11eb-8ace-088abe48ea0e.png&#34; alt=&#34;arp-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 통해서, 패킷 추적을 시작한다. 그리고 MAC 주소를 확인하기 위해서 &lt;code&gt;PING&lt;/code&gt; 명령어를 자신의 IP 주소로 보내며, 네트워크 패킷이 호출되는 것을 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566398-2fca6280-9cad-11eb-9b7e-13eb549a4a3c.png&#34; alt=&#34;arp-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114566393-2e993580-9cad-11eb-8886-2ee5ee935ad9.png&#34; alt=&#34;arp-3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffff:ffff:ffff는 목적지 주소를 나타내며, 브로드 캐스트의 의미이다. 바로 뒤에오는 주소가 바로 송신지의 주소이며 목적지의 MAC 주소를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114567037-d0b91d80-9cad-11eb-81a4-dc9aea24b583.png&#34; alt=&#34;arp-4&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MAC&lt;/code&gt; 주소를 확인하면, 나의 &lt;code&gt;MAC&lt;/code&gt; 주소와 일치하는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>ICMP란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:52:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/icmp%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;icmpinternet-control-message-protocol&#34;&gt;ICMP(Internet Control Message Protocol)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;L3(네트워크 계층) 통신 프로토콜로서, 라우터를 포함한 네트워크 장치가 다른 IP 주소와 통신을 할 때 성공 또는 실패를 나타내는 오류 메시지 및 운영정보를 보내는데 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흔히 사용하는 &lt;code&gt;PING&lt;/code&gt; 명령어가 &lt;code&gt;ICMP&lt;/code&gt; 프로토콜을 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564433-45d72380-9cab-11eb-88c5-8529a0adb7ee.png&#34; alt=&#34;ping&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;네트워크-패킷-추적하기&#34;&gt;네트워크 패킷 추적하기&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install tshark
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력하여 &lt;code&gt;tshark&lt;/code&gt;를 설치한다, 네트워크 패킷 분석을 할 수 있는 툴이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114565051-e299c100-9cab-11eb-8c29-8c0c4a1f914f.png&#34; alt=&#34;ping-1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 입력해서, &lt;code&gt;ICMP&lt;/code&gt; 패킷을 분석을 시작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114564927-c3029880-9cab-11eb-8081-63f0837202a8.png&#34; alt=&#34;ping-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제로 &lt;code&gt;PING&lt;/code&gt;을 8.8.8.8 주소로 날리게 되면, 패킷 추적이 되는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>MAC 주소란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:21:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/mac-%EC%A3%BC%EC%86%8C%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;mac-주소란&#34;&gt;MAC 주소란?&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mac-주소-알아내는-법&#34;&gt;MAC 주소 알아내는 법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114561564-a0bb4b80-9ca8-11eb-822e-f5123ca09728.png&#34; alt=&#34;mac&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 명령어를 이용하면 사용하고 있는 하드웨어의 &lt;code&gt;MAC&lt;/code&gt; 주소 및 네트워크 카드 &lt;code&gt;ID&lt;/code&gt;, 제조사를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>라우팅이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:48 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;라우팅이란&#34;&gt;라우팅이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 패킷이 목적지를 찾아가기 위한, 최적의 경로이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요청한-서버까지-라우터를-추적하는-방법&#34;&gt;요청한 서버까지 라우터를 추적하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114563693-98fca680-9caa-11eb-85d8-1ea7de69d92a.png&#34; alt=&#34;router&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 서버까지 굉장히 많은 라우터를 거쳐간다는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;네이버 서버에 요청하였을 때는 보안상의 이유로 라우터가 가려진 것을 확인할 수 있다. 모든 라우터의 주소를 확인할 수 있는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>웹 클라이언트(브라우저) 부터 웹서버까지의 구조 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</link>
      <pubDate>Tue, 13 Apr 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B6%80%ED%84%B0-%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B5%AC%EC%A1%B0-draft/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114560424-a5333480-9ca7-11eb-9929-ae4566a72689.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 주소를 입력하면 &lt;code&gt;HTTP&lt;/code&gt; 통신이 일어나게 되고, DNS 서버에서, 도메인 주소를 &lt;code&gt;IP&lt;/code&gt; 주소로 변환하는 요청을 하게 된다.&lt;/li&gt;
&lt;li&gt;IP 주소를 알아내면, 라우터를 통해서 &lt;code&gt;TCP / IP&lt;/code&gt; 통신을 하게 된다.&lt;/li&gt;
&lt;li&gt;웹 서버에 도착했을 때는 최종적으로 &lt;code&gt;HTTP&lt;/code&gt; 통신이 이루어지게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 13 Apr 2021 21:23:30 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크에 대해서 공부를 하였다.&lt;/li&gt;
&lt;li&gt;자바 스크립트 세미나 자료를 작성하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크에 대한 지식이 부족함을 알게 되었고, 부족한 점을 채우기 위해서 노력해야겠다는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;생각보다 대략적으로 알고 있는 내용이 많았고, 제대로 알고 넘어가야하는 점이 많다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;생각보다 발표준비를 할 시간이 많이 남지 않았다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 지식이 나중에 문제를 해결할 때 많은 도움을 줄 것이라고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 기본기가 부족한 부분이 어디인지를 파악할 필요성을 느끼게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본기가 튼튼한 프로그래머가 되어서, 문제를 해결할 수 있는 개발자로 성장할 것이다.&lt;/li&gt;
&lt;li&gt;리더십과 책임감이 있는 개발자로 성장할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>문서화를 코드로 관리하는 법 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft/</link>
      <pubDate>Tue, 13 Apr 2021 15:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EB%AC%B8%EC%84%9C%ED%99%94%EB%A5%BC-%EC%BD%94%EB%93%9C%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B2%95-draft/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114509642-b745b080-9c70-11eb-95f6-f5083a8b8f5e.jpg&#34; alt=&#34;images&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에 프로젝트를 진행할 때는 문서화에 대한 고민이 정말로 많았다. 왜냐하면 요구사항은 나날이 변경되는데, 요구사항에 맞춰서 문서화를 변경하는 일은 손이 많이가고 귀찮은 일이었기 때문이다. 또한 변경사항이 변경할 때마다, 어느 부분을 어떤 이유로 수정하였는지 추적하기도 힘이 들었다.&lt;/p&gt;
&lt;p&gt;따라서 추후에 프로젝트를 다시 시작할 때 무조건 문서화를 코드에 가깝게 두려고 노력을 했다. 또한 깃으로 상태 관리를 할 수 있었으면 좋겠다는 생각을 하기도 하였다. 그러던 중에, &lt;code&gt;plantuml&lt;/code&gt; 이라는 도구를 알게 되었다. 이 도구는 아키텍처를 도식화할 때 사용할 수 있는 툴로써 다양한 다이어그램을 그릴 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://plantuml.com/ko/&#34;&gt;Plantuml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kroki.io/&#34;&gt;Kroki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>윈도우 함수에서 WHERE 절을 사용하지 못하는 이유(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft/</link>
      <pubDate>Tue, 13 Apr 2021 15:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/13/%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C-where-%EC%A0%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://learnsql.com/blog/window-functions-not-allowed-in-where/&#34;&gt;Why Window Functions Are Not Allowed in WHERE Clauses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 12 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 친구랑 같이 밥을 먹었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예상은 했지만, 그래도 기대를 해서 그런지 기분이 조금 꿀꿀한 하루였다.&lt;/li&gt;
&lt;li&gt;친구랑 밥먹으면서 얘기를 하니까 기분이 조금은 풀렸다.&lt;/li&gt;
&lt;li&gt;오늘 일이 쉽게 풀려서 기분이 좋았다. 목표한 기간내에 마감을 할 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 알 수 있는 소중한 기회였다.&lt;/li&gt;
&lt;li&gt;진행하고 있는 프로젝트를 열심히 해보고, 꾸준히 해야겠다. 매주 일요일마다. 조금씩 하는 것을 계획하고 있다.&lt;/li&gt;
&lt;li&gt;프로젝트를 제대로 하여서, 실패한 졸업 작품을 키우면 좋겠다고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 실력을 키우기&lt;/li&gt;
&lt;li&gt;일을 미루지 않기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일을 미루지 않고 하기로 계획한 일은 바로바로 실행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 11 Apr 2021 12:00:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/11/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;우아한 형제들에서 일하고 있는 박재성 개발자의 10년차 이상의 개발자는 어떤 준비를 하면 좋을까라는 영상을 시청하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사에서 이슈를 처리하다가, 각각의 이슈의 경우에는 해결이 되었지만, 그 이슈들이 조합되어서 나타났을 때의 상황을 고려하지 못했던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전에 레디스에서 &lt;code&gt;Sorted Set&lt;/code&gt;이 어떻게 구현되어있는지 궁금해서 직접 찾아보고, &lt;code&gt;SKIP LIST&lt;/code&gt; 자료구조를 이용해서 구현을 했다는 것을 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 다른 사람들을 이끌고 설계할 수 있는 리더십 역량이 필요할텐데 시니어 때가 되서 부랴부랴 준비하려면 늦을 것 같다. 따라서, 미리 발표 능력 및 내가 생각하고 있는 것들을 글로 조리있게 작성할 수 있는 연습을 하고, 항상 큰 그림을 볼 수 있게 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;브랜치를 만들 때, 기존에 작업한 내용이 다른 이슈에 영향을 줄 것 같다면, 다른 이슈로 분리가 되어있다고 하더라도, 밑에 이전에 구현했던 이슈를 깔고 구현해야겠다는 생각이 들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SKIP LIST&lt;/code&gt;에 대해서 공부를 하고 나서, 이러한 개념을 직접 구현을 하려고 할 때, 어디서부터 구현을 해야하는지 막막했다. 그리고 어떤 개념을 배웠다고 하더라도, 이를 코딩으로 구현하는 능력이 부족하다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;최근에 내가 알고 있다고 생각한 것을 발표하고 이를 녹화하였는데, 매우 형편없이 말하고 있다는 것을 알게 되었다. 따라서 발표를 잘 하기 위해서 연습을 해야겠다는 생각을 했고, 이를 녹화하면서 내가 얼마만큼 발전했는지 측정하면 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기술 세미나를 볼 때, 기술 적인 내용뿐만 아니라, 이 사람이 어떻게 발표하고 있는지에 대해서 유심히 살펴보게 된 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설계나, 개념을 구현하는 능력을 미리미리 키워야겠다는 생각을 했다. 이는 알고리즘 문제를 풀면서 증가시킬 수 있다고 생각할 수도 있지만, 조금은 다른 것 같다. 처음에는 학부때 배웠던 알고리즘의 의사코드나, 개념에 대해서 공부하고 이를 내가 코드로 옮길 수 있는지를 측정해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우선은 발표 실력을 늘리고, 자주 발표를 하고 녹화하면서 피드백을 얻어야겠다.&lt;/li&gt;
&lt;li&gt;목표를 달성하기 위한 구체적인 방법을 세워야겠다는 것을 느끼게 되었다. 예를 들어서, 막연하게 영어를 잘해야지, 코딩을 잘해야지 보다는 구체적인 목표를 세우고 이를 달성하기 위해서 구체적인 노력을 하는게 목표를 이룰 가능성이 높을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들 앞에서 발표를 잘하고, 의사소통을 잘 할 수 있는 개발자가 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 10 Apr 2021 21:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 다시 마음을 다잡고 공부를 이어가야겠다.&lt;/li&gt;
&lt;li&gt;사내 세미나 준비를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 주말에 재충전을 하였고, 다시 앞으로 나갈 힘을 얻은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많은 것을 배울 수 있었으며, 나에게 현재 어떤점이 부족한지를 파악할 수 있었다.&lt;/li&gt;
&lt;li&gt;사내 세미나 준비를 하면서, 나의 발표 실력을 키울 수 있는 기회로 삼아야겠다.&lt;/li&gt;
&lt;li&gt;영어 공부를 하여서, 인생에서 내가 선택할 수 있는 선택지를 늘려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한점을 파악했으니, 이제 그것을 채우기 위해서 노력하자.&lt;/li&gt;
&lt;li&gt;운동을 꾸준히 하여, 건강 상의 문제가 없도록 하고 스트레스 관리를 하여 일을 열심히 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;발표 실력 및 부족한 점을 키워야겠다.&lt;/li&gt;
&lt;li&gt;운동을 꾸준히 하여, 건강 및 스트레스 관리를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 08 Apr 2021 09:03:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정신없는 하루를 보냈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번 주말에 재정비를 하고, 다시 앞으로 나가야할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;평소에 준비를 하지 않으면 기회를 잡을 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상황에 닥쳐서 하지 말고, 미리미리 준비하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 기술 블로그에 내가 배운 것들을 차곡차곡 준비할 것이다.&lt;/li&gt;
&lt;li&gt;어떤 기술을 익힐 때, 내부 원리에 대해서 이해하려고 노력할 것이다.&lt;/li&gt;
&lt;li&gt;나는 평소에 발표 실력을 키워서 내가 가지고 있는 생각이나 지식을 조리 있게 말할 수 있도록 할 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주키퍼란 무엇인가? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</link>
      <pubDate>Thu, 08 Apr 2021 08:53:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%A3%BC%ED%82%A4%ED%8D%BC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zookeeper.apache.org/&#34;&gt;What is ZooKeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>카프카란 무엇인가? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</link>
      <pubDate>Thu, 08 Apr 2021 08:19:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/08/%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/0974525&#34;&gt;KafkaConsumer Client Internals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE-LOCK(2PL)이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Wed, 07 Apr 2021 18:05:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/07/two-phase-lock2pl%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;two-phase-lock&#34;&gt;TWO PHASE LOCK&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949645-b4028d00-984a-11eb-98e5-e1d592569831.png&#34; alt=&#34;100518_0439_DBMSConcurr1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113949641-b238c980-984a-11eb-8ae0-64619edcf82c.png&#34; alt=&#34;2PL&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PC(TWO PHASE COMMIT)&lt;/code&gt;과 헷갈리는 개념이 있다. 그것은 바로 &lt;code&gt;2PL(TWO PHASE LOCK)&lt;/code&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2단계 잠금 프로토콜은 트랜잭션 도줌에 락을 걸어서 동일한 데이터에 동시에 접근하려는 트랜잭션을 차단하여 직렬화를 보장하는 &lt;code&gt;DBMS&lt;/code&gt;의 동시 제어 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt;의 동시성 문제를 해결하는데 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 잠금 프로토콜은 트랜잭션의 실행 단계를 세 단계로 나눈다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 번째 단계에서는 트랜잭션이 실행되기 시작할 때 필요한 락에 대한 권한을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째 부분은 트랜잭션이 모든 락 권한을 얻는 부분이다. 트랜잭션이 첫 번째 락을 해제할 때 세번째 단계가 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 세 번째 단계에서는 트랜잭션이 새로운 락을 요청할 수 없으며, 대신 획득한 락을 해제할 수 만 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;2PL&lt;/code&gt;에서는 각 트랜잭션이 두 단계로 락 획득 또는 해제 요청을 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Growing Phase&lt;/strong&gt;: 이 단계에서는 오직 잠금을 획득할 수 있고, 해제할 수는 없다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shrinking Phase&lt;/strong&gt;: 이 단계에서는 트랜잭션이 잠금을 해제할 수는 있지만 새로운 잠금을 획득하지는 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;2PL&lt;/code&gt; 프로토콜 방식은 직렬화는 보장하지만, 교착 상태가 발생하지 않도록 보장하지 못한다는 특징이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/two-phase-locking-protocol/&#34;&gt;Two Phase Locking protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.guru99.com/dbms-concurrency-control.html#5&#34;&gt;dbms-concurrency-control&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 07 Apr 2021 09:01:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/07/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전에 레디스에 구현되어 있는 &lt;code&gt;SORTED SET&lt;/code&gt; 연산이 어떻게 구현되어 있는지 찾아보다가, &lt;code&gt;SKIP LIST&lt;/code&gt; 까지 조사하게 되었다. 대충 돌아가는 구현은 파악하였지만, 실제 구현된 코드를 보고 이해하기는 힘들었고, 내가 이를 실제로 코드로 구현할 생각을 하니까 자신이 없었다.&lt;/li&gt;
&lt;li&gt;발표 연습을 위해서 내가 어떤 주제를 가지고 발표를 하려는데, 잘 정리된 발표 자료가 필요했다. 물론 내가 발표할 주제에 맞게 구성을 변경할 수는 있지만, 내용이 탄탄해야했다. 그러던 중에 적합한 사이트를 발견하였다. (GeeksforGeeks)[https://www.geeksforgeeks.org/two-phase-locking-protocol/]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;따라서 이때 부터 개념을 내가 실제로 코드로 옮길 수 있는 능력을 키워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;논문에 나와있는 개념을 익혀서 실제로 코드로 옮기는 작업을 전부터 해보고 싶다는 생각을 하였다.&lt;/li&gt;
&lt;li&gt;어떤 개념을 보고 나서 구현하는 능력이 부족함을 느끼게 되었고, 어떻게 하면 이러한 능력을 키울 수 있을지를 고민해보았다.&lt;/li&gt;
&lt;li&gt;어떤 개념에 대해서 매우 잘 정리가 되어있고, 데이터베이스 뿐만 아니라 컴퓨터공학 기반 지식에 대해서 잘 정리가 된 사이트이다. 이러한 사이트를 참조하여 학습하고 발표를 하면 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113792124-22c6e400-9780-11eb-9f2a-a0a5914eeb5f.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 능력을 키우려면 우선 &lt;code&gt;The Art of Computer Programming&lt;/code&gt; 책에 나와있는 의사 코드를 보고 코드로 옮기는 연습부터 해야겠다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;이러한 과정이 익숙해진다면, 나중에 논문에 나와있는 의사 코드를 보고 실제 코드로 구현할 때 많은 도움이 될 것 같다.&lt;/li&gt;
&lt;li&gt;그냥 막연히 시간이 지나면 좋아질 것이라고 착각했던 것 같다. 내가 현재 키우고자 하는 발표 능력, 구현 능력, 개발자 리더십은 시간이 지나면서 저절로 키워지지 않는다.&lt;/li&gt;
&lt;li&gt;따라서, 목표에 도달하기 위한 구체적인 방법이 있어야 한다. 발표 능력의 경우에는 특정 주제를 학습하고 이를 발표하는 영상을 녹화함으로써, 키운다. 구현 능력의 경우에는 우선은 알고리즘 책에 의사코드를 보고 직접 구현을 함으로써 키워나간다. 마지막으로 개발자 리더십의 경우에는 어떻게 키워야할지 생각이 나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘의 개념을 익히고 실제 코드에 녹여낼 수 있는 연습을 하고, 이러한 능력을 갖추기 위해서 노력할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 06 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 이슈를 처리하는데 느낀게 많았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 이슈 각각의 구현을 끝내고 나서, 고려할 사항이 끝났다고 생각했는데 이슈들이 조합될때의 경우를 고려하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이슈는 각각으로 나누어져 있어도 사실, 이슈가 조합되면 내가 예상하지 못하는 버그가 생길 수 있다는 점을 염두해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 05 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근길에 박재성님의 &lt;a href=&#34;https://www.youtube.com/watch?v=93qrbRRPZUU&#34;&gt;10년차 이상의 개발자는 어떤 준비를 하면 좋을까?
&lt;/a&gt; 영상을 보았다.&lt;/li&gt;
&lt;li&gt;오늘 기술 주제를 가지고, 설명을 하는 과정을 녹화하고 녹화된 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 언젠가는 회사에서 개발 능력 뿐만 아니라, 리더십 역량이 필요할 날이 올텐데 미리 준비하면 좋을 것 같다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;우선 발표 실력부터 늘리고, 내 생각을 남에게 논리적으로 표현할 수 있어야 겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;설명을 할 때는 완벽하지는 않아도 설명을 그럭저럭 했다고 생각했는데, 녹화된 영상을 보니까 논리가 하나도 맞지 않고 횡설 수설 하였다.&lt;/li&gt;
&lt;li&gt;그리고 설명을 하다 보니, 목소리가 기어들어가고, 자신감도 없어 보여 집중할 수 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시니어 개발자가 된다면 어떤 능력이 필요할 지 생각을 해보게되었다.&lt;/li&gt;
&lt;li&gt;실제 내가 발표하는 과정을 녹화하고 녹화된 영상을 시청하여  피드백을 스스로 얻거나, 남에게 얻는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;최근에 발표하는 것을 연습하다보니까 기술 세미나를 볼 때, 그저 기술적인 내용을 보는 것 뿐만 아니라 이 사람이 어떻게 말하고 있는지, 시선처리는 어떻게 하는지 그리고 어떤 방식으로 발표하는지에 대해서 보이는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;책상에 앉아서 모니터를 보고 발표하는 것보다, 실제 프로젝터나, 큰 스크린 앞에서 발표하는 것은 또 다를 것이다. 따라서 이를 연습하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꾸준하게 내가 발표하는 것을 녹화하고, 내가 배운 것을 실제로 발표하면서 제대로 알고 있는지 검증하자.&lt;/li&gt;
&lt;li&gt;시선처리와 제스처, 그리고 발성이 중요하다는 것을 알고 이를 연습하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GC(Garbage Collector) 종류 및 내부 원리</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC/</link>
      <pubDate>Sun, 04 Apr 2021 20:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/gcgarbage-collector-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EB%82%B4%EB%B6%80-%EC%9B%90%EB%A6%AC/</guid>
      <description>&lt;p&gt;모든 자바 애플리케이션은 JVM(&lt;code&gt;Java Virtual Machine&lt;/code&gt;) 위에서 작동한다. 따라서, &lt;code&gt;JVM&lt;/code&gt;이 작동하는데 있어서 메모리 구조와 &lt;code&gt;GC&lt;/code&gt;는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 맺고 있다.&lt;/p&gt;
&lt;h3 id=&#34;gc란-무엇인가&#34;&gt;GC란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GC(Garbage Collection)는 자바 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C/C++&lt;/code&gt; 같은 언어는 메모리를 할당하고 직접 해제해야했지만, 자바에서는 &lt;code&gt;GC&lt;/code&gt;를 이용하여 개발자들이 메모리 관리를 비교적 신경쓰지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-메모리-영역&#34;&gt;JVM 메모리 영역&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507707-1deb1000-9587-11eb-9ab6-2bbe0091be87.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GC&lt;/code&gt;의 동작 방법을 이해하려면, 먼저 자바의 메모리 구조를 이해할 필요가 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 애플리케이션에서 사용되는 객체는 오래 유지되는 객체보다 잠시 사용되는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507754-5a1e7080-9587-11eb-91e9-f14a446cb441.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바에서는 크게 두 영역으로 메모리를 구분한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Young&lt;/code&gt; 영역과 &lt;code&gt;Old&lt;/code&gt; 영역인데, &lt;code&gt;Young&lt;/code&gt; 영역은 생성된지 얼마 되지 않은 객체들을 저장하는 장소이고 &lt;code&gt;Old&lt;/code&gt; 영역은 생성된지 오래된 객체를 저장하는 장소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;영역&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;New/Young 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;이 영역은 자바 객체가 생성되자마자 저장되고 생긴지 얼마 안 된 객체가 저장되는 곳이다. 자바 객체가 생성되면 이 영역에서 저장되다가 시간이 지남에 따라서 우선 순위가 낮아지면 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮겨진다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Old 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;New/Young&lt;/code&gt; 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어서 저장되는 영역이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Perm 영역&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Class, Method 등의 코드가 저장되는 영역으로, JVM에 의해서 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jvm이-메모리를-관리하는-방식&#34;&gt;JVM이 메모리를 관리하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;minor-gc&#34;&gt;Minor GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508143-4c69ea80-9589-11eb-84be-2ec3ff175995.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;New/Young&lt;/code&gt; 영역을 &lt;code&gt;Minor GC&lt;/code&gt; 라고 부른다. &lt;code&gt;New/Young&lt;/code&gt; 영역은 &lt;code&gt;Eden / Survivor&lt;/code&gt; 이라는 두 영역으로 또 나뉘게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 영역은 자바 객체가 생성되자마자 저장되는 곳이다. 이렇게 생성된 객체는 &lt;code&gt;Minor GC&lt;/code&gt;가 발생할 때 &lt;code&gt;Survivor&lt;/code&gt; 영역으로 이동하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt; 영역은 &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 두 영역으로 나뉘는데, &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor1&lt;/code&gt;에 활성 객체를 &lt;code&gt;Survivor2&lt;/code&gt;로 복사한다.&lt;/li&gt;
&lt;li&gt;활성이 아닌 객체는 자연스럽게 &lt;code&gt;Survivor1&lt;/code&gt;에 남아있게 되고, &lt;code&gt;Survivor1&lt;/code&gt;과 &lt;code&gt;Eden&lt;/code&gt; 영역을 클리어 한다. (결과적으로 활성 객체만 &lt;code&gt;Survivor2&lt;/code&gt;)로 이동하게 된 것이다.&lt;/li&gt;
&lt;li&gt;다음번 &lt;code&gt;Minor GC&lt;/code&gt;가 발생하면 같은 원리로 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor2&lt;/code&gt; 영역에서 활성 객체를 &lt;code&gt;Survivor1&lt;/code&gt;으로 이동시키게 된다. 계속 이런 방식을 반복하면서 &lt;code&gt;Minor GC&lt;/code&gt;를 수행한다.&lt;/li&gt;
&lt;li&gt;이렇게 &lt;code&gt;Minor GC&lt;/code&gt;를 수행하다가 &lt;code&gt;Survivor&lt;/code&gt; 영역에서 오래된 객체는 &lt;code&gt;Old&lt;/code&gt; 영역으로 옮기게 된다.&lt;/li&gt;
&lt;li&gt;이러한 방식의 &lt;code&gt;GC&lt;/code&gt; 알고리즘을 &lt;code&gt;Copy &amp;amp; Scavenge&lt;/code&gt; 라고 한다. 이 방식은 속도가 매우 빠르며 작은 크기의 메모리를 콜렉팅하는데 매우 효과적이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Minor GC&lt;/code&gt;의 경우에는 자주 일어나기 때문에 &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 짧은 알고리즘을이 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;full-gc&#34;&gt;FULL GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508252-e3cf3d80-9589-11eb-9792-a038da5850d1.jpg&#34; alt=&#34;java-gc-29-638&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Old&lt;/code&gt; 영역의 가비지 컬렉션을 &lt;code&gt;Full GC&lt;/code&gt; 라고 부르며 &lt;code&gt;Full GC&lt;/code&gt;에 사용되는 알고리즘을 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘은 객체들의 참조를 확인하면서 참조가 연결되지 않은 객체를 표시한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 표시하고 이 표시된 객체를 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Full GC&lt;/code&gt;는 속도가 매우 느리며, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 도중에는 순간적으로 자바 애플리케이션이 멈춰버리기 때문에, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 정도와 시간은 애플리케이션의 성능과 안정성에 아주 큰 영향을 미친다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc가-중요한-이유&#34;&gt;GC가 중요한 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;가비지 컬렉션 중에서 마이너 GC의 경우에는 보통 0.5 이내에 끝나기 때문에 큰 문제가 되지 않지만, 그러나 FULL GC의 경우에는 자바 애플리케이션이 멈춰 버리기 때문에, 문제가 될 수 있다.&lt;/li&gt;
&lt;li&gt;멈추는 동안 사용자의 요청이 큐에 들어있다가, 순간적으로 요청이 한꺼번에 들어오기 때문에 과부하에 의한 여러 장애를 만들 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 원활한 서비스를 위해서는 &lt;code&gt;GC&lt;/code&gt;가 어떻게 일어나게 하느냐가 시스템의 안정성과 성능에 큰 변수로 작용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-gc-알고리즘&#34;&gt;다양한 GC 알고리즘&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;앞에서 설명한 방식 말고도 다양한 &lt;code&gt;GC&lt;/code&gt; 방법을 제공하고 있다. 방식은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Default Collector&lt;/li&gt;
&lt;li&gt;Parallel GC for young generator&lt;/li&gt;
&lt;li&gt;Concurrent GC for old generator&lt;/li&gt;
&lt;li&gt;Incremental GC (Train GC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;default-collector&#34;&gt;Default Collector&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 설명했던 전통적인 GC 방식으로, Minor GC로 &lt;code&gt;Scanvenge&lt;/code&gt;를 Full GC로 &lt;code&gt;Mark &amp;amp; Compact&lt;/code&gt; 알고리즘을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113508603-f8acd080-958b-11eb-9c89-f025df1daab9.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자바는 멀티 스레드 환경을 지원하지만, 하나의 CPU에서는 동시에 하나의 스레드 밖에 수행할 수 없어서 예전에는 하나의 CPU에서만 GC를 수행하였지만 후에 하나의 CPU에서 동시에 여러 개의 스레드를 실행할 수 있는 하이퍼스레딩 기술이나 여러개의 CPU를 동시에 장착한 하드웨어의 보급으로 하나의 하드웨어에서 동시에 여러 개의 스레드를 수행할 수 있게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parallel GC&lt;/code&gt;에는 크게 두 가지 종류의 옵션을 가지고 있는데, &lt;code&gt;Low-pause&lt;/code&gt; 방식과 &lt;code&gt;Throughput&lt;/code&gt; 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Low-pause&lt;/code&gt; 방식은 GC가 일어날 때 애플리케이션이 멈추는 현상을 최소화하는데 역점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Throughput&lt;/code&gt; 방식의 &lt;code&gt;Parallel&lt;/code&gt; GC는 마이너 GC가 발생하였을 때 되도록이면 신속하게 수행하도록 &lt;code&gt;throughput&lt;/code&gt;에 중점을 두었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;concurrent-gc&#34;&gt;Concurrent GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC 즉, Old 영역을 GC하는데 시간이 길고 애플리케이션이 순간적으로 멈춰버리므로, 애플리케이션이 멈추는 현상을 최소화 하는 GC 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full GC에 소요되는 작업을 애플리케이션을 멈추고 진행하는 것이 아니라, 일부는 애플리케이션이 돌아가는 단계에서 수행하고 최소한의 작업만을 애플리케이션이 멈췄을 때 수행하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;incremental-gc-train-gc&#34;&gt;Incremental GC (Train GC)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Train GC&lt;/code&gt;라고도 불리는 &lt;code&gt;GC&lt;/code&gt; 방식은 의도는 &lt;code&gt;Full GC&lt;/code&gt;에서 의해서 애플리케이션이 멈추는 시간을 줄이기 위한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동은 &lt;code&gt;Minor GC&lt;/code&gt;가 일어날 때마다 &lt;code&gt;Old&lt;/code&gt; 영역을 조금씩 &lt;code&gt;GC&lt;/code&gt; 해서 &lt;code&gt;Full GC&lt;/code&gt;가 발생하는 횟수나 시간을 줄이는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Incremental GC&lt;/code&gt;는 많은 자원을 소모하고 &lt;code&gt;Minor GC&lt;/code&gt;를 자주 일으켜서, 그리고 &lt;code&gt;Incremental GC&lt;/code&gt;를 사용한다고 &lt;code&gt;Full GC&lt;/code&gt;가 없어지거나 그 횟수가 획기적으로 줄어드는 것이 아니다. 오히려 느려지는 경우가 많으므로 반드시 테스트를 거치고 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc-로그-수집-방법&#34;&gt;GC 로그 수집 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;에서는 GC 상황에 대한 로그를 남기고자 옵션을 제공하고 있다.&lt;/li&gt;
&lt;li&gt;자바 옵션에 &lt;code&gt;-verbosegc&lt;/code&gt; 라는 옵션을 주면 되고, &lt;code&gt;&amp;gt;&lt;/code&gt; 리다이렉션 명령어를 통해서 파일로 저장하고 분석할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509041-6659fc00-958e-11eb-92e2-bc0633609ea6.png&#34; alt=&#34;자바&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위는 스프링 부트로 만든 간단한 웹 애플리케이션이다. 이를 터미널에서 &lt;code&gt;jar&lt;/code&gt; 파일로 만들어 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;./gradlew bootjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509104-b6d15980-958e-11eb-8a43-07b56114335a.png&#34; alt=&#34;jar&#34;&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 생성이 되면, 다음과 같은 경로에 &lt;code&gt;jar&lt;/code&gt; 파일이 생성된다. 터미널을 통해서 이 경로로 이동한다.&lt;/p&gt;
&lt;p&gt;그런 후에 다음과 같은 명령어를 터미널에서 실행 시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar -verbosegc app.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113509189-26474900-958f-11eb-836f-e70adb0a34ac.png&#34; alt=&#34;Screen Shot 2021-04-04 at 9 45 53 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러면 애플리케이션이 실행되자마자 &lt;code&gt;GC&lt;/code&gt;와 관련된 로그들이 출력된다.&lt;/li&gt;
&lt;li&gt;마이너 GC는 &amp;ldquo;GC&amp;quot;로 표기되고, FULL GC는 &amp;ldquo;FULL GC&amp;quot;로 표기된다.&lt;/li&gt;
&lt;li&gt;그 다음의 값은 &lt;code&gt;HEAP SIZE BEFORE GC&lt;/code&gt;인데, GC전의 힙 사용량 (New/Young 영역 + Old 영역 + Perm 영역의) 크기를 나타낸다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 GC가 발생한 후의 HEAP 사용량이다. 마이너 GC가 발생하였을 때는 &lt;code&gt;Eden&lt;/code&gt;과 &lt;code&gt;Survivor&lt;/code&gt; 영역을 &lt;code&gt;GC&lt;/code&gt; 하게 되므로 &lt;code&gt;HEAP SIZE AFTER GC&lt;/code&gt;는 Old 영역의 용량과 유사하다.&lt;/li&gt;
&lt;li&gt;마지막 값은 &lt;code&gt;GC&lt;/code&gt;에 소요된 시간을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jvm-gc-튜닝&#34;&gt;JVM GC 튜닝&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;step-1-애플리케이션의-종류-및-튜닝-목표값을-설정&#34;&gt;STEP 1. 애플리케이션의 종류 및 튜닝 목표값을 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;JVM 튜닝을 할 때 가장 중요한 것은 튜닝의 목표를 설정하는 것이다.&lt;/li&gt;
&lt;li&gt;메모리를 적게 사용하는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt; 횟수를 줄이는 것이 목표인지, &lt;code&gt;GC&lt;/code&gt;에 걸리는 시간이 문제인지, 애플리케이션의 성능(&lt;code&gt;Throughput or Response Time&lt;/code&gt;) 향상이 목표인지를 먼저 정하고 나서 목표치에 근접하도록 &lt;code&gt;JVM&lt;/code&gt; 파라미터를 조정하는 것이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-2-힙크기와-perm-크기-설정&#34;&gt;STEP 2. 힙크기와 &lt;code&gt;Perm&lt;/code&gt; 크기 설정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-ms, -mx 옵션을 이용해서 힙 크기를 정한다. 일반적으로 서버 애플리케이션은 ms와 mx크기를 같게 하는 것이 메모리의 &lt;code&gt;Growing&lt;/code&gt;와 &lt;code&gt;Shrinking&lt;/code&gt;에 의한 불필요한 로드를 막을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ms&lt;/code&gt;와 &lt;code&gt;mx&lt;/code&gt; 크기를 다르게 하는 경우는 애플리케이션의 시간대별 메모리 사용량이 급격하게 변화가 있는 애플리케이션에 효과적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-3-테스트와-로그-분석&#34;&gt;STEP 3. 테스트와 로그 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; 옵션에 &lt;code&gt;GC&lt;/code&gt;로그를 수집하기 위한 &lt;code&gt;-verbosegc&lt;/code&gt; 옵션을 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nGrinder&lt;/code&gt;와 같은 스트레스 테스트 도구로 애플리케이션에 스트레스를 주어서, 그 로그를 수집한다.&lt;/li&gt;
&lt;li&gt;튜닝에 있어서 가장 중요한 것은 목표 산정이지만, 그만큼이나 중요한 것은 실제 튜닝한 파라미터가 애플리케이션에 어떤 영향을 주는지를 테스트 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-4-perm-크기-조정&#34;&gt;STEP 4. Perm 크기 조정&lt;/h4&gt;
&lt;h4 id=&#34;step-5-gc-수행-시간-분석&#34;&gt;STEP 5. GC 수행 시간 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full GC가 일어나는 횟수가 많아서 &lt;code&gt;Old&lt;/code&gt; 영역을 늘려주면, Full GC 가 일어나는 횟수가 줄어들 것이고, 반대로 Full GC 수행 시간은 늘어날 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 서버 애플리케이션은 Full GC가 일어날 때는 &lt;code&gt;JVM&lt;/code&gt; 자체가 멈춰버리기 때문에 일정 시간동안 응답을 못하는 상태가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 애플리케이션에서 Full GC가 적게 일어나게 하고, Full GC 시간을 양쪽 다 줄이려면 &lt;code&gt;Old&lt;/code&gt; 영역의 메모리를 줄이고 여러 개의 인스턴스를 동시에 띄워서 로드 밸런싱을 해주면 부하가 분산된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇게 되면, &lt;code&gt;Full GC&lt;/code&gt;가 일어나는 횟수가 줄어들게 되며 &lt;code&gt;Old&lt;/code&gt; 영역을 줄였기 때문에 Full GC가 수행되는 시간 또한 줄어든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 하나의 서버 인스턴스가 멈춰있는 동안 로드 밸런싱이 되는 다른 서버가 응답하고 있기 때문에 &lt;code&gt;Full GC&lt;/code&gt;로 인하여 애플리케이션이 멈추는 상황에서 받을 영향을 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;step-6-파라미터-변경&#34;&gt;STEP 6. 파라미터 변경&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 영역의 허용 범위를 기준으로, &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역을 적절하게 조절한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Perm&lt;/code&gt; 크기와 &lt;code&gt;New&lt;/code&gt; 영역의 배분(Eden, Survivor) 영역을 조정한다.&lt;/li&gt;
&lt;li&gt;가장 중요한 것은 &lt;code&gt;Old&lt;/code&gt; 영역과 &lt;code&gt;New&lt;/code&gt; 영역의 비율을 어떻게 조정하는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;향상 포인트&lt;/th&gt;
&lt;th&gt;GC 알고리즘&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Perfomance (속도)&lt;/td&gt;
&lt;td&gt;Parallel GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Concurrent GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Responsiveness (응답성)&lt;/td&gt;
&lt;td&gt;Incremental GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반&lt;/td&gt;
&lt;td&gt;Default GC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝 이야기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>그림으로 공부하는 IT 인프라 구조를 읽고나서 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Sun, 04 Apr 2021 20:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-it-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0%EB%82%98%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113507344-cd72b300-9584-11eb-9235-ec9bbdfc400a.jpg&#34; alt=&#34;k642736774_1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데브옵스 팀이 따로 있기 때문에, 실무에서 인프라 지식을 접할 기회가 별로 없었다. 따라서 이 책을 읽게 되었다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 시스템을 구축하는 기반 지식들을 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;특히 웹 데이터 흐름이라는 파트가 많은 도움이 되었는데, 내가 어떤 웹 사이트에 접속을 하였을 때, 내부적으로 어떻게 동작하는지 알 수 있었다.&lt;/li&gt;
&lt;li&gt;특히 네트워크에 대한 지식이 많이 부족했는데, 네트워크의 흐름에 대해서 알게 되었다.&lt;/li&gt;
&lt;li&gt;다양한 계층에서의 이중화 전략에 대해서 알게 되었다. 현재 나에게도 도움이 많이 되었던 책이지만, 나 말고도 많은 신입 개발자들에게 많은 도움이 될 것 같다.&lt;/li&gt;
&lt;li&gt;나중에 후배들이 들어와서 내게 좋은 책을 추천해줄 수 있냐고 물어볼 때 주저없이 이 책을 추천해줄 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=257114341&#34;&gt;그림으로 공부하는 IT 인프라 구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 04 Apr 2021 15:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/04/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서버 성능 튜닝 및 성능 개선에 관련된 책을 읽었다.&lt;/li&gt;
&lt;li&gt;구글 번역기 관련 이슈가 발생하였다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서가 업데이트 되지 않는 문제가 있어서, 이를 수정하는 작업을 하였다.&lt;/li&gt;
&lt;li&gt;사내 세미나가 거의 코 앞으로 다가 왔다.&lt;/li&gt;
&lt;li&gt;예전에 리눅스 공부 및 정리한 내용을 블로그에 옮겨서 적어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서버 성능 튜닝을 제대로 이해하려면 학부 때 배운 운영체제 지식 및 데이터베이스에 대한 이해가 필수라는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;이론으로만 배운 지식이 어떤 원리로 나타나는지 확인하는 과정이 재미있었다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 스트레스 관리를 잘하는 것도 중요하다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;최근에 무리해서 밤을 새워서 어떤 공부를 하였는데, 그러니까 몸에 힘도 없고 우울했다.&lt;/li&gt;
&lt;li&gt;처음에는 원인을 찾기 힘든 이슈를 서서히 범위를 좁혀나가고 결국에, 원인을 파악하고 실제 이슈를 해결하니까 뿌듯했다.&lt;/li&gt;
&lt;li&gt;코드랑 &lt;code&gt;API&lt;/code&gt; 문서가 떨어지니까 많이 힘들었고, 올바르게 작성되지 않은 &lt;code&gt;API&lt;/code&gt;를 수정하고 싶은 마음이 들었다.&lt;/li&gt;
&lt;li&gt;같은 팀에 새롭게 입사한 분이 생겼는데, 그 분에게 배울 점이 있는 사람이라고 느껴지고 싶었다. 따라서 제대로 발표하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;학부 때 배운 운영체제, 네트워크, 데이터베이스에 대한 깊은 지식을 배우고 이를 실제로 옵션 값이나 눈으로 확인하면서 익히는 것이 재미도 있고 기억에도 오래 남는 것 같다.&lt;/li&gt;
&lt;li&gt;톰캣 AP 서버나, &lt;code&gt;JVM&lt;/code&gt;의 내부 동작 원리 및 &lt;code&gt;GC&lt;/code&gt; 원리에 대해서 공부를 해야겠다는 마음을 먹었다.&lt;/li&gt;
&lt;li&gt;좋은 컨디션으로 꾸준히 공부하는 것이 중요하다. 급하다고 단기간에 무리해서 공부하면 길게 가지 못하고 공부를 하면서 재미도 없는 것 같다.&lt;/li&gt;
&lt;li&gt;오픈 소스 커뮤니티에서 원인 분석 및 해결책이 이미 나와있었지만, 만약 나와있지 않고 내가 첫번째로 버그를 발견한 상태라면 조금 많이 헤매였을 것 같다. 따라서 직접 원인 분석 및 해결책을 알려면 평소에 내부를 어떻게 분석할 수 있는지 파악할 수 있는 능력이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 올바르게 작성하고, 사용자들이 어떻게 하면 더 쉽게 이해할 수 있을지를 고민하고 작성하자.&lt;/li&gt;
&lt;li&gt;발표를 연습하기 위해서는 꾸준하게 많이 연습을 하는 것이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;실제로 내가 배운 것을 설명할 때 생각처럼 말이 쉽게 나오지는 않았다. 그리고 설명하면서 내가 제대로 알 고 있지 못하다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;발표를 할 때, 내용도 중요하지만, 청중을 집중시키는 능력 또한 중요한 것 같다. 이를 위해서는 자신감 있게 발표하는 것이 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;발표 연습을 할 때, 완벽한 준비 또는 준비할게 많다는 핑게로 자꾸 미루는 것 같다. 따라서 발표 연습을 꾸준하게 하려면, 작게나마 연습하는 것이 중요한 것 같다. 예를 들어서, 발표 자료를 준비하지 않고 책을 읽었다면 한 챕터에 대해서 요약을 해보는 것 부터 시작하는 것이다. 이를 통해서 나의 생각을 정리할 수 있고 내가 모르는 것이 있는지 체크 해 볼 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;연습을 할 때 가능한 스스로 그림을 그려가면서, 다른 사람들에게 설명할 것을 추천한다고 나와있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인내심을 가지고, 프로그래밍 및 기반 지식을 깊게 공부해야겠다.&lt;/li&gt;
&lt;li&gt;잘 만들어진 소프트웨어는 코드가 클린하거나, 기능이 풍부한 것 뿐만 아니라, 커뮤니티, 문서화에도 뛰어난 것을 알고, 이러한 능력을 키우기 위해서 노력하자.&lt;/li&gt;
&lt;li&gt;생각만 하는 것보다는 직접 행동을 하면서 피드백을 얻고 배우자.&lt;/li&gt;
&lt;li&gt;관심있는 시스템 개발쪽도 항상 놓치지 말고 공부할 수 있도록 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;건강 관리를 해서 건강하게 오래 코딩 공부 및 일을 할 수 있도록 하자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 지식을 잘 이해하면, 튜닝을 하는데 많은 즐거움을 느낄 수 있다. 따라서 부족한 컴퓨터 공학 지식들을 이번 기회에 다시 한 번 더 복습하자.&lt;/li&gt;
&lt;li&gt;해커의 자세를 가지고 내가 사용하고 있는 시스템들의 내부 원리를 어떻게 눈으로 확인할 수 있을 지 실제로 분석할 수 있을지를 연구하자.&lt;/li&gt;
&lt;li&gt;블로그에 기록을 잘 하는 것도 중요하지만, 내가 알고 있는 지식들을 잘 설명하는 능력도 중요하다. 따라서 남에게 잘 설명하는 연습을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 03 Apr 2021 22:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예전에 리눅스 커널을 보면서 공부했던 내용을 블로그에 정리하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아쉽게도 공부한 직후에 바로 기록하여 내용이 정리 되어 있지는 않았다. 블로그를 예전 부터 시작하고, 기록 했으면 편했을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오랜만에 운영체제에 대해서 공부하게 되었고, 지금은 잊어버린 시스템 코드를 분석하는 툴 및 방법을 다시 확인해볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 개발에 대한 열정을 일어버리지는 말자.&lt;/li&gt;
&lt;li&gt;현재는 다른 것을 공부하느라 바쁘지만, 언젠가는 시스템 개발을 취미로 할 수 있을 정도로 실력을 키우자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재는 시간이 부족하지만, 시스템 개발을 잘 할 수 있도록 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>메모리 액세스 과정</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95/</link>
      <pubDate>Sat, 03 Apr 2021 21:21:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%A1%EC%84%B8%EC%8A%A4-%EA%B3%BC%EC%A0%95/</guid>
      <description>&lt;h3 id=&#34;메모리-액세스-과정&#34;&gt;메모리 액세스 과정&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478449-da7b9d80-94c3-11eb-989d-f4926b2321d5.png&#34; alt=&#34;Slide07&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그램을 실행 할 때, 반드시 모두 물리 메모리에 있어야 할 필요는 없으므로, 일부분만 물리 메모리에 올려 놓고 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프로그램은 더 이상 물리 메모리에 의해서 더 이상 제약 받지 않으며, 사용자들은 매우 큰 가상 공간을 가정하고 프로그램을 만들 수 있고, 프로그래밍 과정이 간단해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 사용자 프로그램이 더 작은 메모리를 차지하므로 더 많은 프로그램을 동시에 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 메모리에서는 페이지들이 실행 과정에서 실제 필요할 때, 메모리에 적재되게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림을 보면, &lt;code&gt;CPU&lt;/code&gt;에서 메모리에 접근할 때, &lt;code&gt;MMU&lt;/code&gt;를 통해서 페이지 테이블에 접근한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 테이블은 가상 주소와 물리 주소를 맵핑하고 있고, &lt;code&gt;MMU&lt;/code&gt;를 통해서 접근하는 메모리가 테이지 테이블에 맵핑 되어 있지 않다면 페이지 폴트(&lt;code&gt;page fault&lt;/code&gt;)를 발생 시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 폴트가 발생하고 나서 가상 메모리와 물리 메모리가 맵핑되고, 가상 메모리를 통해서 물리 메모리에 접근할 수 있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이지-교체&#34;&gt;페이지 교체&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기본적인 페이지 교체는 다음과 같다. 메모리에서 빈 프레임이 없다면 현재 사용되지 않는 프레임을 찾아서 그것을 비워버린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그 프레임의 내용을 스왑 (&lt;code&gt;swap&lt;/code&gt;) 공간에 쓰고 그 페이지가 메모리에 더 이상 존재하지 않는다는 것을 나타내기 위해서, 페이지 테이블을 비운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 페이지를 비울지에 대해서는 다음과 같은 알고리즘이 있다. (&lt;code&gt;FIFO&lt;/code&gt;, &lt;code&gt;LRU&lt;/code&gt;, &lt;code&gt;LFU&lt;/code&gt;, &lt;code&gt;MFU&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세그먼트-폴트와-페이지-폴트의-차이점&#34;&gt;세그먼트 폴트와 페이지 폴트의 차이점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;세그먼트 폴트 : 세그먼트 폴트는 컴퓨터 소프트웨어의 실행중에 일어날 수 있는 오류로서, 프로그램이 허용되지 않은 메모리 영역에 접근을 시도하였을 때 발생합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이지 폴트 : 페이지 폴트는 메모리에 적재된 페이지 중에 사용 페이지가 없을 때 발생한다. 페이지 폴트가 발생하고 나서, 페이지 테이블에 가상 주소와 물리 주소가 맵핑되고 나서는 발생하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ps-명령어를-사용하여-실제-사용하는-메모리와-가상-메모리-크기를-확인하는-방법&#34;&gt;&lt;code&gt;PS&lt;/code&gt; 명령어를 사용하여 실제 사용하는 메모리와 가상 메모리 크기를 확인하는 방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478868-7ad2c180-94c6-11eb-879a-bd526b1c4d86.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 49 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps&lt;/code&gt; 명령어를 통해서, &lt;code&gt;RSS&lt;/code&gt; 항목을 보면 다음과 같이 설명하고 있다.&lt;/li&gt;
&lt;li&gt;상주하고 있는 메모리 사이즈이며, 스왑되지 않은 물리적 메모리라고 설명되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478927-dac96800-94c6-11eb-93d1-375419b14f4d.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 52 07 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반면에 &lt;code&gt;VSZ&lt;/code&gt;는 프로세스의 가상 메모리 크기라고 설명되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ps -eo pmem,rss,vsz,comm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 명령어를 실행하여, 프로세스 별 실제 사용하고 있는 물리 메모리와 가상 메모리를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478993-3ac00e80-94c7-11eb-88a1-63a0ad9fd7f5.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 54 48 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=46380306&#34;&gt;운영체제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>좀비 프로세스와 고아 프로세스</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</link>
      <pubDate>Sat, 03 Apr 2021 18:57:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</guid>
      <description>&lt;h3 id=&#34;좀비zombie-프로세스란&#34;&gt;좀비(zombie) 프로세스란&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료 될 때, 마지막 문장의 실행을 끝내고, &lt;code&gt;exit()&lt;/code&gt; 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면서 종료된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 시점에서, 프로세스는 자신의 부모가 호출한 &lt;code&gt;wait()&lt;/code&gt; 시스템 호출을 통해서, 상태 값을 반환할 수 있고, 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제로 반납된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부모 프로세는 &lt;code&gt;wait()&lt;/code&gt; 시스템 호출을 사용하여 자식 프로세스가 종료할 때를 기다릴 수 있고, 부모가 자식의 종료 상태를 얻어 낼 수 있도록 하나의 인자를 전달 받는다. 이 시스템 호출은 부모가 어떤 자식이 종료되었는지 구별할 수 있도록 종료된 자식의 프로세스 식별자를 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 종료되면 사용하던 자원은 운영체제가 되찾아가게 된다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 &lt;code&gt;wait()&lt;/code&gt;을 호출할 때까지 남아있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 종료가 되었지만 부모 프로세스가 아직 &lt;code&gt;wait()&lt;/code&gt; 호출을 하지 않은 프로세스를 좀비 (&lt;code&gt;zombie&lt;/code&gt;) 프로세스라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 프로세스는 종료하게 되면, 좀비 상태가 되지만 아주 짧은 시간 동안 머무르게 되고, 부모가 &lt;code&gt;wait()&lt;/code&gt;를 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에게 반환된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;고아-프로세스란orphan&#34;&gt;고아 프로세스란(orphan)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;좀비 프로세스와 비슷한 고아 프로세스라는 것이 있다.&lt;/li&gt;
&lt;li&gt;고아 프로세스는 부모 프로세스가 &lt;code&gt;wait()&lt;/code&gt;을 호출하는 대신에 그냥 종료를 해버리는 것이다. 이러한 상황에 처한 자식 프로세스를 고아(&lt;code&gt;orphan&lt;/code&gt;) 프로세스라고 한다.&lt;/li&gt;
&lt;li&gt;이 경우에는 고아 프로세스의 새로운 부모 프로세스로 &lt;code&gt;init&lt;/code&gt; 프로세스를 지정함으로써 이 문제를 해결한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 프로세스는 주기적으로 &lt;code&gt;wait()&lt;/code&gt; 시스템 콜을 호출하여 고아 프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실습&#34;&gt;실습&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

int main ()
{
  pid_t child_pid;
  int child_status;

  child_pid = fork ();
  if (child_pid &amp;gt; 0) {
    // parent process will sleep for 30 seconds and exit, without a call to wait()
    fprintf(stderr,&amp;quot;parent process - %d\n&amp;quot;, getpid());
    sleep(30);
    exit(0);
  }
  else if (child_pid == 0) {
    // child process will exit immediately
    fprintf(stderr,&amp;quot;child process - %d\n&amp;quot;, getpid());
    exit(0);
  }
  else if (child_pid == -1) {
    // fork() error
    perror(&amp;quot;fork() call failed&amp;quot;);
    exit (-1);
  }
  else {
    // this should not happen
    fprintf(stderr, &amp;quot;unknown return value of %d from fork() call&amp;quot;, child_pid);
    exit (-2);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같은 소스 코드를 작성하고 컴파일을 한 뒤에 실행을 해보자.
소스 코드의 대략적인 내용은 부모 프로세스에서 자식 프로세스를 만들고 나서, &lt;code&gt;wait()&lt;/code&gt; 호출을 하지 않고 종료 시켜버리는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -o zombie zombie.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;실행을 하기 전에, &lt;code&gt;top&lt;/code&gt; 명령어를 통해서 좀비 프로세스의 여부를 확인한 모습이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113477959-c1252200-94c0-11eb-946c-384317e800aa.png&#34; alt=&#34;Screen Shot 2021-04-03 at 9 05 53 PM copy&#34;&gt;&lt;/p&gt;
&lt;p&gt;좀비 프로세스가 없다는 것을 확인할 수 있다. 아까 작성한 프로그램을 실행 시킨 후에, 다시 한 번더 확인하였을 때는 다음과 같이 표시됨을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113478040-4a3c5900-94c1-11eb-9d54-dc99e1262648.png&#34; alt=&#34;zombie_after&#34;&gt;&lt;/p&gt;
&lt;p&gt;아까는 존재 하지 않았던, 좀비 프로세스가 생긴 것을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=46380306&#34;&gt;운영체제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://reallinux.co.kr/&#34;&gt;리얼 리눅스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>프로그램 실행시 메모리 구조 및 실제로 확인해보는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Sat, 03 Apr 2021 18:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>&lt;p&gt;컴퓨터 구조 시간때 배웠듯이 프로그램이 메모리에 올라가면 다음과 같은 구조로 메모리가 할당되고 실행이 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474822-3d156f00-94ad-11eb-815d-f3bc78df9d97.png&#34; alt=&#34;FdJ8Xbd&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스크에 저장되어 있는 프로그램이 메모리에 올라가게 된다.&lt;/li&gt;
&lt;li&gt;메모리에는 크게 코드, 스택, 힙 영역이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 리눅스에서 확인해보려면 다음과 같은 명령어를 사용하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/self/maps
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 명령어가 뜻하는 바는 &lt;code&gt;cat&lt;/code&gt;이라는 프로그램을 실행했을 때의 메모리 구조를 의미한다.&lt;/li&gt;
&lt;li&gt;여기서 &lt;code&gt;self&lt;/code&gt;는 자기 자신을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474795-10f9ee00-94ad-11eb-9b69-e7ec306975b3.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 46 26 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위에서부터 코드 영역, 힙 영역, 스택이 메모리에 할당되어 있는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;개념으로만 알고 있던 것을 실제로 눈으로 확인해보니까 더 와닿았다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리눅스는 특별한 프로그램인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80/</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B8%EA%B0%80/</guid>
      <description>&lt;h3 id=&#34;리눅스는-과연-특별한가&#34;&gt;리눅스는 과연 특별한가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;리눅스 파일이 다른 실행 파일과 다른지 알아보기 위해서 커널을 실제로 빌드 해보고 일반 실행파일과 다른점이 있는지 알아보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474362-8c0dd500-94aa-11eb-9173-aa348199400c.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 29 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 리눅스 커널을 &lt;code&gt;make&lt;/code&gt; 명령어를 통해서, 빌드한 모습이다. 빌드를 마치게 되면 &lt;code&gt;vmlinux&lt;/code&gt; 라는 실행 파일이 나오게 된다.&lt;/p&gt;
&lt;p&gt;이를 &lt;code&gt;file&lt;/code&gt; 도구를 통해서 알아보았다. &lt;code&gt;file&lt;/code&gt; 도구는 파일이 어떤 타입인지를 알려주는 리눅스 도구이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474446-faeb2e00-94aa-11eb-8e60-54f4e516c57f.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 32 41 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt;을 통해서 메뉴얼을 확인해보면 더욱 자세한 사용법을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474566-a1373380-94ab-11eb-9f23-c2d46c38b3c8.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 37 15 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113474587-b57b3080-94ab-11eb-8abc-1cf19518211c.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 37 49 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;리눅스 실행 파일과 간단한 프로그램을 만들어서 비교한 결과, 거의 같은 파일이라는 것을 확인할 수 있었다. 차이가 있다면 리눅스의 경우에는 정적 링킹이 되었고 예제 프로그램의 경우에는 동적 링킹이 되어있다는 차이점 밖에는 없다. 이에 대해서는 나중에 자세하게 정리하도록 하겠다.&lt;/p&gt;
&lt;p&gt;따라서 결론은 리눅스도 하나의 프로그램일 뿐이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>운영체제의 역할 및 리눅스를 공부할 때 중요한 핵심 개념</title>
      <link>https://dongwooklee96.github.io/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90/</link>
      <pubDate>Sat, 03 Apr 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B0%8F-%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%A0-%EB%95%8C-%EC%A4%91%EC%9A%94%ED%95%9C-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90/</guid>
      <description>&lt;p&gt;예전에 시스템 프로그래밍을 조금 더 잘 알고 싶어서 &lt;a href=&#34;https://reallinux.co.kr&#34;&gt;리얼 리눅스&lt;/a&gt;에서 강의를 들은 적이 있는데, 그 때는 노션에 정리를 하던 시절이라서 블로그에 게시하지 못했다. 따라서 그때 정리한 개념을 블로그에 글로 작성해보고 다시 운영체제에 대해서 복습하였다.&lt;/p&gt;
&lt;h3 id=&#34;리눅스를-공부할-때-중요한-개념&#34;&gt;리눅스를 공부할 때 중요한 개념&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;리눅스를 공부할 때는 다음과 같은 개념이 중요하다고 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;소프트웨어 기본 원리 : 당연한 말이지만, 소프트웨어의 기본 동작 원리를 제대로 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리 액세스 원리 : 운영체제에서 메모리를 어떻게 액세스 하고 관리하는지 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일(디스크) IO : 디스크 및 파일 시스템에 대해서 아는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크 IO: 네트워크 통신 및 기초에 대해서 알아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;운영체제의-역할&#34;&gt;운영체제의 역할&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;운영체제의 핵심 역할은 다음과 같이 나누어 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 관리 (&lt;code&gt;Process Management&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;메모리 관리 (&lt;code&gt;Memory Management&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;인터럽트(&lt;code&gt;Interrupt&lt;/code&gt;) / 예외 처리(&lt;code&gt;Exception&lt;/code&gt;) / 락킹(&lt;code&gt;Locking&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;IO 처리
&lt;ul&gt;
&lt;li&gt;네트워크 (L4: TCP, L3: IP, L2: DD)&lt;/li&gt;
&lt;li&gt;스토리지 (&lt;code&gt;VFS&lt;/code&gt;/ &lt;code&gt;FS&lt;/code&gt;/ &lt;code&gt;BLOCK&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기타 : 보안(&lt;code&gt;security&lt;/code&gt;), 도구(&lt;code&gt;tools&lt;/code&gt;), 사운드(&lt;code&gt;sounds&lt;/code&gt;), 드라이버(&lt;code&gt;drivers&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113473846-17856700-94a7-11eb-84d9-7bf3c267ec28.png&#34; alt=&#34;Screen Shot 2021-04-03 at 6 04 31 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 스크린샷은 리눅스 커널 소스코드인데, 위에서 설명한 운영체제의 핵심 역할에 맞게 디렉터리가 구성되어 있는 것을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kernel&lt;/code&gt; : 리눅스 커널 내부와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mm&lt;/code&gt; : 메모리와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs&lt;/code&gt; : 파일 시스템과 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net&lt;/code&gt; : 네트워크와 관련된 작업을 하는 곳이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 02 Apr 2021 17:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자바스크립트 세미나를 들었다.&lt;/li&gt;
&lt;li&gt;내가 개발하고 있는 솔루션에서 이제 슬슬 성능 문제가 나오고 있다.&lt;/li&gt;
&lt;li&gt;엔지닉스 및 톰캣에 대해서 자세히 공부를 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자신감 있게 발표하는 것이 중요할 것 같다. 내용 뿐만 아니라 자신감 있는 목소리는 우선 집중이 되기 때문이다. 따라서 비언어적인 요소에도 신경을 많이 쓰자&lt;/li&gt;
&lt;li&gt;발표 연습을 할 주제를 정하기가 어려워서 자꾸 발표 연습을 하는 것을 꺼리게 된다. 그리고 발표 자료를 만들어야한다는 마음에 자꾸 발표를 미루게 되는 것 같다.&lt;/li&gt;
&lt;li&gt;정확한 원인을 파악하고 분석하는 것이 어려운 것 같다. 곰곰히 생각해보니까 그 이유는 원인을 파악하는 정보를 수집하지 못했기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;발표를 하는데, 내용도 중요하지만, 맺음말, 그리고 발성 시선 처리 또한 무시못하는 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=59668172&#34;&gt;그림으로 공부하는 시스템 성능구조&lt;/a&gt; 라는 책을 읽으면서 초반에 이러한 글귀가 나온다.
&amp;ldquo;가능한 스스로 그림을 그려가면서, 다른 사람에게 설명할 것을 추천한다. 해보면 알겠지만 막상 직접 설명하려고 하면, 자신이 애매하게 이해하고 있었다는 것을 깨닫게 된다.&amp;rdquo;
따라서 나도 그림을 그려가면서 어떤 개념을 남에게 설명하는 연습을 하고 이를 녹화하면서 피드백을 얻어야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 저자는 엔지니어를 가르치는 일을 5년간 하면서 발표 능력이나 설명 능력을 키울 수 있었다고 한다. 이를 통해서 그림을 그려서 설명하는 것과, 기본을 먼저 이해하는 것이 가장 분명한 방법이라는 것을 깨달았다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 측정의 시작은, 바로 측정이라는 것을 배웠다. 측정이 되지 않으면 성능에 대해서 이야기를 할 수 없다. 또한 성능 문제의 대처나, 성능 튜닝은 항상 바른 측정이 수반되어야 한다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 발성을 바꾸도록 노력해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 작은 발표를 해보자. 그리고, 이를 측정하고 내가 얼마나 괜찮아졌는지를 측정하고 기록하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 01 Apr 2021 20:10:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/04/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 곧 있으면 자바스크립트 관련 사내 세미나 발표를 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;곧 회사 사람들 앞에서 발표를 한다고 생각하니까 떨리고 살짝 무섭기도 하다.&lt;/li&gt;
&lt;li&gt;최근 팀에 새로운 분이 들어왔는데, 뭔가 부끄럽지 않은 모습과 배울 점이 있는 사람으로 느껴졌으면 하는 마음이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;발표 할 수 있는 것을 좋은 기회라고 생각하고, 회고를 작성했던 것 처럼, 말하는 연습을 하는데 좋은 동기로 작용했으면 좋겠다.&lt;/li&gt;
&lt;li&gt;발표를 하기 전에, 자료를 준비하고 이를 녹화해보면서 블로그에 글을 꾸준히 작성하는 것 처럼 주말마다. 주제를 정해서, 슬라이드를 만들고 이에 대해서 남에게 설명하는 연습을 하면 좋을 것이다. 그리고 슬라이드는 슬라이드 쉐어에 공유를 하고 발표 영상 또한 유튜브에 공유하면 나의 노력에 대해서 알아주는 사람이 있을 것이라고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생각만 하지 말고 행동으로 보이자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자료 준비 및 발표를 잘해서, 사람들에게 배울 점이 있는 사람으로 생각되자.&lt;/li&gt;
&lt;li&gt;준비를 철저하게 하고, 이를 통해서 말하는 연습을 꾸준히 하는 계기로 삼자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ARIES란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft/</link>
      <pubDate>Wed, 31 Mar 2021 22:56:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/aries%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&#34;&gt;WIKI - ARIES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 31 Mar 2021 22:25:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제는 한 시간정도 일찍 취침을 했다.&lt;/li&gt;
&lt;li&gt;오늘 회사에서, 모바일 개발을 위한 &lt;code&gt;API&lt;/code&gt; 정리를 하였다.&lt;/li&gt;
&lt;li&gt;팀이 변경되어서 자리를 옮기게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서가 현재와 맞지 않는 것들이 많아서 어지러웠다. 그리고 어떻게 해야지 모바일 개발자들이 더 쉽게 &lt;code&gt;API&lt;/code&gt;를 사용할 수 있을까 그리고 쉽게 사용하려면 사실 컨트롤러 부분을 수정해야하는것이 아닌지 고민을 하게 되었다.&lt;/li&gt;
&lt;li&gt;새로운 팀에서 새롭게 시작한 기분이 되어서 조금 기분 전환이 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 제대로 관리하고 되도록이면 소스 코드랑 동떨어지지 않도록 노력해야겠다.&lt;/li&gt;
&lt;li&gt;새로운 팀에서 새롭게 시작한다고 생각을 하면서 더 좋은 모습을 처음부터 보여드려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;잘 만들어진 소프트웨어는 코드 및 기능 뿐만 아니라, 주석, 문서화, 커뮤니티까지 완벽한 경우가 많다 따라서, 이러한 부분의 능력을 기르기 위해서 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 문서를 어떻게 하면 잘 작성할 지 고민하고 &lt;code&gt;API&lt;/code&gt; 설계를 잘 하는 방법 및 문서화를 어떻게 하면 코드와 함께 맞출 수 있을지에 대해서 고민을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;내부 원리 및 이를 디버깅할 수 있는 방법을 찾아서 계속 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스에 대해서 배울 수 있는 좋은 강의 (CS186Berkeley)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley/</link>
      <pubDate>Wed, 31 Mar 2021 20:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%B0%B0%EC%9A%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A2%8B%EC%9D%80-%EA%B0%95%EC%9D%98-cs186berkeley/</guid>
      <description>&lt;p&gt;우연히 유튜브에서 데이터베이스에 대해서 체계적이고 좋은 영상이 있는 것을 발견하였다.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/ZLtwOp8pz_Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;커리큘럼을 보면, 초반에는 디스크, 버퍼, 파일 및 인덱스 B+Tree 부터 시작해서 간단한 &lt;code&gt;SQL&lt;/code&gt; 및 간단하 쿼리 튜닝까지 배운다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154480-0227f700-9273-11eb-9683-6ac82864c697.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113154484-03592400-9273-11eb-8897-6de7f64fb366.png&#34; alt=&#34;dbms&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그리고, 트랜잭션 처리 부터 시작해서, 병렬 쿼리 실행 그리고 분산 트랜잭션 처리까지 철저하게 배운다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심지어 과제 및 시험문제도 풀어볼 수 있다. &lt;a href=&#34;https://cs186.gitbook.io/project/assignments/proj0&#34;&gt;CS186&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;남는시간에 틈틈히 DBMS에 대해서 공부하면서 부족했던 기본기를 튼튼하게 하면서, 오픈 소스에 기여할 때 도움이 되도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DBMS&lt;/code&gt; 프로젝트를 이해할 때, 기본기에 대한 부족함을 많이 느꼈다. 따라서 이 강의를 통해서 기본기를 다진다면 한결 흐름을 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/user/CS186Berkeley/videos&#34;&gt;CS186Berkeley&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 30 Mar 2021 22:09:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/30/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 어제 발생했던 이슈의 원인을 찾아보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 하루 우울하고 힘이 없었던 것 같다.&lt;/li&gt;
&lt;li&gt;오늘 밤에는 조금 쉬기로 하였다.&lt;/li&gt;
&lt;li&gt;내일이면 팀이 새롭게 개편되어서 자리를 옮길 것 같다. 팀원들이랑 정들었는데 조금 아쉽다. 새로운 팀이랑 일을 잘 할 수 있을지 조금은 걱정되기도 한다.&lt;/li&gt;
&lt;li&gt;이슈가 발생한 정확한 원인을 파악해서 기쁘다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;오픈 소스 커뮤니티에 가면, 대부분 발생했던 문제들의 해결책이 있고 만약 없더라도 내가 이슈를 만들어서 보고하도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;조금 쳐졌을 때, 마음을 다잡고 열심히 해보려는 마음이 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;나의 마음을 드러내지 않도록 하는 것이 중요하고, 팀원들에게 좋은 모습을 보여야겠다.&lt;/li&gt;
&lt;li&gt;이번에는 오픈 소스 커뮤니티에서 원인 분석과 해결책을 주었지만, 만약 그러지 못할 경우를 대비해야한다. 따라서 평소에 사용하는 프레임워크의 내부 동작을 잘 익히고 이를 어떻게 디버깅할 수 있을지를 항상 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내부 원리 및 이를 디버깅할 수 있는 방법을 찾아서 계속 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>리액트에서 구글 번역기가 번역하면서, DOM 트리를 변경해 렌더링이 되지 않는 현상</title>
      <link>https://dongwooklee96.github.io/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81/</link>
      <pubDate>Tue, 30 Mar 2021 13:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80-%EB%B2%88%EC%97%AD%EA%B8%B0%EA%B0%80-%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B4%EC%84%9C-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%98%84%EC%83%81/</guid>
      <description>&lt;h3 id=&#34;문제-상황&#34;&gt;문제 상황&lt;/h3&gt;
&lt;p&gt;개발을 진행하다가,  &lt;code&gt;PM&lt;/code&gt;에서 데이터가 이상하다고, 확인해달라는 요청을 받았다. 확인을 해본 결과, 데이터베이스 및 서버에서 내려오는 데이터는 정상이였다. 하지만 화면에서 업데이트를 시키지 않고, 기존에 데이터가 그대로 남아있어 화면 업데이트가 안되는 상황이였다. 재현을 해봤을 때는 아무런 문제가 없어서 혹시나 하고 구글 번역기를 켜고 재현을 해보았을 때 버그가 발생하였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934001-d82fe100-915b-11eb-917b-9405fadc17da.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 28 22 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;원인&#34;&gt;원인&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934219-407ec280-915c-11eb-8a90-c8be38c7c471.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 31 30 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;검색을 해보니, 비슷한 현상이 이미 보고가 되어있었고, 원인을 파악하기 위해서 살펴보았다.&lt;/p&gt;
&lt;p&gt;구글 번역기를 켰을 때 변경된 텍스트가 업데이트 되지 않는 이유는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;웹 사이트에서 구글 번역기를 켰을 때 번역기가 텍스트를 &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; 태그로 대체한다. 하지만 리액트에서 변경된 것을 감지하지 못해서, 이미 &lt;code&gt;DOM&lt;/code&gt; 트리에서 사라진 객체를 참조한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;텍스트는 조건부로 렌더링이 되며, 부모 노드의 유일한 하위 노드가 아니다. 그런 후에 텍스트 노드가 제거되면 &lt;code&gt;React&lt;/code&gt;는 &lt;code&gt;parent.removeChild(textNode)&lt;/code&gt;를 호출하고 텍스트 노드가 더 이상 상위 노드의 하위 노드가 아니기 때문에 삭제한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;조건부로 렌더링 된 텍스트 노드가 부모의 유일한 자식일 때는 던지지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;텍스트 노드가 앞의 노드가 조건 부로 렌더링되고, 그런 다음에 노드가 삽입 될 때 &lt;code&gt;parent.insertBefore(someNode, textNode)&lt;/code&gt;를 호출하고 &lt;code&gt;textNode&lt;/code&gt;가 더이상 상위 노드가 아니기 때문에 예외를 던진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112934676-39a47f80-915d-11eb-81b9-2cf4771030db.png&#34; alt=&#34;Screen Shot 2021-03-30 at 1 38 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해결책은, 텍스트를 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그로 감싸서 내용이 &lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt; 태그로 대체되더라도 리액트에서 참조하는 노드가 &lt;code&gt;DOM&lt;/code&gt; 트리에서 사라지지 않게 하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/react/issues/11538&#34;&gt;Make React resilient to DOM mutations from Google Translate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클라우드 이벤트 스펙이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Mon, 29 Mar 2021 22:55:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8A%A4%ED%8E%99%EC%9D%B4%EB%9E%80/</guid>
      <description>&lt;h3 id=&#34;클라우드-이벤트-스펙이란&#34;&gt;클라우드 이벤트 스펙이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941452-927a1500-9169-11eb-9947-5291c6d27c86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 06 29 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트는 어디에서든지 발생하지만, 이벤트를 생산하는 생산자에 따라서 이벤트를 다르게 정의하는 경향이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 설명하는 표준이 없기 때문에, 개발자는 이벤트 사용방법을 계속해서 배워야 한다. 또한 &lt;code&gt;SDK&lt;/code&gt;, 이벤트 라우터 또는 추적 시스템과 같은 환경에서 이벤트 데이터를 전달하는데 도움이 되는 도구 및 인프라의 잠재력을 제한한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우드 이벤트는 서비스, 플랫폼 및 시스템간에 상호 운영성을 제공하기 위해서 이벤트 데이터를 공통 형시으로 설명하기 위한 스펙이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112941821-277d0e00-916a-11eb-83bd-4a426cf9ea86.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 11 01 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서를 보면 프로토콜 별로 스펙과 문서를 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 카프카에 관심이 있으므로 카프카 메시지에 대한 문서를 살펴보도록 하겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;카프카-메시지-맵핑&#34;&gt;카프카 메시지 맵핑&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112943105-01f10400-916c-11eb-88a1-546ffe6c47a1.png&#34; alt=&#34;Screen Shot 2021-03-30 at 3 24 17 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;카프카 &lt;code&gt;0.11.0.0&lt;/code&gt; 이상에서는 이벤트 발신자가 콘텐츠 모드를 선택한다, 특정 콘텐츠 모드를 사용해서 이벤틀르 요청을 허용할 수 있는 프로토콜 사용 패턴은 응용 프로그램에서 정의 할 수 있지만, 여기에서는 정의되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 수신자는 카프카 메시지의 &lt;code&gt;Content-type&lt;/code&gt; 헤더를 검사하여 두 콘첸츠 모드를 구분할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;미디어 타입이 &lt;code&gt;application/cloudevents&lt;/code&gt; 인 경우에는 이벤트 형식의 사용을 나타내고 수신자는 구조화된 모드를 사용합니다. 그렇지 않은 경우에는 디폴트로 바이너리 모드입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 다음과 같은 &lt;code&gt;JSON&lt;/code&gt; 형태로 작성하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------ Message -------------------

Topic Name: mytopic

------------------- key ----------------------

Key: mykey

------------------ headers -------------------

content-type: application/cloudevents+json; charset=UTF-8

------------------- value --------------------

{
    &amp;quot;specversion&amp;quot; : &amp;quot;1.0&amp;quot;,
    &amp;quot;type&amp;quot; : &amp;quot;com.example.someevent&amp;quot;,
    &amp;quot;source&amp;quot; : &amp;quot;/mycontext/subcontext&amp;quot;,
    &amp;quot;id&amp;quot; : &amp;quot;1234-1234-1234&amp;quot;,
    &amp;quot;time&amp;quot; : &amp;quot;2018-04-05T03:56:24Z&amp;quot;,
    &amp;quot;datacontenttype&amp;quot; : &amp;quot;application/xml&amp;quot;,

    ... further attributes omitted ...

    &amp;quot;data&amp;quot; : {
        ... application data encoded in XML ...
    }
}

-----------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34;&gt;cloudevents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec/blob/v1.0.1/kafka-protocol-binding.md&#34;&gt;cloudevents - kafka spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>메시지 큐를 이용한 비동기처리 및 에러 처리</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC/</link>
      <pubDate>Mon, 29 Mar 2021 22:19:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC-%EB%B0%8F-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC/</guid>
      <description>&lt;h2 id=&#34;메시지-큐를-이용한-비동기-요청-처리&#34;&gt;메시지 큐를 이용한 비동기 요청 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112848087-a9295900-90e2-11eb-82ce-b6dd8ec80708.png&#34; alt=&#34;engineering linecorp&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;요청을 처리하는 방법에는 전통적인 동기식 방식도 있지만, 비동기식 방식도 있는데, 동기 방식이 클라이언트가 요청을 보내면 처리한 다음에 응답이 오는 방식이라면 비동기 방식은 요청을 보낸 후 비즈니스 로직이 처리가 완료되지 않은 상태에서 다음 로직을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버로 전달된 요청은 나중에 처리되며 나중에 클라이언트로 응답이 전달된다. (응답을 전달하지 않을 때도 있다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동기식 방식과 비동기식 방식의 가장 큰 차이점은 동기식 방식은 응답이 올 때까지 클라이언트가 대기하는 것이고, 비동기식 방식은 요청만 보내놓고 응답이 오는 것과 상관없이 클라이언트 대기 없이 다음 로직을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선택적으로 콜백 메시지를 보내는 경우가 있는데, 콜백은 클라이언트에게 비동기로 요청된 작업이 끝났음을 알려주는 호출이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 페이스북 사진을 첨부해서 글을 올리면, 브라우저에서는 글이 등록되었다고는 하지만 바로 타임라인에 표시되지 않고 1 ~ 2 초 후에 업데이트 되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 브라우저에서 글쓰기 요청을 받으면 먼저 클라이언트에게 완료되었다는 응답을 보낸 후 서버는 뒷단에서 그림의 크기를 조정하는 등의 추가적인 작업을 한후에 데이터베이스에 저장한 후 타임라인에 반영하기 때문이다. 이러한 처리가 대표적인 비동기 처리의 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주로 시간이 오래 걸리는 대규모 작업에 유리하고, 동영상 인코딩 같은 변환 작업이나 시간이 오래 걸리는 계산 작업, 또는 하나의 메시지를 보냈지만 여러 개의 작업이 필요한 경우 등 여러 시나리오에 폭 넓게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 비동기식 패턴 구현에는 일반적으로 메시지 큐라는 것을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 메시지 큐는 들어온 요청을 쌓아놓는 임시 공간으로, 쌓여있는 요청 메시지는 뒤의 비즈니스에 의해서 처리 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112851308-d3c8e100-90e5-11eb-8524-592565d189ff.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 비동기식 구현에서 가장 중요하게 고려해야 할 사항은 전달된 요청 메시지가 잘 처리되었느냐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트는 단순하게 요청을 보내고, 그에 대한 응답을 받지 않기 때문에, 해당 요청이 제대로 처리되었는지 보장할 방법이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 클라이언트는 요청을 보내고 메시지 큐에 잘 저장된 후에 응답을 받는다. 이 상태에서 클라이언트는 이 메시지가 제대로 처리될 것을 기대하지만, 메시지 큐에서 해당 메시지를 읽어서 처리하는 서버가 메시지를 꺼내서 처리하다가 장애를 일으켜서 정지하였다고 가정해보면 그 메시지는 유실되고 처리되지 않게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112852203-ab8db200-90e6-11eb-9746-2c7cd11dc9d2.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 이러한 비동기 구현에서는 에러 처리 부분에 가장 많은 신경을 써야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 컴포넌트에서 메시지 처리 중 에러가 났을 때, 해당 메시지를 에러 큐라는 재처리용 큐로 전달한다. 메시지의 에러 처리 정책을 정해서 에러를 어떻게 처리할지를 지정할 수 있는데, 비동기 메시지 처리에서는 다음과 같이 크게 4가지 정책을 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-재처리-retry&#34;&gt;1. 재처리 (Retry)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;메시지 처리 중 에러가 발생하였을 때, 다시 처리를 시도하도록 하는 방법ㅇ다.&lt;/li&gt;
&lt;li&gt;메시지를 처리하는 비즈니스 컴포넌트가 일시적인 장애 (네트워크 문제, 리소스 부족 등) 일 경우에는 효율적으로 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;재처리를 할 때는 반드시 최대 재처리 횟수를 지정해야 한다. (통상적으로 3 ~ 5 번 정도를 사용한다).&lt;/li&gt;
&lt;li&gt;그리고 재처리를 할 때, 에러 발생 후 바로 재처리를 시도하면 같은 원인으로 같은 에러가 발생할 수 있기 때문에 일정 시간을 기다렸다가 다시 처리하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-무시-ignore&#34;&gt;2. 무시 (Ignore)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;에러가 난 메시지는 무시하고 메시지를 없애 버리는 방식이다. 중요하지 않는 로그 정보를 저장할 때와 같이 메시지 유실이 허용되는 경우에만 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-알림-notify&#34;&gt;3. 알림 (Notify)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;메시지 처리 중 에러가 발생하였을 때 이메일, &lt;code&gt;SMS&lt;/code&gt;등을 이용하여 관리자에게 통보하여 관리자가 직접 에러에 대한 후 처리를 할 수 있도록 하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-사람이-처리하도록-함-human-interaction&#34;&gt;4. 사람이 처리하도록 함 (Human Interaction)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;에러가 발생하였을 때, 자동으로 처리하지 않고 관리자가 직접 처리할 수 있는 사용자 인터페이스를 제공한다.&lt;/li&gt;
&lt;li&gt;관리자가 에러난 메시지를 확인하고 재처리할지 무시할지 등을 결정하도록 한다.&lt;/li&gt;
&lt;li&gt;에러 재처리 부분이 복잡하거나 규모가 큰 경우 이런 메시지에 대한 에러 처리를 별도의 컴포넌트로 구현하기도 하는데, 이를 &lt;code&gt;Error Hospital&lt;/code&gt; 이라고 부른다.
처리 중 에러가 난 메시지를 모아서 다양한 에러 처리 정책에 따라서 재처리를 할 수 있는 기능을 갖는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;메시지-큐-구성-시-고려해야-할-사항&#34;&gt;메시지 큐 구성 시 고려해야 할 사항&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;성능 및 페일 오버를 고려한 Persistence의 선택&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지를 물리적으로 어디에 저장할 것인지 고민하는 것으로, 메시지는 보통 메모리, 디스크 또는 &lt;code&gt;RDBMS&lt;/code&gt;와 같은 저장소에 저장할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보통 메모리에 저장하는 모델이 가장 빠르기는 하지만, 서버 장애가 났을 때는 처리되지 않은 메시지들이 유실 될 수 있는 위험이 있기 때문에 아주 고성능에 메시지 유실이 허용되는 시스템이 아닌 경우에는 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 메시지 큐를 클러스터링 해서 사용할 경우에는, 클러스터된 인스턴스 중 특정 인스턴스가 죽었을 경우, 처리되지 않은 메시지를 살아 있는 인스턴스로 넘기기 위해서는 이 파일 시스템이 인스턴스 간에 공유 되어야하는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러 인해서 &lt;code&gt;NFS(Network File System)&lt;/code&gt;와 같은 공유 파일 저장소를 사용해야 하는 경우가 있는데, 이 경우 &lt;code&gt;NFS&lt;/code&gt; 성능 저하로 말미아마 전체 메시징 시스템의 성능 저하가 올 수 있기 때문에 이 부분에 대해서 고려해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 마지막 방법으로는 &lt;code&gt;RDBMS&lt;/code&gt;를 메시지 저장소로 사용할 수 있는데, 클러스터링 구성 시 페일 오버(Fail Over)도 비교적 잘되고, 메시지에 대한 관리도 매우 쉽다는 장점을 가지고 있지만, 3가지 구조 중에서 가장 느리고 추가적으로 &lt;code&gt;RDBMS&lt;/code&gt; 운영이 필요하다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;펜딩 메시지로 말미암은 Out of Memory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음 고려사항으로, 메세지 큐 미들웨어는 메모리 과다 사용으로 말미 암은 &lt;code&gt;Out of Memory&lt;/code&gt; 에러에 주의해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메모리에 메시지를 저장하는 &lt;code&gt;Persistence&lt;/code&gt; 구조를 가지고 있을 경우에는 메시지를 큐에서 꺼내 가지 않은면 쌓여 있는 메시지들이 정체되어 메모리를 잡아먹으면서 &lt;code&gt;Out of Memory(메모리 부족 에러)&lt;/code&gt;를 일으킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 쌓여있는 메세지들을 펜딩 (Pending Message) 라고 하는데, 이 펜딩 메시지에 의한 &lt;code&gt;Out of Memory&lt;/code&gt; 에러는 메시지 저장소를 이용하지 않더라도 발생하는 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 메시지 큐 미들웨어의 특성상 성능 향상을 위해서 메시지를 파일이나 &lt;code&gt;RDBMS&lt;/code&gt;에 저장하더라도, 최소한의 메시지에 대한 메타 정보(메시지 ID와 같은 인덱스 정보)를 메모리에 저장할 때 발생할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;트랜잭션 지원 기능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;높은 신뢰성을 요구하는 시스템은 트랜잭션 지원 기능을 고려해야 하는데, 메시지를 큐에서 빼간 후에 처리하다가 에러가 났을 경우의 이 메시지는 다시 큐에 복귀되거나 또는 에러 큐로 보내져야 한다. 이런 기능을 지원 하려면 트랜잭션 지원 기능이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션 기능을 지원하는 경우가 많지만 근래의 &lt;code&gt;AMQP&lt;/code&gt;나 고속 메시징 시스템의 경우 이러한 트랜잭션 기능을 지원하지 않는 경우가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 큐에서 메시지를 읽고 그 메시지를 데이터베이스에 쓰는 것은 하나의 트랜잭션으로 묶는 경우, 메시지를 큐에서 꺼내 온 후 메시지를 데이터베이스에 넣는 것을 실패하였을 때 이 트랜잭션을 실패로 처리하고 메시지를 다시 큐에 돌려 넣거나 아니면 에러 큐에 보내야 하는데, 분산 트랜잭션을 지원하는 메시지 큐 시스템은 데이터베이스와 큐의 트랜잭션을 하나로 묶어서 자동으로 이러한 작업을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 트랜잭션을 지원하지 않을 때에는 에러가 발생하였을 때, 개발자가 에러 큐로 메시지를 던지거나 또는 다시 큐에 넣는 작업을 해줘야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;클러스터링 기능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 클러스터링 지원 여부로, 메시지 큐에서 클러스터링이란 여러 개의 메시지 큐를 하나의 클러스터로 묶는 기능을 정의하느데, 여기서 오는 장점은 크게 두 가지 관점에서 고민 해 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫 번째로는 클러스터링을 통해서 특정 인스턴스 장애 시 다른 인스턴스들이 장애가 난 인스턴스의 메시지를 받아서 처리하는 페일 오버(&lt;code&gt;Fail Over&lt;/code&gt;) 기능이 있을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 번째로는 한 대의 서버로 처리할 수 없는 양의 메시지를 여러 대의 서버에서 분산 처리하면서 올 수 있는 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐 미들웨어는 한 번 선택이 되면 표준처럼 계속 사용되기 때문에 서비스의 특성을 잘 파악하고 위의 고려 사항을 기반으로 적절한 제품군을 선택할 것을 권고한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>멤티어 벤치마크로 아커스 성능 측정하기</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 29 Mar 2021 22:04:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EB%A9%A4%ED%8B%B0%EC%96%B4-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC%EB%A1%9C-%EC%95%84%EC%BB%A4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112841192-2c46b100-90db-11eb-8c96-0eb41685ebb4.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 06 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아커스에 내가 작성한 코드를 도입하고 나서, 얼마만큼의 성능 개선이 이루어졌는지 궁금했다. 따라서 오픈 소스 컨트리뷰톤 행사를 참여할 때, 도움을 주셨던 멘토님이 &lt;a href=&#34;https://github.com/RedisLabs/memtier_benchmark&#34;&gt;memtier_benchmark&lt;/a&gt; 라는 툴을 알려주셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 멘토님께서는 눈에 띄는 변화는 없을 것이라고 하셨다. 하지만, 내가 작성한 코드가 과연 성능 개선이 있을까 궁금해서 이를 측정해보고 싶었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/RedisLabs/memtier_benchmark.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112842051-1f768d00-90dc-11eb-942c-9e1b54aed4f9.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 14 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;README&lt;/code&gt; 문서에 나와있는데로, 의존성 패키지들을 다운로드 받고 이를 빌드 하면된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112843612-b98b0500-90dd-11eb-9d1f-7ea73465e0ec.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 25 46 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;귀찮은 의존성들을 모두 설치해주고, &lt;code&gt;make&lt;/code&gt;를 해주면, 드디어 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112844625-e2f86080-90de-11eb-93d3-880f0eb66c29.png&#34; alt=&#34;memtier&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은, &lt;code&gt;help&lt;/code&gt; 명령어를 실행한 모습이다. 많은 옵션이 있지만 나는 다음과 같이 사용했다. 우선 아커스 서버를 띄운다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845032-57330400-90df-11eb-9f08-eb62de685aad.png&#34; alt=&#34;arcus&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 쉘 스크립트를 이용해서 아커스 서버를 실행시켰는데, 포트번호 11216 인것 만 확인하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845376-c4469980-90df-11eb-8871-e5c75b1f26d5.png&#34; alt=&#34;arcus&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버를 띄우면 다음과 같은 화면이 뜨고, 이제 &lt;code&gt;memtier_benchmark&lt;/code&gt;를 다음의 옵션을 설정해서 실행을 시키면 끝난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112845383-c6105d00-90df-11eb-81d9-4e9afe5634b7.png&#34; alt=&#34;memtier&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./memtier_benchmark -s 127.0.0.1 -p 11216 -t 4 -c 50 -P memcache_text
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위에 작성한 명령어는 &lt;code&gt;localhost&lt;/code&gt; 주소의 &lt;code&gt;11216&lt;/code&gt; 포트로 쓰레드 4개와 커넥션 50개를 이용하여 &lt;code&gt;memcached&lt;/code&gt; 프토로콜 테스트를 하겠다는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112846408-fc9aa780-90e0-11eb-86e8-ea810284c90a.png&#34; alt=&#34;Screen Shot 2021-03-29 at 10 48 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트가 모두 끝나면 결과가 나온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/RedisLabs/memtier_benchmark&#34;&gt;memtier_benchmark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 29 Mar 2021 21:53:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 서버 성능 튜닝 및 알아야할 지식에 대한 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;운영 체제 및 기반 지식을 이해하고, 이렇게 구성하면 빨라지겠구나를 이해하고 튜닝을 하는 것은 재미있는 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 할 때, 스트레스 관리를 잘 하는 것이 중요할 것 같다. 최근에 무리해서 공부를 했더니 오늘 조금 지쳐있어서 제대로 일을 하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;기술적인 역량 및 운영체제, 네트워크, 디스크에 대한 깊은 지식이 있어야 겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;또한 특정 솔루션에 대한 전문적인 지식을 쌓아야겠다는 생각을 했다, 톰캣의 내부 구조 및 &lt;code&gt;JVM&lt;/code&gt;의 동작 원리에 대해서 공부를 해야겠다는 마음을 먹었다.&lt;/li&gt;
&lt;li&gt;인내심을 가지고, 디컴파일을 하던, 덤프를 추출하건 구준히 보고 오픈 소스의 경우에는 소스코드를 참조해서 로직을 따라가다 보면 풀어갈 수 있다고 했다.&lt;/li&gt;
&lt;li&gt;좋은 컨디션으로 꾸준히 공부하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인내심을 가지고, 프로그래밍 및 기반 지식을 깊게 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자기 관리를 해서, 업무에 지장이 없는 상태로 만들자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 기반지식을 잘 이해하면 튜닝하는데, 즐거움을 느낄 수 있다. 따라서 컴퓨터 공학 기반 지식을 이해하려고 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>슬로우 쿼리란? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft/</link>
      <pubDate>Mon, 29 Mar 2021 20:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/29/%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;슬로우-쿼리란&#34;&gt;슬로우 쿼리란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&#34;&gt;MySql - The Slow Query Log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>성능 엔지니어링 및 절차</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8/</link>
      <pubDate>Sun, 28 Mar 2021 23:24:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%84%B1%EB%8A%A5-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EB%B0%8F-%EC%A0%88%EC%B0%A8/</guid>
      <description>&lt;h2 id=&#34;1성능-엔지니어링이란&#34;&gt;1.성능 엔지니어링이란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;성능 엔지니어링은 시스템의 목표 성능 (응답 시간과 동시 접속자 수)를 정의하고 이를 달성하기 위해서 시스템의 구조를 반복적으로 개선하는 작업을 이야기 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좁게 생각하면 코드 상의 병목을 잡고 시스템의 설정을 바꿔서 성능을 높이는 튜닝으로 생각할 수 있지만, 성능 목표의 정의부터 최적의 성능을 위한 디자인 및 구현 같은 개발 초기의 설계 부분과 개발 후의 운영 단계 그리고 모니터링까지 전 과정을 포함한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능-엔지니어링을-해야하는-시기&#34;&gt;성능 엔지니어링을 해야하는 시기&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-분석-단계&#34;&gt;1. 분석 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;초기 요구사항 분석 및 시스템 기획 단계에서 성능에 대한 목표를 정해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표시간 , 시스템을 사용할 사용자 수와 시스템을 사용하는 동시 접속자수가 어떻게 되는지와 같은 성능 목표를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 성능 모델을 만들어서, 시스템에 부하가 어떤 패턴으로 들어오는지를 정의할 필요가 있다. 예를 들어서, 주부를 대상으로 하는 사이트라면 시스템의 부하는 한국 시간으로 아이들이 학교나 유치원에 간 시간에 많이 몰릴 것이라고 추측할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-디자인-단계&#34;&gt;2. 디자인 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 디자인 단계에서는 목표 성능과 용량을 달성할 수 있는 규모로 시스템 설계를 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 관점에서 시스템 디자인은 항상 피크 타임(최대 성능)에 맞춰서 디자인 된다. 전체 시스템이 감당할 수 있는 용량과 응답 시간을 고려해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 성능과 용량은 애플리케이션 디자인뿐만 아니라 기술을 결정하는 데도 많은 도움을 준다. 어떤 미들웨어나 프레임워크를 사용할 것인지에 따라서 성능의 차이가 많이 발생하기 때문에, 디자인 단계부터 성능과 용량을 고려해서 시스템을 설계 해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하드웨어 관점에서는 예전에는 성능 모델을 산정하고, 피크 타임을 기준(최대 성능 요구)으로 시스템을 설계하고 하드웨어를 구매하였으나, 근래에는 클라우드를 이용하여 필요 시에만 하드웨어를 탄력적으로 사용하는 오토 스케일 모델을 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 성능이나 용량에 관련된 제품 선정이나 설계는 돌려 보지 않으면 확신하기 어렵다 따라서 사용할 기술은 선택한 다음에, 간단한 프로토타입을 구현하고 시나리오가 단순한 대규모 성능 및 용량 테스트를 해보는 &lt;code&gt;PoC(Proof of Concept)&lt;/code&gt;같은 작업을 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-개발-단계&#34;&gt;3. 개발 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발 단계는 리스크가 높은 부분과, 아키텍처에 관련되는 부분, 난도가 높은 부분, 핵심 기능 등을 개발 초기의 스프린트에서 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 스프린트가 끝나고 릴리즈 돼서 성능 테스트나 가능한 &lt;code&gt;QA&lt;/code&gt;나 스테이징 환경으로 시스템이 이전되면 성능 엔지니어링 역량을 이 단계에서 집중하여 시스템의 아키텍처와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 단계에서 성능 목표의 달성 가능 여부가 판단되어야 아키텍쳐 변경이 가능하고 주요 성능 이슈들을 초반에 발견해야 성능에 대해서 같은 문제가 발생하지 않도록 디자인 가이드나 코딩 가이드를 개발자들에게 배포하여 위험을 줄인다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-최종-테스트-단계&#34;&gt;4. 최종 테스트 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;앞의 단계에서 성능과 용량을 고려해서 설계했고 개발 초기 단계에서 성능과 용량 부분의 검증을 제대로 하였다면, 최종 테스트 단계에서는 개발된 최종 시스템에 대한 성능, 용량 부분의 측정, 미세 튜닝을 하는 정도로 마무리되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 과정에서는 실수로 잘못한 설정이나, 코딩의 검증이 이루어진다. 예를 들어서 로그 파일을 &lt;code&gt;NFS&lt;/code&gt;와 같은 리모트 디스크에 쓴다든지, 인텔 계열의 &lt;code&gt;CPU&lt;/code&gt;에서 하이퍼스레딩 &lt;code&gt;ON&lt;/code&gt;을 하지 않았든지 같은 실수가 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 오류들이 해결되면 실제 미세 튜닝에 들어가는데, &lt;code&gt;JVM&lt;/code&gt; 튜닝이나 톰캣의 설정 튜닝, &lt;code&gt;SQL&lt;/code&gt; 튜닝 등이 이루어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 미세 튜닝에서 성능이 비약적으로 향상되지는 않는다, 보통 &lt;code&gt;20%&lt;/code&gt; 내외 정도의 성능이 올라간다고 생각하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-운영-단계&#34;&gt;5. 운영 단계&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 시에 발견되지 않은 성능 문제가 있을 수 있기 때문에, 모니터링 도구를 사용하여 지속적으로 성능을 모니터링하고 성능 상태에 문제가 있는 부분을 지속적으로 수정해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;성능 및 목표 용량 설정은 매우 중요한 과정이다. 기존 업무 시스템의 사용 패턴을 분석하는 것이 효율적이기 때문에, 운영 시스템의 로그를 수집하고 분석하여 성능 모델을 분석 및 보유해두는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2시스템-용량-산정&#34;&gt;2.시스템 용량 산정&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;response-time-응답-시간&#34;&gt;Response Time (응답 시간)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사용자가 서버에 요청을 한 시간부터 응답을 받을 때까지의 모든 시간을 포함한다. 이 응답 시간은 내부적으로 세분화 하여 분리된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Time(또는 Latency Time) : 서버에 요청을 보내고 받을 때 소요되는 네트워크 시간&lt;/li&gt;
&lt;li&gt;Transaction Time : 서버에서 실제 트랜잭션에 처리되는 시간을 의미한다.&lt;/li&gt;
&lt;li&gt;Think Time : 사용자가 보낸 요청에 대한 응답을 받고, 웹 페이지를 보거나 화면을 보는 시간을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrent-user동시-사용자&#34;&gt;Concurrent User(동시 사용자)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112756483-512a1e00-9020-11eb-9d33-9da5f8dac741.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템을 사용하는 사용자를 말한다. 웹 사이트를 사용하기 위해서 현재 브라우저를 열어놓고 웹 사이트를 보는 것과 같이 현재 시스템을 사용하는 사용자 수를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;active-user액티브-사용자&#34;&gt;Active User(액티브 사용자)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템에 트랜잭션을 실행하여 부하를 주는 사용자를 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;는 클릭을 통해 그 시간에 서버에 트랜잭션을 발생시키는 사용자를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 서버에서 순간 실행되고 있는 스레드 수(스레드 기반의 자바 서버인 경우)나 프로세스의 수와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Active User&lt;/code&gt;의 수는 실제로 서버가 동시에 처리할 수 있는 트랜잭션의 양을 판단할 수 있는 기준이 되기 때문에, 매우 중요한 성능 요인이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transaction-트랜잭션&#34;&gt;Transaction (트랜잭션)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션이란 사용자로부터 요청을 다루는 단위를 말한다.&lt;/li&gt;
&lt;li&gt;이러한 트랜잭션의 정의는 무엇을 판단 기준으로 할 것인가에 따라 결정되는데, 예를 들어 리소스를 톰캣과 같은 애플리케이션 서버에서 처리하지 않고 앞단의 &lt;code&gt;CDN&lt;/code&gt;이나 웹 서버에서 처리할 때, 톰캣은 리소스에 대한 트랜잭션 요청을 받지 않는다.&lt;/li&gt;
&lt;li&gt;리소스에 대한 로딩은 비즈니스 로직 처리보다 부하가 상대적으로 적고, 일반적으로 브라우저에 캐시 되기 때문에, 보통 서버의 성능 측정 시 이러한 리소스 로딩에 대한 부하는 트랜잭션 단위로 처리하지 않는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tpstransaction-per-second&#34;&gt;TPS(Transaction per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;초당 처리할 수 있는 트랜잭션의 양을 말한다.&lt;/li&gt;
&lt;li&gt;보통 서버의 성능 평가 기준이 된다, &lt;code&gt;Active User&lt;/code&gt;가 순간 트랜잭션을 처리한다고 하면 이는 목표 응답시간 &lt;code&gt;(Response Time)&lt;/code&gt;으로 나눈 값이 목표 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;li&gt;예를 들어서 &lt;code&gt;Active User&lt;/code&gt;가 50 명이고 개당 응답 시간이 2초라고 하면 이 시스템의 &lt;code&gt;TPS&lt;/code&gt;는 25 &lt;code&gt;TPS&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hpshit-per-second&#34;&gt;HPS(Hit Per Second)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 처리할 수 있는 모든 웹 요청의 초당 처리량이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TPS&lt;/code&gt;가 비즈니스 트랜잭션에 대한 처리 시간만을 정의한다면 &lt;code&gt;HPS&lt;/code&gt;는 리소스(이미지, 자바 스크립트)에 대한 요청 처리량을 포함하기 때문에 &lt;code&gt;TPS&lt;/code&gt;보다 약 10 ~ 20 배 높게 나온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-테스트와-모니터링&#34;&gt;3. 테스트와 모니터링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;부하 테스트를 할 때, 주요 성능 요인을 모니터링하고 기록해야한다.&lt;/li&gt;
&lt;li&gt;주요 모니터링 해야하는 대상 및 관점은 애플리케이션, 미들웨어, 인프라 관점으로 나눌 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;애플리케이션-관점&#34;&gt;애플리케이션 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적으로 애플리케이션, 즉 시스템의 성능을 측정해야한다. 주요 모니터링 내용은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Response Time&lt;/code&gt; : 요청(&lt;code&gt;Request&lt;/code&gt;)별 응답시간&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TPS(Throughput per second)&lt;/code&gt; 초당 요청(&lt;code&gt;Request&lt;/code&gt;) 처리량&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 요인들이 성능의 궁극적인 최종 목표 값이 되기 때문에, 가장 중요한 성능 요인이 되며 부하 생성 도구를 통해서 쉽게 측정 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;미들웨어-관점&#34;&gt;미들웨어 관점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;미들웨어는 애플리케이션이 동작하기 위한 기본적인 솔루션이다.&lt;/li&gt;
&lt;li&gt;아파치와 같은 웹 서버나 톰캣과 같은 웹 애플리케이션 서버, &lt;code&gt;RabbitMQ&lt;/code&gt;와 같은 메시지 큐, &lt;code&gt;MySQL&lt;/code&gt;과 같은 데이터베이스가 해당한다.&lt;/li&gt;
&lt;li&gt;각 성능 시나리오 별로 거쳐가는 모든 미들웨어를 모니터링 해야하는데, 이를 위해서는 각 솔루션에 대한 깊은 이해가 필요하다.&lt;/li&gt;
&lt;li&gt;웹 서버는 성능이 문제가 되는 부분은 거의 없다, 성능 문제는 대부분 네트워크 아웃 바운드 (&lt;code&gt;IO&lt;/code&gt;, 대역폭) 쪽에서 발생할 때가 많다.&lt;/li&gt;
&lt;li&gt;웹 서버가 설치된 하드웨어 네트워크 아웃바운드 &lt;code&gt;IO&lt;/code&gt;의 대역폭을 모니터링하는 것이 유용하다.&lt;/li&gt;
&lt;li&gt;대부분의 성능 문제는 실제 애플리케이션 로직이 수행되는 톰캣과 같은 애플리케이션 서버와 데이터베이스 단에서 많이 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;애플리케이션 서버는 스레드의 수오 큐의 길이가 1차 모니터링 대상이 된다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;서버가 용량을 추가하게 되면 유휴 스레드(&lt;code&gt;Idle Thread&lt;/code&gt;) 수가 떨어지게 되고 유휴 스레드가 0이 되면 요청 메시지가 앞단의 큐에 저장된다.&lt;/li&gt;
&lt;li&gt;따라서 이 두개를 모니터링 하면, 시스템이 병목 상태인지 아닌지를 판단할 수 있다.&lt;/li&gt;
&lt;li&gt;이 값들은 &lt;code&gt;JMX(Java Management Extenstion)&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;를 이용하여 모니터링 하면된다.&lt;/li&gt;
&lt;li&gt;DB의 경우에는 슬로우 쿼리를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다.&lt;/li&gt;
&lt;li&gt;슬로우 쿼리를 찾았으면, &lt;code&gt;EXPLAIN&lt;/code&gt; 명령어를 이용하여 쿼리의 수행 내용을 분석한 후에 인덱스 등의 튜닝을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인프라-관점--cpu-메모리-네트워크-io-디스크-io&#34;&gt;인프라 관점 : CPU, 메모리, 네트워크 IO, 디스크 IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하드웨어 인프라 모니터링은 전문적인 인프라 모니터링 도구를 사용하거나 &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;sar&lt;/code&gt;와 같은 기본적인 유닉스 또는 리눅스 명령어를 사용해도 가능하다.&lt;/li&gt;
&lt;li&gt;부하 테스트 중에 &lt;code&gt;top&lt;/code&gt;을 띄워놓고 모니터링 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 &lt;code&gt;CPU&lt;/code&gt;는 대부분 잘 모니터링 한다.&lt;/li&gt;
&lt;li&gt;목표 성능을 달성할 시에는 보통 70 ~ 80 퍼센트를 사용하는 것이 좋고 항상 20 ~ 30 퍼센트의 여유를 두는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;메모리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로, 메모리 부분이다. 피크 타임시에 메모리가 얼마나 사용되느냐가 중요한데, 자바 애플리케이션은 특성상 전체 &lt;code&gt;JVM&lt;/code&gt; 프로세스가 사용할 메모리 양을 미리 정해놓기 때문에, 부하 테스트 중에도 메모리 사용량은 크게 변화지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다만, 스와핑 (&lt;code&gt;Swapping Status&lt;/code&gt;)를 자주 놓치게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스, 유닉스 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해서 가상 메모리라는 개념을 사용하고 스와핑 공간이라는 디스크 공간에 자주 사용하지 않는 메모리의 내용을 덤프해 저장해여, 다시 사용할 때 메모리에 로딩하는 방식을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런데 이 메모리의 내용을 디스크에 저장 및 로드 하는 과정 (스와핑)이 실제 디스크 &lt;code&gt;IO&lt;/code&gt;를 발생시키기 때문에 실제 메모리 액세스 성능이 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래서 시스템에서 스와핑이 발생하면 시스템 성능이 장애 수준으로 매우 급격하게 떨어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;디스크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디스크 &lt;code&gt;IO&lt;/code&gt;는 파일 시스템에 파일을 저장하는 시나리오나 로그를 저장하는 모듈, 그리고 데이터베이스와 같이 뒷단에서 파일 시스템을 요구하는 모듈에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디스크 IO에 대한 병복은 여러 가지 해결 방법이 있다. 먼저 하드웨어 인프라 자체에서 접근하는 방식은 디스크 자체를 &lt;code&gt;SSD&lt;/code&gt;로 변경하거나, 버퍼가 크거나 &lt;code&gt;RPM&lt;/code&gt;이 높은 디스크로 변경하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RAID&lt;/code&gt; 구성을 스트리핑 방식으로 변경해서,&lt;code&gt;IO&lt;/code&gt;를 여러 디스크로 분산시키는 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 차원에서는 데이터베이스 앞에 &lt;code&gt;Memcached&lt;/code&gt;와 같은 캐싱을 사용하거나, 로깅의 경우에는 중간에 메시지 큐를 써서 로그를 다른 서버에 쓰도록 하여 &lt;code&gt;IO&lt;/code&gt;를 분산시킬 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 백 라이트(&lt;code&gt;Back Write&lt;/code&gt;)같은 방식으로 로그 메시지가 발생할 때마다, 디스크에 쓰는 것이 아니라, 20, 30개씩 한꺼번에 디스크로 플러싱하는 방식을 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조금 더 높은 아키텍처 수준으로는, 디스크 &lt;code&gt;IO&lt;/code&gt;가 많이 발생하는 로직은 동기 처리에서, 메시지 큐를 이용하는 비동기 방식으로 시스템 설계를 변경하는 방법을 고민할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, 사진을 올려서 변환하는 서비스는 파일을 업로드 하는 시나리오와 변경하는 모듈을 분리하여, 파일 업로드가 끝나면 사용자에게 동기 방식으로 바로 응답을 줘서 응답 시간을 빠르게 하고, 업로드된 파일은 뒷단에서 비동기 프로세스를 통한 변환 과정을 끝낸 후에 사용자에게 결과를 알려주는 방법을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 IO&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 &lt;code&gt;IO&lt;/code&gt;는 특히 고용량의 파일이나 이미지 전송에서 병목이 주로 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주로 &lt;code&gt;Reverse Proxy&lt;/code&gt;, &lt;code&gt;NAT(Network Address Translator)&lt;/code&gt;, 라우터, 로드 밸런서 등에서 많이 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러가지 지점과 장비에 대해서 모니터링해야하기 때문에, 일반적인 유닉스, 리눅스 명령어를 사용하는 것 보다는 전문적인 툴을 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그래프를 보면서 추이를 지켜보는 것이 중요한데, 부하를 넣으면 일정 수준이 되어도 시스템들의 &lt;code&gt;CPU&lt;/code&gt;, 메모리, 디스크 등의 기타 자원들은 넉넉한데 네트워크 입력, 출력 수준이 일정 수준 이상으로 올라가지 않는 경우가 있다. 이러한 경우는 네트워크 병목일 가능성이 크다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 소프트웨어 기반의 로드 밸런서 및 소프트웨어 기반의 &lt;code&gt;NAT&lt;/code&gt; 장비에서 많이 발생하는데 이미지와 같은 정적 콘텐츠는 될 수 있으면 &lt;code&gt;CDN&lt;/code&gt;이나 분리된 웹 서버를 이용해서 서비스 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라우는 특히나 소프트웨어기반의 &lt;code&gt;NAT&lt;/code&gt; 및 로드밸런서를 사용해서 문제가 생기는 경우가 많은데, &lt;code&gt;NAT&lt;/code&gt;의 경우에는 여러 개의 &lt;code&gt;NAT&lt;/code&gt;을 사용해서 로드를 분산하도록 하고 로드 밸런서의 경우에도 충분히 용량이 큰 로드 밸런서를 사용하거나 두 개 이상의 로드 밸런서를 사용하고 &lt;code&gt;DNS&lt;/code&gt; 라운드 로빈을 사용하는 방법을 고려해보는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 28 Mar 2021 18:15:49 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 시작했다.&lt;/li&gt;
&lt;li&gt;내가 여태까지 정리했던 글을 보면서, 남에게 이를 설명할 수 있는지 녹화를 해보고 이를 시청하였다.&lt;/li&gt;
&lt;li&gt;다른 곳에 적어두었지만, 미쳐 블로그에 올리지 않은 내용을 정리해서 블로그에 포스팅을 해보았다.&lt;/li&gt;
&lt;li&gt;회의 때 토의했던 내용중에 다르게 해석한 부분이 있었다.&lt;/li&gt;
&lt;li&gt;회의 때 토의했던 내용을 착각한 뒤로 팀원에게 메신저로 내가 했던 일을 공유하고 그 다음에 어떤 일을 진행할 것인지 상세하게 말했다.&lt;/li&gt;
&lt;li&gt;내가 궁금해하는 기업이 어떤 기술을 쓰는지를 분석하기 위해서 그 회사의 기술 블로그 및 세미나 발표 영상을 보면서 공부를 하였다.&lt;/li&gt;
&lt;li&gt;토이 프로젝트를 진행할 때 사용자 관점에서 생각을 하지 못한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112748805-4b6d1200-8ff9-11eb-93b1-24b0b3265418.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 진행할 때 주 마다 사용자는 무엇을 할 수 있는지를 적어야 하는데, 나는 우선 개발이 되지 않았으므로 사용자는 할 수 있는 것이 없다고 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;토이 프로젝트를 하면서 혼자서 많은 일을 하는 것 보다, 다른 사람들에게 일감을 나누고 같이 협업하는 방법을 배우는게 중요하다고 생각했다.&lt;/li&gt;
&lt;li&gt;실제로 설명을 해보면서 내가 제대로 설명하지 못하는 것을 알게 되었고, 실제로 모르고 있었음에도 불구하고 안다고 착각하는 것도 많았다.&lt;/li&gt;
&lt;li&gt;내가 공부한 내용을 포스팅 하면서 다시 복습하니까 몰랐던 부분도 이해가 되고 좋았다. 다만 시간이 너무 많이 들어서 진작 포스팅에 재미를 느꼈으면 어떨까하는 아쉬움도 남는다.&lt;/li&gt;
&lt;li&gt;회의때 집중을 하면서 들어야겠다는 생각이 들었고 조금 많이 부끄러웠다.&lt;/li&gt;
&lt;li&gt;팀원 분들이 좋아하셨고, 내가 어떤 문제를 막혔을 때 내가 진행했던 상황을 이해시키는 시간도 훨씬 빨랐다.&lt;/li&gt;
&lt;li&gt;과거에 그 회사가 고민한 내용을 배울 수 있었고, 현재 어떤 기술을 사용하는지도 익힐 수 있었다.&lt;/li&gt;
&lt;li&gt;하지만, 트레이너분은 사용자에게 어떤 방식으로도 가치를 전달할 수 있는 것이 중요하다고 했고 구글 스프레드를 이용해서 사용자에게 가치를 전달 할 수 있다고 했다. 그 이야기를 듣고 내가 너무 개발자 적인 사고에 갇혀있다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배운 내용을 직접 남에게 설명하듯이 설명해보면서 내가 정말로 알고있는지를 검증하는 법을 배웠다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 보안이 정말로 중요함에도 불구하고 보안에 대해서 소흘히 생각하고 있었다.&lt;/li&gt;
&lt;li&gt;실제 웹 애플리케이션을 만들 때 비즈니스 로직 뿐만 아니라 인프라적인 지식이 중요하다는 것을 깨닫게 되었다. 현재 회사에서 데브옵스 팀이 있다고 해서 인프라적인 지식을 몰라도 되는 것은 아니다 토이프로젝트를 하거나 따로 익히면서 인프라적인 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;브라우저 보안을 위한 다양한 정책을 알게 되었고, 어떠한 에러가 발생하였을 때, 왜 이러한 에러가 발생하였는지 브라우저, 운영체제, 프레임워크 설계자 관점에서 생각을 해봐야겠다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;일을 시작하기전에, 다른 팀원들에게 내가 하려는 일과 했던 일을 공유하자.&lt;/li&gt;
&lt;li&gt;기업을 분석할 때, 그 회사 및 부서에서 작성한 기술 블로그를 살펴보고 세미나에서 발표한 영상을 보면서 분석하면 그 회사에 대해서 자세히 알 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;개발적으로만 문제를 해결하려고 하지 말자. 다양한 방법으로 문제를 해결할 수 있다 중요한 것은 어떤 가치를 줄 수 있는가이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;배우려고 노력했고, 기록하려고 노력했다, 이제는 남에게 쉽게 알려줄 수 있게 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남에게 설명해본적이 별로 없는 것 같다. 이는 나중에 들어오는 사람에게 뭔가를 설명할 때 제대로 설명해주지 못해서 많은 도움을 줄 수 없을 수도 있다. 따라서 지금부터라도 내가 알고 있는 것을 잘 설명할 수 있는 연습을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 정말로 알고 있는지 남에게 설명하면서 이를 검증해보자.&lt;/li&gt;
&lt;li&gt;발표를 평소에 많이 해보고, 혼자서라도 남에게 설명해주듯이 설명하는 연습을 하자.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리플리케이션이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sun, 28 Mar 2021 17:43:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;gelera-리플리케이션&#34;&gt;Gelera 리플리케이션&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113364491-a05caf80-938e-11eb-8a11-e5933db7f28d.png&#34; alt=&#34;Screen Shot 2021-04-02 at 8 36 21 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MariaDB&lt;/code&gt; 클러스터에서, 서버는 트랜잭션과 관련된 쓰기를 클러스터의 모든 노드에 브로드캐스트해서 커밋을 할 때, 모든 노드에 트랜잭션을 복사한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트는 &lt;code&gt;DBMS&lt;/code&gt;에 직접 연결하여 대부분의 경우 기본의 &lt;code&gt;MariaDB&lt;/code&gt;와 유사한 동작을 경험할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wsrep(write set replication API)&lt;/code&gt;를 이용하여 &lt;code&gt;Galera&lt;/code&gt; 리플리케이션과 &lt;code&gt;MariaDB&lt;/code&gt; 사이의 인터페이스를 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;동기-vs-비동기-리플리케이션&#34;&gt;동기 vs 비동기 리플리케이션&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;동기식 복제와 비동기식 복제의 기본적인 차이점은 동기식 복제는 클러스터에서 한 노드에서 변경이 발생한 경우에, 클러스터의 다른 노드에서 동기적으로 변경이 발생한다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비동기적인 복제는 마스터 노드에 변경사항을 적용하는 것과 슬레이브 노드에 변경사항을 전파 하는 도중에 데이터가 다를 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 마스터 노드가 비동기적인 복제 중에 오류가 생기면 변경 사항중에 일부가 손상 될 수 있다는 것을 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 이점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 가용성이 높다.&lt;/li&gt;
&lt;li&gt;노드중에 하나가 손실 되더라도 데이터는 손실되지 않으며 모든 클러스터 노드는 항상 일관적이다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터를 사용하면, 모든 노드에 동시에 트랜잭션을 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;동기식 복제를 사용하는 클러스터는 전체 클러스터에서 인과 관계를 보장할 수 있다. 즉, 클러스터 노드에서 트랜잭션을 실행한 후에 하나의 클러스터 노드에서 &lt;code&gt;SELECT&lt;/code&gt;가 실행되는 경우 해당 트랜잭션의 영향을 확인해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제가 가지는 단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만, 동기식 데이터베이스 복제는 전통적으로 매우 느린것으로 판명된 &lt;code&gt;2PC(two phase commit)&lt;/code&gt;또는 분산 잠금을 통해서 구현되었다.&lt;/li&gt;
&lt;li&gt;동기식 복제의 낮은 성능과 구현의 복잡성으로 인해서 비동기식 복제가 데이터베이스 성능 확장성 및 가용성의 주요 수단으로 사용되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만, &lt;code&gt;Galera&lt;/code&gt;의 리플리케이션은 완전하게 동기화된 것은 아니지만 이것은 가상 동기 리플리케이션이라고 불린다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/about-galera-replication/&#34;&gt;About Galera Replication&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>쿼리 오프 로딩이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sun, 28 Mar 2021 17:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EC%BF%BC%EB%A6%AC-%EC%98%A4%ED%94%84-%EB%A1%9C%EB%94%A9%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>네트워크 메시지 암호화 및 방식 (중간자 공격, HMAC, 대칭, 비대칭 키)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4/</link>
      <pubDate>Sun, 28 Mar 2021 16:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%94%ED%98%B8%ED%99%94-%EB%B0%8F-%EB%B0%A9%EC%8B%9D-%EC%A4%91%EA%B0%84%EC%9E%90-%EA%B3%B5%EA%B2%A9-hmac-%EB%8C%80%EC%B9%AD-%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%82%A4/</guid>
      <description>&lt;h3 id=&#34;네트워크전송-레벨-암호화&#34;&gt;네트워크(전송) 레벨 암호화&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745214-a7c43780-8fe1-11eb-8d75-3bd315668317.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적이고 필수적인 &lt;code&gt;REST API&lt;/code&gt; 보안 방법은 네트워크 전송 프로토콜에서 &lt;code&gt;HTTPS&lt;/code&gt; 보안 프로토콜을 사용하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt; 프로토콜을 사용한다 하더라도, 메세지 자체를 암호화해서 전송하기 때문에 해킹으로 말미암은 메시지 누출 위협을 해소할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 &lt;code&gt;HTTPS&lt;/code&gt;를 사용하더라도 메시지를 낚아 채거나 변조하는 방법이 있는데 이러한 해킹 방법을 바로 중간자 공격 (&lt;code&gt;Man-In-The-Middle-Attack&lt;/code&gt;)이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정상적인 &lt;code&gt;HTTPS&lt;/code&gt; 통신의 경우 다음과 같이 서버에서 제공하는 인증서를 이용하여 API와 서버 상호간에 암호화된 신뢰할 수 있는 새로운 네트워크 연결을 만든다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745283-1bfedb00-8fe2-11eb-8bf1-6c7de2d8fcee.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;중간자 공격의 경우에는 신뢰할 수 있는 연결을 만들려고 할 때 해커가 &lt;code&gt;API&lt;/code&gt; 클라이언트와 서버 사이에 끼어들어 온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;신뢰할 수 있는 연결을 만들고자 서버가 인증서를 클라이언트에 내릴 때 해커가 이 인증서가 아닌 다른 인증서를 클라이언트에게 전달하고, 다른 인증서를 이용하여 &lt;code&gt;API&lt;/code&gt; 클라이언트와 해커간에 HTTPS SSL 연결을 만든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 서버에게서 받은 인증서를 이용해서 서커와 &lt;code&gt;API&lt;/code&gt; 서버 간의 HTTP SSL 연결을 맺는다. 이렇게 되면 해커는 중간에서 API 클라이언트와 서버 사이에 메시지를 모두 열어보고 변조도 가능해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 중간자 공격을 방지하는 방법중에는 여러가지가 있지만, 가장 손쉬운 방법은 공인인증서를 사용하고 인증서를 확인하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공인인증서는 &lt;code&gt;Verisign&lt;/code&gt;과 같은 기관에서 인증서에 대한 공인 인증을 해준다. 즉, 이 인증서를 발급한 사람이 누구인가에 대한 신원 정보를 가지고 있다. 이를 공인 인증서라고 하는데, 공인 인증서는 인증 기관의 서명이 되어 있다. (공인 인증기관이 인증했다는 정보가 암호화 되서 들어간다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해커가 공인인증서를 사용하려면 인증 기관에 가서 개인 정보를 등록해야하고, 자체 발급한 비공인 인증서를 사용하기 때문에 이를 이용해서 체크가 가능하다. 특히 인증서 안에는 인증서를 발급한 기관의 정보와 인증서에 대한 고유 일련번호가 들어가 있기 때문에 클라이언트에서 이 값을 확인해서 내가 발급하고 인증 받은 공인 인증서인지를 점검하도록 하면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메시지-본문-암호화&#34;&gt;메시지 본문 암호화&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;암호화가 필요한 특정 필드만 애플리케이션 단에서 암호화하여 보내는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지를 암호화하여 통신하려면, 클라이언트와 서버가 암호화 키를 가져야하는데, 암호화키는 크게 대칭 키와 비대칭 키 알고리즘 두 가지가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비대칭 키 알고리즘은 암호화를 하는 키와 암호를 푸는 복호화 키가 다른 경우로, 암호화 하는 키를 공개 키(&lt;code&gt;Public Key&lt;/code&gt;)라고 하고, 암호화를 푸는 키를 비밀 키(&lt;code&gt;Private Key&lt;/code&gt;)라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 공개 키는 암호화 할 수 있지만, 반대로 암호화된 메시지는 풀 수 없으므로 누출이 되어도 안전하다. (해커가 중간에서 공개 키를 낚아 챈다하더라도 이 키로는 암호화된 메시지를 복호화할 수 없다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 처음 클라이언트가 서버에 인증이 되었을 때 클라이언트에게 이 공개 키를 내리고, 이 후에 메시지를 이 공개 키를 통해서 암호화를 하게 되면 암호화된 메시지는 비밀키를 가진 서버만이 풀 수 있어서 안전하게 서버로 메시지를 보낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 비대칭 키 알고리즘으로는 &lt;code&gt;RSA&lt;/code&gt; 등이 있으며 익숙한 &lt;code&gt;HTTPS&lt;/code&gt;의 경우에도, 이 &lt;code&gt;RSA&lt;/code&gt; 알고리즘을 사용한다. &lt;code&gt;RSA&lt;/code&gt; 알고리즘을 사용하는 비대칭 키 암호화 로직과 라이브러리등은 공개된 것들이 많으므로 참고해서 사용하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비대칭 키 알고리즘은 클라이언트에서 서버로 보내는 단방향 메시지에 대해서는 암호화하여 사용할 수 있지만, 반대로 서버에서 클라이언트로 내려오는 응답 메시지 등에는 적용하기 어렵다. 아니면 클라이언트가 서버에 등록될 때, 위와 반대 방법으로 클라이언트가 서버로 공개 키를 보내서 향후 서버에서 클라이언트로 통신에 그 공개 키를 사용하도록 해도 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 클라이언트와 서버 그리고 서버와 클라이언트 간의 키 쌍 두개를 관리해야 하기 때문에 복잡할 수 있는데, 이런 때에는 대칭 키 알고리즘을 고려해 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대칭 키 알고리즘은 암호화와 복호화 키가 같은 알고리즘이다. 이 경우 &lt;code&gt;API&lt;/code&gt; 클라이언트와 서버가 같은 키를 알고 있어야 한다. 키를 네트워크를 통해서 보내면 중간에 해커에 의해서 낚아 채일 염려가 있기 때문에, 양쪽에 안전하게 키를 전송하는 방법이 필요하다. 따라서 다음과 같은 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 서버에서 공개 키 KA1과 비공개 키 KA2 쌍을 생성한다.
2. 클라이언트에게 공개 키 KA1을 네트워크를 통해서 내려 보낸다.
3. 클라이언트는 새로운 비공개 대칭 키 KB를 생성하고 KA1을 이용하여 암호화하여 서버로 전송한다.
4. 서버는 전송된 암호화 메세지를 `KA2`로 복호화하여 그 안에 있는 비 공개 키 KB를 꺼낸다.
5. 향후 클라이언트와 서버는 상호 API 통신시 비공개 대칭 키 KB를 이용하여 암호화와 복호화를 진행한다.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;메시지-무결성-보장&#34;&gt;메시지 무결성 보장&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;무결성이란 서버에서 &lt;code&gt;API&lt;/code&gt; 호출을 받았을 때, 이 호출이 신뢰할 수 있는 호출인지 아닌지를 구별하는 방법을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉, 해커가 중간에서 메시지를 가로채고 나서 내용을 변조하여 서버에 보냈을 때 내용이 변조되었는지를 판단하는 방법인데, 일반적으로 &lt;code&gt;HMAC&lt;/code&gt;을 이용한 방식이 널리 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112745861-6c783780-8fe6-11eb-9f69-b693913434ed.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 먼저 클라이언트는 호출하고자 하는 REST API의 메시지를 앞에서 정의한 키를 이용하여 HMAC 알고리즘을 이용하여 해시 값을 추출한다.

2. API를 호출할 때, 메시지에 추출한 HMAC을 포함해서 호출한다.
3. 서버는 호출된 메시지를 보고 HMAC을 제외한 나머지 메시지를 미리 정의된 키를 이용해서 HMAC 알고리즘으로 해시 값을 추출한다.
4. 서버는 3버에서 생성된 HMAC 값과 API 호출시 같이 넘어온 HMAC 갑을 비교해서 값이 같으면 이 호출이 유효한 호출이라고 판단한다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약에 해커가 메시지를 중간에 가로채 변조했을 경우 서버에서 해시를 생성하면 변조된 메시지에 대한 해시가 생성되기 때문에, 클라이언트에서 변조 전에 보낸 해시 값과 달라진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 통해서 메시지 변조의 여부를 판단할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 메시지를 변경하지 않고 해커가 같은 요청을 반복해서 보낸다면 메시지를 변조하지 않았다는 것으로, 서버는 이를 유효한 호출로 인식할 수 있는데 이를 재전송 공격(&lt;code&gt;Reply Attack&lt;/code&gt;)이라고 한다. 따라서 이를 방지하기 위해서는 &lt;code&gt;timestamp&lt;/code&gt;를 이용하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방법은 &lt;code&gt;HMAC&lt;/code&gt;을 생성할 때, 메시지를 이용해서 해시 값을 생성하는 것이 아니라, 타임 스탬프를 포함해서 메시지를 생성하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;API&lt;/code&gt;를 호출할 때 &lt;code&gt;timestamp&lt;/code&gt; 값을 같이 실어 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://service.myapi.com/restapiservice?xxxxx&amp;amp;hmac={hashvalue}&amp;amp;timestamp={호출시간}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이렇게 하면 서버는 메세지가 호출된 시간을 알 수 있고, 호출된 시간 +- 10분(또는 개발자가 정한 시간 폭)만큼의 호출만 정상적인 호출로 인식하고 시간이 지난 호출의 메시지는 비정상적인 호출로 무시하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST API 보안 및 인가 방식</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D/</link>
      <pubDate>Sun, 28 Mar 2021 15:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EA%B0%80-%EB%B0%A9%EC%8B%9D/</guid>
      <description>&lt;h3 id=&#34;권한-인가&#34;&gt;권한 인가&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;인증이 끝나면 다음 단계는 권한에 대한 인증, 즉 인가(&lt;code&gt;Authoriation&lt;/code&gt;) 과정이 필요하다. 사용자가 인증을 받고 로그인을 했더라도, 해당 API를 호출할 수 있는 권한이 있는가를 확인 해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;api-인가-방식&#34;&gt;API 인가 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;권한 인가(Authorization) 방식에는 여러 가지 방식이 있는데, 대표적인 방식 몇 가지만 보면 가장 일반적인 권한 인증 방식으로는 사용자의 역할을 기반으로 하는 &lt;code&gt;RBAC (Role Based Access Control)&lt;/code&gt; 이라는 방식이 있다. 이 방식은 정해진 연결에 권한을 연결해놓고, 이 역할을 가진 사용자에게 해당 권한을 부여하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 &lt;code&gt;API&lt;/code&gt; 권한 인가 체크는 인증(Authentication)이 끝난 후에 인가에 사용된 API Access Token을 이용하여 사용자 정보를 조회하고, 사용자 정보에 연관된 정보(&lt;code&gt;Permission&lt;/code&gt;이나 &lt;code&gt;Role&lt;/code&gt; 정보)를 받아서 이 권한 정보를 기반으로 &lt;code&gt;API&lt;/code&gt; 사용 권한을 인가하는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 권한 검증을 이용하여 &lt;code&gt;API Access Token&lt;/code&gt; 으로 사용자를 찾고 사용자에게 할당된 역할이나 &lt;code&gt;Access Control&lt;/code&gt;을 받아서 &lt;code&gt;API&lt;/code&gt; 인증을 처리할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인가 방식의 종류로는 아래 두 가지 방식이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rbacrole-based-access-control&#34;&gt;RBAC(Role Based Access Control)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744459-3d0ffd80-8fdb-11eb-9300-594cc1bebe93.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;일반 사용자 : 사용자 관리, 게시물 관리, 회원 가입 승인
마스터 관리자 : 카폐 게시판, 관리, 메뉴 관리, 사용자 관리, 게시물 관리, 회원 가입 승인
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위와 같은 권한을 만들고, 사용자에게 &lt;code&gt;마스터 관리자&lt;/code&gt;라는 역할을 부여하면, 사용자는 카페 게시판 관리, 사용자 관리, 게시물 관리, 회원 가입 승인 등의 권한을 가지게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 권한 부여의 대상이 되는 사용자나 그룹을 &lt;code&gt;Object&lt;/code&gt;라고 하고 개별 권한을 &lt;code&gt;Permission&lt;/code&gt; 이라고 정의하며 사용자의 역할을 &lt;code&gt;Role&lt;/code&gt; 이라고 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RBAC&lt;/code&gt;는 이 &lt;code&gt;Role&lt;/code&gt;에 권한을 맵핑한 다음 &lt;code&gt;Object&lt;/code&gt;에 이 &lt;code&gt;Role&lt;/code&gt;을 부여하는 방식으로, 많은 권한 인가는 사용자 역할을 기반으로 하기 때문에 사용하기 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;aclaccess-control-list&#34;&gt;ACL(Access Control List)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744519-c45d7100-8fdb-11eb-8ee7-9f2e073c8752.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RBAC 방식이 권한을 &lt;code&gt;Role&lt;/code&gt;이라는 중간 매개체를 통해서 사용자에게 부여하는데 반해서 ACL 방식은 사용자 (또는 그룹과 같은 권한의 부여 대상) 에게 직접 권한을 부여하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자에게 직접 카페 게시판 관리, 메뉴 관리, 게시물 관리, 회원 가입 승인 권한을 부여하는 방식이 대표적인 &lt;code&gt;ACL&lt;/code&gt;의 예이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;api-권한-인가-처리-위치&#34;&gt;API 권한 인가 처리 위치&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API에 대한 권한 인가 처리는 여러가지 계층에서 처리할 수 있다. 권한 인가는 API를 호출하는 쪽인 클라이언트, API를 실행하는 API 서버, 그리고 API에 대한 중간 길목 역할을 하는 게이트웨이 등 3군데에서 처리할 수 있으며 근래에는 API 서버쪽에서 처리하는 것이 가장 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;권한 인가 위치는 아래와 같은 경우가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클라이언트에-대한-api-권한-인가-처리&#34;&gt;클라이언트에 대한 API 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;를 호출하는 클라이언트 쪽에서 사용자의 권한에 따라서 &lt;code&gt;API&lt;/code&gt;를 호출하는 방식인데, 이 방식은 클라이언트가 신뢰할 수 있는 경우에만 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 기존에 웹 &lt;code&gt;UX&lt;/code&gt; 로직이 서버에 배치된 형태 (스트러츠나 스프링 &lt;code&gt;MVC&lt;/code&gt;와 같은 웹 레이어가 있는 경우)에 주로 사용했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞의 사용자 &lt;code&gt;API&lt;/code&gt;를 예로 들어보면 웹 애플리케이션에서 사용자 로그인 정보(세션 정보와 같은)를 보고 사용자 권한을 조회하고 API를 호출하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 세션에서 사용자 ID와 역할을 본 후에, 역할이 일반 사용자일 경우 세션 내의 사용자 ID와 조회하고자 하는 사용자 ID가 일치하는 경우에만 API를 호출하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112744706-69c51480-8fdd-11eb-83cf-cc16fefd7fb6.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 구조를 사용할 때, 모바일 디바이스 등에 제공하는 API는 사용자 역할을 하는 API와 같이 별도의 권한 인가가 필요 없는 API를 호출하는 구조를 갖는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;게이트웨이에-의한-권한-인가-처리&#34;&gt;게이트웨이에 의한 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 권한 인가는 모바일 클라이언트, 자바스크립트 기반의 웹 클라이언트 등 다양한 클라이언트가 지원됨에 따라서 점차 서버쪽으로 이동하게 되었는데, 특히 자바 스크립트 클라이언트는 클라이언트에서 권한에 대한 인가는 의미가 없어서 어쩔 수 없이 서버 쪽에서 권한 인가 처리를 할 수 밖에 없게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약에 자바스크립트에 권한 인가 로직을 넣은 경우, 브라우저의 디버거로 코드 수정이 가능하기 때문에 권한 처리 로직을 우회할 수도 있고, 또한 &lt;code&gt;API&lt;/code&gt; 포맷만 안다면 직접 &lt;code&gt;API&lt;/code&gt; 서버로 호출해서 권한 인가 없이 API를 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버에서 권한을 처리하는 방법은 &lt;code&gt;API&lt;/code&gt; 호출의 길목이 되는 게이트웨이나 &lt;code&gt;API&lt;/code&gt; 비즈니스 로직 두 군데서 처리할 수 있다. &lt;code&gt;API Gateway&lt;/code&gt;에 의한 권한 처리를 쉽지 않기 때문에 API 서머에서 권한 처리를 하는 것이 일반적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 호출이 들어오면 API 토큰 관리 정보를 이용해서, &lt;code&gt;API Access Token&lt;/code&gt;을 사용자 정보와 권한 정보로 변환하고 접근하고자 하는 &lt;code&gt;API&lt;/code&gt;에 대해서 권한 인가 처리를 한다. 이때는 &lt;code&gt;API&lt;/code&gt; 별로 &lt;code&gt;API&lt;/code&gt;에 접근하고자 하는데 필요한 권한을 확인해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 &lt;code&gt;HTTP GET /users/{:id}&lt;/code&gt;의 API를 예로 들면 이 &lt;code&gt;URL&lt;/code&gt;에 대한 &lt;code&gt;API&lt;/code&gt;를 호출하려면 일반 사용자 권한을 가진 사용자는 호출하는 사용자 &lt;code&gt;ID&lt;/code&gt;와 &lt;code&gt;URL&lt;/code&gt;상의 {id}가 일치할 떄, 호출을 허용하고, 같지 않을 때는 호출을 거절 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 이러한 &lt;code&gt;API Gateway&lt;/code&gt;에서의 권한 인가는 쉽지 않은데, 앞의 &lt;code&gt;/users/{id}&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;의 경우에는 사용자 ID가 &lt;code&gt;URL&lt;/code&gt;에 들어가 있기 때문에 &lt;code&gt;API Access Token&lt;/code&gt;과 맵핑되는 사용자 &lt;code&gt;ID&lt;/code&gt;와 그에 대한 권한을 통해서 &lt;code&gt;API&lt;/code&gt; 접근 권한을 통제할 수 있다. 하지만 &lt;code&gt;API&lt;/code&gt;에 따라서 사용자 아이디나 권한 인증에 필요한 정보가 &lt;code&gt;HTTP&lt;/code&gt; 바디에 &lt;code&gt;JSON&lt;/code&gt; 형태나 &lt;code&gt;HTTP&lt;/code&gt; 헤더 등에 들어가 있는 경우 일일히 메시지 포맷에 따라 별도의 권한 로직을 게이트 웨이 단에서 구현해야 하는 부담이 있고, 권한 통제를 위해서 &lt;code&gt;HTTP&lt;/code&gt; 메시지 전체를 일일히 파싱해야하는 오버로드가 발생하기 때문에 공통 필드 등으로 &lt;code&gt;API&lt;/code&gt; 권한 처리를 하지 않을 때에는 사용하기 어렵다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서버에-의한-api-권한-인가-처리&#34;&gt;서버에 의한 API 권한 인가 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 일반적이고 보편적인 방법은 &lt;code&gt;API&lt;/code&gt; 요청을 처리하는 &lt;code&gt;API&lt;/code&gt;서버의 비즈니스 로직 단에서 권한 처리를 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 앞에서 언급한 &lt;code&gt;API Gateway&lt;/code&gt; 방식과 비교했을 때, 각 비즈니스 로직에서 &lt;code&gt;API&lt;/code&gt; 별로 권한 인가 로직을 구현하기 용이하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 권한 인가에 필요한 필드들을, &lt;code&gt;API Gateway&lt;/code&gt;에서 변환해서 &lt;code&gt;API&lt;/code&gt; 서버로 전달해줌으로써 구현을 간략하게 할 수 있는데, 다음 그림과 같이 &lt;code&gt;API&lt;/code&gt; 클라이언트가 &lt;code&gt;API Access Token&lt;/code&gt;을 이용해서 &lt;code&gt;API&lt;/code&gt;를 호출 했을 경우, &lt;code&gt;API Gateway&lt;/code&gt;가 이 &lt;code&gt;Access Token&lt;/code&gt;을 권한 인가에 필요한 사용자 아이디, 롤 등으로 변환해서 &lt;code&gt;API&lt;/code&gt; 서버에 전달해주게 되면, 각 비즈니스 로직은 &lt;code&gt;API&lt;/code&gt; 권한 인가에 필요한 사용자 정보를 별도의 데이터베이스에서 찾지 않고도 이 헤더의 내용만을 이용해서 API 권한 인가 처리를 할 수 있게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HTTP란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/http%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol)의 약자로서, 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP는 요청(&lt;code&gt;REQUEST&lt;/code&gt;), 응답(&lt;code&gt;RESPONSE&lt;/code&gt;)을 통해서 정보를 주고 받으며, HTTP 메시지 구조는 크게 헤더(&lt;code&gt;HEADER&lt;/code&gt;)와 바디(&lt;code&gt;BODY&lt;/code&gt;)로 나누어진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;curl-명령어를-통한-요청&#34;&gt;CURL 명령어를 통한 요청&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;요청 헤더 및 응답 헤더&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562451-79b14980-9ca9-11eb-9b65-dcee73144654.png&#34; alt=&#34;google&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 &lt;code&gt;curl&lt;/code&gt; 명령어를 통해서 구글 서버에 &lt;code&gt;GET&lt;/code&gt; 요청을 날려보았다.&lt;/li&gt;
&lt;li&gt;요청 헤더 및 응답 헤더를 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;응답 바디&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/114562913-e62c4880-9ca9-11eb-9df8-b399eaa6e1da.png&#34; alt=&#34;response&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;, &lt;code&gt;CSS&lt;/code&gt;, &lt;code&gt;JS&lt;/code&gt; 파일을 응답한 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;웹 서버가 응답하는 파일은 이것이 전부이고, 브라우저에는 응답받은 파일을 통해서 화면에 그려주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>HTTP와 HTTPS의 차이점 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft/</link>
      <pubDate>Sun, 28 Mar 2021 13:18:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/http%EC%99%80-https%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2818&#34;&gt;RFC - 2818&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST API 보안 및 인증 방식</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D/</link>
      <pubDate>Sun, 28 Mar 2021 13:17:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/rest-api-%EB%B3%B4%EC%95%88-%EB%B0%8F-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D/</guid>
      <description>&lt;h3 id=&#34;rest-api-보안&#34;&gt;REST API 보안&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;보안에 관해서는 백번, 천번을 강조해도 과함이 없다.&lt;/li&gt;
&lt;li&gt;근래의 대부분의 서비스 시스템들은 API를 기반으로 통신한다.&lt;/li&gt;
&lt;li&gt;앱과 서버 간의 통신 또는 자바 스크립트 웹 클라이언트와 서버 간 대부분의 통신이 이 API들을 이용해서, 이루어지기 때문에 한번 보안이 뚫리면 개인 정보가 탈취되는 것 뿐만 아니라, 더 많은 문제를 일으킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api-보안-관점-및-개요&#34;&gt;REST API 보안 관점 및 개요&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;인증authentication&#34;&gt;인증(Authentication)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;인증은 누가 서비스를 사용하는지를 확인하는 절차이다.&lt;/li&gt;
&lt;li&gt;쉽게 생각하면 웹 사이트에 사용자 아이디와 비밀번호를 넣어서 사용자를 확인하는 과정이 인증이다.&lt;/li&gt;
&lt;li&gt;API도 마찬가지로 API를 호출하는 대상 (단말이 되었던 다른 서버가 되었던 사용자가 되었건) 확인하는 절차가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112742701-a5ef7980-8fcb-11eb-8813-b50f905cdefe.png&#34; alt=&#34;Screen Shot 2021-03-28 at 1 43 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링 시큐리티에서는 인증을 &lt;code&gt;who are you?&lt;/code&gt; 라고 표현하고 인가를 &lt;code&gt;what are you allow to do?&lt;/code&gt; 라는 문장으로 비유하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;인가authorization&#34;&gt;인가(Authorization)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인가는 해당 리소스에 대해서 사용자가 그 리소스를 사용할 권한이 있는지 확인하는 권한 체크 과정이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서, &lt;code&gt;/users&lt;/code&gt; 라는 리소스가 있을 때, 일반 사용자 권한으로는 내 사용자 권한만 볼 수 있지만, 관리자 권한으로는 다른 사용자 정보를 볼 수 있는 것과 같은 권한의 차이를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;네트워크-레벨-암호화&#34;&gt;네트워크 레벨 암호화&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인증과 인가 과정이 끝나서 API를 호출하게 되면, 네트워크를 통해서 데이터가 오가는데, 해커나 누군가 중간에서 이 네트워크 통신을 낚아채 (감청) 데이터를 볼 수 없게 할 필요가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 네트워크 프로토콜단에서 처리하는 것을 네트워크 암호화라고 하는데, &lt;code&gt;HTTP&lt;/code&gt;에서의 네트워크 암호화는 일반적으로 &lt;code&gt;HTTPS&lt;/code&gt; 기반의 프로토콜을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-무결성-보장&#34;&gt;메시지 무결성 보장&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 무결성이란, 메시지가 해커와 같은 외부 요인에 의해서 중간에 변조가 되지 않게 방지하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무결성을 보장하기 위해서 많이 사용하는 방식은 메시지에 대한 서명(Signature)를 생성해서 메시지와 같이 보내고 검증하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 메시지 문자열이 있을 때, 이 문자열에 대한 해시 코드를 생성해서 문자열과 함께 보내고 이 받은 문자열로 생성한 해시 코드를 문자열과 함께 온 해시 코드와 비교하는 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약에 문자열이 중간에 변조되었으면 원래 문자열과 함께 전송된 해시 코드와 맞지 않기 때문에 메시지가 중간에 변조되었는지 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메시지 무결성의 경우 앞에서 언급한 네트워크 레벨의 암호화를 완벽하게 사용한다면 외부적인 요인(해커)에 의해서 메시지를 해석당할 염려가 없으므로 사용할 필요가 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-본문-암호화&#34;&gt;메시지 본문 암호화&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네트워크 레벨의 암호화를 사용할 수 없거나, 또는 이를 신뢰할 수 없는 상황에서 추가로 메시지 자체를 암호화하는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 애플리케이션 단에서 구현하는데, 전체 메시지를 암호화하는 방법과 특정 필드만 암호화하는 방식 두 가지로 접근할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전체 메시지를 암호화할 경우 암호화에 드는 비용이 많은 뿐더러 중간에 &lt;code&gt;API Gateway&lt;/code&gt;를 통해서 메시지를 열어보고 메시지 기반으로 라우팅 변환 작업이 어렵기 때문에 일반적으로 전체 암호화보다는 보안이 필요한 특정 필드만 암호화하는 방식을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인증authentication-방식의-종류&#34;&gt;인증(Authentication) 방식의 종류&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;에 대한 인증 방식은 여러 가지 방식이 있으며 각 방식에 따라 보안 수준과 구현 난도가 달라서 각 방식의 장단점을 잘 이해하여 서비스 수준에 맞는 적절한 API 인증 방식을 선택하도록 할 필요가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-키-방식&#34;&gt;API 키 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;가장 기초적인 방법은 &lt;code&gt;API&lt;/code&gt; 키를 이용하는 방법이다.&lt;/li&gt;
&lt;li&gt;API 키(Key)란 특정 사용자만 알 수 있는 일종의 문자열이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;를 호출하고자 할 때, 개발자는 &lt;code&gt;API&lt;/code&gt; 제공사의 포탈 페이지에서 &lt;code&gt;API&lt;/code&gt; 키를 발급 받고 API를 호출 할 때 API 키를 메시지 안에 넣어 호출한다.&lt;/li&gt;
&lt;li&gt;서버는 메시지 안에서 API 키를 읽어서 이 API를 누가 호출한 API인지를 인증하는 흐름이다.&lt;/li&gt;
&lt;li&gt;모든 클라이언트가 같은 API 키를 공유하기 때문에, 한번 API 키가 노출되면 전체 API가 뚫려버리는 문제가 있으므로 높은 보안 인증이 필요할 때에는 권장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-토큰-방식&#34;&gt;API 토큰 방식&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743016-a5a4ad80-8fce-11eb-9511-bf6a22147f08.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 토큰(&lt;code&gt;Token&lt;/code&gt;)을 발급하는 방식이 있는데, ID, 비빌번호 등으로 사용자를 인증한 다음에 그 사용자가 API 호출에 사용할 기간이 유효한 API 토큰을 발급해서 API 토큰으로 사용자를 인증하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매번 API 호출 시 사용자 ID, 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자 비밀번호는 주기적으로 바뀔 수 있기 때문이고, 매번 네트워크를 통해서 사용자 ID와 비밀번호를 보내는 것은 보안상 사용자 계정 정보를 탈취당할 가능성이 크기 때문에 API 토큰을 별도로 발급해서 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 토큰을 탈취당하면, &lt;code&gt;API&lt;/code&gt;를 호출할 수는 있지만, 반대로 사용자 ID와 비밀번호는 탈취당하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 비밀번호를 탈취당하면 일반적으로 사용자들은 다른 서비스에도 같은 비밀번호를 사용하는 경우가 많아서 연쇄적으로 공격을 당할 가능성이 커진다. 따라서 이러한 연쇄적인 피해를 최소화 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림을 보면 다음과 같은 형태로 인증이 이루어진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;API 클라이언트가 사용자 ID, 비밀번호를 보내서 API 호출을 위한 API 토큰을 요청한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;API 인증 서버는 사용자 ID, 비밀번호를 바탕으로 사용자를 인증한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;인증된 사용자에 대해서 API 토큰을 발급한다 (유효시간을 가지고 있다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;API 클라이언트는 이 API 토큰으로 API를 호출한다. API 서버는 API 토큰이 유효한지를 API 토큰 관리 서버에 문의하고 API 토큰이 유효하면 API 호출을 받아들인다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;보안-수준에-따른-사용자-인증-방식&#34;&gt;보안 수준에 따른 사용자 인증 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;http-basic-auth&#34;&gt;HTTP Basic Auth&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743145-bc97cf80-8fcf-11eb-9784-08fb6ffbd620.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 기본적이고 단순한 형태의 인증 방식으로, 사용자 ID와 비밀번호를 가지고, HTTP 헤더에 &lt;code&gt;Base64&lt;/code&gt; 인코딩 형태로 넣어서 인증을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어서 사용자 ID가 &amp;ldquo;terry&amp;quot;이고 비밀번호가 &amp;ldquo;hello world&amp;rdquo; 일 때 다음과 같이 &lt;code&gt;HTTP&lt;/code&gt; 헤더에 &amp;ldquo;terry: hello world&amp;rdquo; 라는 문자열을 &lt;code&gt;Base64&lt;/code&gt; 인코딩을 해서 &lt;code&gt;Authorization&lt;/code&gt; 라는 이름의 헤더로 서버에 전송하여 인증을 요청한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Authorization: Basic ZG9uZ3dvb2s6cGFzc3dvcmQ=
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743286-f0272980-8fd0-11eb-9871-dc55b2ee30f2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음은 Base64 인코딩을 도와주는 사이트이다. &lt;a href=&#34;https://www.base64decode.org/&#34;&gt;https://www.base64decode.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;중간에 패킷을 가로채서 이 헤더를 Base64로 디코딩하면 사용자 ID와 비밀번호가 그대로 노출되기 때문에, 반드시 &lt;code&gt;HTTPS&lt;/code&gt; 프로토콜을 사용해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;digest-access-authentication&#34;&gt;Digest Access Authentication&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP Basic Auth가 Base64 형태로 비밀번호를 실어서 보내는 단점을 보강하여 나온 인증 프로토콜이 &lt;code&gt;Digest Access Authentication&lt;/code&gt; 이라는 방법으로, 기본 원리는 클라이언트가 인증을 요청할 때, 클라이언트가 서버로부터 &lt;code&gt;nonce&lt;/code&gt; 라는 일종의 난수 값을 받고 (클라이언트와 서버가 이 난수 값을 알 고 있다.) 사용자 ID와 비밀번호를 이 난수 값을 이용해서 해시화하여 서버로 전송하는 방식&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우에는 직접 ID와 비밀번호가 평문 형태로 날아가지 않기 때문에, 해커가 중간에 비밀번호를 탈취할 수 없고, 설령 &lt;code&gt;HASH&lt;/code&gt; 알고리즘을 알고 있다고 하더라도 해시된 값에서 반대로 비밀번호를 추출하기가 어려워서 &lt;code&gt;Basic Auth&lt;/code&gt; 방식보다 향상된 보안을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743403-f23db800-8fd1-11eb-9e18-ce8415bf64d9.gif&#34; alt=&#34;digest-auth1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;흐름은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 서버에 특정 리소스를 요청한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;서버는 해당 세션에 대한 &lt;code&gt;nonce&lt;/code&gt; 값을 생성하여 저장하고, 클라이언트에게 반환한다. 이때 &lt;code&gt;realm&lt;/code&gt;을 같이 반환하는데, &lt;code&gt;realm&lt;/code&gt;은 인증의 범위로, 예를 들어 웹 서버에 car.war, market.war가 각각 &lt;code&gt;http://myweb/car&lt;/code&gt;, &lt;code&gt;http://myweb/market&lt;/code&gt;이라는 &lt;code&gt;URL&lt;/code&gt;로 배포되었다고 하면, 이 웹사이트는 각각 애플리케이션 &lt;code&gt;car.war&lt;/code&gt;와 &lt;code&gt;market.war&lt;/code&gt;에 대해서 서로 다른 인증 &lt;code&gt;realm&lt;/code&gt;을 가진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;클라이언트는 앞에서 서버로 부터 받은 &lt;code&gt;realm&lt;/code&gt;과 &lt;code&gt;nonce&lt;/code&gt; 값으로 해시 값을 생성하는데 다음을 통해서 응답 해시 값을 생성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HA1 = MD5(사용자 이름:realm:비밀번호)
HA2 = MD5(HTTP method:HTTP URL)
  response hash = MD5(HA1:nonce:HA2)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;서버는 3번에서 전달된 &lt;code&gt;nonce&lt;/code&gt; 값을 이 세션을 위해서 서버에 저장된 &lt;code&gt;nonce&lt;/code&gt; 값과 같은지 비교를 한 후, 전달된 사용자 이름인 &lt;code&gt;terry&lt;/code&gt;와 &lt;code&gt;nonce&lt;/code&gt;값 그리고 서버에 저장된 사용자 비밀번호를 이용해서 같은 3번과 같은 방식으로 해시 값을 계산하여 클라이언트에서 전달된 해시 값과 같은지를 비교한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클라이언트-인증-추가&#34;&gt;클라이언트 인증 추가&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;추가적인 보안 강화를 위해서 사용자 인증 뿐만 아니라, 클라이언트 인증 방식을 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;페이스북은 API 토큰을 발급 받도록 사용자 ID, 비밀번호 뿐만 아니라, &lt;code&gt;Client ID&lt;/code&gt;와 &lt;code&gt;Client Secret&lt;/code&gt;이라는 것을 같이 입력받도록 하는데, &lt;code&gt;Client ID&lt;/code&gt;는 특정 앱에 대한 등록 ID이고 &lt;code&gt;Client Secret&lt;/code&gt;은 특정 앱에 대한 비밀번호로, 앱을 등록하면 앱 별로 발급되는 일종의 비밀번호이다.&lt;/li&gt;
&lt;li&gt;API 토큰을 발급 받을 때, Client ID와 Client Secret을 이용하여 클라이언트 앱을 인증하고, 사용자 ID와 비밀번호를 추가적으로 받아서 사용자를 인증하여 API 액세스 토큰을 발급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ip-화이트-리스트를-이용한-터널링&#34;&gt;IP 화이트 리스트를 이용한 터널링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 API를 호출하는 클라이언트의 API가 일정하다면 사용할 수 있는 손쉬운 방법인데, 서버 간의 통신이나 타사 서버와 자사 서버 간의 통신 같은 경우에 API 서버는 특정 API URL에 대해서 들어오는 IP 주소를 화이트 리스트로 유지하는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 서버 앞단에 &lt;code&gt;HAProxy&lt;/code&gt;나 &lt;code&gt;Apache&lt;/code&gt;와 같은 웹 서버를 배치하여서 특정 URL로 들어올 수 있는 IP 목록을 제한하거나 아니면 전체 &lt;code&gt;API&lt;/code&gt;가 특정 서버와의 통신에만 사용된다면 아예 하드웨어 방화벽 자체에 들어올 수 있는 IP 목록을 제한할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설정만으로 가능한 방법이기 때문에, 서버간의 통신이 있을 때 적용할 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bi-directional-certification-mutual-ssl&#34;&gt;Bi-directional Certification (Mutual SSL)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보통은 &lt;code&gt;HTTPS&lt;/code&gt; 통신을 할 때, 서버에 공인 인증서를 놓고 단방향으로 &lt;code&gt;SSL&lt;/code&gt;을 제공하는데, &lt;code&gt;Bi-directional Certification&lt;/code&gt; (양방향 인증서 방식) 방식은 클라이언트에도 인증서를 놓고 양방향으로 &lt;code&gt;SSL&lt;/code&gt;을 제공하면서 &lt;code&gt;API&lt;/code&gt; 호출에 대한 인증을 클라이언트의 인증서를 이용하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구현 방법이 가장 복잡한 방식이기는 하지만, 공인 기관에서 발생된 인증서를 사용한다면 &lt;code&gt;API&lt;/code&gt;를 호출하는 쪽의 신원을 확실하게 할 수 있고 메세지까지 암호화되기 때문에, 가장 높은 수준의 인증을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 인증 방식은 일반 서비스에서는 사용되지 않으며 높은 인증 수준을 제공하는 몇몇 서비스나 특정 서버 통신에 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;제-3자-인증-방식-oauth-20-authorization-grant-type&#34;&gt;제 3자 인증 방식 (OAuth 2.0 Authorization grant type)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;제 3자 인증 방식은 페이스북이나, 구글, 트위터 같은 API 서비스 제공자들이 인증을 대신 해주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743810-704f8e00-8fd5-11eb-8a83-905f69044f67.jpg&#34; alt=&#34;maxresdefault&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;claim-기반의-jwt-방식&#34;&gt;Claim 기반의 JWT 방식&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Claim 기반 토큰의 개념&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OAuth&lt;/code&gt;에 의해서 발급되는 &lt;code&gt;access_token&lt;/code&gt;은 랜덤 문자열로, 토큰 자체에는 특별한 정보를 가지고 있지 않은 일반적인 스트링 형태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;access_token&lt;/code&gt;을 통해서 사용자와 연관된 정보를 구별하여 이를 허용해주는 구조인데, 서버 입장에서는 토큰을 가지고 그 토큰과 연관된 정보를 서버 쪽에서 찾아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 &lt;code&gt;JWT&lt;/code&gt;는 &lt;code&gt;Claim&lt;/code&gt; 기반이라는 방식을 사용하는데, &lt;code&gt;Claim&lt;/code&gt;은 사용자에 대한 프로퍼티나 속성을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토큰 자체가 정보를 가지는 방식인데, &lt;code&gt;JWT&lt;/code&gt;는 이 클레임을 &lt;code&gt;JSON&lt;/code&gt;을 이용해서 정리한다. 아래와 같은 형태로 표현된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;id&amp;quot;: &amp;quot;terry&amp;quot;,
  &amp;quot;role&amp;quot;: &amp;quot;[&amp;quot;admin&amp;quot;, &amp;quot;user&amp;quot;]&amp;quot;,
  &amp;quot;company&amp;quot;: &amp;quot;pepsi&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에, 다른 곳에서 가져올 필요가 없다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112743985-0d5ef680-8fd7-11eb-955b-80b7a9778016.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;결과적으로 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며, 토큰을 사용하는 &lt;code&gt;API&lt;/code&gt; 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;는 이 &lt;code&gt;JSON Claim&lt;/code&gt;을 &lt;code&gt;Base64&lt;/code&gt;로 인코딩하여 &lt;code&gt;HTTP&lt;/code&gt; 헤더에 쉽게 넣을 수 있으며, &lt;code&gt;JSON&lt;/code&gt; 기반이기 때문에 파싱과 사용이 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결과적으로 &lt;code&gt;Claim&lt;/code&gt; 기반의 토큰은 토큰 자체가 정보를 담음으로써 토큰으로 서비스나 &lt;code&gt;API&lt;/code&gt; 접근을 제어할 때, 별도의 작업이 서버에서 필요하지 않으며, 토큰 자체를 서버에서 관리할 필요가 없어서 구현이 상대적으로 단순해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;jwt의-단점&#34;&gt;JWT의 단점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;길이 : &lt;code&gt;Claim&lt;/code&gt;에 넣는 데이터가 많아질 수록 &lt;code&gt;JWT&lt;/code&gt; 토큰의 길이가 길어진다. &lt;code&gt;API&lt;/code&gt; 호출에 사용할 시에 호출마다 헤더에 붙어서 가야하기 때문에 길이가 길다는 것은 그만큼 네트워크 대역폭 낭비가 심하다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한번 발급된 토큰은 값을 수정하거나 폐기가 불가 : &lt;code&gt;JWT&lt;/code&gt;는 토큰 내에 모든 정보를 다 가지고 있기 때문에 한 번 발급된 토큰에 대한 변경은 서버에서는 더는 불가능하다. 예를 들어서, 토큰을 잘못 발행해서 삭제하고 싶더라도 서명만 맞으면 맞는 토큰으로 인식하기 때문에 서버에서는 한번 발급된 토큰의 정보를 바꾸는 일이 불가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 만약 &lt;code&gt;JWT&lt;/code&gt;를 사용한다면 만료 시간(&lt;code&gt;Expire Time&lt;/code&gt;)을 꼭 명시적으로 두도록 하고 &lt;code&gt;Refresh Token&lt;/code&gt;등을 이용하여 중간마다 토큰을 재발행하도록 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;암호화 : &lt;code&gt;JWT&lt;/code&gt;는 기본적으로 &lt;code&gt;Claim&lt;/code&gt;에 대한 정보를 암호화하지 않는다, 단순히 &lt;code&gt;Base64&lt;/code&gt;로 인코딩만 하기 때문에, 중간에 패킷을 가로채거나 기타 방법으로 토큰을 취득했으면 토큰 내부 정보를 통해서 사용자 정보가 노출될 가능성이 있다. 따라서 이를 보완하는 방법으로 토큰 자체를 암호화하는 방법이 있고, &lt;code&gt;JSON&lt;/code&gt;을 암호화하기 위한 스펙으로는 &lt;code&gt;JWE&lt;/code&gt;가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://grooveshark.tistory.com/25&#34;&gt;https://grooveshark.tistory.com/25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bcho.tistory.com/955&#34;&gt;https://bcho.tistory.com/955&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7617&#34;&gt;RFC - 7617&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>나만의 지도 시스템을 만드는데 유용한 도구 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft/</link>
      <pubDate>Sun, 28 Mar 2021 10:45:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/28/%EB%82%98%EB%A7%8C%EC%9D%98-%EC%A7%80%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94%EB%8D%B0-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-draft/</guid>
      <description>&lt;h3 id=&#34;지도-시스템을-만드는데-추천하는-도구&#34;&gt;지도 시스템을 만드는데, 추천하는 도구&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;지도 시스템을 만드는데 추천하는 도구들은 다음과 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우선 프론트엔드로는, &lt;a href=&#34;https://leafletjs.com/&#34;&gt;Leaflet&lt;/a&gt;, &lt;a href=&#34;https://openlayers.org/&#34;&gt;Openlayers&lt;/a&gt;, &lt;a href=&#34;https://geoext.org/&#34;&gt;GeoExt&lt;/a&gt;, &lt;a href=&#34;https://turfjs.org/&#34;&gt;Turf.js&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;벡엔드로는 &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/contrib/gis/&#34;&gt;GEODjango&lt;/a&gt;, &lt;a href=&#34;http://geoserver.org/&#34;&gt;GeoServer&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스는 &lt;a href=&#34;https://postgis.net/&#34;&gt;PostGIS&lt;/a&gt;를 많이 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터는 &lt;a href=&#34;https://qgis.org/ko/site/&#34;&gt;QGIS&lt;/a&gt;, &lt;a href=&#34;https://mapshaper.org/&#34;&gt;Mapshaper&lt;/a&gt; 등이 있고, 데이터소스로는 &lt;a href=&#34;https://www.openstreetmap.org/#map=7/35.948/127.736&#34;&gt;OpenStreetMap&lt;/a&gt;을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/swlh/tools-i-recommend-for-building-geospatial-web-applications-274d6939536c&#34;&gt;Tools I recommend for building Geospatial Web Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스토리지 티어링이란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft/</link>
      <pubDate>Sat, 27 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%8B%B0%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;스토리지-티어링이란&#34;&gt;스토리지 티어링이란&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 27 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네이버 기술 블로그를 대략적으로 보면서, 시스템 성능 분석 및 디버깅을 통해서 객관적인 자료를 수집하는 것을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발을 잘하기 위해서는 호기심을 가지고 실험을 많이 해보고, 이를 확인할 수 있는 디버깅 툴을 많이 알아두고 적재 적소에 사용할 수 있어야겠다.&lt;/li&gt;
&lt;li&gt;나도 네트워크 패킷을 분석하면서 문제점을 빠르게 찾고 개선해나갈 수 있는 개발자가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 도구 및 성능 측정 도구를 많이 사용해봐야겠다. 그리고 평소에 궁금했던 것들을 모두 테스트 해볼 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그냥 귀찮다고 문서나 눈으로만 보고 넘어가지 말고, 실제로 테스트를 해보고 이를 도구로 증명하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;궁금했던 점들을 직접 확인할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>인코딩과 캐릭터 셋의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Sat, 27 Mar 2021 17:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%BA%90%EB%A6%AD%ED%84%B0-%EC%85%8B%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>&lt;p&gt;최근에 인코딩과 캐릭터 셋의 차이를 아는지에 대한 질문을 받았고, 제대로 답변하지 못한 기억이 난다. 따라서 이 두개의 차이점 및 추가적인 궁금증에 대해서 조사를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112772028-8c9d0a80-9069-11eb-85a4-adb185619b6b.png&#34; alt=&#34;Screen Shot 2021-03-29 at 8 33 54 AM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;유니코드와-utf-8-utf-16은-무엇이-다른가&#34;&gt;유니코드와 &lt;code&gt;UTF-8&lt;/code&gt;, &lt;code&gt;UTF-16&lt;/code&gt;은 무엇이 다른가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;유니코드는 문자 집합으로, 문자 집합만 의미하며, 실제로 저장되는 방식(바이트로 맵핑)에 대해서는 아무런 설명을 하지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16 은 문자열 또는 바이트 배열에서 바이트로 문자를 맵핑하는 방법을 정의하는 인코딩이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8, UTF-16, UTF-32는 기본적으로 일부 문자를 인코딩하는데, 사용되는 바이트의 양이 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTF-8은 ASCII에 정의된 문자에 대해서 1바이트를 사용하고, 다른 문자에 대해서는 2~4 사이의 바이트를 사용합니다. UTF-32는 각 문자에 대해서 4바이트를 지속적으로 사용하므로 문자열의 문자에 대한 반복은 사소한 것이지만 공통 문자열의 경우에는 더 많은 공간을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;캐릭터-셋과-인코딩의-차이점&#34;&gt;캐릭터 셋과 인코딩의 차이점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;캐릭터 셋은 단순히 특정 인코딩으로 나타낼 수 있는, 문자의 집합을 의미한다.&lt;/li&gt;
&lt;li&gt;예를 들면, &amp;lsquo;☯&amp;rsquo; 같은 문자는 유니코드 문자 집합과 다른 문자 집합에도 사용할 수 있다. 하지만 이 문자에 대한 인코딩을 서로 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Unicode character: ☯
UTF-8 encoded: 0xE2 0x98 0xAF
UTF-16 encoded: 0x26 0x2F
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kore-nordmann.de/blog/php_charset_encoding_FAQ.html#what-is-the-difference-between-a-charset-and-an-encoding&#34;&gt;what is the difference between a charset and an encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST 및 베스트 프랙티스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</link>
      <pubDate>Sat, 27 Mar 2021 17:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/rest-%EB%B0%8F-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4/</guid>
      <description>&lt;h3 id=&#34;rest&#34;&gt;REST&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 웹의 창시자 중의 한 사람인 로이 필딩이 2000년에 발표한 논문에 의해서 처음 소개되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 아키텍처가 웹의 장점을 잘 활용하지 못하고 있다고 판단했기 때문에 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개했는데 그것이바로 &lt;code&gt;Representational Safe Transfer(REST)&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 근래에 들어 &lt;code&gt;HTTP&lt;/code&gt;와 &lt;code&gt;JSON&lt;/code&gt;을 함께 사용하여 OPEN API를 구현하는 방법으로 주류를 이루고 있으며, 대부분의 &lt;code&gt;OPEN API&lt;/code&gt;는 이 &lt;code&gt;REST&lt;/code&gt; 아키텍처를 기반으로 설계 및 구현되고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-기본&#34;&gt;REST의 기본&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;REST는 크게 리소스, 메서드, 메시지의 3가지 요소로 구성된다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &amp;ldquo;이름이 Terry인 사용자를 생성했을 때&amp;rdquo; 사용자는 생성되는 리소스, 생성한다라는 행위는 메서드 그리고, 이름이 &lt;code&gt;Terry&lt;/code&gt;는 메시지가 된다.&lt;/li&gt;
&lt;li&gt;이를 REST로 표현해보면 다음과 같은 형태가 된다, &amp;lsquo;생성한다&amp;rsquo;라는 의미가 있는 메서드는 &lt;code&gt;HTTP&lt;/code&gt; &lt;code&gt;POST&lt;/code&gt;가 되고, 생성하고자 하는 대상이 되는 사용자라는 리소스는 &lt;code&gt;http://myweb/users&lt;/code&gt;라는 형태의 URI로 표현되며, 생성하고자 하는 사용자의 구체적인 내용은 &lt;code&gt;JSON&lt;/code&gt; 문서를 이용하여 표현된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;users&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;http-메서드&#34;&gt;HTTP 메서드&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;행위에 대한 메서드는 HTTP 메서드를 그대로 사용한다.&lt;/li&gt;
&lt;li&gt;HTTP에는 여러가지 메서드가 있지만, &lt;code&gt;REST&lt;/code&gt;에서는 &lt;code&gt;CRUD(CREATE, READ, UPDATE, DELETE)&lt;/code&gt;에 해당하는 4가지의 메서드만 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112715716-53f41880-8f25-11eb-96a0-52dc9613dc36.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;멱등성은 여러 번 수행해도 결과가 같은 경우를 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 연산은 리소스를 추가하는 연산이기 때문에, 멱등성을 성립하지 않지만, 나머지 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;는 반복수행하더라도, 멱등하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;의 경우 게시물의 조회 카운트를 늘려준다거나 하는 기능을 같이 수행했을 때는 멱등하지 않은 메서드로 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REST&lt;/code&gt;는 개별 &lt;code&gt;API&lt;/code&gt;를 상태 없이 수행하게 된다, 따라서 해당 &lt;code&gt;REST&lt;/code&gt; API를 다른 API와 함께 호출하다가 실패했을 때 트랜잭션 복구를 위해서 다시 실행해야하는 경우가 있는데, 멱등하지 않은 메서드의 경우에는 기존 상태를 저장했다가 다시 원상 복구시켜줘야 하는 경우가 있지만, 멱등한 메서드의 경우에는 반복적으로 다시 메서드를 수행하면 된다.&lt;/li&gt;
&lt;li&gt;멱등성을 충족하지 않는 메서드에 대해서는 트랜잭션에 대한 처리에 주의가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-리소스&#34;&gt;REST의 리소스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 리소스 지향 아키텍처 스타일이라는 정의 답게 모든 것을 리소스, 즉 명사로 표현하며, 각 세부 리소스에는 &lt;code&gt;ID&lt;/code&gt;를 붙인다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스가 명사의 형태를 띄우다 보니 명령 성격의 API를 정의하는데 혼동이 올 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동사형을 명사형으로 바꿔서 적용해보면 리소스 형태로 표현하기가 조금 더 수월해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api의-간단한-예제&#34;&gt;REST API의 간단한 예제&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;사용자 생성&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;name&amp;quot;:&amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;:&amp;quot;seoul&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP GET, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;업데이트&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP PUT, http://myweb/users/terry 
{
  &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;,
  &amp;quot;address&amp;quot;: &amp;quot;suwon&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;삭제&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP DELETE, http://myweb/users/terry
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;상당히 간단하다, 단순하게 리소스를 URI로 정해주고, 거기에 HTTP 메서드를 이용해서 CRUD를 구현하고 메세지를 &lt;code&gt;JSON&lt;/code&gt;으로 표현하여 &lt;code&gt;HTTP&lt;/code&gt; 바디에 실어서 보내면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; 에 리소스 ID가 없다는 것을 빼면 크게 신경쓸 부분이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest의-특성&#34;&gt;REST의 특성&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;유니폼-인터페이스uniform-interface&#34;&gt;유니폼 인터페이스(Uniform Interface)&lt;/h4&gt;
&lt;p&gt;REST는 HTTP 표준에만 따른다면 어떤 기술이든지 사용할 수 있는 인터페이스 스타일이다. 예를 들어, HTTP + JSON으로 REST APII를 정의했다면, 안드로이드 플랫폼이건 IOS 플랫폼이건 특정 언어나 기술에 종속받지 않고, HTTP와 JSON을 모든 플랫폼에서 사용할 수 있는 느슨한 결합이다.&lt;/p&gt;
&lt;h4 id=&#34;무상태성스테이트리스stateless&#34;&gt;무상태성/스테이트리스(Stateless)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt;는 Representational State Transfer의 약어로 Stateless(상태를 유지하지 않음)란ㄴ 특징을 가진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태가 있다 없다는 사용자나 클라이언트의 컨텍스트를 서버에 유지하지 않는다는 의미로, 쉽게 표현하면 HTTP 세션과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메시지로 처리하면 되며, 세션과 같은 컨텍스트 정보를 신경쓸 필요가 없으므로 구현이 단순해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;캐시-가능cacheable&#34;&gt;캐시 가능(Cacheable)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 큰 특징 중에 하나는 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 프로토콜 기반의 로드 밸런서나 SSL은 물론이고, HTTP가 가진 가장 강력한 기능중에 하나인 캐싱 기능을 적용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 시스템에서 &lt;code&gt;60%&lt;/code&gt;에서 많게는 &lt;code&gt;80%&lt;/code&gt; 가량의 트랜잭션이 &lt;code&gt;SELECT&lt;/code&gt;와 같은 조회성 트랜잭션인 것을 고려하면, &lt;code&gt;HTTP&lt;/code&gt;의 리소스들은 웹 캐시 서버 등에 캐싱하는 것은 용량이나 성능 면에서 많은 장점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 HTTP 프로토콜 표준에서 사용하는 &lt;code&gt;Last-Modified&lt;/code&gt; 태그나 &lt;code&gt;E-Tag&lt;/code&gt;를 이용하면 캐싱을 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다음과 같이 클라이언트가 HTTP GET을 &lt;code&gt;Last-Modified&lt;/code&gt; 값과 함께 보냈을 때 콘텐츠에 변화가 없으면 &lt;code&gt;REST&lt;/code&gt; 컴포넌트는 &lt;code&gt;304 Not Modified&lt;/code&gt;를 반환하며 클라이언트는 자체 캐시에 저장된 값을 사용하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112716331-0d082200-8f29-11eb-95d1-21b0a40accbe.png&#34; alt=&#34;267E914554241E6512&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이렇게 캐시를 사용하게 되면 네트워크 응답 시간뿐만 아니라, &lt;code&gt;REST&lt;/code&gt; 컴포넌트가 위치한 서버에 트랜잭션을 발생시키지 않기 때문에 전체 응답 시간과 성능 그리고 자원 사용률을 비약적으로 향상시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;자체-표현-구조self-descriptiveness&#34;&gt;자체 표현 구조(Self-descriptiveness)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 가장 큰 특징중의 하나는 REST API 자체가 쉬워서 API 메시지만 보고도 이를 이해할 수 있는 자체 표현 구조로 되어 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리소스와 메서드를 이용해서, 어떤 메서드에 무슨 행위를 하는지 알 수 있으며, 또한 메시지 포맷 역시 JSON을 이용해서 직관적으로 이해할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 REST 기반 Open API가 API 문서를 제공하고는 있지만, 디자인 사상은 최소한의 문서의 도움만으로 API 자체를 이해할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;클라이언트-서버-구조client-server&#34;&gt;클라이언트 서버 구조(Client-Server)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST 서버는 API를 제공하고 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임 진다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 각자의 역할이 확실하게 구분되면서 개발 관점에서 클라이언트와 서버에서 개발해야 할 내용이 명확해지고, 서로의 개발에서 의존성이 줄어들게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;계층형-구조layered-system&#34;&gt;계층형 구조(Layered System)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트로서는 REST API 서버만 호출한다. 그러나 서버는 다중 계층으로 이루어질 수 있다.&lt;/li&gt;
&lt;li&gt;순수 비즈니스 로직을 수행하는 &lt;code&gt;API&lt;/code&gt; 서버와 그 앞단에 사용자 인증(Authentication), 암호화(SSL), 로드 밸런싱을 하는 계층을 추가해서 구조상의 유연성을 둘 수 있다.&lt;/li&gt;
&lt;li&gt;이는 마이크로서비스의 API GATEWAY나 간단한 기능은 리버스 프록시를 이용해서 구현하는 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-안티-패턴&#34;&gt;REST 안티 패턴&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;다음은 REST API를 디자인할 때 하지 말아야 할 것들이다.&lt;/p&gt;
&lt;h4 id=&#34;getpost를-이용한-터널링&#34;&gt;GET/POST를 이용한 터널링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 나쁜 디자인 중에 하나가 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 메서드의 실제 동작은 리소스를 업데이트 하는 내용인데, HTTP PUT을 사용하지 않고, GET에 쿼리 파라미터로 이 메서드가 수정 메서드임을 표시하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대단히 안좋은 디자인인데, &lt;code&gt;HTTP&lt;/code&gt; 메서드 사상을 따르지 않았기 때문에 REST라고 부를 수 없고, 또한 웹 캐시 인프라도 사용할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 많이 사용하는 안좋은 예는 &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다. 생성 요청이 아닌데도 바디에 명령을 넘겨서 호출하는 방식인데 좋지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP POST, http://myweb/users/
{
  &amp;quot;getuser&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;terry&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;self-descriptiveness-속성을-사용하지-않음&#34;&gt;Self-descriptiveness 속성을 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REST의 특성 중 하나는 자체 표현 구조로, REST URI와 메서드, 그리고 정의된 메시지 포맷에 의해서 쉽게 API를 이해할 수 있는 기능이 되어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히나 자체 표현 구조를 갉아 먹는 가장 대표적인 사례가 앞서 언급한 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;를 이용한 터널링이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-응답-코드를-사용하지-않음&#34;&gt;HTTP 응답 코드를 사용하지 않음&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음으로 많이 하는 실수가 HTTP 응답 코드를 충실하게 따르지 않고, 성공은 200, 실패는 500 같이 1 ~ 2개의 HTTP 응답 코드만 사용하는 경우이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심한 경우에는 에러도 &lt;code&gt;200&lt;/code&gt; 응답 코드와 함께 보내는 경우인데, 이는 &lt;code&gt;REST&lt;/code&gt; 디자인 사상에도 어긋남은 물론이고 자기 표현 구조에도 어긋난다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rest-api-디자인-가이드&#34;&gt;REST API 디자인 가이드&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;단순하고-직관적으로-만들어라&#34;&gt;단순하고 직관적으로 만들어라&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;URI에 리소스명은 동사보다는 명사를 사용하라.&lt;/li&gt;
&lt;li&gt;REST API는 리소스에 대해서, 행동을 정의하는 형태를 사용한다.&lt;/li&gt;
&lt;li&gt;예를 들어서, &lt;code&gt;/dogs&lt;/code&gt;는 리소스를 생성하라는 의미고, URL은 HTTP 메서드에 의해서 CRUD(생성, 수정, 수정, 삭제)의 대상이 되는 개체(명사)라야 한다.&lt;/li&gt;
&lt;li&gt;그리고 될 수 있으면 단수형 명사보다는 복수형 명사를 사용하는 것이 의미상 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;리소스-간의-관계를-표현하는-방법&#34;&gt;리소스 간의 관계를 표현하는 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;REST 리소스 간에는 연관 관계가 있을 수 있다.&lt;/li&gt;
&lt;li&gt;예를 들어서 사용자가 소유한 디바이스 목록이나, 사용자가 가진 강아지들이 예가 될 수 있다.&lt;/li&gt;
&lt;li&gt;사용자 - 디바이스 또는 사용자 - 강아지 등 각각의 리소스 간의 관계를 표현하는 방법에는 여러가지가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1. 서브 리소스로 표현하는 방법
/&amp;quot;리소스명&amp;quot;/&amp;quot;리소스 아이디&amp;quot;/&amp;quot;관계가 있는 다른 리소스명&amp;quot;
HTTP GET, /users/{userId}/devices
예) /users/1/devices
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;2. 서브 리소스에 관계를 명시하는 방법
HTTP GET, /users/{userid}/likes/devices
예) /uesrs/1/likes/devices
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;에러-처리&#34;&gt;에러 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러 처리의 기본은 &lt;code&gt;HTTP&lt;/code&gt; 응답 코드를 사용한 후 응답 바디(&lt;code&gt;Response Body&lt;/code&gt;)에 에러에 대한 자세한 내용을 서술하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대표적인 &lt;code&gt;API&lt;/code&gt; 서비스들이 어떤 응답 코드를 사용하는지를 살펴보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글 : &lt;code&gt;200, 201, 304, 400, 401, 403, 404, 409, 410, 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;넷플릭스 : &lt;code&gt;200, 201, 304, 400, 403, 404, 412, 500&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 응답 코드를 사용하면 명시적이긴 하지만, 코드 체계 관리가 복잡해져서 다음과 같이 몇 가지 응답 코드만 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;200 - 성공
400 Bad Request - field validation 실패 시
401 Unauthorized - API 인증, 인가 실패
404 Not Found - 해당 리소스가 없음
500 Internal Server Error - 서버 에러
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에러에는 에러 내용에 대한 구체적인 내용을 HTTP 바디에 정의해서 상세한 에러의 원인을 전달하는 것이 디버깅에 유리하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Twillo&lt;/code&gt;의 에러 메시지 형식은 다음과 같은데, 에러 코드 번호와 이 번호에 대한, &lt;code&gt;Error dictionary link&lt;/code&gt;를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자나 트러블 슈팅하는 사람에게 많은 정보를 제공해서 디버깅을 손쉽게 해주는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에러 발생시에 스택 정보를 포함시킬 수 있지만, 이는 대단히 위험한 일이다. 내부적인 코드 구조와 프레임워크 구조를 외부에 노출함으로써, 해커들에게 해킹을 할 수 있는 정보를 제공해주기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 서비스 구조에서는 이를 제공하지 않는 것이 일반적이지만 내부 개발중이거나 서비스 개발할 때는 매우 유용하다. 따라서 API 서비스를 개발할 때 프로덕션과 데브 환경을 분리해서 개발하면 디버깅에 매우 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;api-버전-관리&#34;&gt;API 버전 관리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 정의에서 중요한 것은 버전 관리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이미 배포된 API 경우에는 계속해서 서비스를 제공하면서 새로운 기능이 들어간 API를 배포할 때는 하위 호환성을 보장하면서 서비스를 제공해야하기 때문에, 같은 &lt;code&gt;API&lt;/code&gt;라도 버전에 따라서는 다른 기능을 제공하도록 하는 것이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 버전을 정의하는 방법에는 여러가지가 있는데, 다음과 같은 형태를 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{servicename}/{version}/{REST URL}
예) api.server.com/account/v2.0/groups
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이는 서비스의 배포 모델과 관계가 있는데, 자바 애플리케이션의 경우 &lt;code&gt;account.v1.0.war&lt;/code&gt;, &lt;code&gt;account.v2.0.war&lt;/code&gt;와 같이 다른 &lt;code&gt;war&lt;/code&gt;로 각각 배포하여 버전별로 배포 바이너리를 관리할 수 있고, 앞단에 서비스명을 별도로 &lt;code&gt;URL&lt;/code&gt;로 떼어 놓은 것은 서비스가 확장되었을 때, &lt;code&gt;account&lt;/code&gt; 서비스만 별도의 서버로 분리해서 배포하는 경우를 대비하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;페이징&#34;&gt;페이징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;큰 사이즈의 리스트 형태의 응답을 처리하려면 페이징 처리와 부분 응답(Partial Response) 처리가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반환되는 리스트가 &lt;code&gt;100,000,000&lt;/code&gt; 개인데, 이를 하나의 HTTP 응답으로  처리하는 것은 서버 성능, 네트워크 비용도 문제지만, 무엇보다 비현실적이다. 그래서 페이징을 고려하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;페이징을 처리하려면 여러가지 디자인이 있다. 예를 들어서 100번째부터 125번째 레코드까지 받는 API를 정의하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이스북 API 스타일 : &lt;code&gt;/record?offset=100&amp;amp;limit=25&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;트위터 API 스타일 : &lt;code&gt;/record?page=5&amp;amp;rpp=25&lt;/code&gt; (RPP는 Record Per Page)로 페이지 당 레코드 수로 RPP=25이면 페이지 5는 100~125가 된다.&lt;/li&gt;
&lt;li&gt;링크드인 API 스타일 : &lt;code&gt;/record?start=50&amp;amp;count=25&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;부분-응답-처리&#34;&gt;부분 응답 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리소스에 대한 응답 메시지에 대해서 굳이 모든 필드를 포함할 필요는 없다.&lt;/li&gt;
&lt;li&gt;예를 들어서 페이스북 피드에는 사용자 ID, 이름, 글, 내용, 날짜, 좋아요, 카운트, 댓글, 사용자 사진 등 여러가지 정보를 갖는데, API를 요청하는 클라이언트의 용도에 따라서 선별적으로 몇 가지 필드만이 필요할 수 있다.&lt;/li&gt;
&lt;li&gt;필드를 제한하는 것은 전체 응답의 양을 줄여서 네트워크 대역폭 (특히 모바일에서) 절약할 수 있고, 응답 메시지를 간소화하여 파싱 등을 간략화 할 수 있다.&lt;/li&gt;
&lt;li&gt;이러한 부분 응답 기능을 제공하는 주요 서비스를 보면 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;링크드인 : /people:(id, first-name, last-name, industry)
페이스북 : /terry/friends?fields=id, name
구글 : ?fields=title, media:group(media:thumnail)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;검색-전역-검색과-지역-검색&#34;&gt;검색 (전역 검색과 지역 검색)&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;검색은 &lt;code&gt;HTTP&lt;/code&gt; GET에서 쿼리 스트링 검색 조건을 정의하는 경우가 일반적인데, 이 경우 검색 조건이 다른 쿼리 스트링이랑 섞여 버릴 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, &lt;code&gt;name=lee&lt;/code&gt; 이고 &lt;code&gt;region=seoul&lt;/code&gt;인 사용자를 검색하는 검색을 쿼리 스트링만 사용하게 되면 다음과 같이 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/users?name=lee&amp;amp;region=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;추가적으로 페이징 처리를 추가하면 다음과 같이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?name=cho&amp;amp;region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;페이징 처리에 의해서 정의된 offset과 limit 가 검색조건인지 페이징 조건인지 잘 분간이 가지 않으므로 따라서 쿼리 조건은 하나의 쿼리 스트링으로 정의하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/user?q=name=lee, region=seoul&amp;amp;offset=20&amp;amp;limit=10
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이런식으로 구분자를 사용하면, 검색 조건은 다른 쿼리스트링과 분리된다.&lt;/li&gt;
&lt;li&gt;물론 이 검색 조건은 서버에 의해서 토큰 단위로 파싱 되어야 한다.&lt;/li&gt;
&lt;li&gt;다음으로는 검색 범위에 대해서 고민할 필요가 있는데, 전역 검색은 전체 리소스에 대한 검색을, 리소스에 대한 검색은 특정 리소스에 대한 검색을 정의한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어서 특정 리소스 안에 대한 검색은 다음과 같이 리소스명에 쿼리 조건을 붙이는 식으로 표현할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/users?q=id=seoul
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;전역 검색은 다음과 같은 식으로 정의할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/search?q=id=lee
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hateoas를-이용한-처리&#34;&gt;HATEOAS를 이용한 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;HATEOS는 &lt;code&gt;Hypermedia as the engine of application data&lt;/code&gt;의 약자로 하이퍼미디어의 특징을 이용하여, &lt;code&gt;HTTP&lt;/code&gt; 응답에 다음 액션이나 관계된 리소스에 대한 &lt;code&gt;HTTP&lt;/code&gt; 링크를 함께 반환하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  [
    {
      &amp;quot;id&amp;quot;: &amp;quot;user1&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;terry&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: &amp;quot;user2&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;carry&amp;quot;
    }
  ],
  &amp;quot;links&amp;quot;: [
    {
      &amp;quot;rel&amp;quot;: &amp;quot;pre_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=6&amp;amp;limit=5&amp;quot;
    },
    {
      &amp;quot;rel&amp;quot;: &amp;quot;next_page&amp;quot;,
      &amp;quot;href&amp;quot;: &amp;quot;http://xxx/users?offset=11&amp;amp;limit=5&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이징 처리의 경우 반환 시 페이지에 대한 링크를 제공하거나, 위와 같이 표현하거나 연관된 리소스에 대한 디테일한 링크를 표시하는 것에 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HATEOAS&lt;/code&gt;를 API에 적용하게 되면, 자체 표현 구조 특성이 증대되어 API에 대한 가독성이 증가하는 장점을 가지고 있는데 반해서, 응답 메시지가 다른 리소스 &lt;code&gt;URI&lt;/code&gt;에 대한 의존성을 가지기 때문에 구현이 다소 까다롭다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단일-api-엔드-포인트-활용&#34;&gt;단일 API 엔드 포인트 활용&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 서버가 물리적으로 분리된 여러 개의 서버에서 작동하고 있을 때, &lt;code&gt;user.apiserver.com&lt;/code&gt;, &lt;code&gt;car.apiserver.com&lt;/code&gt;과 같이 API 서버마다 URL이 분리되어 있으면 개발자가 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매번 다른 서버로 연결해야 하거나와 중간에 방화벽이라도 있으면 일일히 이를 해제해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 서비스는 물리적으로 서버가 분리되어 있더라도 단일 URL을 사용하는 것이 좋은데, 방법은 &lt;code&gt;HAProxy&lt;/code&gt;와 &lt;code&gt;Reverse Proxy&lt;/code&gt;를 사용하는 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/user/&lt;/code&gt;는 user.apiserver.com으로 라우팅하고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;api.apiserver.com/car/&lt;/code&gt;는 car.apiserver.com으로 라우팅하도록 구현하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 할 경우 향후 뒷단에 API 서버 들이 확장되도라도 &lt;code&gt;API&lt;/code&gt;를 사용하는 클라이언트로서는 단일 엔드포인트를 보면 되고, 관리 관점에서도 단일 엔드 포인트를 통해서 부하 분산 및 로그를 통해서 감사(Audit)을 할 수 있기 때문에 편리하며, API에 대한 라우팅을 Reverse Proxy를 이용해서 함으로써 조금 더 유연한 운영이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>리버스 프록시란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>메시지 교환 패턴이란(MESSAGE EXCHNAGE PATTERN)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern/</link>
      <pubDate>Sat, 27 Mar 2021 14:47:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B5%90%ED%99%98-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80message-exchnage-pattern/</guid>
      <description>&lt;h2 id=&#34;비동기-메시지-패턴&#34;&gt;비동기 메시지 패턴&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;비동기 메시지 패턴은 앞서 살펴보았듯이 중간에 큐를 두어서 구현하기 때문에, 여러 가지 메시지 전달 패턴을 구현할 수 있다. 몇 가지 대표적인 패턴에 대해서 알아보자.&lt;/p&gt;
&lt;h3 id=&#34;fire--forgot-패턴&#34;&gt;Fire &amp;amp; Forgot 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 사용하는 패턴 중에 가장 일반적인 비동기 호출 패턴으로, 클라이언트가 호출한 후 큐에 메시지가 제대로 들어갔을면 메시지의 처리 결과에 관계없이 응답을 기다리지 않고 바로 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;큐에 저장된 메시지는 비즈니스 컴포넌트에 의해서 나중에 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;publish--subscribe-패턴&#34;&gt;Publish &amp;amp; Subscribe 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐에 구독자를 등록하면 클라이언트에서 보낸 하나의 메시지가 등록된 모든 구독자에게 전달이 되어서 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 : N 관계의 비동기 처리를 구현하고자 할 때 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;JMS&lt;/code&gt;의 &lt;code&gt;Topic&lt;/code&gt;이 이에 해당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;routing-패턴&#34;&gt;Routing 패턴&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112854564-f14b7a00-90e8-11eb-8463-8e0152c7a3c6.png&#34; alt=&#34;0_gFwb04MsfqtVB5bY&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;라우팅 패턴은 큐에 저장된 메시지를 조건에 따라서, 특정 비즈니스 컴포넌트로 라우팅 하는 기능이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Pub/Sub&lt;/code&gt; 처럼 큐에 여러 개의 비즈니스 컴포넌트가 붙기는 하지만, 특정 메시지는 조건에 따라서 특정 비즈니스 컴포넌트 한 개에만 전달 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;콜백-패턴&#34;&gt;콜백 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;메시지 큐를 이용한 비동기 패턴은 클라이언트가 메시지 처리에 대한 응답을 받을 수 없다고 설명했었는데, 예외적으로 콜백 패턴을 사용하면 메시지 처리에 대한 응답을 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트가 요청을 보내서, 메시지 큐에 저장한 후에 &lt;code&gt;CallBack&lt;/code&gt; 패턴도 다른 비동기 패턴과 마찬가지로 응답을 기다리지 않고 다음 로직을 진행한다. (그래야지 비동기 패턴이므로)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 컴포넌트에서 처리가 끝나면 서버는 다시 클라이언트에 처리가 끝났다는 응답과 함께 처리 결과 (&lt;code&gt;Response&lt;/code&gt;) 메시지를 콜백으로 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이때 클라이언트가 응답 메시지가 올 때까지 기다리는 것이 아니라 비즈니스 로직을 수행하고 있기 때문에, 서버가 응답 메시지를 보내면 이벤트 핸들러 방식에 의해서 응답 메시지를 처리하는 이벤트 핸들러를 호출하여 응답 메시지를 처리하도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;콜백 방식의 호출은 응답 메시지를 받기 위해서, 몇 가지 부가적인 정보가 필요한데, 콜백 주소와 &lt;code&gt;Correlation ID&lt;/code&gt; 라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;콜백 주소는 서버가 메시지를 다 처리하고 난 후에 클라이언트로 응답을 보낼 때 사용하는 클라이언트의 IP 주소와 포트이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 &lt;code&gt;Correlation ID&lt;/code&gt; 라는 것이 특이한데, 클라이언트에서 10개의 요청을 서버에 보냈다고 가정하면, 서버가 메시지를 처리한 후에 콜백을 이용하여 응답을 보내면 해당 응답 메시지가 10개의 요청중 어느 요청에 대한 응답인지 식별할 수 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이를 식별하기 위해서 요청을 할 때, &lt;code&gt;Corrleation ID&lt;/code&gt;를 같이 실어 보낸후 응답에 이 &lt;code&gt;ID&lt;/code&gt;를 다시 실어서 보내게 된다. 따라서 콜백 응답 메시지가 어느 요청에 대한 응답 메시지인지를 식별할 수 있게 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rabbitmq.com/getstarted.html&#34;&gt;MEP 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>아키텍처란 무엇인가?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</link>
      <pubDate>Sat, 27 Mar 2021 14:23:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</guid>
      <description>&lt;h3 id=&#34;아키텍처란-무엇인가&#34;&gt;아키텍처란 무엇인가?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;아키텍처에 대한 정의는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;아키텍처는 비즈니스 요구사항을 만족하는 시스템을 구축하기 위해서 전체 시스템에 대한 구조를 정의한 문서로, 시스템을 구성하는 컴포넌트와 그 컴포넌트 간의 관계, 그리고 컴포넌트가 다루는 정보(데이터)를 정의한다&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;아키텍처-설계-프로세스&#34;&gt;아키텍처 설계 프로세스&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아키텍처 설계 방법론은 여러 가지가 있으나, 주로 사용되는 프레임워크로는 &lt;code&gt;Zachman&lt;/code&gt;, &lt;code&gt;TOGAF&lt;/code&gt;, &lt;code&gt;Federal Enterprise Architecture&lt;/code&gt;등이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 이러한 전통적인 방법론은 학문적이고, 그 깊이가 매우 깊어서 일반적인 개발자들이 실무에 적용하기가 매우 어렵다. 따라서 &lt;code&gt;TOGAF&lt;/code&gt;를 경량화한 프로세스를 정의하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;먼저 비즈니스 요구사항을 기반을 한 아키텍처를 정의한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;비즈니스 아키텍처란 구현하고자 하는 소프트웨어의 기능, 시장 상황, 로드맵 등 기능 보다는 비즈니스 관점에서의 소프트웨어를 정의한 모델이다. 주로 요구사항 정의서나 시장 조사서를 기반으로 이를 요약해서 정리해놓은 것을 비즈니스 아키텍처라고 한다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;설계 원칙을 정의한다. 아키텍처 설계 중 여러가지 옵션이 나왔을 때, 의사 결정의 기초가 되는 것으로, 시스템의 설계 사상에 해당한다. 이 아키텍처 설계 원칙과 비즈니스 아키텍처를 기반으로 기술적인 시스템 아키텍처를 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 아키텍처는 관점에 따라서 소프트웨어 코드로 구성되는 애플리케이션 아키텍처, 하드웨어 등 인프라에 대한 테크니컬 아키텍처, 웹 서버 데이터베이스 구성 등에 관련되는 솔루션 아키텍처와 데이터 저장 구조를 기술하는 데이터 아키텍처로 구분된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;아키텍처 설계 과정 중 의사 결정이 필요한 경우에는 앞서 언급한 아키텍처 설계 원칙을 기반으로 하여, 내부적인 의사결정 프로세스에 따른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SOA, 모놀리틱, 그리고 MSA 아키텍처</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
      <pubDate>Sat, 27 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/soa-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-msa-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid>
      <description>&lt;h3 id=&#34;soa&#34;&gt;SOA&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOA(Service Oriented Architecture)는 1990년대에 정의되어, 2008년에 유행했던 아키텍처 스타일이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 서버 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 많은 영향을 받았고 많은 분산 아키텍처가 거의 이 &lt;code&gt;SOA&lt;/code&gt; 사상에 기인한다고 해도 될 만큼 중요한 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;soa의-기본-개념&#34;&gt;SOA의 기본 개념&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112712065-4f713500-8f10-11eb-9b36-a603fccd7e3d.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SOA&lt;/code&gt;란 기존 애플리케이션들의 기능을 비즈니스적인 의미가 있는 기능 단위로 묶고, 표준화된 호출 인터페이스를 통해 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을 서로 조합(&lt;code&gt;Orchestration&lt;/code&gt;)하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존의 시스템이 각각 독립된 업무 시스템으로 개발되어왔던 반면에 &lt;code&gt;SOA&lt;/code&gt;는 기업의 전체 업무가 하나의 거대한 &lt;code&gt;SOA&lt;/code&gt; 시스템으로 구성이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 시스템의 기능들을 업무를 기준으로 주요 기능들로 묶어서 플랫폼에 독립적인 인터페이스(예를 들어 &lt;code&gt;XML/HTTP&lt;/code&gt;, &lt;code&gt;CORBA&lt;/code&gt;, &lt;code&gt;SOAP&lt;/code&gt;)를 구현하여 외부 서비스로 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇게 제공된 서비스 이벤트를 조합하여, 새로운 기능을 개발할 때, 시스템을 신규 개발하는 것이 아니라, 기존에 제공된 서비스들을 조합하여 하나의 업무를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;수직적 분할(Vertical Slicing) : 수직적 분할이란 애플리케이션을 여러 개의 서비스로 나누고 각각의 서비스를 독립적으로 개발하는 것을 말한다. 따라서 각 서비스간의 의존성이 최소화 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;표준 인터페이스 기반(Has Standard Interface) : 서비스가 제공하는 인터페이스는 표준 기술로 구현되어야 한다. 서비스를 사용하고자 하는 사람이 &amp;lsquo;서비스 규약&amp;rsquo; 만을 가지고도 해당 서비스를 호출 할 수 있어야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;느슨한 결합(Loosely Coupled) : 수직적 분할에서도 설명하였듯 각 서비스 컴포넌트들은 다른 서비스에 대해서 의존성이 최소화되어 있어서 서비스의 구현 내용을 변경하였을 때 다른 서비스는 이에 거의 영향을 받지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조합 가능(Composable) : 서비스형 컴포넌트들은 서로 연결되어 하나의 조합된 형태의 애플리케이션을 구성해야하기 때문에, 서비스 간에 연결 및 조합이 가능해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;모놀리틱-아키텍처&#34;&gt;모놀리틱 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713152-1b4d4280-8f17-11eb-8529-5f69c0d9b17b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마이크로 서비스 아키텍처를 이해하려면 먼저 모놀리틱 아키텍처 스타일에 대해서 이해해야한다.&lt;/li&gt;
&lt;li&gt;모놀리틱 아키텍처 스타일은 기존의 전통적인 웹 시스템 개발 스타일로, 하나의 애플리케이션 내에 모든 로직이 들어가있는 &amp;lsquo;통짜 구조&amp;rsquo;이다.&lt;/li&gt;
&lt;li&gt;각 컴포넌트는 상호 호출을 함수를 이용한 참조에 의한 호출 구조를 취한다.&lt;/li&gt;
&lt;li&gt;전체 애플리케이션을 하나로 처리하기 때문에 개발 도구에서 하나의 애플리케이션만 개발하면 되고, 배포 역시 간편하며 테스트도 하나의 애플리케이션만 수행하면 되므로 간편하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;문제점&#34;&gt;문제점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;작은 크기의 애플리케이션에서는 유리하지만, 규모가 큰 애플리케이션에서는 불리한 점이 많다.&lt;/li&gt;
&lt;li&gt;크기가 커서 빌드 및 배포시간, 서버의 가동 시간이 오래 걸린다.(서버 가동에만 2시간까지 걸리는 경우도 있다)&lt;/li&gt;
&lt;li&gt;시스템 컴포넌트들이 서로 로컬 콜 기반으로 타이트하게 연결되어 있으므로, 전체 시스템의 구조를 제대로 파악하지 않고 개발을 진행하면 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향을 주게 된다.&lt;/li&gt;
&lt;li&gt;이러한 문제를 해결하려면 개발자가 대략적인 전체 시스템의 구조를 이해햐야하는데 시스템의 구조가 커질 수록 이해하기 힘들다.&lt;/li&gt;
&lt;li&gt;특정 컴포넌트를 수정할 때, 컴포넌트 재배포 시 수정된 컴포넌트만 재배포 하는 것이 아니라 전체 애플리케이션을 재컴파일해서 전체를 다시 통을 재배포 해야한다.&lt;/li&gt;
&lt;li&gt;이 때문에 잦은 배포가 있는 시스템은 불리하며 컴포넌트 별로 기능/비기능에 특성에 맞춰서 다른 기술을 도입하고자 할 때 유연하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처&#34;&gt;마이크로 서비스 아키텍처&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처(MSA)는 근래의 웹 기반 분산 시스템의 디자인에 많이 반영되어 있는 스타일로, 특정 사람이 정의한 아키텍처가 아니라 분산 웹 시스템과 비슷한 구조로 설계 되면서 개념적으로만 존재하던 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 대용량 웹 서비스가 많아짐에 따라 정의된 아키텍처인데, 그 근간은 &lt;code&gt;SOA(Service Oriented Architecture)&lt;/code&gt;에 두고 있다. &lt;code&gt;SOA&lt;/code&gt;가 엔터프라이즈 시스템을 중심으로 고안된 아키텍처라면, 마이크로 서비스 아키텍처는 &lt;code&gt;SOA&lt;/code&gt; 사상에 근간을 두고, 대용량 웹 개발 서비스 개발에 맞는 구조로 사상이 경량화 되고 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍처이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스&#34;&gt;서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처에서는 각 컴포넌트를 서비스라는 개념으로 정의한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스는 데이터부터 비즈니스 로직까지 독립적으로 상호 컴포넌트 간의 의존성 없이 개발된 컴포넌트 (이를 수직 분할이라고 함)로, REST API 같은 표준 인터페이스로 그 기능을 개발한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 경계는 구문 또는 도메인 (업무)의 경계를 따른다. 예를 들어 사용자 관리, 상품 관리, 주문 관리와 같이 업무별로 서비스를 나눠서 정의해도 사용자/사품 관리 처럼 여러개의 업무를 동시에 하나의 서비스로 섞어서 정의하지는 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;msa-아키텍처-구조&#34;&gt;MSA 아키텍처 구조&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713447-6b78d480-8f18-11eb-8af4-a41448e23a94.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;배포 구조 관점에서도 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성 없이 독립적으로 배포된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;확장을 위해서 서비스가 배치된 톰캣 인스턴스는 횡적으로 스케일(인스턴스를 더함으로써)이 가능하고, 앞단에 로드 밸런서를 배치하여 서비스 간의 로드를 분산 시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션 로직을 분리해서 여러 개의 애플리케이션으로 나눠서 서비스화하고 서비스 별로 톰캣을 분산 배치한 것이 가장 큰 특징이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터-분리&#34;&gt;데이터 분리&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713617-80099c80-8f19-11eb-864a-e539715b08a5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터 저장 관점에서는 중앙 집중화된 하나의 데이터베이스를 사용하는 것이 아니라, 서비스 별로 별도의 데이터베이스를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스의 종류 자체를 다른 데이터베이스로 사용할 수도 있지만, 같은 데이터베이스를 사용하더라도 &lt;code&gt;DB&lt;/code&gt;를 나누는 방법을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 경우 다른 컴포넌트에 대한 의존성 없이 서비스를 독립적으로 개발 및 배포 / 운영 할 수 있다는 장점을 가지고 있으나, 다른 컴포넌트의 데이터를 API 통신을 통해서 가지고 와야하므로, 성능상의 문제를 일으킬 수 있고, 또한 이 기종 데이터베이스 간의 트랜잭션을 묶을 수 없다는 문제점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-gateway&#34;&gt;API GATEWAY&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처 설계에서 가장 많이 언급되는 컴포넌트 중에 하나가 &lt;code&gt;API GATEWAY&lt;/code&gt;라는 컴포넌트이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;는 마치 프록시 서버처럼 &lt;code&gt;API&lt;/code&gt;들 앞에서 모든 &lt;code&gt;API&lt;/code&gt;에 대한 엔드 포인트를 통합하고, 몇 가지 추가적인 기능을 제공하는 미들웨어로, 다음과 같은 기능을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;엔드-포인트-통합-및-토폴로지-정리&#34;&gt;엔드 포인트 통합 및 토폴로지 정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처의 문제점 중 하나는 각 서비스가 다른 서버에 분리, 배포 되기 때문에 API의 엔드포인트, 즉 서버의 URL이 각기 다르다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자 컴포넌트는 &lt;code&gt;http://user.server.com&lt;/code&gt;, 상품 컴포넌트는 &lt;code&gt;http://product.server.com&lt;/code&gt;과 같은 분리된 URL을 사용하는데 이는 API 사용자 경험 관점에서도 사용하기 불편하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 마이크로 서비스 아키텍처는 될 수 있으면 컴포넌트를 업무 단위로 잘게 자르는 작은 덩어리(&lt;code&gt;Fine Grained&lt;/code&gt;)의 서비스를 지향하기 때문에, 컴포넌트의 &lt;code&gt;URL&lt;/code&gt;수는 더 많이 늘어날 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112713879-d1fef200-8f1a-11eb-8f72-eb90fa0360e9.png&#34; alt=&#34;t1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 토폴로지의 문제점을 해결하기 위해서, 중앙에 서비스 버스와 같은 역할을 하는 채널을 배치 시켜서 전체 토폴로지를 &lt;code&gt;Hub &amp;amp; Spoke&lt;/code&gt; 방식으로 변화시켜서 서비스 간 호출을 단순화 시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;오케스트레이션-orchestration&#34;&gt;오케스트레이션 (Orchestration)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여러 개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 포인트 적립과 물품 구매라는 서비스가 있을 때, 이 두 개의 서비스를 묶어서 &amp;lsquo;물품 구매 시 포인트 적립&amp;rsquo; 이라는 새로운 서비스를 만들어 낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 오케스트레이션 기능은 &lt;code&gt;API Gateway&lt;/code&gt;를 통해서 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;공통-기능-처리cross-cutting-function-handling&#34;&gt;공통 기능 처리(Cross Cutting Function Handling)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;에 대한 인증(&lt;code&gt;Authentication&lt;/code&gt;)이나 로깅과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API GATEWAY&lt;/code&gt;에서 이러한 공통 기능을 처리하게 되면, API 자체는 비즈니스 로직에만 집중하여 개발중에 발생할 수 있는 중복을 방지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;중재mediation&#34;&gt;중재(Mediation)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;이외에도 &lt;code&gt;XML&lt;/code&gt;이나 네이티브 메시지 포맷을 &lt;code&gt;JSON&lt;/code&gt;으로 상호 변환해주는 메시지 변환 기능이나 프로토콜을 변환하는 기능, 서비스 간의 메시지를 라우팅해주는 여러 가지 고급 중재 기능을 제공하지만, &lt;code&gt;API GATEWAY&lt;/code&gt;를 최대한 가볍게 가져간다는 설계 원칙 아래에서 될 수 있으면 고급 중재 기술을 사용할 때는 높은 설계와 기술적인 노하우를 동반해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배포&#34;&gt;배포&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;마이크로서비스의 큰 장점중에 하나가 바로 유연한 배포 모델이다.&lt;/li&gt;
&lt;li&gt;각 서비스가 다른 서비스와 물리적으로 완벽하게 분리되기 때문에, 변경이 있는 서비스 부분만 부분 배포가 가능하다.&lt;/li&gt;
&lt;li&gt;예를 들어, 사용자 관리 서비스 로직이 변경되었을 때, 모놀리틱 아키텍처는 전체 시스템을 재배포해야하지만, 마이크로 서비스 아키텍처는 변경이 있는 사용자 관리 서비스 부분만 재배포하면 되기 때문에 전체 시스템의 영향을 최소화한 수준에서 빠르게 배포를 진행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;확장성&#34;&gt;확장성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서비스 별로 독립된 배포 구조는 확장성에서도 많은 장점이 있는데, 부하가 많은 특정 서비스에 대해서만 확장할 수 있어서 조금 더 유연한 확장 모델을 가져갈 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모노리틱 아키텍처는 특정 서비스의 부하가 많아서 성능 확장이 필요할 때 전체 서버의 수를 늘리거나 각 서버의 &lt;code&gt;CPU&lt;/code&gt; 숫자를 늘려줘야 하지만, 마이크로 서비스 아키텍처는 부하를 많이 받는 서비스 컴포넌트만 확장시켜주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이크로-서비스-아키텍처의-문제점&#34;&gt;마이크로 서비스 아키텍처의 문제점&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;성능&#34;&gt;성능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모놀리틱 아키텍처는 하나의 프로세스 내에서, 서비스 간의 호출에 참조 호출 모델을 이용하지만, 마이크로서비스 아키텍처는 서비스 간의 호출을 &lt;code&gt;API&lt;/code&gt; 통신을 이용하기 때문에, 값을 &lt;code&gt;JSON&lt;/code&gt;이나 &lt;code&gt;XML&lt;/code&gt;에서 프로그래밍에서 사용하는 데이터 모델(자바 객체)로 변환하는 마샬링 오버헤드가 발생하고 호출을 위해서 이 메시지들이 네트워크를 통해서 전송되기 때문에 그 만큼 시간이 많이 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;테스팅이-어려움&#34;&gt;테스팅이 어려움&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 서비스들이 분리되어 있고, 다른 서비스에 대한 종속성을 가지고 있어서, 특정 사용자 시나리오나 기능을 테스트하고자 할 경우 여러 서비스에 걸쳐서 테스트를 진행해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 때문에 테스트 환경 구축이나, 문제 발생시에 분리된 여러 개의 시스템을 동시에 봐야 하기 때문에 테스팅의 복잡도가 올라간다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;서비스간-트랜잭션-처리&#34;&gt;서비스간 트랜잭션 처리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현상의 가장 어려운 점 중에 하나가 바로 트랜잭션 처리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 해결하기 위한 방법으로 SAGA 패턴이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Choreography SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714624-7df60c80-8f1e-11eb-80f9-071d84562006.png&#34; alt=&#34;0_mcZ5UcSdTd4RvlnH&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하나의 큰 트랜잭션으로 묶지 않고, 각 서비스의 작업을 트랜잭션 단위로 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 서비스의 이벤트에 의해서 처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Orchestrator SAGA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112714669-ada51480-8f1e-11eb-84f8-516e4d291a38.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트를 통해서가 아니라, 각 서비스를 관리하는 &lt;code&gt;Orchestration&lt;/code&gt; 클래스가 직접 처리하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 패턴에서처럼 메시지 이벤트를 사용하지 않고 동기식 &lt;code&gt;API&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a&#34;&gt;Event Driven Architecture란?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=54438883&#34;&gt;대용량 아키텍처와 성능 튜닝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jjeongil.tistory.com/1100&#34;&gt;MSA - SAGA 패턴&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>네이버 페이 배송 모듈 아키텍처 및 사용기술 분석</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D/</link>
      <pubDate>Sat, 27 Mar 2021 10:31:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EB%84%A4%EC%9D%B4%EB%B2%84-%ED%8E%98%EC%9D%B4-%EB%B0%B0%EC%86%A1-%EB%AA%A8%EB%93%88-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EA%B8%B0%EC%88%A0-%EB%B6%84%EC%84%9D/</guid>
      <description>&lt;p&gt;많은 양의 트래픽을 감당하고 어떻게 고가용성의 시스템을 구축하는지 알아보기 위해서 네이버 기술 블로그 및 세미나를 보면서 사용하는 기술을 분석하고 어떤 고민을 하고 있는지 살펴보았다.&lt;/p&gt;
&lt;h3 id=&#34;네이버-페이가-고민했던-문제점&#34;&gt;네이버 페이가 고민했던 문제점&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;https://tv.naver.com/v/16970002&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112708898-58560c80-8ef8-11eb-8cbf-63e2c05e0c08.png&#34; alt=&#34;Watch the video&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위에 있는 기술 세미나 영상을 보면서, 기존에 네이버 페이에서 발생했던 문제점들과 이를 해결하기 위한 기술들을 살펴볼 수 있었다.&lt;/p&gt;
&lt;h4 id=&#34;네이버-페이에서-유저와-상호-작용하는-서비스&#34;&gt;네이버 페이에서 유저와 상호 작용하는 서비스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;스마트 스토어에 보이는 주문형 페이&lt;/li&gt;
&lt;li&gt;배달의 민족에 연동되어 있는 결제형 페이&lt;/li&gt;
&lt;li&gt;송금&lt;/li&gt;
&lt;li&gt;네이버 통장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;배송 모듈은 주문형 페이에 속하고, 주문형 페이에는 이커머스 삼대장인 &lt;code&gt;주문&lt;/code&gt;, &lt;code&gt;배송&lt;/code&gt;, &lt;code&gt;클레임&lt;/code&gt; 을 관리하는 부서이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709049-59d40480-8ef9-11eb-8706-414fe24baa17.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 38 32 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;배송-모듈의-특징-및-문제점&#34;&gt;배송 모듈의 특징 및 문제점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;배송 모듈은 트래픽이 높았고, 다른 모듈과는 다른 특성이 있었다.&lt;/li&gt;
&lt;li&gt;다른 모듈들은, 온라인에서 데이터가 생성되며 액션의 주체가 사용자 및 내부시스템이다.&lt;/li&gt;
&lt;li&gt;배송은 오프라인에 의해서 데이터가 생성되며 액션의 주체가 유저가 아닌 외부 시스템이다.&lt;/li&gt;
&lt;li&gt;다른 모듈은 자체적으로 데이터를 생산하기에 데이터 보정 및 생성 규칙에 대해서 지정을 할 수 있지만, &lt;strong&gt;배송 모듈은 외부에 의해서 생성되는 데이터이기 때문에 데이터에 대한 필터링 및 검증이 어렵다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709148-11691680-8efa-11eb-81ee-b8f45b245d10.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 43 35 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709170-3fe6f180-8efa-11eb-959e-5729c28895f3.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 44 52 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;또한 점점 더 비즈니스 로직이 복잡해지고, 따라서 배송 모듈에 대한 트래픽도 증가했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;기존-배송-시스템&#34;&gt;기존 배송 시스템&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709273-3dd16280-8efb-11eb-8648-562344390386.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 52 00 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;택배사와 다이렉터로 연결하는 것이 아니라, 배송 모듈을 엔드포인트로 하여, 택배사의 정보를 제공해주는 업체와 연동을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;배송 데이터가 생성되면 연동 업체에 전달하고, 변경 사항이 발생했을 때, 연동 업체에서 변경분에 대해서 &lt;code&gt;FTP&lt;/code&gt; 통신으로 정보를 주고 받았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최소 설계시에는 빠른 배송에 대한 관심이 없었던 시절이라서 &lt;code&gt;FTP&lt;/code&gt; 통신으로도 문제가 없었지만, 빠른 배송에 대한 니즈 및 실시간성을 사용자들이 요구하면서 위의 구조는 한계점을 드러내었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;배송 데이터 생성 패턴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709318-c0f2b880-8efb-11eb-86a3-e797569ce216.png&#34; alt=&#34;Screen Shot 2021-03-27 at 12 55 43 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배송의 경우 특정 시간대에 트래픽이 몰리게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;한계점&#34;&gt;한계점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HPA(Horizontal Pod Autoscaler) 구성이 되어있지 않음&lt;/li&gt;
&lt;li&gt;배송 처리로 인해서 상품 주문 및 클래임으로 다른 모듈에 부하가 전파된다.&lt;/li&gt;
&lt;li&gt;장애 인지의 어려움 (지연, 누락, 장애)&lt;/li&gt;
&lt;li&gt;내부 시스템에서 장애가 발생한 경우에는 비교적 빠른 대응이 가능했지만, 외부 업체에서 생성된 장애를 인지하기에는 어려웠다.&lt;/li&gt;
&lt;li&gt;모니터링 시스템이 미비하여 쉽게 장애를 캐치하기 어려웠다.&lt;/li&gt;
&lt;li&gt;택배사가 코드에 적용되어 있어, 심심하면 나타나는 택배사를 추가해주어야하는 업무가 있었다.&lt;/li&gt;
&lt;li&gt;이전에는 국내 택배사만 있었지만 최근에는 (일반, 해외, 물류, 장보기) 등 다양한 종류의 택배사가 등장했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;개선-시도&#34;&gt;개선 시도&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;과거 &lt;code&gt;FTP&lt;/code&gt;를 통해서 통신하던 배치에서 &lt;code&gt;Kafka&lt;/code&gt;로 변경하여 적용하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결제 모듈과 다르게, 배송은 특정 시간대에 몰리게 되며, 배송은 N개 단위의 벌크로 진행하게 된다. 이 통신 사이에는 데이터 밸리데이션을 수행하고 데이터가 유실될 경우 데이터를 재보정 처리할 수 있어야하는 구조여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 데이터가 외부 업체와 연동이 되어야하므로, 누구 귀책으로 데이터가 처리되지 않았는지를 알아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 한 요청당 약 1000건의 데이터 통신이 이루어 지므로, 통신이 길어지는 문제가 발생하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709472-58a4d680-8efd-11eb-8968-274833727a20.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 07 06 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API로 수신한 내용들을 파일로 저장하고, 그 파일을 배치로 처리하는 구조로 변경하였다.&lt;/li&gt;
&lt;li&gt;하지만 여전히 대량의 데이터를 처리하는데에는 많은 한계를 가지고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709525-c2bd7b80-8efd-11eb-81d1-4b3bb51ca795.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 10 04 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;따라서 카프카를 이용하여, 이러한 작업을 처리해주었다.&lt;/li&gt;
&lt;li&gt;배치가 주는 모니터링의 장점을 버리게 되었다.&lt;/li&gt;
&lt;li&gt;배치가 카프카로 변경되는 건 기술을 적용했을 뿐 큰 변화는 없었다.&lt;/li&gt;
&lt;li&gt;데이터 누수 및 보정에 대한 새로운 FLOW 생성이 필요했다.&lt;/li&gt;
&lt;li&gt;메시지 스펙 정의 시 확장이 아닌 기능 기반 설계를 진행하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배송-분리-프로젝트-plasma&#34;&gt;배송 분리 프로젝트 Plasma&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;네이버 페이 서비스의 &lt;code&gt;Scalability&lt;/code&gt; 확보&lt;/li&gt;
&lt;li&gt;모놀리틱 구조의 네이버 페이 주문 서비스를 분리&lt;/li&gt;
&lt;li&gt;기존 네이버 페이 서비스 개발자와 사내 플랫폼 개발자가 협업&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;문제 해결 접근 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술적인 부분과 비즈니스 적인 부분을 나누어서 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분에는 나도 공감하는데, 기술적으로 풀려고 시도했을 경우 많은 생각을 해야하지만 사실 비즈니스적으로 변경하여 문제가 쉽게 풀리는 경우가 많았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;렉 모니터링에 대한 세분화된 알람이 필요할 것으로 보임&lt;/li&gt;
&lt;li&gt;앞 모듈에 컨트롤 할 수 있는 부분을 두어서 랙이 기준치 이상 도달 할 경우, 우선순위가 중요한 메시지는 특정 큐에 집어 넣고 특정 큐에 대한 오퍼레이션을 별도로 수행하는 구조를&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;배송-서비스를-분리한-후에-구조&#34;&gt;배송 서비스를 분리한 후에 구조&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112709855-192bb980-8f00-11eb-9807-d750cf2865c3.png&#34; alt=&#34;Screen Shot 2021-03-27 at 1 26 47 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡한 쿼리가 필요한 데이터들은 분산 &lt;code&gt;RDBMS&lt;/code&gt;에 저장을 한다.&lt;/li&gt;
&lt;li&gt;로직이 간단한 데이터들은 &lt;code&gt;Redis&lt;/code&gt;에 저장을 한다.&lt;/li&gt;
&lt;li&gt;간단한 조회의 경우에는 API 서버를 통해서 분산 저장소에서 데이터를 읽어와 처리한다.&lt;/li&gt;
&lt;li&gt;추가 처리가 필요한 경우에는 &lt;code&gt;Kafka&lt;/code&gt;에 추가 처리나 이벤트를 발송시키게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kafka&lt;/code&gt;에서 처리하는 모든 이벤트는 &lt;code&gt;Logstash&lt;/code&gt;를 통해서 &lt;code&gt;Elasticseach&lt;/code&gt;에 저장이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;이벤트-기반-모니터링&#34;&gt;이벤트 기반 모니터링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에는 최종 데이터만 저장하고 갱신하기 때문에, 이벤트 기반 모니터링 시스템을 구축하였다. 따라서 특정 시간에 대한 데이터를 배송 이벤트를 분석해서 데이터를 처리하기 때문에 상태를 추적하거나, 상태를 복원할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;확장성에 대해서는 분산 저장소를 사용하여, 스토리지 확장성을 높혔고, 쿠버네티스를 활용하여 컴퓨팅 확장성을 높혔다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모니터링을 강화함으로써, 운영 비용을 절감시켰다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인스턴스 분리 및 의존성 분리를 통해서 장애적으로 독립적인 상태가 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네이버-페이-아키텍처-및-인프라-구성&#34;&gt;네이버 페이 아키텍처 및 인프라 구성&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706593-a2cf8d00-8ee8-11eb-902b-c52b16ce62d6.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 38 54 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;나도 현재는 웹 개발자로 일하고 있지만 언젠가는 플랫폼 개발을 경험하고 싶은 마음이 있는데, 멋있다는 생각이 들었다. 내가 만든 기능을 통해서 개발자들이 어떤 서비스를 만들었다고 생각하면 자부심과 동시에, 책임감을 느낄 수 있을 것 같다. 물론 이는 모든 개발자가 마찬가지지만 특히 플랫폼 개발을 하면 더욱 와닿을 것 같은 생각이 들었다. 내가 오픈 소스 활동을 하는 이유도 이와 비슷하다. 다른 사람들에게 선한 영향력을 주고 싶다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;네이버페이는 비즈니스 성장과 트래픽 급증에 대응할 수 있도록 마이크로 서비스 아키텍처와 이벤트 드리븐 아키텍처를 적용해서 개발하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 구조를 사용하면 각각의 마이크로서비스가 독자적으로 유연하게 개발되고 데이터가 더 다양한 곳에 다양한 형태로 존재하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 기존에 고려되었지 않았던 새로운 문제가 발하고 이러한 문제를 플랫폼에서 지원해서 시스템적으로 해결하면 서비스와 완성도를 높일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 기존 서비스 개발자와 플랫폼 개발자가 협력하여 일을 하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;마이크로서비스 아키텍처 및 이벤트 드리븐 아키텍처에 대해서 대략적으로만 알고 있어서 이 기회에 정리를 해보았다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;마이크로 서비스 아키텍처&lt;/strong&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706776-e5459980-8ee9-11eb-85d0-29316803cc43.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 47 46 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706932-e5926480-8eea-11eb-8161-373b02c6dd56.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처는 애플리케이션을 느슨하게 결합된 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로서비스 아키텍처에서 서비스들은 섬세하고, 프로토콜은 가벼운 편이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마이크로 서비스 아키텍처의 서비스들은 독립적인 배포가 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스의 교체가 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이벤트 드리븐 아키텍처&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112706975-3dc96680-8eeb-11eb-8174-3e310a6fae21.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707012-7f5a1180-8eeb-11eb-8828-510c5390ffc9.png&#34; alt=&#34;Screen Shot 2021-03-27 at 10 59 22 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트 드리븐 아키텍처(EDA)는 이벤트의 생산, 감지, 소비 및 반응을 제고하는 소프트웨어 아키텍처 패턴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트는 &amp;ldquo;상태의 변화&amp;quot;로 정의할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템 내부 및 외부에 발생한 주목할 만한 상태의 변환에 기반하여 동작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, 소비자가 자동차를 구매할 때, 자동차의 상태는 &amp;ldquo;판매 중&amp;quot;에서 &amp;ldquo;판매 완료&amp;quot;로 바뀐다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 행동이 자동으로, 순서에 따라서 발생하는 것이 아닌 어떤 일에 대한 반응으로 동작하는 패턴이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;이벤트-주도-마이크로서비스edm&#34;&gt;&lt;strong&gt;이벤트 주도 마이크로서비스(EDM)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;이벤트 주도 마이크로 서비스(EDM)은 &lt;strong&gt;MSA가 적용된 시스템에서 이벤트 발생시 해당 이벤트 로그를 보관하고 이를 기반으로 동작하며, 비동기 통신을 통해 시스템 내 통합(integeration)을 수행하는 아키텍처이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707540-8daa2c80-8eef-11eb-9e23-ee07bae1391d.png&#34; alt=&#34;0_FvyN47z7FwnKPflx&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이벤트 : 이벤트 주도에서 언급하는 이벤트는 상태의 변경, 즉 데이터의 변경, 생성, 삭제 (&lt;code&gt;CUD&lt;/code&gt;)를 통해서 발생하는 서비스의 의미있는 변화를 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 로그 보관: 현재의 데이터는 상태 변경의 누적이라는 생각에서 시작한다. 이 때의 상태 변경은 이벤트를 뜻하고 이를 누적하는 행위는 이벤트 로그를 보관하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EDM&lt;/code&gt;에서 생성한 이벤트는 반드시 보관되어야 한다. 보관된 이벤트는 데이터의 현재 상태를 구성하는 근간이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 보관된 이벤트를 바탕으로 장애 발생 또는 특정 요구사항에 따라 지정된 시점으로 복원을 수행한다. 이벤트 로그를 보관하는 장소를 이벤트 스토어라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비동기 통신 : &lt;code&gt;AMQP&lt;/code&gt;, &lt;code&gt;MQTT&lt;/code&gt;, &lt;code&gt;JMS&lt;/code&gt;등 메세지 프로토콜을 통한 메시지 큐 방식이 자주 사용된다. 서비스에서 데이터의 생성, 변경, 삭제(CUD)를 통해 이벤트가 발생하면, 발생 서비스는 메시지의 형태로 이벤트를 발생하고, 해당 이벤트에 관심이 있는 서비스에서 구독을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네이버-페이를-뒷-받침하는-플랫폼&#34;&gt;네이버 페이를 뒷 받침하는 플랫폼&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707316-c1845280-8eed-11eb-9a00-62e759d3b2d6.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112707334-e8428900-8eed-11eb-89c5-e3397fd6f3cc.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;빠르고 유연한 확장을 위해서, 쿠버네티스 클러스터에서 서비스 이미지를 배포해서 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메인 데이터베이스 저장소로는 자체 분산 데이터베이스 클러스터(&lt;code&gt;nBase-T&lt;/code&gt;)와 분산 레디스 클러스터를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이벤트 전달 및 저장을 위해서 &lt;code&gt;Kafka&lt;/code&gt;, &lt;code&gt;ElasticSearch&lt;/code&gt; 클러스터와 &lt;code&gt;LogStash&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모니터링과 분석을 위해서 사용하는 플랫폼은 &lt;code&gt;Grafana&lt;/code&gt;를 사용하고 있고, &lt;code&gt;Elasticsearch&lt;/code&gt; 상태와 데이터 확인을 위해서 &lt;code&gt;Kibana&lt;/code&gt;와 &lt;code&gt;Cerebro&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;로그 수집과 매트릭 수집은 자체 플랫폼을 사용하고 있고 &lt;code&gt;APM(application performance management)&lt;/code&gt;로는 사내에서 오픈 소스로 발표한 &lt;code&gt;Pinpoint&lt;/code&gt;를 사용하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 플랫폼을 활용해서 서비스를 개발하고 있고, 공통화가 필요한 부분은 플랫폼에 적용하거나 라이브러리화 하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인상 깊었던 부분은 &lt;code&gt;Spring Data JDBC&lt;/code&gt;에서 제공하지 않는 추가 기능들은 직접 개발해서 사용한다는 것이다. 기술에 이해도가 높지 않으면 절대로 쉽지 않다는 것을 알기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;인프라-운영&#34;&gt;인프라 운영&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CI/CD&lt;/code&gt; 시스템으로 젠킨스를 적극적으로 활용하고 있다.&lt;/li&gt;
&lt;li&gt;서비스가 메모리나 CPU를 과도하게 사용하고 있으면 &lt;code&gt;Grafana&lt;/code&gt;가 알려주고, 오류 로그가 있으면 로깅 시스템이 알려주고, &lt;code&gt;Kafka&lt;/code&gt;에 &lt;code&gt;LAG&lt;/code&gt;이 생기면 매트릭 시스템이 알려주고, 에러 응답이 늘어나면 &lt;code&gt;Pinpoint&lt;/code&gt;가 알려주는 식으로 동작한다.&lt;/li&gt;
&lt;li&gt;서비스가 복잡해지고 문제 상황에서 확인해봐야 하는 곳이 늘어나도 이러한 알람을 통해서 빠르게 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;이러한 플랫폼들을 활용하여 시간을 아낄 수 있었고, 아낀 시간을 서비스 개발에 투자할 수 있었다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;새로운 플랫폼을 접했을 때는 대부분 개념 증명부터 해보면서 필요한 부분만 빨리 익혀서 사용하는 편이라고 했다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;일하는-방식&#34;&gt;일하는 방식&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;길거나 짧은 목표를 설정한 후 거기까지 각자의 역량을 발휘해서 자유롭게 도달하는 방식으로 일한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표에 어떤 방법으로도 도달해도 좋지만, 그 방식에 타당한 이유가 있어야하고, 방식에 확신이 없을 때는 주위 사람과 활발하게 논의해서 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스의 목표 내지는 문제를 해결하는 과정에서 플랫폼이 지원하면 효율적인 일도 도출되었던 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기록과 공유가 권장되는 분위기이다. 그렇기에 팀에서는 사내/외 세미나나 기고를 통해서 경험을 활발하게 공유하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/naver_diary/222059276316&#34;&gt;네피셜 플랫폼 개발자의 커머스 서비스 개발기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Microservices&#34;&gt;Wiki - Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a&#34;&gt;Event Driven Architecture란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tv.naver.com/v/16970002&#34;&gt;페이왕국 주문가문 배송용사 독립기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>샤딩이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%EC%83%A4%EB%94%A9%EC%9D%B4%EB%9E%80draft/</guid>
      <description>&lt;h3 id=&#34;샤딩&#34;&gt;샤딩&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>클러스터링이란?(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Sat, 27 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80draft/</guid>
      <description>&lt;h3 id=&#34;클러스터링&#34;&gt;클러스터링&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/docs/multi-node/galera-cluster/understand-mariadb-enterprise-cluster/#architecture&#34;&gt;Understanding MariaDB Enterprise Cluster&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://kaaproject.github.io/kaa/docs/v0.10.0/Administration-guide/System-installation/Cluster-setup/MariaDB-cluster-setup-guide/&#34;&gt;MariaDB cluster setup&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mariadb.com/kb/en/what-is-mariadb-galera-cluster/&#34;&gt;What is MariaDB Galera Cluster?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://menakamadushanka.wordpress.com/2017/12/15/how-to-deploy-a-mysql-cluster-from-scratch-with-docker/&#34;&gt;How to deploy a MySQL Cluster from Scratch with Docker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CONCURRENCY(동시성)와 PARALLELISM(병행성) (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft/</link>
      <pubDate>Sat, 27 Mar 2021 01:09:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/27/concurrency%EB%8F%99%EC%8B%9C%EC%84%B1%EC%99%80-parallelism%EB%B3%91%ED%96%89%EC%84%B1-draft/</guid>
      <description>&lt;h3 id=&#34;concurrency동시성와-parallelism병행성&#34;&gt;CONCURRENCY(동시성)와 PARALLELISM(병행성)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112660338-af2bf980-8e98-11eb-8aec-e165f24e7fde.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;병행성&#34;&gt;병행성&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성&#34;&gt;동시성&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CONCURRENCY(동시성)&lt;/strong&gt; 에서 가장 중요한 것은 동시에 수행되는 기능들의 빠른 반응이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 빠른 반응은, 운영체제의 핵심인 커널에서 프로세스 스케줄러가 선점형(&lt;code&gt;Preemption&lt;/code&gt;)으로 동작하느냐가 관건이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 자원은 한정되어 있는데 반해서 작업 진행이 필요한 프로세스들은 여러 개가 생길 수 있다. 이때 CPU 자원을 어떻게 분배하느냐가 스케줄링이 필요한 이유이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컴퓨터에서 사용자가 파일을 다운로드 받을 때 파일을 다운로드 받는 프로세스가 &lt;code&gt;CPU&lt;/code&gt; 자원을 할당 받아서 작업을 진행하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이때 사용자가 뮤직 플레이를 실행 시켜서 또 다른 프로세스가 생성되었다고 할 때 비선점형의 경우에는 파일을 다운로드 받는 프로세스 작업이 끝나야 음악을 플레이 하는 프로세스가 CPU 자원을 할당 받아서 작업을 진행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;즉 파일 다운로드가 완료될 때까지 음악이 나오지 않을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선점형 스케줄링의 경우에는 스케줄러가 강제로 그 즉시 음악을 플레이하는 프로세스에게 자원을 할당해주고, 상황에 따라서 적당히 &lt;code&gt;CPU&lt;/code&gt; 자원을 분배하여 두 개의 프로세스가 작업을 진행하는데 문제가 없도록 하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;물론 자세히 들어가면 비선점형 스케줄링 방식을 사용하더라도 여러 가지 방법을 통해서 동시에 실행되는 것 처럼 보이게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>트랜잭션과 ACID</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid/</link>
      <pubDate>Fri, 26 Mar 2021 23:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-acid/</guid>
      <description>&lt;p&gt;누군가 트랜잭션에 대해서 물어보았을 때, 분명히 알고 있다고 생각한 것인데도 제대로 답변하지 못했다. 이건 평소에 생각이 정리되지 않아서 그런 것 같다. 따라서 이참에 이에 대해서 정리를 해보도록 했다.&lt;/p&gt;
&lt;h3 id=&#34;트랜잭션이란&#34;&gt;트랜잭션이란&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112649044-6de21c80-8e8d-11eb-9e40-2f597a3555ac.png&#34; alt=&#34;트랜잭션&#34;&gt;&lt;/p&gt;
&lt;p&gt;위키 백과에서는 트랜잭션을 다음과 같이 정의하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 트랜잭션은 데이터베이스에 대해서 DBMS 내에서 수행되고 다른 트랜잭션과 무관하게 일관되고 신뢰할 수 있는 방식으로 처리되는 작업 단위를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션은 일반적으로 데이터베이스의 모든 변경 사항이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스 환경의 트랜잭션에는 두 가지의 주요 목적이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행 중지 (완전 및 부분적으로) 및 데이터베이스에 대한 많은 작업이 완료되지 않은 상태로 남아있는 경우에 장래로부터 정확하게 복구하고 데이터베이스를 일관성 있게 유지할 수 있는 신뢰할 수 있는 작업 단위를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 동시에 액세스 하는 프로그램 간에 분리를 제공한다. 이러한 분리를 제공하지 않으면 프로그램의 결과가 잘못될 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112650101-6707d980-8e8e-11eb-8d32-a92f3bce761b.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;p&gt;ACID 트랜잭션은 관계형 데이터베이스에서 여러 개의 SQL 연산을 하나의 단일 트랜잭션으로 처리하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;여러 개의 테이블에 대해서 읽고 쓰고 하는 행동을 하나의 연산처럼 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID 라는 단어는 분해할 수 없이 원자적(Atomicity)이고, 일관된(Consistency) 데이터 상태를 유지하고, 고립(Isolation)되어 다른 연산이 끼어들 수 없고, 데이터가 영원히(Durability) 반영된 상태로 있는 것을 의미한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;원자성(Atomicity) : 데이터베이스에서 가장 중요한 개념은 원자성일것이다, 여러개의 SQL 연산이 하나의 연산 처럼 동작해야한다. 어느 것 하나라도 실패했다면 모든 연산이 실행되지 않아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 같은 시점에 접속하는 클라이언트는 항상같은 데이터를 보고 있어야 한다는 것이다. 동일한 시간에 A와 B가 요청을 할 때, A가 읽은 데이터와 B가 읽은 데이터가 다르다면 아주 기본적인 일관성이 보장되지 않은 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고립성(Isolation) : 트랜잭션이 수행되는 동안에, 다른 연산이 끼어들지 못한다는 것이다. 이에 대해서는 고립 수준이라는 것이 있는데 이는 나중에 자세히 알아보도록 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;영속성(Durability) : 트랜잭션이 완료된 이후의 데이터는 업데이트 된 상태 그대로 영원히 반영되어 있다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Database_transaction&#34;&gt;WIKI - Database transaction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 26 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 일을 하기전에, 내가 어떤 일을 할 계획이고 그 일이 마감되었다면 내가 구현한 것을 녹화하여 공유하였다.&lt;/li&gt;
&lt;li&gt;내가 경험해보지 못한 생소한 업계에는 어떤 기술을 사용하고, 어떤 고민을 할까라는 생각을 해봤다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그렇게 하니까 동료들이 내가 무엇을 했는지 쉽게 이해할 수 있고, 개발자 뿐만 아니라 &lt;code&gt;PM&lt;/code&gt; 및 &lt;code&gt;QA&lt;/code&gt; 분들도 작업이 어떻게 진행되고 있는지 쉽게 이해하시는 것 같았다.&lt;/li&gt;
&lt;li&gt;내가 어떤 일을 하고 있는지 설명하기가 더 쉬워지고 상대방도 더 빠르게 이해하는 것 같았다.&lt;/li&gt;
&lt;li&gt;기술 블로그를 통해서, 대략적인 아키텍처와 사용하는 기술을 파악할 수 있다는 생각이 들었다. 따라서 내가 분석하고 싶은 분야 회사 기술 블로그를 파악하고 관련된 기술을 공부하면 좋을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;말로 설명하는 것 보다는 내가 작업한 내용을 동영상으로 결과만이라도 같이 공유하는 것이 의사소통에 도움이 된다.&lt;/li&gt;
&lt;li&gt;나도 다른 사람들에게 내가 했던 작업을 이해시키기가 훨씬 쉬워진다.&lt;/li&gt;
&lt;li&gt;다양한 매체로 내가 작업하고 있는 내용, 그리고 앞으로 작업할 내용, 고민하고 있는 내용을 관계된 사람들에게 알리자.&lt;/li&gt;
&lt;li&gt;은행들은 개발자 관점에서 어떤 기술을 사용하고, 어떤 고민을 할 지 파악하는 가장 좋은 방법은 기술 블로그를 분석하고 이와 관련된 주제를 공부하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;영상으로 녹화하는 작업을 일일히 수작업으로 하는 것이 아니라, 테스트 코드를 통해내가 작업한 과정을 자동화 시키면 업무 시간을 획기적으로 단축 시킬 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;결과가 화면상으로 나타나지 않는 코드 레벨에서 고민해야할 것은 화면으로 공유하기 어려울 것 같다. 따라서 이러한 경우에는 어쩔 수 없이 글로 라도 작성해야하는데, 코드를 글로 설명하기가 어려워 이러한 공유를 꺼리는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CAP 이론이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/cap-%EC%9D%B4%EB%A1%A0%EC%9D%B4%EB%9E%80/</guid>
      <description>&lt;h3 id=&#34;cap-정리&#34;&gt;CAP 정리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112651209-86533680-8e8f-11eb-9579-2d9a2389ce27.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CAP 정리에 의하면 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 그림에서 볼 수 있듯이, Consistency, Availablity를 합치면, &lt;code&gt;CA&lt;/code&gt; 또는 Consistency와 Partition tolerance를 조합하면 &lt;code&gt;AP&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 모든 속성을 다 포함한 시스템은 절대로 존재할 수 없다는 것이 CAP 정리이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;각-특징의-의미&#34;&gt;각 특징의 의미&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. &lt;code&gt;ACID&lt;/code&gt; 원리에서 의미하는 것과 같다. 어떤 데이터베이스 속성에 &lt;code&gt;C&lt;/code&gt;가 있다면, 트랜잭션 기능 또는 그와 비슷한 매커니즘이 존재한다는 뜻이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가용성(Availablity) : 가용성은 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 처리 응답을 보애주어야 한다는 것을 의미한다. 클라이언트가 읽기, 쓰기 요청을 하면 제대로 읽고 쓰는 작업을 해야한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분단 허용성(Partition tolerance) : 분단 허용성은 클러스터가 여러 대 동작하고 있을 때, 해당 클러스터 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 시스템이 잘 동작해야 한다는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;관계형 데이터베이스는 CA 시스템이다. 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다.
만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;해결책은 간단한데, CA를 포기하면 된다. CA를 포기한다는 뜻이 극단적으로 일관성과 가용성을 포기하는 것이 아닌 1 ~ 100까지의 수치가 있을 때 일관성과 가용성을 100% 지원하던 것에서 수치를 60%로 낮춘다고 생각을 하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;대부분의 NoSQL 데이터베이스는 CA가 아닌 CP나 AP 시스템이다. 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62639053&#34;&gt;모바일 서버 프로그래밍 입문, 얼랭으로 만들며 배운다&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MVCC(다중 버전 동시성 제어)란 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/mvcc%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%A0%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%9E%80-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>TWO-PHASE COMMIT 이란?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/two-phase-commit-%EC%9D%B4%EB%9E%80/</guid>
      <description>&lt;h3 id=&#34;two-phase-커밋이란&#34;&gt;TWO-PHASE 커밋이란?&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113822026-dd260d80-97b7-11eb-8ea8-b3c939d08cec.png&#34; alt=&#34;95&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;투 페이즈 커밋은 여러 노드에 거쳐서 원자성 트랜잭션 커밋을 달성하기 위한 알고리즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분산 데이터베이스의 트랜잭션 처리를 위해서 사용하는 고전적인 방법이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC에서는 일반적으로 단일 노드 트랜잭션에서는 나타나지 않는 새로운 구성 요소인 코디네이터(트랜잭션 관리자)를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2PC 트랜잭션은 애플리케이션이 정상적으로 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커밋할 준비가 되면 트랜잭션 관리자는 1 단계를 시작한다. 그런 다음에 각 노드에 준비 요청을 보내서 커밋 가능 여부를 묻게 되며, 참가자의 응답에 따라서 커밋을 할지, 롤백을 할지 결정을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 노드가 &amp;ldquo;예&amp;rdquo; 라고 대답하여, 커밋할 준비가 되었다고 하면, 트랜잭션 매니저는 2단계에서 커밋 요청을 전송하고 커밋이 실제로 수행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;참가자가 &amp;ldquo;아니오&amp;quot;라고 대답하면 코디네이터는 2단계의 모든 노드에 중단 요청을 보낸다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/113823077-32aeea00-97b9-11eb-888f-4a5f9b9d2ae5.jpg&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이러한 과정은 결혼식에 비유할 수 있는데, 주례자가 신랑과 신부에서 각각 결혼하고 싶은지 물어보고, 모두 결혼을 하고 싶다는 대답을 받고 나서, 결혼식을 마무리하는 과정이라고 비유를 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 주례자는 트랜잭션 매니저이며, 신랑과 신부는 각 데이터베이스 노드들이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;two-phase-커밋의-단점&#34;&gt;TWO-PHASE 커밋의 단점&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;2PC의 가장 큰 단점은 블록킹이라는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Two-phase_commit_protocol&#34;&gt;Two-phase commit protocol&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ebrary.net/64872/computer_science/introduction_phase_commit&#34;&gt;introduction_phase_commit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>합의(Consensus) 알고리즘이란(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft/</link>
      <pubDate>Fri, 26 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/26/%ED%95%A9%EC%9D%98consensus-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Consensus_(computer_science)&#34;&gt;WIKI - Consensus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zookeeper.apache.org/doc/r3.4.13/zookeeperInternals.html&#34;&gt;ZOOKEEPER DOCS -  CONSENSUS ALGORITHMS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://betterprogramming.pub/demystifying-consensus-algorithms-and-their-implementations-c52f8aca3020&#34;&gt;Demystifying Consensus Algorithms and Their Implementations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://raft.github.io/&#34;&gt;RAFT 합의 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/5663184&#34;&gt;D2 - Raft 분산 합의 알고리즘과 Python에서의 활용&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC의 여러가지 구현 방식(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</link>
      <pubDate>Thu, 25 Mar 2021 19:03:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/25/ioc%EC%9D%98-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9Ddraft/</guid>
      <description>&lt;p&gt;스프링 문서를 보면서, &lt;code&gt;IoC&lt;/code&gt;에 대해서 공부를 하다가, 서비스 로케이터 패턴을 알게 되었다. 서비스 로케이터 패턴을 조사하다가 자연스럽게 다른 &lt;code&gt;IoC&lt;/code&gt; 구현 방식도 알게 되었는데 정리를 해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292089-15b3ea80-8cd4-11eb-80fd-943416430267.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ahea.wordpress.com/2018/09/09/1754/&#34;&gt;IOC 구현 방식&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 25 Mar 2021 18:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;팀 회식을 했다.&lt;/li&gt;
&lt;li&gt;회의때 진행한 이야기중에 내가 놓친것들이 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회의때 집중을 해야겠다는 생각을 하게 되었고, 부끄러웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;회의때 내용을 파악하고 이를 기록하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일을 진행할 때 다시한번 회의때 내가 파악하고 있는것이 맞는지 확인하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회의때 집중하고, 내가 놓친부분이 있을 수 있으니 이를 확인하고 일을 시작하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>빈 펙토리와 애플리케이션 컨텍스트의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Wed, 24 Mar 2021 23:30:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/%EB%B9%88-%ED%8E%99%ED%86%A0%EB%A6%AC%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>&lt;h3 id=&#34;궁금증을-가지게-된-이유&#34;&gt;궁금증을 가지게 된 이유&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112328879-10699680-8cfa-11eb-8c22-2db852326801.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 38 22 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 문서를 보면서 공부하다가 위와 같은 문구를 보게 되었다. &lt;code&gt;ApplicationContext&lt;/code&gt;가 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 타입의 인터페이스라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇다면 무슨 차이가 있을까라는 생각을 하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean-facotry&#34;&gt;BEAN FACOTRY&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112329428-88d05780-8cfa-11eb-8c53-63c801dadfbb.png&#34; alt=&#34;Screen Shot 2021-03-24 at 11 41 55 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다행스럽게도 위와 같은 문서가 스프링 공식문서에서 제공되고 있었다. 차이점은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API는 &lt;code&gt;Spring IoC&lt;/code&gt; 기능을 위한 기초적인 기반을 제공한다.&lt;/li&gt;
&lt;li&gt;이것의 구체적인 계약은, 주로 스프링의 다른 부분과 관련된 써드 파티 프레임워크와의 통합에 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 및 관련 인터페이스 (예: &lt;code&gt;BeanFactoryAware&lt;/code&gt;, &lt;code&gt;Initializing Bean&lt;/code&gt;, &lt;code&gt;DispisableBean&lt;/code&gt;)는 다른 프레임워크 구성 요소의 중요한 통합지점이다.&lt;/li&gt;
&lt;li&gt;어노테이션이랑 리플렉션이 필요하지 않으므로, 컨테이너와 컴포넌트간에 매우 효율적인 상호작용을 할 수 있다.&lt;/li&gt;
&lt;li&gt;응용 프로그램 수준 빈은 동일한 콜백 인터페이스를 사용할 수 있지만, 일반적으로 어노테이션을 또는 설정을 통한 선언적 종속성 주입을 선호한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; API 레벨과, &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 구현에서는 구성 형식이나 사용할 구성 요소 어노테이션에 대해서 가정을 하지 않는다.&lt;/li&gt;
&lt;li&gt;이러한 것은 확장 기능(예: &lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;, &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;)을 통해서 제공되며, 공유 &lt;code&gt;BeanDefinition&lt;/code&gt; 개체에서 핵심 메타데이터 표현으로 작성한다.&lt;/li&gt;
&lt;li&gt;이것이 바로 스프링 컨테이너를 유연하고 확장 가능하게 만드는 본질이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;솔직히 이 부분은 아직 잘 모르겠다&amp;hellip; 그래도 정리를 해둔 기억이 있으니 코딩을 하면서 관련된 API를 사용할 때 다시 한번 확인해봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;빈-펙토리와-애플리케이션-컨텍스트&#34;&gt;빈 펙토리와 애플리케이션 컨텍스트&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112332863-70ae0780-8cfd-11eb-8ad5-23a995c1a92d.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 28 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 섹션에서는 &lt;code&gt;BeanFactory&lt;/code&gt;와 &lt;code&gt;ApplicationContext&lt;/code&gt; 컨테이너 수준 간의 차이와 부트스트래핑에 대한 의미에 대해서 설명한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 부트스트랩핑을 &lt;code&gt;GenericApplicationContext&lt;/code&gt;, &lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;를 이용하여 구현할 것이 아니라면 일반적으로는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 공통 목적을 위해서 스프링의 핵심 컨테이너에 대한 기본 진입 지점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;에는 &lt;code&gt;BeanFactory&lt;/code&gt;의 모든 기능이 포함되므로, &lt;code&gt;BeanFactory&lt;/code&gt;에 대한 완전한 제어가 필요한 시나리오를 제외하고 일반적으로 &lt;code&gt;BeanFactory&lt;/code&gt;보다는 &lt;code&gt;ApplicationContext&lt;/code&gt;를 사용하는 것을 권장한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;(일반 애플리케이션 컨텍스트 구현 등) 내에서 몇 가지 종류의 빈이 컨벤션에(특히, &lt;code&gt;post-processors&lt;/code&gt;) 의해서 탐지되는 반면에 일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;는 특별한 빈들에게 대해서 관련이 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주석 처리 및 &lt;code&gt;AOP&lt;/code&gt; 프록시와 같은 많은 확장 컨테이너 기능의 경우, &lt;code&gt;BeanPostProcessor&lt;/code&gt; 확장 지점이 필수적이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;만 사용하는 경우에는 기본적으로 이러한 사후 프로세스가 탐지 및 활성화 되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈 구성에 아무런 문제가 없기 때문에 이러한 상황은 혼란스러울 수 있지만 오히려 이러한 시나리오에서 컨테이너를 추가 설정을 통해서 완전히 부트스트랩 해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112334414-c0410300-8cfe-11eb-87ba-a5566175c744.png&#34; alt=&#34;Screen Shot 2021-03-25 at 12 02 42 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;는 &lt;code&gt;Bean&lt;/code&gt;을 인스턴스화 하거나 와이어링 하는 것 빼고는 &lt;code&gt;ApplicationContext&lt;/code&gt;과 비교해서 많은 기능을 제공하지 않는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;BeanFactory&lt;/code&gt;에서 사후 프로세서를 명시적으로 등록하려면, 다음의 예외 같이 프로그래밍 방식으로 &lt;code&gt;addBeanPostProcessor&lt;/code&gt;를 호출해야한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음에 생각했던 것 과는 달리 기능을 제공하지 않을 뿐, 코드 상으로 설정을 해주면 사용할 수는 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;그래도 이렇게 명시적으로 등록을 해주어야 하기 때문에, 다양한 &lt;code&gt;ApplicationContext&lt;/code&gt; 변형이 일반 &lt;code&gt;DefualtListableBeanFactory&lt;/code&gt; 보다 선호 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 일반적인 엔터프라이즈 환경에서 확장 컨테이너 기능을 위해서 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 및 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 인스턴스에 의존하는 경우 더욱 그렇다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일단 내가 생각하기에 가장 와닿는건 빈의 생명주기 관리를 할 수 없고, &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 자동으로 등록해주지 않는다는 것이다. 뭐 수동으로 등록해주면 되기는 하지만, 상당히 불편하다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-introduction&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wonwoo.ml/index.php/post/1571&#34;&gt;ApplicationContext와 BeanFactory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IoC 컨테이너란 무엇일까</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Wed, 24 Mar 2021 18:13:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>&lt;p&gt;스프링 전반적인 기술을 주제로 사내 세미나를 하였다. 따라서 이를 공식 문서를 보면서 복습하면서 다시 정리해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112285137-55c39f00-8ccd-11eb-9416-87ba7f879ce0.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 18 09 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 코어 문서 가장 첫 부분에 나와있는 문구이다. 전체적인 기술을 다루지만 특히 스프링 프레임워크의 &lt;code&gt;IoC(Inversion of Control)&lt;/code&gt; 컨테이너가 가장 중요하다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring Framework&lt;/code&gt;의 IoC 컨테이너에 대한 처리는 &lt;code&gt;Spring&lt;/code&gt;의 &lt;code&gt;AOP(Aspect-Oriented Programmin)&lt;/code&gt; 기술을 밀접하게 따르고 있다고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프링 프레임워크는 개념적으로 이해하기 쉽고 자바 엔터프라이즈 프로그래밍에서 &lt;code&gt;AOP&lt;/code&gt; 요구사항의 80%를 성공적으로 해결하는 &lt;code&gt;AOP&lt;/code&gt; 프레임워크가 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스프링-ioc-컨테이너-및-빈bean&#34;&gt;스프링 IoC 컨테이너 및 빈(Bean)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112286205-6c1e2a80-8cce-11eb-9eef-2ca033148bc9.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 26 06 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 장에서는 제어의 반전(&lt;code&gt;IoC&lt;/code&gt;) 원칙의 스프링 프레임워크 구현에 대해서 다룬다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IoC&lt;/code&gt;는 의존성 주입이라고 알려져 있다. &lt;code&gt;(DI)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DI&lt;/code&gt;는 객체가 생성자 파라미터, 펙토리 메서드에서 반환된 후 객체 인스턴스에 설정된 속성을 통해서만 객체의 종속성을 정의하는 프로세스이다.&lt;/li&gt;
&lt;li&gt;그런 다음에, 컨테이너가 빈을 생성할 때, 이러한 종속성을 주입한다.&lt;/li&gt;
&lt;li&gt;이러한 프로세스는 기본적으로 클래스 직접 구성이나 서비스 로케이터 패턴과 같은 매커니즘을 이용하여, 종속성의 인스턴스 화를 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt;와 &lt;code&gt;org.springframework.context&lt;/code&gt; 패키지들이 스프링 프레임워크 &lt;code&gt;IoC&lt;/code&gt; 컨테이너의 기본 구성을 이루고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 인터페이스는 모든 타입의 객체를 관리할 수 있는 고급 설정 매커니즘을 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;는 &lt;code&gt;BeanFactory&lt;/code&gt;의 서브 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112288026-48f47a80-8cd0-11eb-8efe-6d675e3ae5da.png&#34; alt=&#34;ApplicationContextInterface&#34;&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 그림으로 이해하면 이해하기 편하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간단히 말해서 &lt;code&gt;BeanFactory&lt;/code&gt;는 구성 프레임워크와 기본 기능을 제공하며 &lt;code&gt;Application Context&lt;/code&gt;는 더 많은 엔터프라이즈별 기능을 추가한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;에서는 애플리케이션의 핵심을 구성하고, &lt;code&gt;Spring IoC&lt;/code&gt; 컨테이너에 의해서 관리되는 개체를 빈(Bean)이라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈은 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너에 의해서 인스턴스화, 조립 및 관리되는 객체이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그렇지 않으면 빈(Bean)은 응용 프로그램의 여러 객체에 불과하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;빈과 빈 사이의 종속성은 컨테이너가 사용하는 설정 메타데이터에 의해서 반영된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;컨테이너-개요&#34;&gt;컨테이너 개요&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289026-434b6480-8cd1-11eb-9a2c-3a924dee26c7.png&#34; alt=&#34;Screen Shot 2021-03-24 at 6 46 34 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;org.springframework.context.ApplicationContext&lt;/code&gt;는 &lt;code&gt;Spring Ioc&lt;/code&gt; 컨테이너를 나타내며 빈의 인스턴스화 및 구성 및 조립을 담당한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 메타데이터 설정을 읽어서, 인스턴스화, 구성 및 조립할 객체에 대한 지침을 가져온다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구성 메타데이터는 &lt;code&gt;XML&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt; 어노테이션 또는 &lt;code&gt;Java&lt;/code&gt; 코드로 표시된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애플리케이션을 구성하는 객체와 이러한 객체간의 풍부한 상호 종속성을 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112289745-e9976a00-8cd1-11eb-9b9d-8022fe6a673b.png&#34; alt=&#34;container-magic&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 그림은, 스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너가 빈 설정정보를 읽어서, &lt;code&gt;ApplicationContext&lt;/code&gt; 생성되고 초기화되면 완전히 구성되고 실행 가능한 시스템 또는 응용 프로그램의 생성을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-스코프와-라이프-사이클bean-scope-and-lifecycle&#34;&gt;빈의 스코프와 라이프 사이클(Bean Scope and LifeCycle)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112292568-8f4bd880-8cd4-11eb-95e0-2884097eed6f.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 10 07 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 &lt;code&gt;IoC&lt;/code&gt; 컨테이너는 하나 이상의 빈을 관리한다. 이러한 빈은 컨테이너에 제공하는 메타데이터 XML &lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt; 형식으로 제공된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너 자체 내에서 이러한 빈 정의는 &lt;code&gt;BeanDefinition&lt;/code&gt; 객체로 표시되며, 여기에는 (다른 정보 중에서도) 다음과 같은 메타데이터가 포함된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스 이름: 정의되는 빈의 실제 구현 클래스이다.&lt;/li&gt;
&lt;li&gt;빈이 클래스에서 어떻게 동작해야하는지를 나타내는 동작 구성 요소이다. (범위, 라이프 사이클 콜백 등).&lt;/li&gt;
&lt;li&gt;빈이 동작하는데 의존성을 가지는 다른 빈에 대한 참조이다. 이러한 참조를 &lt;code&gt;collaborators&lt;/code&gt; 또는 &lt;code&gt;dependencies&lt;/code&gt; 라고 한다.&lt;/li&gt;
&lt;li&gt;새로 생성된 개체에서 설정할 기타 구성 설정(예: 풀의 크기 제한 또는 연결 풀을 관리하는 빈에서 사용할 연결 수)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112293473-87d8ff00-8cd5-11eb-9250-16ae9694c705.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 17 00 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 표는 빈의 정의를 나타내고 속성은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;: Bean을 생성하기 위한 클래스를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;: Bean의 이름을 말한다. Bean이 누군가에 의해 참조되어야 할 때 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scope&lt;/code&gt;: Bean의 생명주기와 관련하여 어느 Scope에 유일하게 존재할 것이냐에 대한 정의이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constructor arguements&lt;/code&gt;: 빈의 생성자로 의존성을 명시 하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Properties&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt;의 생성자로 의존성을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Autowiring&lt;/code&gt;: &lt;code&gt;Autowiring&lt;/code&gt;에 대한 방법을 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lazy initializaton&lt;/code&gt;: &lt;code&gt;Lazy&lt;/code&gt; 하게 &lt;code&gt;Bean&lt;/code&gt;을 초기화 시키도록 명시하는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Initialization method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 초기화 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destuction method&lt;/code&gt;: &lt;code&gt;Bean&lt;/code&gt; 파괴 시에 호출되는 LifeCycle 메서드를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112295826-9d4f2880-8cd7-11eb-8792-a5ce9d603d7e.png&#34; alt=&#34;Screen Shot 2021-03-24 at 7 31 54 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;: (Default) SPRING IoC 컨테이너당 하나의 레퍼런스만 존재하는 스코프입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;: 임의의 수의 객체 인스턴스로 단일 빈의 범위를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;: 단일 빈 정의의 범위를 단일 HTTP 요청의 수명 주기로 지정한다, 각, HTTP 요청에는 단일 빈 정의 뒤에 생성된 빈 인스턴스가 있다, 오직 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 단일 빈 정의의 범위를 HTTP 세션의 생명주기로 지정한다. 오직 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application&lt;/code&gt;: 단일 빈의 정의를 서블릿 컨텍스트의 생명주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt; 에서만 유효하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;websocket&lt;/code&gt;: 단일 &lt;code&gt;bean&lt;/code&gt;의 정의를 &lt;code&gt;WebSocket&lt;/code&gt;의 생명 주기에 범위를 지정한다. 웹의 &lt;code&gt;ApplicationContext&lt;/code&gt;에서만 유효하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;빈의-생명-주기-콜백lifecycle-callbacks&#34;&gt;빈의 생명 주기 콜백(Lifecycle Callbacks)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112397674-e8078980-8d45-11eb-8439-6ab8de4ed0b0.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 41 23 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨테이너의 빈 생명주기와 상호 작용하기 위해서 &lt;code&gt;InitializingBean&lt;/code&gt;, &lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스를 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨테이너는 빈을 초기화 하기 전에 &lt;code&gt;afterPropertiesSet()&lt;/code&gt;을 호출하고 &lt;code&gt;Bean&lt;/code&gt; 소멸시에 &lt;code&gt;destory()&lt;/code&gt;를 호출하여 특정 작업을 수행하게 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JSR-250 스펙에서는 &lt;code&gt;@PostConstruct&lt;/code&gt;, &lt;code&gt;@PreDestory&lt;/code&gt; 어노테이션을 사용하는데, 일반적으로 최신 스프링 애플리케이션에서 생명 주기 콜백을 수신하기 위한 좋은 방법이다. 어노테이션을 사용한다는 것은 스프링이 특정 인터페이스에 결합되지 않는다는 것을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내부적으로 &lt;code&gt;SpringFramework&lt;/code&gt;는 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 구현을 사용하여 적절한 메서드를 찾아 호출할 수 있는 모든 콜백 인터페이스를 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;커스텀 기능이 필요하거나, 스프링이 기본적으로 제공하지 않는 다른 라이프 사이클 동작이 필요한 경우 &lt;code&gt;BeanPostProcessor&lt;/code&gt;를 직접 구현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398510-b8f21780-8d47-11eb-8584-09600530656c.png&#34; alt=&#34;Screen Shot 2021-03-25 at 8 54 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InitializingBean&lt;/code&gt; 인터페이스는 불 필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PostConstruct&lt;/code&gt; 주석을 사용하거나 &lt;code&gt;POJO&lt;/code&gt; 초기화 방법을 지정하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XML 기반 구성 메타 데이터의 경우 &lt;code&gt;init-method&lt;/code&gt; 속성을 사용하여 인수없는 빈 서명이 있는 메서드의 이름을 지정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 설정으로는 &lt;code&gt;@Bean&lt;/code&gt;의 &lt;code&gt;initMethod&lt;/code&gt; 속성을 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;여러 가지 방법으로 구현할 수 있지만, 인터페이스 방법은 권장하지 않는 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112398918-84cb2680-8d48-11eb-8b2a-29065259f433.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 00 11 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.beans.factory.DisposableBean&lt;/code&gt; 인터페이스를 구현하면 이를 포함하는 컨테이너가 소멸될 때, &lt;code&gt;Bean&lt;/code&gt;이 콜백을 받을 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스는 단일 메서드를 지정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기화와 같이 인터페이스 구현은 불필요하게 코드를 스프링에 연결하므로 사용하지 않는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또는 &lt;code&gt;@PreDestory&lt;/code&gt; 주석을 사용하거나 빈 정의에서 지원하는 일반 메서드를 지정하는 것이 좋습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112400248-4d11ae00-8d4b-11eb-9b5c-8de0b739da81.png&#34; alt=&#34;Screen Shot 2021-03-25 at 9 19 57 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 고유의 &lt;code&gt;InitializingBean&lt;/code&gt; 또는 &lt;code&gt;DisposableBean&lt;/code&gt; 콜백 인터페이스를 사용하지 않는 초기화 및 폐기 메서드 콜백을 작성할 때는 일반적으로 &lt;code&gt;init()&lt;/code&gt;, &lt;code&gt;initialize()&lt;/code&gt;, &lt;code&gt;dispose()&lt;/code&gt;등과 같은 이름으로 작성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이상적으로는 이러한 수명주기 콜백 메서드의 이름은, 모든 개발자가 동일한 메서드 이름을 사용하고 일관성을 보장하기 위함이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;그렇다면 InitializingBean과 DisposableBean 인터페이스를 구현하는 것과 @PostConstruct, @PreDestory를 사용하는 것의 차이점은 무엇일까?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans&#34;&gt;SPRING CORE DOCS 5.3.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 24 Mar 2021 09:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SOP에 대해서 정리해보았다.&lt;/li&gt;
&lt;li&gt;스프링 문서를 보면서, 세미나에서 들었던 내용을 다시 한번 보았다.&lt;/li&gt;
&lt;li&gt;빈 펙토리와 애플리케이션 컨텍스트의 차이에 대해서 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SOP에 대해서 정리하면서 CORS에 대해서도 알게 되었는데, 퍼즐이 맞춰지는 기분이였다.&lt;/li&gt;
&lt;li&gt;이전에는 CORS 에러가 발생했을 때, 왜 발생했는지 원인을 파악하고 해결 방법만 찾고나서 끝이였다. 하지만 중요한 것은 왜 브라우저에서 CORS 에러를 나게 했을까라는 근본적인 물음을 가지고, 해결하는 것이 중요하다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;막연히 문서를 바로 보는 것 보다 세미나를 통해서 전체적인 흐름을 한번 훓고 나서 문서를 보니까, 훨씬 이해도 잘되고 재미있었다.&lt;/li&gt;
&lt;li&gt;오늘 스프링 문서를 보면서 많은 것을 느꼈다. 오픈 소스에 기여하는 것에 굉장히 관심이 많은데 그 이유는 처음에는 단순하게 멋져보이기도 했고 학부때 예제 코드가 아닌 실제 대규모 프로젝트의 코드를 보고 싶었고 나도 개발을 해보고 싶었다. 따라서 오픈 소스에 기여를 할 때 문서가 아닌 주로 코드로만 기여하고 싶은 마음이 있었다. 하지만 오늘 완전히 그 생각이 깨졌다. 사실 문서로 기여하는 것도 굉장히 많은 지식을 가지고 있어야 가능하다는 것을 느끼게 되었다. 따라서 일단은 나와 같은 사람들이 굉장히 많은 도움을 받는 공식문서를 작성해보고 싶은 마음이 생겼다.&lt;/li&gt;
&lt;li&gt;동기와 같이 식사를 하는데, 발표를 어떻게 하면 잘할 수 있을까라는 고민을 했다. 단순하게 든 생각은 많이 해보지 않았기 때문에 그리고 평소에 내 생각을 정리해두지 않았기 때문에 말을 잘 못하는 것이라고 생각한다. 따라서 일단은 발표를 많이 해볼 수 있게 아무도 듣지 않더라도 일단 다른 사람에게 내가 아는 것을 설명해보는 연습을 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에서 보안을 위한 다양한 정책을 알 수 있었고, 어떠한 에러가 발생했을 때, 왜 이러한 에러를 발생시켰는지 브라우저, 운영체제, 프레임워크 설계자 관점에서 생각을 해봐야한다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;문서도 아는 놈이 작성한다. 우선 아는놈부터 되자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현상을 보지 말고, 원인을 파악하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예외, 에러 설계자 관점에서 이러한 예외 및 에러를 왜 발생시키게 하였는지를 고민하겠다.&lt;/li&gt;
&lt;li&gt;발표를 잘하기 위한 나의 생각은 우선 많이 해보는 것이다. 이제 곧 사내에서 자바스크립트 프로토타입과 관련해서 세미나 발표를 하는데, 발표 준비 및 실제로 연습을 많이 해보면서 발표 실력을 연마하자. 그리고 블로그에 글을 작성하듯이 유튜브에 채널을 운영 해보는 것도 좋은 생각인것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CSP(Content Security Policy) 란 무엇일까? (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/cspcontent-security-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP&#34;&gt;MDN - CSP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SOP(Same-origin policy) 란 무엇일까?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Tue, 23 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/sopsame-origin-policy-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>&lt;p&gt;브라우저 보안 정책에 &lt;code&gt;SOP(same-origin-policy)&lt;/code&gt; 있다는 것을 알게 되었고, 어떤건지 궁금해서 찾아보았다. 마침 MDN 문서에 잘 나와있어서 이를 참조할 수 있었다.&lt;/p&gt;
&lt;h3 id=&#34;same-origin-policy동일-출처-정책&#34;&gt;Same-Origin-Policy(동일 출처 정책)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112231170-8974d980-8c79-11eb-99e5-4a9b5f85513d.png&#34; alt=&#34;sop&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SOP&lt;/code&gt;는 한 &lt;code&gt;Origin&lt;/code&gt;에서 로드된 문서 또는 스크립트가 다른 &lt;code&gt;Origin&lt;/code&gt;의 리소스와 상호 작용할 수 있는 방법을 제한하는 중요한 보안 메커니즘이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안을 위협하는 문서를 격리하여, 보안 위협으로부터 보호할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한마디로 말해서 웹 브라우저에서 동작하는 프로그램은 로딩된 위치에 있는 리소스만 접근 할 수 있다는 정책이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;출처origin의-정의&#34;&gt;출처(Origin)의 정의&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112231662-78789800-8c7a-11eb-8897-048e15a11d65.png&#34; alt=&#34;origin&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;두개의 URL이 존재할 때 프로토콜, 포트(지정된 경우), 호스트가 동일한 경우 두 URL의 &lt;code&gt;Origin&lt;/code&gt;이 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 표를 보면 &lt;strong&gt;&lt;a href=&#34;http://store.company.com/dir/page.html&#34;&gt;http://store.company.com/dir/page.html&lt;/a&gt;&lt;/strong&gt; 과 비교하여, 같은 &lt;code&gt;Origin&lt;/code&gt;인지 아닌지를 나타내고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상속된-출처origin&#34;&gt;상속된 출처(Origin)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112232063-47e52e00-8c7b-11eb-8f7a-918fd0885a8a.png&#34; alt=&#34;inherited origins&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;about:blank&lt;/code&gt;, &lt;code&gt;javascript:URL&lt;/code&gt;과 같은 URL이 포함된 페이지에서 실행되는 스크립트는 해당 URL에 포함된 문서의 원본을 상속합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 유형의 URL에는 원본 서버에 대한 정보가 포함되어 있지 않기 때문입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Internet Explorer의 예외&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;항상 인터넷 익스플로러는 표준을 지키지 않아서 문제가 생기는 것 같다.&lt;/p&gt;
&lt;h4 id=&#34;trust-zones&#34;&gt;Trust Zones&lt;/h4&gt;
&lt;p&gt;만약 두 도메인이 모두 신뢰도가 높은 영역 (예: 회사 인트라넷 도메인)에 있는 경우 동일한 오리진 제한이 적용되지 않는다.&lt;/p&gt;
&lt;h4 id=&#34;port&#34;&gt;Port&lt;/h4&gt;
&lt;p&gt;IE는 동일 출처 검사에 포트를 포함하지 않는다. 따라서 &lt;code&gt;https://company.com:81/index.html&lt;/code&gt;과 &lt;code&gt;https://company.com/index.html&lt;/code&gt;은 같은 오리진으로 간주되며 제한은 적용되지 않는다.&lt;/p&gt;
&lt;h3 id=&#34;출처origin를-변경하기&#34;&gt;출처(Origin)를 변경하기&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;일부 제한 사항이 있는 페이지는 자체 출처를 변경할 수 있다.&lt;/li&gt;
&lt;li&gt;스크립트는 &lt;code&gt;document.domain&lt;/code&gt;의 값을 현재 도메인 또는 현재 도메인의 슈퍼 도메인으로 설정할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 이 기능은 동일한 출처 정책에서 제공하는 보안 보호 기능을 약화시키고 브라우저의 출처 모델을 복잡하게 하여, 상호 운용성 문제와 보안 버그를 유발하기 때문에 더 이상 사용되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112233574-0c982e80-8c7e-11eb-9ddb-0804823875c0.png&#34; alt=&#34;Document.domain&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 문서를 보더라도, 몇몇의 브라우저가 지원을 하더라도, 지금은 표준에서 제외되었고 사용하지 않는게 좋다고 나와있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 디프리케이트 상태이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서로-다른-출처-접근cross-origin-network-access&#34;&gt;서로 다른 출처 접근(Cross-origin network access)&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112234075-08b8dc00-8c7f-11eb-8c8b-293057534eff.png&#34; alt=&#34;another origin&#34;&gt;&lt;/p&gt;
&lt;p&gt;동일 출처 정책은 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 또는 &lt;code&gt;img&lt;/code&gt; 요소를 사용하는 경우와 같이 서로 다른 두 출처 간의 상호 작용을 제어한다. 이러한 상호작용은 다음과 같은 세 가지의 범주로 나누어진다.&lt;/p&gt;
&lt;h3 id=&#34;동일-출처-정책에-대한-처리&#34;&gt;동일 출처 정책에 대한 처리&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112746418-a39c1800-8fe9-11eb-8c98-afc0d95db147.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 웹 사이트 &lt;code&gt;http://sitea.com&lt;/code&gt;에서 자바스크립트를 로딩 한 다음에 이 스크립트에서, &lt;code&gt;http://api.my.com&lt;/code&gt;을 호출한다면 동일 출처 정책에 의해서 호출한다면 호출 에러가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이를 해결하는 방법으로는 인프라 측면에서 프록시를 사용하는 방법이나 &lt;code&gt;JSONP&lt;/code&gt;와 &lt;code&gt;CORS(Cross Origin Resource Sharing)&lt;/code&gt;이라는 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;프록시를-이용하는-방법&#34;&gt;프록시를 이용하는 방법&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프록시를 이용하는 경우에는 간단하게 해결된다. 동일 출처 정책의 문제는 &lt;code&gt;API&lt;/code&gt; 서버와 자바 스크립트가 호스팅 되는 서버의 URL이 달라서 문제가 발생하게 된다. 이를 앞단에 &lt;code&gt;Reverse Proxy&lt;/code&gt;를 넣어서 전체 URL이 같게 만들어주면 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 구조가 되면, 자바 스크립트가 로딩된 사이트도 &lt;code&gt;mysite.com&lt;/code&gt;이 되고 자바스크립트에서 호출하고자 하는 &lt;code&gt;API&lt;/code&gt; URL도 &lt;code&gt;mysite.com&lt;/code&gt;이 되기 때문에 동일 출처 정책에 위배되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 간단하지만, 자사의 웹 사이트를 서비스하느 경우에만 가능하다. 그래서 자사의 서비스용 &lt;code&gt;API&lt;/code&gt;를 만드는 경우에는 괜찮지만, 파트나사나 일반 개발자에게 자바스크립트용 &lt;code&gt;REST API&lt;/code&gt;를 공개하는 경우에는 적절하지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;특정-사이트에-대한-접근-허용-방식&#34;&gt;특정 사이트에 대한 접근 허용 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CROS 방식 중 이 방식은 가장 간단한 방식으로, &lt;code&gt;API&lt;/code&gt; 서버의 설정에서 모든 소스에서 들어오는 &lt;code&gt;API&lt;/code&gt; 호출을 허용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 &lt;code&gt;HTTP&lt;/code&gt;로 &lt;code&gt;API&lt;/code&gt;를 호출하였을 때 HTTP에 요청에 응답을 주면서 HTTP 헤더에 &lt;code&gt;Request Origin&lt;/code&gt;(요청을 처리해 줄 수 있는 출처)를 명시하는 방식이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;api.my.com&lt;/code&gt;에서 응답 헤더에 다음과 같이 명시해주면 &lt;code&gt;sitea.com&lt;/code&gt;에 의해서 로딩된 자바스크립트 클라이언트 요청에 대해서만 &lt;code&gt;api.my.com&lt;/code&gt;이 요청해준다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Access-Controll-Allow-Origin: sitea.com
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;만약에 다음과 같이 &lt;code&gt;*&lt;/code&gt;로 해주면 &lt;code&gt;Request Origin&lt;/code&gt;에 관계없이 사이트에서 로딩된 자바스크립트 요청에 대해서 처리해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;pre-flight를-이용한-세세한-cors-통제&#34;&gt;Pre-flight를 이용한 세세한 CORS 통제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REST&lt;/code&gt; 리소스(URL)당 섬세한 &lt;code&gt;CORS&lt;/code&gt; 통제가 필요한 경우에는 &lt;code&gt;Pre-Flight&lt;/code&gt; 호출이라는 것을 이용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 방식은 &lt;code&gt;REST&lt;/code&gt; 리소스를 호출하기 전에, 웹 브라우저가 &lt;code&gt;HTTP OPTIONS&lt;/code&gt; 요청을 보내면 해당 &lt;code&gt;REST&lt;/code&gt; 리소스에 대해서 가능한 &lt;code&gt;CORS&lt;/code&gt; 정보를 보내준다. (접근이 허용된 사이트, 접근이 허용된 메서드 등)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저에서는 &lt;code&gt;XMLHttpRequest&lt;/code&gt;를 특정 &lt;code&gt;URL&lt;/code&gt;로 요청하기 전에, &lt;code&gt;HTTP OPTIONS&lt;/code&gt;를 호출한다. 그러면 서버는 해당 &lt;code&gt;URL&lt;/code&gt;에 접근할 수 있는 &lt;code&gt;Origin URL&lt;/code&gt;과 &lt;code&gt;HTTP&lt;/code&gt; 메서드를 반환해준다. 이를 &lt;code&gt;Pre-flight&lt;/code&gt; 호출이라고 하는데, 이 정보를 바탕으로 해당 &lt;code&gt;URL&lt;/code&gt;에 &lt;code&gt;XMLHttpRequest&lt;/code&gt;를 보낼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로는 교차 오리진 쓰기가 허용된다, 예를 들어 링크, 리디렉션 및 &lt;code&gt;form&lt;/code&gt; 제출이 있다. 일부 HTTP 요청에서는 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests&#34;&gt;preflight&lt;/a&gt; 가 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112240206-402d8580-8c8b-11eb-9c2c-849a644bfdd7.png&#34; alt=&#34;preflight_correct&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;preflight&lt;/code&gt; 요청이란 일반적인 요청과 다르게, 먼저 &lt;code&gt;OPTIONS&lt;/code&gt; 메서드를 사용하여 HTTP 요청을 다른 출처(&lt;code&gt;Origin&lt;/code&gt;) 리소스로 전송하여 실제 요청이 안전한지 확인하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;교차 사이트 요청은 사용자 데이터에 영향을 미칠 수 있으므로 &lt;code&gt;preflight&lt;/code&gt;을 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버는 이 &lt;code&gt;URL&lt;/code&gt;에 대한 접근 권한을 반환한다, &lt;code&gt;CORS&lt;/code&gt; 접근이 가능한 &lt;code&gt;Origin&lt;/code&gt; 사이트를 반환하고 사용할 수 있는 메서드를 반환한다. 그리고 &lt;code&gt;Pre-flight&lt;/code&gt; 호출은, &lt;code&gt;Access-Control-Max-Age&lt;/code&gt;에 정의된 &lt;code&gt;86400&lt;/code&gt; 초 동안 유효하다. (한번 &lt;code&gt;Pre-flight&lt;/code&gt; 호출을 하고 나면, 이 시간 동안은 다시 &lt;code&gt;Pre-flight 호출을 할 필요가 없다&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 &lt;code&gt;CORS&lt;/code&gt; 설정은 &lt;code&gt;API&lt;/code&gt; 호출 코드에서 직접 구현할 수 도 있고 로드 밸런서 역할을 하는 &lt;code&gt;HAProxy&lt;/code&gt;나 &lt;code&gt;Nginx&lt;/code&gt; 같은 리버스 프록시 설정을 통해서 간단하게 처리할 수도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 &lt;code&gt;API&lt;/code&gt; 단에서 구현이 필요하더라도, &lt;code&gt;HTTP&lt;/code&gt; 헤더를 직접 건드리지 않아도 스프링 등의 프레임워크에서 이미 &lt;code&gt;CORS&lt;/code&gt; 구현을 지원하고 있으므로 프레임워크를 통해서 간단하게 구현하는 것을 추천한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;&gt;MDN - SOP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 23 Mar 2021 21:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 정리했던 블로그 글을 정해서, 남이 궁금해서 물어볼 때, 설명을 할 수 있는지 알아보기 위해, 녹화를 해보았다.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 보안이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;분명히 알고 있다고 생각한 것인데도 불구하고 정리가 되지 않아 버벅거리고 힘들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;블로그에 기술적인 내용을 정리하고, 스스로 제대로 이해하고 있는지 문제를 만들어서 직접 풀어보도록 해야겠다. 그리고, 이를 스스로 녹화해보면서 다른 사람이 내 설명을 어떻게 들었는지 테스트 해본다면 좋을 것이다.&lt;/li&gt;
&lt;li&gt;저자는 보안에서, 정찰이 매우 중요한 주제임을 깨달았다고 한다. 이유는 첫 째, 공격의 우선순위를 알아야하기 때문이다. 방어가 잘된 시스템은 어떤 유형의 공격을 받더라도, 로그를 남길 것이기 때문이다. 이는 같은 공격이 두 번 다시는 통하지 않기 때문이다.&lt;/li&gt;
&lt;li&gt;과거의 해커들은 서버, 네트워크, 브라우저를 공격하는데 집중했지만, 보안성이 높아져서 요즘에는 애플리케이션 코드의 취약점을 침투하는데 집중한다.&lt;/li&gt;
&lt;li&gt;새로운 기술에는 고유한 공격면과 취약점이 있다.&lt;/li&gt;
&lt;li&gt;이는 새로운 기술을 도입하는 일이 단순히 러닝 커브 및 기술 적합성을 고려하는 것 뿐만 아니라 보안 이슈도 고려해야한다는 것을 깨닫게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;설명을 잘하기 위해서는 자주 시도해보고, 피드백을 받는 것이 중요하다. 따라서 자주 설명하는 연습을 하자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;글로 정리하고 끝내는 것이 아니라, 내가 제대로 알고 있는지 동료에게 제대로 설명할 수 있는지를 테스트하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP 및 네트워크 계층 및 RFC 791 (draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/tcp/ip-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EB%B0%8F-rfc-791-draft/</guid>
      <description>&lt;h3 id=&#34;네트워크-통신&#34;&gt;네트워크 통신&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112009913-2ba59c00-8b6a-11eb-96f4-c8e28e12bb05.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 통신은 관점에 따라 &lt;code&gt;OSI 7&lt;/code&gt; 모델과 &lt;code&gt;TCP/IP&lt;/code&gt; 모델 두가지로 설명할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OSI 7&lt;/code&gt; 모델은 1984년에 &lt;code&gt;ISO&lt;/code&gt; (국제 표준화 기술)에 의해 표준화되었고, 통신이 이루어지는 과정을 단계별로, 파악할 수 있도록 7 개의 계층인 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구분되어 있으며 네트워크 구현을 연구하고 배우기에 적합한 구조다.&lt;/li&gt;
&lt;li&gt;반면에, &lt;code&gt;TCP/IP&lt;/code&gt; 모델은 현장에 많이 사용하는 기술 위주로 4계층으로 단순화한 모델로, 실제 사용하는 프로토콜 규약은 이 모델을 따르고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네트워크-계층&#34;&gt;네트워크 계층&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;네트워크 계층은 데이터를 전송할 수 있는 여러 경로 중 가장 안전하고 빠른 경로를 찾아주는 역할을 하는 라우팅을 수행하며, 데이터를 다른 네트워크로 전달하여 인터넷을 가능하게 만들어주는 계층이다.&lt;/p&gt;
&lt;h4 id=&#34;ip-프로토콜&#34;&gt;IP 프로토콜&lt;/h4&gt;
&lt;p&gt;네트워크 계층에서 운영되는 IP 프로토콜에는 목적지 위치를 알려주는 고유한 32비트의 주소 값이 있으며, 이를 IP 주소라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112010844-036a6d00-8b6b-11eb-984e-082bf51904f7.jpg&#34; alt=&#34;addressing-design-network-host-1024x576&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP 주소는 네트워크 부분과 호스트로 구분되는데, 위의 그림과 같이 지역을 대표하는 부분을 네트워크, 지역별 사용자 PC에 할당하는 것을 호스트라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;rfc-791&#34;&gt;RFC 791&lt;/h4&gt;
&lt;p&gt;더 자세히 알아보고 싶은 마음에 RFC 791 문서를 살펴보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/112071041-5e738280-8bb2-11eb-80a8-472ff7e6aef9.png&#34; alt=&#34;Screen Shot 2021-03-23 at 8 32 38 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;위의 문서는 개요 및 동기 그리고, 범위, 인터페이스에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 패킷을 교환을 통해 상호 연결된 시스템에서 사용하도록 설계 되었다.&lt;/li&gt;
&lt;li&gt;이러한 시스템을 &lt;code&gt;catenet&lt;/code&gt; 이라고 부른다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 데이터그램(&lt;code&gt;datagram&lt;/code&gt;)이라는 데이터 블록들을 소스에서부터 목적지까지 전송한다.&lt;/li&gt;
&lt;li&gt;여기서 말하는 소스 및 목적지는 고정된 길이의 주소로 식별되는 호스트다.&lt;/li&gt;
&lt;li&gt;또한 인터넷 프로토콜은 작은 패킷을 다루는 네트워크를 위해 긴 데이터그램을 조각화하여 나누거나 및 작게 나누어진 데이터그램을 재조립을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;범위&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 프로토콜은 특별히 범위를 한정하여 다음과 같은 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;상호 연결된 네트워크 시스템을 통해서 소스에서 목적지까지 비트 패키지(데이터그램)을 전달하는데 필요한 기능이다.&lt;/li&gt;
&lt;li&gt;호스트 간의 프로토콜에서 일반적으로 볼 수 있는 엔드 투 엔드 데이터 신뢰성, 흐름 제어, 시퀀싱, 그리고 기타 서비스를 강화하는 메커니즘은 없다.&lt;/li&gt;
&lt;li&gt;인터넷 프로토콜은 지원 네트워크의 서비스를 활용하여 다양한 서비스 유형과 품질을 제공할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;인터페이스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 프로토콜은 네트워크 환경에서 호스트 대 호스트 프로토콜에 의해서 호출된다.&lt;/li&gt;
&lt;li&gt;이 프로토콜은 인터넷 데이터그램을 다음 게이트웨이 또는 대상 호스트로 이동하기 위해 로컬 네트워크 프로토콜을 호출한다.&lt;/li&gt;
&lt;li&gt;예를 들어, TCP 모듈이 네트워크 모듈을 호출하여, TCP 세그먼트(TCP 헤더 및 사용자 정보를 포함)를 사용한다.&lt;/li&gt;
&lt;li&gt;TCP 세그먼트는 데이터 그램의 일부이다.&lt;/li&gt;
&lt;li&gt;TCP 모듈은 인터넷 헤더의 주소와 기타 매개변수를 인수로 네트워크 모듈에게 제공한다.&lt;/li&gt;
&lt;li&gt;그러면 네트워크 모듈은 데이터 그램을 만들고 데이터그램을 전송하기 위해서 로컬 네트워크 인터페이스를 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc791&#34;&gt;RFC 791&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>최근에 애플리케이션 보안에 관심을 가지게 된 이유</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 22 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/%EC%B5%9C%EA%B7%BC%EC%97%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88%EC%97%90-%EA%B4%80%EC%8B%AC%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/</guid>
      <description>&lt;p&gt;최근에 내가 웹 애플리케이션 보안에 대해서 굉장히 무관심함을 알게 됨과 동시에 데이터베이트 연결이 끊어지는 네트워크 통신과 관련된 장애가 있었다.&lt;/p&gt;
&lt;p&gt;장애의 이유를 알지 못하니까 굉장히 답답함과 동시에 문제를 해결할 수 없었다. 따라서 디버깅을 하듯이 네트워크 패킷을 분석해서 원인을 알아 낼 수 있으면 굉장히 좋을 것 같다는 생각을 함과 동시에 내가 주도하면서 진행하는 토이 프로젝트가 보안에 대해서 굉장히 견고한 애플리케이션이 되었으면 하는 마음이 있다.
따라서, 앞으로 웹 애플리케이션 보안에 대해서 공부하고 견고한 시스템을 구축해나갈 생각이다.&lt;/p&gt;
&lt;p&gt;책에서는 다루는 대부분의 내용이 네트워크 공격을 패킷 단위로 분석하고 있다. 실제로도 공격 대응을 위한 분석 단계에서 패킷을 분석하는 빈도가 상당히 높다고 한다. 나는 보안 전문가보다는 웹 애플리케이션 개발자에 가깝기 때문에 실무적으로 패킷을 분석해서 보안 위협을 감지하는 일은 없을 확률이 높지만, 네트워크에 대해서 내부 원리까지 깊게 이해하는 것이 목표이므로, 많은 도움이 될 것 같다.&lt;/p&gt;
&lt;p&gt;첫 장에서는 인터넷 통신의 표준 프로토콜인 &lt;code&gt;TCP/IP&lt;/code&gt;의 계층별 헤더의 구조에 대해서 패킷 단위로 소개하고 있고, 주로 네트워크 공격에 사용되는 네트워크 계층의 &lt;code&gt;IP&lt;/code&gt; 프로토콜과 전송 계층의 &lt;code&gt;TCP&lt;/code&gt;, &lt;code&gt;UDP&lt;/code&gt; 프로토콜의 구조에 대해서 설명하고 있다.&lt;/p&gt;
&lt;p&gt;책에서는 한 번에 모든 개념을 숙지하기 보다는, 필요할 때, 찾아보며 각 헤더의 구조를 조금씩 명확히 새기는 것을 권장하고 있다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=217703927&#34;&gt;네트워크 공격 패킷 분석, 프리렉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 22 Mar 2021 20:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아커스 이슈 구현을 하는데, 전체적인 흐름 및 구현 위치는 파악을 하였으나, 자료구조를 정확히 파악하지 못해서, 어디서부터 손대야할지 감이오지 않고, 깊은 이해를 하기 힘들었다.&lt;/li&gt;
&lt;li&gt;대학교 동기들과 토이프로젝트를 시작했다.&lt;/li&gt;
&lt;li&gt;회사에서 일하면서 소프트웨어 스펙을 정하고 어떤 것을 만들지 구체화 하는 과정이 중요하다는 것을 깨달았기 때문에, 지루하기는 하지만 작성하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 주관해서 이끌어 가는 일이 힘들것이라고 예상했지만 생각보다 많은 공수가 들었다.&lt;/li&gt;
&lt;li&gt;그래도 처음이 가장 힘들것이라고 생각하고 프로세스가 정립되면 쉬워질 것이다.&lt;/li&gt;
&lt;li&gt;흐름을 대략적으로 파악하고나서, 흐름을 관통하는 자료구조를 파악할 필요를 느끼게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 이끌어 가는 과정은 힘들지만 재미있기도 하다.&lt;/li&gt;
&lt;li&gt;프로젝트를 구현하고 있는, 자료구조를 제대로 파악하지 못하면 이해를 할 수 없고, 더 이상 나아갈 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 이끌어 가는 만큼 내가 솔선 수범을 보이고, 모든 일을 다 하려고 하지말고 어떻게 일을 하는지 방식을 공유하고 일을 나누자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;혼자서 할 수 있는 일은 한정적이다. 같이 일을 할 수 있는 방식을 공유하고 일을 나누자.&lt;/li&gt;
&lt;li&gt;개략적인 모듈의 인터페이스 시작점 및 흐름을 파악했다면 그 흐름을 관통하고 있는 자료구조에 대해서 공부를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 21 Mar 2021 17:15:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/21/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩을 하면서, 사소한 실수가 발견되었고 재배포를 해야하는 상황이 되었다.&lt;/li&gt;
&lt;li&gt;내가 아는 것을 다른사람에게 설명하는데 생각보다 말이 잘 나오지 않았고, 더듬더듬 말하고 있었다.&lt;/li&gt;
&lt;li&gt;오랜만에 코딩 테스트 문제를 풀어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들에게 미안하기도 했고, 시간이 많이 소모되었다.&lt;/li&gt;
&lt;li&gt;다른 사람에게 쉽게 설명할 수 없으면 제대로 아는 것이 아니라는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;남들이 꺼려하는 일을 먼저 나서서 하려고 하는 자세가 동료들에게 신뢰를 줄 수 있을 것같다.&lt;/li&gt;
&lt;li&gt;문제의 난이도가 생각보다 높지 않아서 그런지는 몰라도 매우 재미있었다.&lt;/li&gt;
&lt;li&gt;취업 준비를 할 때, 코딩 테스트 문제를 푸는 것과 직장에 다니는 입장에서 코딩 테스트 문제를 푸는 느낌이 달랐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 사소한 실수가 다른 사람들의 시간을 많이 소모시키는 것을 알 수 있었다.
꼼꼼하게 확인하여 다른 사람들에게 피해를 끼치는 일이 없도록 하자.&lt;/li&gt;
&lt;li&gt;어떤 개념을 제대로 배웠는지 확인하려면 내가 배운 내용을 다른 사람에게 설명을 해보자.&lt;/li&gt;
&lt;li&gt;배우는 속도에 집착하기 보다는 하나라도, 제대로 알고 있는지, 남에게 설명할 수 있는지를 확인하자.&lt;/li&gt;
&lt;li&gt;웹 애플리케이션을 구성하는 부분을 전체적으로 공부해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;보안에 대해서는 나의 일이 아니고, 보안 전문가의 일이라고 생각했던 경향이 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;앞으로 토이프로젝트를 할 때는 기능도 신경을 많이 쓰지만 보안에 대한 점도 많은 공부를 하고 신경을 쎠서 공부를 해야할 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt; 설계에 대한 부분을 소흘히 한 것 같다. 어떻게 하면 좋은 &lt;code&gt;API&lt;/code&gt;를 설계할 수 있을지에 대해서 공부를 하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;하나라도 제대로 공부하는 것이 중요하기는 하지만, 서버 및 브라우저의 내부 원리에 대해서 깊게 공부할 필요를 느끼게 되었다. 사실 &lt;code&gt;DevOps&lt;/code&gt; 팀에서 인프라 관리를 하기는 하지만, 이러한 부분도 잘 알아야지 좋은 개발자가 될 것 같다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 풀면서 코드부터 구현하는 것보다 내가 어떻게 구현할지를 미리 생각하고 나서 코드를 작성하니까 훨씬 재미있고 문제도 잘 풀리는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 했던 일을 다른 동료들에게 공유하려고 노력하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꼼곰히 코딩하는 습관을 들이자.&lt;/li&gt;
&lt;li&gt;말을 잘 할 수 있도록 평소에 발표를 연습해야겠다.&lt;/li&gt;
&lt;li&gt;어떤 일을 하다보니 생활 리듬이 깨지는 경우가 있는데 이를 주의해야겠다.&lt;/li&gt;
&lt;li&gt;하루에 조금씩이라도 운동하는 습관을 들이거나 주말에 어떤 스포츠 배워야겠다는 생각을 했다. 장기적으로 보았을 때 스트레스 관리를 잘 하는 것이 멀리 갈 수 있는 방법일 것이다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 풀 때 다양한 예외 사항 및 제약 조건을 미리 생각해야하는데 다양한 예외 케이스에 대한 고려를 더 잘하려고 노력해야할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 커밋하기 전에, 오타는 없는지 꼼꼼히 확인하자.&lt;/li&gt;
&lt;li&gt;다른 사람들 앞에서 내가 알고 있는 내용을 설명하자.&lt;/li&gt;
&lt;li&gt;보안도 애플리케이션의 한 요소라고 생각하고 열심히 공부하자.&lt;/li&gt;
&lt;li&gt;토이프로젝트를 잘 진행하고 계속 유지보수를 하면서 발전시켜나가자.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 20 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오랜만에 코딩 테스트 문제를 풀어봤다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;직장을 구하기 전에는 코딩 테스트가 그저 스트레스였는데, 오랜만에 풀어보니까 매우 재미있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;재귀를 활용해서 푸는 문제가 있었는데 재귀를 이용하니까 너무 시간이 오래 걸렸다. 따라서 메모이제이션을 공부하고 이를 이용해서 풀 수 있는지 생각을 해봐야할 것 같다.&lt;/li&gt;
&lt;li&gt;추가로 다이나믹 프로그래밍을 이용해서 문제를 푸는 방법 및 &lt;code&gt;DFS&lt;/code&gt; &lt;code&gt;BFS&lt;/code&gt; 문제를 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 평소에 풀어보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제 풀면서 코드를 작성하기 전에 어떻게 풀지, 시간 복잡도 및 공간 복잡도에 대해서 생각을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy 세션(draft)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft/</link>
      <pubDate>Fri, 19 Mar 2021 16:40:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/19/sqlalchemy-%EC%84%B8%EC%85%98draft/</guid>
      <description>&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 19 Mar 2021 07:07:36 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 REST DOCS를 이용해서 문서화하는 법에 대해서 배울 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 애플리케이션 보안에 대해서 더 많이 배우기 위해서 다음과 같은 책을 구매했다.&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=263537948&#34;&gt;웹 애플리케이션 보안&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이번에 GC 및 JVM에 대해서 더 자세히 알고 싶어서 책을 구매 하였다. &lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=32526713&#34;&gt;자바 성능 튜닝이야기&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버와 브라우저에 대해서 앞으로 더 깊게 공부를 해야겠다는 마음을 먹었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 부족한 점을 채우기 위해서 더 열심히 공부를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;자바독을 작성할 때는, 문장이 자연스럽게 읽히는 형태로 만들어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111706690-0bce5980-8886-11eb-85c0-9030bdc9cdd7.png&#34; alt=&#34;Screen Shot 2021-03-19 at 7 37 24 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 사진을 보면, &lt;code&gt;Returns&lt;/code&gt; 항목에 중복되어서 &lt;code&gt;Returns&lt;/code&gt; 라는 문장으로 시작하는데 이는 별로 좋지 않다.&lt;/li&gt;
&lt;li&gt;블로그에, 코드를 첨부할 때, GIST를 이용하면 더 좋을 것 같다. &lt;a href=&#34;https://gohugo.io/content-management/shortcodes/&#34;&gt;GIST&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서화에 대해서 더 많은 생각을 해봐야 할 것 같다.&lt;/li&gt;
&lt;li&gt;내가 세운 목표를 달성하기 위해서 노력하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 가치있게 사용하기 위해서 노력하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 18 Mar 2021 22:11:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘은 회사에서 배포를 기다리고 문제가 생겼을 때, 대응하기 위해서 대기하는 시간이 많았고, 이때 평소에 궁금했던 것과 현재 프로젝트에 적용하면 좋을 기술들을 찾아보고 정리하였다.&lt;/li&gt;
&lt;li&gt;같은 솔루션을 진행하는 선배에게 프로젝트에 트랜잭션 처리를 위해서 조사를 하고 있다고 솔직하게 말하고 공부를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션에 대해서 공부하게 되었는데, &lt;code&gt;SQLAlchemy&lt;/code&gt; 에서 트랙잭션을 사용하느 법과 세션마다 고립 레벨을 설정하는 법에 대해서 배우게 되었다.&lt;/li&gt;
&lt;li&gt;하지만, 현재 프로젝트에 어떻게 적용하면 좋을지 조금 막막했다. 따라서 데이터베이스를 잘 아는 선배들에게 물어봐야겠다.&lt;/li&gt;
&lt;li&gt;솔직하게 말하니까, 나도 몰래 딴짓하는 기분도 안들고 선배가 이해해줘서 고마웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션을 어떻게 설계해야할지에 대해서 고민을 할 필요가 있을 것 같다.&lt;/li&gt;
&lt;li&gt;분산 트랜잭션 처리에 대해서도 조금 알게 되었는데, &lt;code&gt;2PC&lt;/code&gt;, &lt;code&gt;SAGA&lt;/code&gt; 패턴등 재미있는 기술들이 많이 있었다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서 고립 수준에 따라서 발생하는 이상 현상들 (&lt;code&gt;Dirty Read&lt;/code&gt;, &lt;code&gt;Non Repetable Read&lt;/code&gt;, &lt;code&gt;Phantom Read&lt;/code&gt;)에 대해서 알게 되었고, 데이터베이스의 고립 수준 유형에 대해서 알게 되었다. (&lt;code&gt;Read Uncommited&lt;/code&gt;, &lt;code&gt;Read Commited&lt;/code&gt;, &lt;code&gt;Repetable Read&lt;/code&gt;, &lt;code&gt;Serializable&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;아직 데이터베이스에 대해서 모르는 것이 많은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들이 꺼려하는 일을 먼저 나서서 하려고 노력할 필요가 있을 것 같다.&lt;/li&gt;
&lt;li&gt;최근에 생활 리듬이 깨진 것 같다 빨리 정상화 시키도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;남들이 꺼려하는 일을 시키지 않아도 나서서 하여, 동료들에게 신뢰를 얻고 같이 일하고 싶은 개발자가 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SQLAlchemy에서 트랜잭션 사용법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95/</link>
      <pubDate>Thu, 18 Mar 2021 13:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/18/sqlalchemy%EC%97%90%EC%84%9C-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%82%AC%EC%9A%A9%EB%B2%95/</guid>
      <description>&lt;p&gt;회사에서 이슈 진행을 하다가, 트랜잭션를 이용하여 처리해야하는 부분을 발견하였다.
따라서 &lt;code&gt;SQLAlchemy&lt;/code&gt;에서는 트랜잭션을 어떻게 사용하는지 정리해보도록 하겟다.&lt;/p&gt;
&lt;h2 id=&#34;트랜잭션-관리하기&#34;&gt;트랜잭션 관리하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111575492-ce1ff100-87f1-11eb-9999-bef313b83749.png&#34; alt=&#34;Screen Shot 2021-03-18 at 1 56 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새롭게 생성된 세션은 &lt;code&gt;begin()&lt;/code&gt; 상태이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin()&lt;/code&gt; 상태에서 &lt;code&gt;Session&lt;/code&gt;은 아직 어떠한  &lt;code&gt;Connection&lt;/code&gt; 및  &lt;code&gt;Transactional&lt;/code&gt;과 연관되지 않았다.&lt;/li&gt;
&lt;li&gt;그러한 다음에, &lt;code&gt;Session&lt;/code&gt; 은 데이터베이스 커넥션 요청을 수신한다.&lt;/li&gt;
&lt;li&gt;일반적으로, 이것은 &lt;code&gt;Engine&lt;/code&gt;을 이용하여, 특정 &lt;code&gt;SQL&lt;/code&gt; 문을 수행해야하는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;특정 &lt;code&gt;SQL&lt;/code&gt;문의 수행은 &lt;code&gt;Session.query()&lt;/code&gt;, &lt;code&gt;Session.execute()&lt;/code&gt; 통해 이루어지고  &lt;code&gt;Session.commit()&lt;/code&gt;, &lt;code&gt;Session.flush()&lt;/code&gt;를 할 때 보류된 변경 사항을 비우고 커밋하면서 발생합니다.&lt;/li&gt;
&lt;li&gt;이러한 요청이 수신되면, 새로운 엔진 각각이 세션에서 유지되고 관리하는 트랜잭션 상태와 연결이 된다.&lt;/li&gt;
&lt;li&gt;첫 번째, 엔진이 작동하면 세션은 &lt;code&gt;begin&lt;/code&gt; 상태를 떠나서, &lt;code&gt;transactional&lt;/code&gt; 상태로 전환되었다고 할 수 있다.&lt;/li&gt;
&lt;li&gt;각각의 엔진에 대해서 연결이 되어 있으며, 이러한 연결은 &lt;code&gt;Engine.contextual_connect()&lt;/code&gt; 메서드를 통해서 획득된다.&lt;/li&gt;
&lt;li&gt;롤백 또는 커밋 후에 트랜잭션 상태가 완료되면 모든 트랜잭션 및 연결 리소스를 해제하고, &lt;code&gt;begin&lt;/code&gt; 상태로 돌아간다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;begin&lt;/code&gt; 상태로 돌아가면, 다시 새로운 &lt;code&gt;SQL&lt;/code&gt; 문을 내보내는 새 요청이 수신될 때 새로운 &lt;code&gt;Connection&lt;/code&gt; 및 &lt;code&gt;Transaction&lt;/code&gt; 객체를 다시 호출합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 위의 라이프 사이클을 보여주는 예제이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;engine = create_engine(&amp;quot;...&amp;quot;)
Session = sessionmaker(bind=engine)

# 새로운 세션, 어떤 커넥션도 사용중이지 않다.
session = Session()
try:
    # 첫 번째 쿼리를 수행하면, 커넥션을 엔진으로 부터 획득하고
    # 트랜잭션이 시작된다.    
    item1 = session.query(Item).get(1)

    # 두 번째 쿼리이다. 같은 커넥션과 트랜젝션이 사용된다.
    item2 = session.query(Item).get(2)

    # 아직 반영되지 않은 변경 사항이 생성된다.
    item1.foo = &#39;bar&#39;
    item2.bar = &#39;foo&#39;
    
    # 커밋을 수행한다.
    # 아직 반영되지 않은 변경사항이 모두 `flush` 된다.
    # 트랜잭션이 커밋되고, 연결 객체가 닫치고 사라진다.
    # DBAPI 연결이 커넥션 풀로 반환된다.
    session.commit()
except:
    # 롤백시에도, 커미과 동일한 상태 종료가 진행된다.
    session.rollback()
    raise
finally:
    # 세션을 닫는다, 이렇게 하면 남아 있는 모든 객체가 영구적으로 삭제되며, 기존 SessionTransaction 상태가 재설정 된다.
    # 일반적으로 이러한 단계는 필수는 아니지만,
    # commit() 또는 rollback() 자체에 예기치 않은 내부 오류가
    # 발생한 경우 close()는 유효하지 않은 상태가 제거되도록 한다.
    session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;savepoint-사용하기&#34;&gt;SAVEPOINT 사용하기&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;기본 엔진에서 지원하는 경우, &lt;code&gt;SAVEPOINT&lt;/code&gt; 트랜잭션은 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드를 사용할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Session = sessionmaker()
session = Session()
session.add(u1)
session.add(u2)

session.begin_nested() # establish a savepoint
session.add(u3)
session.rollback()  # rolls back u3, keeps u1 and u2

session.commit() # commits u1 and u2
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt;는 여러 번 호출 될 수 있으며, 각 호출에 대해서 고유한 식별자가 있는 새로운 SAVEPOINT를 발행합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각각의 &lt;code&gt;Session.begin_nested()&lt;/code&gt; 호출에 대해서, &lt;code&gt;Session.rollback()&lt;/code&gt;또는, &lt;code&gt;Session.commit()&lt;/code&gt;을 수행 해야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러나 반환 값이 컨텍스트 매니저에 의해서 사용되는 경우 예를 들어서 &lt;code&gt;with&lt;/code&gt; 문에서 &lt;code&gt;rollback&lt;/code&gt; 및 &lt;code&gt;commit&lt;/code&gt;은 컨텍스트를 종료할 때, 컨텍스트 관리자가 실행하므로 명시적으로 추가해서는 안된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Session.begin_nested()&lt;/code&gt; 메서드는 &lt;code&gt;Session.begin()&lt;/code&gt;을 덜 사용하기 위해서 사용하며 컨텍스트 매니저로 작동하는 &lt;code&gt;SessionTransaction&lt;/code&gt;을 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발 레코드를 삽입할 때, 유용하게 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for record in records:
    try:
        with session.begin_nested():
            session.merge(record)
    except:
        print(&amp;quot;Skipped record %s&amp;quot; % record)
session.commit()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;트랜잭션-격리-수준-설정--dbapi-autocommit&#34;&gt;트랜잭션 격리 수준 설정 / DBAPI AUTOCOMMIT&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111587615-d08c4600-8805-11eb-8a03-8f3379b7a441.png&#34; alt=&#34;Screen Shot 2021-03-18 at 4 20 02 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 &lt;code&gt;DBAPI&lt;/code&gt;는 설정할 수 있는 트랜잭션 격리 수준의 개념을 지원한다.&lt;/li&gt;
&lt;li&gt;전통적으로 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;, &lt;code&gt;READ COMMITED&lt;/code&gt;, &lt;code&gt;REPEATABLE READ&lt;/code&gt;, 및 &lt;code&gt;SERIALIZABLE&lt;/code&gt;의 네 가지 수준이 있다.&lt;/li&gt;
&lt;li&gt;이는 일반적으로 새로운 트랜잭션을 사용하기 전에, &lt;code&gt;DBAPI&lt;/code&gt; 연결에 적용되며 대부분의 DBAPI는 SQL문이 처음 생성될 때, 트랜잭션을 암시적으로 시작한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;는 &lt;code&gt;create_engine&lt;/code&gt; 수준과, &lt;code&gt;Connection.execution_options()&lt;/code&gt; 수준 모두에서 플래그를 사용하여 엔진 별 또는 연결 별로 설정 가능한 격리 모드를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;세션-메이커-및-엔진-전체에-대한-고립-수준-설정&#34;&gt;세션 메이커 및 엔진 전체에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;전역 적으로 특정 고립 수준으로 &lt;code&gt;Session&lt;/code&gt; 또는 &lt;code&gt;Session Maker&lt;/code&gt;를 설정하려면 첫 번째 기술은 모든 경우에 특정 격리 수준에 대해서 엔진을 설정한 다음에, 세션 메이커의 연결 소스로 사용하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(
    &amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;,
    isolation_level=&#39;REPEATABLE READ&#39;
)

Session = sessionmaker(eng)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서로 다른 격리 수준을 가진 두 개의 엔진이 있는 경우 유용한 다른 옵션은 &lt;code&gt;Engine.execution_options()&lt;/code&gt; 메서드를 사용하는 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

eng = create_engine(&amp;quot;postgresql://scott:tiger@localhost/test&amp;quot;)

autocommit_engine = eng.execution_options(isolation_level=&amp;quot;AUTOCOMMIT&amp;quot;)

transactional_session = sessionmaker(eng)
autocommit_session = sessionmaker(autocommit_engine)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;위의 &lt;code&gt;eng&lt;/code&gt;과 &lt;code&gt;autocommit_engine&lt;/code&gt;은 동일한 연결 풀을 공유합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AUTOCOMMIT&lt;/code&gt; 모드는 &lt;code&gt;autocommit_engine&lt;/code&gt;에서 연결할 때 따로 설정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;각각의-세션에-대한-고립-수준-설정&#34;&gt;각각의 세션에 대한, 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;생성자를 직접 사용하거나, 세션 메이커가 생성한 호출 가능한 객체를 호출 할 때, &lt;code&gt;bind&lt;/code&gt; 인자로 바로 전달 할 수 있다.
예를 들어, &lt;code&gt;transactional_session&lt;/code&gt;에서 세션을 만들고, &lt;code&gt;autocommit_engine&lt;/code&gt;을 전달할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session = transactional_session(bind=autocommit_engine)
# work with session
session.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;각각의-트랜잭션에-대한-고립-수준-설정&#34;&gt;각각의 트랜잭션에 대한 고립 수준 설정&lt;/h4&gt;
&lt;p&gt;격리 수준과 관련된 주요한 주의 사항은 트랜잭션이 이미 시작된 연결에서 설정을 안전하게 수정할 수 없다는 것이다.&lt;/p&gt;
&lt;p&gt;데이터베이스는 진행중인 트랜잭션의 격리 수준을 변경할 수 없으며 일부 &lt;code&gt;DBAPI&lt;/code&gt; 및 &lt;code&gt;SQLALchemy&lt;/code&gt; 언어에서는 이러한 영역에서 일관적이지 않은 동작이 있다.&lt;/p&gt;
&lt;p&gt;따라서 원하는 격리 수준을 가진 엔진 앞쪽에 바인딩 된 세션을 사용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;그러나 연결 단위의 격리 수준은 트랜잭션이 시작될 때 &lt;code&gt;Session.commection()&lt;/code&gt; 메서드를 사용하여 영향 받을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sqlalchemy.orm import Session

sess = Session(bind=engine)
with sess.begin():
    sess.connection(execution_options={&#39;isolation_level&#39;: &#39;SERIALIZABLE&#39;})

# commits transaction.  the connection is released
# and reverted to its previous isolation level.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위에서 먼저, 생성자 또는 세션 메이커를 사용하여 세션을 생성한다. 그런 다음에 트랜잭션이 시작되기 전에 연결에 전달되는 실행 옵션을 제공하는 &lt;code&gt;Session.connection()&lt;/code&gt;을 호출하여 트랜잭션 시작을 명시적으로 설정한다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sqlalchemy.org/en/13/orm/session_transaction.html#transactions-and-connection-management&#34;&gt;Transactions and Connection Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 17 Mar 2021 22:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 자투리 시간이 굉장히 많았음에도 불구하고, 시간을 가치있게 사용하지 못했다.&lt;/li&gt;
&lt;li&gt;신규 개발을 거의 하지 않고, 유지보수만 하였더니 &lt;code&gt;API&lt;/code&gt; 설계에 대한 감이 완전히 죽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;평소에는 시간이 없다고 불평하였는데, 예상하지 못하게 시간이 비어있을 경우에는 내가 시간을 제대로 활용하지 못했다.&lt;/li&gt;
&lt;li&gt;업무상 많이 다루지 않는 기술을 조금 놔버렸던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예상하지 못하게 자투리 시간을 활용할 수 있도록 항상 고민을 해야겠다.&lt;/li&gt;
&lt;li&gt;업무상 많이 다루지 않는 기술이라고 하더라도, 중요하게 여기고 평상시에 토이프로젝트를 많이 만들면서 시행착오를 거쳐야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 애플리케이션을 다루는 기술의 깊이를 전체적으로 끌어올려야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API&lt;/code&gt;를 만들 때, 보안에 대해서 별로 중요하게 생각하지 않았던 것 같다. 하지만 현대 애플리케이션에서 보안은 굉장히 중요하고, 토이프로젝트를 하면서 &lt;code&gt;API&lt;/code&gt;
를 설계해보고 어떻게 하면 좋은 &lt;code&gt;API&lt;/code&gt;를 만들 수 있을까에 대한 고민을 꾸준하게 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시간을 가치 있게 사용하려고 노력하고, 평소에 자투리 시간이 생기면 어떤 일을 해야할지에 대해서 미리 계획할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 16 Mar 2021 12:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/16/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 내가 정말 아는 것이 없구나라는 것을 깨닫게 되었다.&lt;/li&gt;
&lt;li&gt;내가 아는 것도 없고 설명도 잘 못한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 통해서, 개인의 역량에 모든 것을 맡기지 않는 방법도 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어렴풋이 들어봤던 것 같은데, 설명하려고 애를 쓰니까 굉장히 힘들었다.&lt;/li&gt;
&lt;li&gt;내가 어떤 것을 안다고 생각하는 기준이 다른 사람에 비해서 터무니 없이 낮고, 얕았다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 한다고 해서, 대충짜도 된다고 생각하지 말고, 다른 사람에게 내가 작성한 의도와 왜 이렇게 작성했냐고 물어보았을 때 항상 대답할 수 있게 알고 작성하자.&lt;/li&gt;
&lt;li&gt;자신감을 가지고 싶다면, 내 자신에게 떳떳해야 한다.&lt;/li&gt;
&lt;li&gt;말을 잘하는 방법에 대해서 고민을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;잘 모를때는 모른다는 것을 인정하고, 배우는 자세를 가지자.&lt;/li&gt;
&lt;li&gt;기본으로 돌아가서, 다시 처음부터 배운다는 생각으로 공부를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람에게 어떤 개념을 설명하려는 연습을 하자.&lt;/li&gt;
&lt;li&gt;어떤 것을 배우고 나서, 내가 이것을 정말로 설명할 수 있는지 녹화를 하자.&lt;/li&gt;
&lt;li&gt;어떤 것을 배우고 나면 무조건 말로 이것을 설명을 해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;글로만 정리하는 것이 아닌 정말로 어떠한 개념을 이해하고 이를 말로 설명할 수 있도록 노력하자.&lt;/li&gt;
&lt;li&gt;배우는 속도에 집착하지 말고, 하나라도 제대로 아는 것에 집중을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 15 Mar 2021 07:37:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/15/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Javadoc&lt;/code&gt;을 영어로 작성할 때에는, 3인칭 단수로 작성한다.&lt;/li&gt;
&lt;li&gt;자바독을 많이 읽어보면서 어떻게 작성했는지 알아보는 것이 좋다.&lt;/li&gt;
&lt;li&gt;코딩을 하면서, 부주의한 실수를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어떻게 보면 별것 아니라고 생각을 할지 모르겠지만, 다른 사람들의 시간을 많이 낭비하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나의 사소한 실수로 인해서, 다른 사람들의 시간을 낭비시키지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 작성하고 나서, 실수를 한 것이 없는지 꼼꼼히 살펴보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 커밋하기 전에, 오타는 없는지 꼼꼼히 확인하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 14 Mar 2021 20:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/14/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h1 id=&#34;커뮤니케이션-및-협업-능력&#34;&gt;커뮤니케이션 및 협업 능력&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;업무를 할 때, 상황 설명 및 커뮤니케이션을 조리있게 하지 못하고 이로 인해서 협업에 여려움을 느끼고 있었다. 어떻게 하면 내가 말을 좀 더 조리있게 잘하고 다른 사람들이 이해할 수 있을까라는 고민을 하던 중에, 다음과 같은 프레임워크를 알게 되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Situation,_task,_action,_result&#34;&gt;Situation, task, action, result&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;쉽게 말하면서 어떤 상황 및 이야기를 할 때, 다음과 같은 순서에 따라서 말을 하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;ituation: 어떠한 상황에서&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt;ask: 어떤 업무(Task) 하거나 또는 목표(target)를 달성해야 했는지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;ction: 그래서 본인이 왜, 무엇을, 어떻게 했으며&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;esult: 결과는 어땠는지, 그 결과로 얻은 성과는? 또는 실패했다면 그로부터 배운것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111066661-7d637c00-8503-11eb-88f3-1cc486a963e6.png&#34; alt=&#34;STAR&#34;&gt;&lt;/p&gt;
&lt;p&gt;원래는 면접관이 직무에 필요한 특정 능력에 대한 모든 관련 정보를 수집하기 위한 방법이지만, 내가 했던 작업 및 상황 설명을 할 때, 이에 맞춰서 말을 하다보면 보다 상대방이 내가 무슨 이야기를 하는지 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;p&gt;이제부터 작성하는 회고부터 &lt;strong&gt;STAR&lt;/strong&gt; 프레임워크에 맞춰 글을 작성하려는 노력을 해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111066795-31fd9d80-8504-11eb-9d50-b64839651a6f.jpg&#34; alt=&#34;8997383833_2&#34;&gt;&lt;/p&gt;
&lt;p&gt;그리고 추가적으로 대화법에 대한 책을 읽으면서 나의 대화법에 잘못된 부분이 없는지 살펴보고 개선하도록 해야겠다. 아침마다 조금씩 읽으면서 대화법을 조금씩 개선해나갈 생각이다.&lt;/p&gt;
&lt;h1 id=&#34;코딩하기-전에-미리-설계하기&#34;&gt;코딩하기 전에 미리 설계하기&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;어떤 일을 처리할 때, 코드 레벨에서부터 분석하는 자세가 잘못된 것 같다. 우선 어떤 방향으로 가야할지, 동료들과 토의를 한 다음에, 그리고 현재 작업하는 프로젝트를 가장 잘 아는 사람에게 검토를 받는것이 일을 하는데 들이는 시간을 많이 줄여준다는 것을 알게 되었다.
처음에 잘못된 설계를 한 것을 발견하여 여태까지 코딩한 작업들이 모두 물거품이 되었는데 이러한 일을 최소화 하려면 잦은 토의와 어떠한 방향이 더 나은 방향인지를 끊임없이 고민하는 것이 정답인 것 같다.&lt;/p&gt;
&lt;h1 id=&#34;실수를-인정하기&#34;&gt;실수를 인정하기&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;내가 나의 실수를 인정하지 못하고 다른 사람이 잘했던 일을 쉽게 칭찬하지 못하는 단점을 발견했다. 내가 무슨 잘못이나 실수를 했을 때, 피하고만 싶어하는 이유를 좀 더 살펴보고 어떤 말을 하기 전에 생각을 좀 더 오래 한다음에 말을 하도록 하는 연습을 해야겠다.
이번주에 같은 기능을 개발하는 것이지만, 나는 변경 사항이 많고 수정할 부분이 많게 코딩을 하였지만 같은 동료는 변경사항을 최소한으로 하고 기존에 동작하던 부분을 최대한 건드리지 않고 코딩을 하는 방식으로 하였다. 이러한 부분은 칭찬을 할 만 하고 내가 여태까지 작업했던 시간보다 훨씬 적은 시간으로 기능이 완성되었을 뿐 만 아니라 사이드 이펙트에 대한 부분도 고려하지 않아도 될 것이다.
또한 코딩을 할 때, 코드만 볼 것이 아니라 전체적인 상황, 문맥을 고려하여 개발하는 자세를 가져야겠다.
내가 개선할 점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실수를 했을 때, 숨기고 싶어하는 경향이 있다. 이러한 점을 고쳐야겠다.&lt;/li&gt;
&lt;li&gt;코드레벨부터 보려고 하지 말고 먼저 왜 이러한 기능이 필요한지에 대한 상황을 파악하고, 그 다음에 전체적인 기능, 그리고 어떻게 구현하면 좋을지 생각을 하고 그 다음에 코드레벨에서 어떻게 구현할지 생각을 해야겠다.&lt;/li&gt;
&lt;li&gt;기존의 소스코드를 의심하기 전에, &lt;code&gt;URS&lt;/code&gt; 문서를 보면서 스펙에 이러한 기능이 존재하는지 먼저 파악을 하자.&lt;/li&gt;
&lt;li&gt;업무를 하는데, 도메인 지식이 사실 코딩 지식보다 중요할 수 있다는 사실을 깨달았다. 따라서 도메인 부터 제대로 파악하기 위해서 노력하자. 짜투리 시간이 날때마다 도메인 지식을 익히기 위해서 노력하고 이를 구글 &lt;code&gt;KEEP&lt;/code&gt;을 이용해서 키워드 별로 정리를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;중요한-결정은-최대한-나중에&#34;&gt;중요한 결정은 최대한 나중에&amp;hellip;&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111067099-db915e80-8505-11eb-8a57-abb936bd0edd.png&#34; alt=&#34;110481786-479d4c80-812b-11eb-9297-6c700c1b528c&#34;&gt;&lt;/p&gt;
&lt;p&gt;잘못된 설계를 하지 않는 방법에 대한 고민을 하였고 트레이너 분들에게 질문을 하였을 때, 기계인간 님은 처음부터 다시 만들 생각을 하고 만든다고 하셨다.&lt;/p&gt;
&lt;p&gt;또한 중요한 결정을 최대한 나중으로 미룰 수 있는 것이 좋다고 하셨다. 왜냐하면 중요한 결정을 성급하게 내리고 나중에 실수를 했다는 것을 깨달아 버리면 그때는 다시 만들어야하기 때문이다.&lt;/p&gt;
&lt;h1 id=&#34;코드숨&#34;&gt;코드숨&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;이번주에는 업무적으로 바쁘기도 했고, 컨디션도 별로 안좋았는데, 회사에서 안좋은일까지 겹쳤다. 따라서 과제를 수행하기 어려웠는데, 컨디션을 위해서 한 주만 쉬자라는 마음으로 자기합리화를 했다. 사실 다음주가 마감일이라서 가장 바쁘기는 하겠지만 그래도 최대한 짜투리 시간을 활용해서라도 과제를 마무리 할 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 13 Mar 2021 23:40:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 회사에서 일한 모습을 곰곰히 생각을 해보았다.&lt;/li&gt;
&lt;li&gt;운동을 배우면 좋다는 이야기를 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;업무중에 사소한 거짓말을 하거나 오해의 소지를 가질 수 있는 말을 하는 것 같다.&lt;/li&gt;
&lt;li&gt;도메인 지식을 완전히 이해하지 못하다보니까, 업무를 할당 받아도 목적을 잘 이해하지 못하는 것 같다.&lt;/li&gt;
&lt;li&gt;나도 요즘에 체력이 많이 줄어든 것 같은데 운동을 배워야겠다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사소한 것이라도 동료들에게 명확하게 말하며, 순간의 실수를 만회하려고 거짓말을 해서는 안된다.&lt;/li&gt;
&lt;li&gt;솔루션의 도메인 적인 지식을 배우고 기록할 필요가 있다. 예를 들어서 &lt;code&gt;Due Date&lt;/code&gt;, &lt;code&gt;Due Days&lt;/code&gt;를 잘 모르고 있었는데 평상시에 관심을 가지고 업무를 익히려고 노력해야겠다.&lt;/li&gt;
&lt;li&gt;운동을 배우면서 스트레스 및 체력 관리를 하는 것이 길게 보았을 때 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 내가 하려고 했던 일을 명확히 하려고 노력하고, 도중에 뭔가 잘못 생각하거나 착각한게 있으면 바로 솔직하게 말하고 정정하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들과 같이 할 수 있는 운동을 알아봐야겠다.&lt;/li&gt;
&lt;li&gt;운동을 하면서, 일과 취미를 같이 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>객체지향 5원칙 (SOLID)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid/</link>
      <pubDate>Sat, 13 Mar 2021 13:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid/</guid>
      <description>&lt;p&gt;회사에서 객체지향 및 SOLID 원칙에 대해서 설명하는 세미나를 진행하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dongwooklee96/java-chap02-assignment&#34;&gt;사내 세미나 과제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;객체지향-5원칙-solid-원칙&#34;&gt;객체지향 5원칙 (SOLID) 원칙&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;srp-single-responsiblity-principle---단일-책임-원칙&#34;&gt;SRP (Single Responsiblity Principle) - 단일 책임 원칙&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 클래스는 하나의 책임만 가져야 한다.&lt;/li&gt;
&lt;li&gt;어떤 변화 (요구 사항등의 변화)에 의해서 클래스를 변경해야하는 이유는 오직 하나여야 한다.&lt;/li&gt;
&lt;li&gt;나머지 4원칙의 기초가 되는 원칙으로 SRP만 잘 지키면 다른 책임의 변경으로 인한 연쇄 작용을 방지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ocp-open-closed-principle---개방-폐쇄-원칙&#34;&gt;OCP (Open-Closed Principle) - 개방, 폐쇄 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫쳐있어야 한다.
&lt;ul&gt;
&lt;li&gt;변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 극대화 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다.&lt;/li&gt;
&lt;li&gt;새로운 기능이 추가되는 경우, 기존에 제공하던 클래스 (또는 메서드)를 수정하는 것이 아니라 새로운 클래스 (또는 메서드)를 추가해서 기능을 확장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lsp-the-liskov-subsitution-principle---리스코프-치환-원칙&#34;&gt;LSP (The Liskov Subsitution Principle) - 리스코프 치환 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다.
&lt;ul&gt;
&lt;li&gt;슈퍼 클래스가 들어갈 자리에 서브 클래스를 넣어도, 원래대로 잘 작동해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;상속의 오용을 방지하게 하는 원칙&lt;/li&gt;
&lt;li&gt;슈퍼 클래스와 서브 클래스의 동작이 일관성 있게 동작해야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;isp-interface-segregation-principle---인터페이스-분리-원칙&#34;&gt;ISP (Interface Segregation Principle) - 인터페이스 분리 원칙&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;한 클래스는 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조함.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UserService&lt;/code&gt;, &lt;code&gt;BoardService&lt;/code&gt; (X)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UserCreateService&lt;/code&gt;, &lt;code&gt;BoardCreateService&lt;/code&gt; (O)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dip-dependency-inversion-principle---의존성-역전의-원칙&#34;&gt;DIP (Dependency Inversion Principle) - 의존성 역전의 원칙&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;변화하기 쉬운 것, 자주 변화하는 것 보다 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;고차원 모듈은 주로 변화하지 않음, 저 차원 모듈에 주로 자주 변화함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구체적인 구현 클래스 보다 추상화된 인터페이스에 의존하라, 구체적이며 변동성이 크다면 절대로 이름을 언급하지 마라.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>사내 세미나 과제 피드백 CH10 - Future, ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</link>
      <pubDate>Sat, 13 Mar 2021 11:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/13/%EC%82%AC%EB%82%B4-%EC%84%B8%EB%AF%B8%EB%82%98-%EA%B3%BC%EC%A0%9C-%ED%94%BC%EB%93%9C%EB%B0%B1-ch10-future-computablefuture/</guid>
      <description>&lt;p&gt;회사에서 자바 비동기 처리 및 &lt;code&gt;Future&lt;/code&gt;, &lt;code&gt;CompletableFuture&lt;/code&gt;에 대해서 세미나를 진행하였다.&lt;/p&gt;
&lt;p&gt;과제를 진행하면서, 비동기 프로그래밍 및 자바에서 비동기 프로그래밍을 어떻게 사용하는지 생각해 볼 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dongwooklee96/java-chap10-assignment&#34;&gt;사내 세미나 과제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/111016625-5a957280-83f2-11eb-847c-b5e8deaf3ac7.png&#34; alt=&#34;Screen Shot 2021-03-13 at 11 50 40 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;친절하게 피드백을 해주셨기 때문에, 내가 &lt;code&gt;ComputableFuture&lt;/code&gt;를 잘못사용하고 있다는 사실을 알게 되었다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java8&#34; data-lang=&#34;java8&#34;&gt;repository.retrieveCategories().parallelStream()
                .map(category -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category)))
                .collect(Collectors.toList())
        .parallelStream()
        .map(CompletableFuture::join)     // (1)
        .flatMap(Collection::parallelStream)
        .collect(Collectors.toList())
        .parallelStream()
        .map(book -&amp;gt; CompletableFuture.runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
        .collect(Collectors.toList())
        .forEach(CompletableFuture::join); // (2)
        executors.shutdown();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위의 코드는 내가 처음에 제출한 코드이다. 문제점을 보면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드에서 &lt;code&gt;join&lt;/code&gt;을 사용한 곳이 2개정도 존재한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt;은 현재 &lt;code&gt;Thread&lt;/code&gt;를 블록킹 하여 결과를 기다리는 연산이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;ComputableFuture&lt;/code&gt;는 이러한 &lt;code&gt;join&lt;/code&gt; 없이 &lt;code&gt;CompletionStage&lt;/code&gt;라는 약속을 기반으로 &lt;code&gt;Non blocking&lt;/code&gt; 기반의 비동기 처리를 할 수 있게 도와준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만, 나는 이러한 특징을 이해하지 못하고, &lt;code&gt;join&lt;/code&gt;을 남발하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 스트림의 중간 연산 단계에서 &lt;code&gt;join&lt;/code&gt;을 호출하면, 게으른 연산을 하는 특성으로 인해서 순차적인 &lt;code&gt;blocking&lt;/code&gt;이 걸릴 수 있다. 따라서 &lt;code&gt;join&lt;/code&gt; 연산은 스트림의 수집이 &lt;code&gt;List&lt;/code&gt;와 같이 완료된 후에 개별적으로 루프를 돌면서 수행하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stream&lt;/code&gt;으로 변환할 때, &lt;code&gt;parallelStream&lt;/code&gt;은 조심해서 사용을 해야한다. &lt;code&gt;parallelStream&lt;/code&gt; 작업을 멀티코어에서 병렬처리 하는 것은 일반적으로 데이터가 많을 때 유리하다. 데이터가 적으면 오히려 분할하는데 시간이 더 걸린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이러한 최적화는 여러번 수행해보면서 반드시 측정을 기반으로 선택이 되어야한다. 그러한 경우가 아니라면 &lt;code&gt;stream&lt;/code&gt;도 충분하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;꼭 필요한 곳이 아니라면, &lt;code&gt;join&lt;/code&gt; 연산은 최종적으로 &amp;ldquo;동기&amp;quot;가 필요한 곳에서 사용하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 피드백을 받은 부분을 개선한 결과는 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final List&amp;lt;CompletableFuture&amp;lt;List&amp;lt;Book&amp;gt;&amp;gt;&amp;gt; futures
            = repository.retrieveCategories().stream()
            .map(category -&amp;gt; supplyAsync(() -&amp;gt; repository.retrieveBooksByCategory(category), executors))
            .collect(toList());

        final List&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; updateFutures
            = futures.stream()
            .map(future -&amp;gt; future.thenCompose(books -&amp;gt; allOf(
                books.stream()
                    .map(book -&amp;gt; runAsync(() -&amp;gt; repository.updateAuthor(book, author), executors))
                    .toArray(CompletableFuture[]::new)
            )))
            .collect(toList());
        updateFutures.forEach(CompletableFuture::join);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ComputableFuture&lt;/code&gt;로 작업을 처리한 후에, 최종적으로 한꺼번에  &lt;code&gt;join&lt;/code&gt; 을 해주고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 12 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/12/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현상보다는 원인을 분석할 수 있어야 할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 성급하게 기존 소스코드에  문제가 있다고 생각  했는데, 사실 그게 아니였고  &lt;code&gt;URS&lt;/code&gt; 스펙 문서를 보면서, 도메인 로직을 모르고 있어서 발생한 문제인 것을 알게 되었다. 도메인 지식을 무시하지 말고, 코딩 실력보다 사실 업무를 하는데 있어서는 도메인 로직이 중요하다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;도메인 로직을 코드 상에서 드러낼 수 있도록 하는 것이 중요함과 동시에, 그렇지 못하다면 직접 검증하는 자세가 필요하다.&lt;/li&gt;
&lt;li&gt;개인의 성장도 물론 중요하지만, 그보다는 팀의 성장이 중요하다는 것을 느끼게 되었다.&lt;/li&gt;
&lt;li&gt;나를 이해하주는 팀원들에게 고마웠다, 내가 보답할 수 있는 방법은 밝은 모습을 보여주는 것과 열정 있는 모습을 보여주는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;때로는 무언가를 바꾸고 싶으면 그만큼의 희생이 따른 다는 것을 느끼게 되었다. 나를 조금은 내려 놓을 필요를 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이제 부터, 동료를 위해서 배우는 사람이 되도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 11 Mar 2021 23:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/11/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 다른 사람의 소스 코드를 내 마음대로 수정했다가, 조심해달라는 이야기를 들었다.&lt;/li&gt;
&lt;li&gt;기존의 소스 코드가 잘못되어 있더라도, 최소한의 영향을 주는 방향으로 코딩하는 것이 좋을 수도 있다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상대방의 입장에서는 기분이 나쁠 수도 있는데, 화내지 않고 말해줘서 고마웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다른 사람의 소스코드를 고칠 때는, 의견을 물어보고 고치도록하고, 어떠한 부탁을 할 때는 최대한 감정을 들어내지 않고 말하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상황에 따라 다르지만, 때로는 최소한의 영향을 주는 소스 코드를 만들도록 노력해야겠다. 현재는 테스트 코드를 도입하기 힘들지만, 만약 기존의 구조를 바꾼다면 책임을 질 수 있게 그만한 테스트 코드가 있어야 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 코드만 보지 말고 전체적인 상황, 문맥, 그림을 보도록 노력해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회사에서 말을 안하다 보니까 말을 잘 못해지는 것 같다. 따라서 다른 사람들과 말을 많이 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항상 코드를 작성하기 전에, 문제가 무엇인지 내가 어떻게 문제를 해결할지 생각을 하고 나서 코딩을 진행하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나도 다른 사람에게 싫은 소리를 할 때는, 최대한 감정을 배제하고 말하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>스프링 시큐리티 아키텍처 (미완성)</title>
      <link>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</link>
      <pubDate>Thu, 11 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/11/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AF%B8%EC%99%84%EC%84%B1/</guid>
      <description>&lt;h2 id=&#34;인증authentication과-인과authorization&#34;&gt;인증(Authentication)과 인과(Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110706470-3f343700-823b-11eb-83e4-103013be399a.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 26 53 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어플리케이션 보안은 두가지의 독립적인 문제로 나뉜다.&lt;/li&gt;
&lt;li&gt;바로 인증(&lt;code&gt;authentication&lt;/code&gt;)과 인가(&lt;code&gt;authorization&lt;/code&gt;)이다.&lt;/li&gt;
&lt;li&gt;인증은 (&lt;code&gt;who are you?&lt;/code&gt;) 이고, 인가는 (&lt;code&gt;what are you allowed to do?&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링 시큐리티는 인증과 인과를 분리하도록 설계된 아키텍처를 가지고 있으며, 두 가지 모두에 대한 전략과 확장 할 수 있는 포인트가 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인증-authentication&#34;&gt;인증 (Authentication)&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;인증을 위한, &lt;code&gt;AuthenticationManager&lt;/code&gt; 라는 인터페이스를 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;authenticate&lt;/code&gt; 라는 메서드를 제공하는데, 다음과 같은 3가지 일을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;입력이 유효한 주체를 나타내는지 확인할 수 있는 경우, &lt;code&gt;Authentication(authentication=true)&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;입력이 잘못된 주체를 나타내는 것으로 판단되는 경우에는, 예외를 던집니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약, 결정할 수 없는 경우에는, &lt;code&gt;null&lt;/code&gt;을 반환합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationException&lt;/code&gt; 예외는 런타임 예외이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 응용 프로그램의 스타일이나 목적에 따라 응용 프로그램에서 일반적인 방식으로 처리됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 프로그래머가 이러한 예외를 처리하지 않습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110708504-1f524280-823e-11eb-86b2-b33bbe5d09d4.png&#34; alt=&#34;Screen Shot 2021-03-11 at 7 48 00 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Authentication Manager&lt;/code&gt;의 가장 일반적으로 사용되는 구현은 &lt;code&gt;ProviderManager&lt;/code&gt;로, &lt;code&gt;AuthenticationProvider&lt;/code&gt; 인스턴스 체인을 지정합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AuthenticationProvider&lt;/code&gt;는 &lt;code&gt;AuthenticationManager&lt;/code&gt;와 비슷하지만, 함수를 호출하는 사람에게, &lt;code&gt;Authentication&lt;/code&gt; 타입을 질의할 수 있는 메서드를 추가적으로 지원합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProviderManager&lt;/code&gt;는 선택적인 부모 요소를 가질 수 있으며, 모든 &lt;code&gt;ProviderManager&lt;/code&gt;가 &lt;code&gt;null&lt;/code&gt;을 반환하는 경우에 이를 확인할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상위의 &lt;code&gt;ProviderManager&lt;/code&gt;를 사용할 수 없는 경우에, &lt;code&gt;AuthenticationException&lt;/code&gt; 예외가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경우에 따라서, 애플리케이션은 접근 권한을 그룹으로 만들어야할 때가 있는데, 그룹 별 권한을 &lt;code&gt;AuthenticationManager&lt;/code&gt;에 위임한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;때때로, 각가의 &lt;code&gt;ProviderManager&lt;/code&gt;는, 상위 요소를 공유한다. 상위 요소는 글로벌 리소스의 일종으로 모든 프로바이더의 예외나 상황을 처리한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;authenticationmanager-커스터마이징&#34;&gt;AuthenticationManager 커스터마이징&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스프링 시큐리티는 응용 프로그램에 설정된 인증과 관련된 관리자 기능을 빠르게 구성할 수 있도록 몇가지 기능을 제공합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 사용되는 헬퍼는 &lt;code&gt;AuthenticationManagerBuilder&lt;/code&gt;를 사용합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

   ... // web stuff here

  @Autowired
  public void initialize(AuthenticationManagerBuilder builder, DataSource dataSource) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser(&amp;quot;dave&amp;quot;)
      .password(&amp;quot;secret&amp;quot;).roles(&amp;quot;USER&amp;quot;);
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;는 &lt;code&gt;@Bean&lt;/code&gt; 메서드로 &lt;code&gt;@Autowired&lt;/code&gt;되므로, &lt;code&gt;AuthenticationManager&lt;/code&gt;를 빌드할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인가-authorization&#34;&gt;인가 (Authorization)&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/guides/topicals/spring-security-architecture&#34;&gt;스프링 시큐리티 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CSRF 란 무엇일까?</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Wed, 10 Mar 2021 22:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/csrf-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110636756-fc00a680-81ef-11eb-8940-ee638da62fc2.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 28 45 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF(Cross-Site Request Forgery)&lt;/code&gt;는 신뢰할 수 있는 사용자를 가장하여 웹 사이트에 원치않는 명령을 보내는 공격입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어, 다른 곳으로 이동하기 위해 사용하는 링크 뒤에 있는 &lt;code&gt;URL&lt;/code&gt;에 악의적인 매겨변수를 포함시킴으로써 다음을 수행할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;https://www.example.com/index.php?action=delete&amp;amp;id=123&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 도메인에 수정 권한이 있는 사용자의 경우 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소가, 사용자 모르게 동작을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;심지어, 요소가 &lt;code&gt;https://www.example.com&lt;/code&gt;에 없는 경우에도 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF&lt;/code&gt;를 방지하는 방법은 &lt;code&gt;RestfulAPI&lt;/code&gt; 구현 및 시큐어 토큰을 추가하는 등 많은 방법이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;위키-백과&#34;&gt;위키 백과&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;설명이 조금 부족해서 위키백과를 찾아보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110638080-77168c80-81f1-11eb-90a1-af13554352bb.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 39 18 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사이트 간 요청 위조, 원 클릭 공격 또는 세션 라이딩이라고 한다.&lt;/li&gt;
&lt;li&gt;웹 응용프로그램이 신뢰하는 사용자로서 무단 명령을 제출하는 웹 사이트의 악의적인 공격 유형이다.&lt;/li&gt;
&lt;li&gt;악의적인 웹 사이트가 이러한 명령을 전송할 수 있는 방법은 여러가지가 있다. 예를들어, 특수하게 조작된 이미지 태그, 숨겨진 양식 및 &lt;code&gt;JavaScript XMLHttpRequest&lt;/code&gt;는 사용자의 동작에 따라서 작동되기도 하지만 전혀 알아차리지 못하게 이루어지기도 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XSS(Cross-site-scripting)&lt;/code&gt;과의 차이점은 &lt;code&gt;XSS&lt;/code&gt;는 특정 사이트에 대해서 사용자가 가지는 신뢰정보를 이용하는데 반해서, &lt;code&gt;CSRF&lt;/code&gt;는 사용자의 브라우저에 있는 신뢰 정보를 이용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110639854-8a2a5c00-81f3-11eb-9cbb-06198496bc29.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 54 10 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CSRF&lt;/code&gt; 공격에서 공격자의 목표는 무고한 피해자가 악의적으로 조작된 웹 공격을 대상자가 액세스 권한을 가진 웹 사이트에 몰래 제출하도록 하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자의 웹 브라우저에 저장된 쿠키에 의해 인증된 사용자는 자신도 모르게 사용자를 신뢰하는 사이트로 &lt;code&gt;HTTP&lt;/code&gt; 요청을 전송하여 원치 않는 작업을 발생시킬 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저는 특정 도메인에서 사용하는 쿠키를 해당 도메인으로 보내는 웹 요청에 보이지 않게 포함시킵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 속성 때문에, 웹 사이트에 로그인 할 때, 생성된 쿠키를 이용해 공격합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 브라우저를 통해서 실수로 요청을 제출한 경우 자동으로 포함된 이 쿠키로 인해서 위조된 요청이 웹 서버에 실제로 나타나며 데이터 반환, 세션 상태 조작, 피해자 계정 변경 등 적절하게 요청된 모든 작업을 수행한다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;웹 브라우저는 특정 도메인에서 사용하는 쿠키를 해당 도메인으로 보내는 웹 요청에 보이지 않게 포함시킵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 속성 때문에, 웹 사이트에 로그인 할 때, 생성된 쿠키를 이용해 공격합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용자가 브라우저를 통해서 실수로 요청을 제출한 경우 자동으로 포함된 이 쿠키로 인해서 위조된 요청이 웹 서버에 실제로 나타나며 데이터 반환, 세션 상태 조작, 피해자 계정 변경 등 적절하게 요청된 모든 작업을 수행 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예방법&#34;&gt;예방법&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110640493-379d6f80-81f4-11eb-83f4-b25ba743308a.png&#34; alt=&#34;Screen Shot 2021-03-10 at 10 59 01 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;대부분의 &lt;code&gt;CSRF&lt;/code&gt; 방지 기술은, 웹 응용 프로그램이 허가되지 않은 요청을 탐지할 수 있도록 요청해 추가 인증 데이터를 포함시킴으로서 작동한다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&#34;&gt;MDN - CSRF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-site_request_forgery&#34;&gt;위키백과 - CSRF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>스프링의 세 가지 특징</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</link>
      <pubDate>Wed, 10 Mar 2021 08:00:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95/</guid>
      <description>&lt;h1 id=&#34;스프링의-세-가지-특징&#34;&gt;스프링의 세 가지 특징&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;회사에서 하는 세미나에서, 자바 세미나가 끝나고 이어서 스프링 세미나를 시작하였다.&lt;/p&gt;
&lt;p&gt;세미나를 진행하면서, 강조했던 스프링의 세 가지 특징에 대해서 설명한 부분을 정리해보겠다.&lt;/p&gt;
&lt;h2 id=&#34;1-ioc--di-dl&#34;&gt;1. IoC / DI, DL&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;스프링 프레임워크는 DL (Dependency Look-up)과 DI(Dependency Injection)를 통해서 IoC (Inversion of Control)을 구현합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 진행하면서, 많은 라이브러리를 사용할 것이다.&lt;/li&gt;
&lt;li&gt;특정 라이브러리에서 원하는 기능을 사용하려면 &lt;code&gt;new&lt;/code&gt; 를 통해서 객체를 생성해야하는데, 이 객체를 생성하기 위해서는 다른 객체를 생성해야하는 등 복잡한 의존 관계가 발생하고 사용자는 파악하기 힘들다.&lt;/li&gt;
&lt;li&gt;따라서 스프링 프레임워크는 이러한 객체에 대한 생성과 객체간의 의존관계에 대한 관리를 개발자가 스프링에게 위임하게 된다.&lt;/li&gt;
&lt;li&gt;개발자는 스프링이 요구하는 대로 설정만 하면, 설정에 따라서 &lt;code&gt;Bean&lt;/code&gt;을 생성하여 컨테이너에 담고 &lt;code&gt;Bean&lt;/code&gt;간의 의존관계를 파악(&lt;code&gt;Dependency Look-up&lt;/code&gt;)하여 주입 (&lt;code&gt;Dependency Injection&lt;/code&gt;)해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;POJO (Plain Java Object)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링에서 생성되어 관리되는 POJO 기반의 객체를 우리는 &lt;code&gt;Spring Bean&lt;/code&gt;이라고 한다.&lt;/li&gt;
&lt;li&gt;여기서 &lt;code&gt;POJO&lt;/code&gt;는 단순 &lt;code&gt;getter/setter&lt;/code&gt;만으로 구성되어 있으며 단순히 &lt;code&gt;new&lt;/code&gt;를 통해서 생성 가능한 형태를 말한다.&lt;/li&gt;
&lt;li&gt;핵심은 특정 기술에 종속되는 어떤 클래스도 상속하지 않고 있으며 어떠한 인터페이스도 구현하고 있지 않은 자바 클래스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-aop-aspect-oriented-programming&#34;&gt;2. AOP (Aspect Oriented Programming)&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110551571-16e40400-8179-11eb-87cd-901053f4404b.png&#34; alt=&#34;image2021-3-8_18-35-52&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AOP는 관점지향 프로그래밍을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분의 프로젝트는 고유한 핵심 기능 외에 트랜잭션, 보안처리(인증, 인가), 로깅 등의 공통 기능을 반드시 포함할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;별다른 정책이 없다면, 우리는 매번 프로젝트에서 똑같은 로직을 계속해서 개발할 것이고 버그가 발생하면 여기저기서 수정 작업을 할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AOP는 어플리케이션의 기능을 핵심 기능과 공통 기능을 각각 종단 관심사와 횡단 관심사로 분리하고 공통 기능을 적절히 끼워넣을 수 있게 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;psa-portable-service-abstraction&#34;&gt;PSA (Portable Service Abstraction)&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;환경의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있는 환경을 제공하려는 추상화 구조를 말한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스프링은 언어가 아닌 기술(구현체의 기술)에 얽메이는 것에 큰 반감을 가짐 (&lt;code&gt;EJB&lt;/code&gt;, &lt;code&gt;Servlet&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;스프링에서 동작할 수 있는 라이브러리들은 &lt;code&gt;POJO&lt;/code&gt; 형태로 되어 있음&lt;/li&gt;
&lt;li&gt;대표적인 추상화의 예
&lt;ul&gt;
&lt;li&gt;JPA의 구현체(&lt;code&gt;Hibernate&lt;/code&gt;, &lt;code&gt;Eclipse Link&lt;/code&gt;)를 추상화하는 &lt;code&gt;Spring Data JPA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mybatis&lt;/code&gt;를 추상화하는 &lt;code&gt;Spring-mybatis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spring Transaction Manager&lt;/code&gt;, &lt;code&gt;Spring Cache Manager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;서비스가 구동되는 환경(&lt;code&gt;Web MVC&lt;/code&gt;, &lt;code&gt;Web Flux&lt;/code&gt;)에 대해서도 추상화를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;버전에 따라서 라이브러리 혹은 프레임워크의 내부 API의 설계나 인터페이스가 달라지더라도, &lt;code&gt;Sping&lt;/code&gt;에서 적절히 감싸 추상화를 하기 때문에 우리의 소스코드는 변경될 일이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 10 Mar 2021 07:07:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/10/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 강의를 들었다.&lt;/li&gt;
&lt;li&gt;회사에서 조금 동료와 트러블이 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;강의를 들으면서, 내가 바꿀 부분에 주석으로 표시하고 진행을 하는 것을 보고 나도 배워야겠다는 생각을 했다. 왜냐하면, 내가 어떤 것을 하고 있는지 까먹을 때가 많이 때문이다.&lt;/li&gt;
&lt;li&gt;설명도 들어보지 않고, 감정부터 앞세워서 굉장히 당황스럽고 나도 화가 났다.&lt;/li&gt;
&lt;li&gt;이럴 때는 어떻게 대응 해야하는지 모르겠다. 그냥 좋은게 좋은거라고 넘어가야할까? 아니면 같이 화를 내는것이 맞을까?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능 개선이나, 유지보수를 할 때, 주석으로 변경되어야하는 범위를 먼저 체크하고 나서 실제 기능 개발을 시작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이는 내가 코드 레벨부터 보는 안좋은 습관이 있는데, 주석으로 전체적인 변경 범위 및 파악을 하면 나의 안좋은 습관을 고칠 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드레벨부터 바로 구현하려고 하지말고, 내가 수정해야할 범위 및 내가 해야할 일들을 미리 주석에 작성해두는 것도 방법이다.&lt;/li&gt;
&lt;li&gt;오늘 일을 하는데, 구현을 완료하고 이제 리펙터링을 해야지라고 마음을 먹고 있었는데, 조금 하기가 귀찮아서 미룰려고 했다. 내가 이러한 생각을 하게 된 이유를 생각해보니, 기능이 구현되는 것을 일이 끝났다고 생각 해서 그런 것 같다. 따라서 작업의 단위가 테스트까지는 힘들더라도, 최소한 리펙터링까지는 모두 마쳐야 일이 끝날 것이라고 생각하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;항상 코드를 작성하기 전에, 문제가 무엇인지 내가 어떻게 문제를 해결할지 생각을 하고 나서 코딩을 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 09 Mar 2021 15:22:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/09/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사에서 동료가 나에게 한 말  조금 화가났다.&lt;/li&gt;
&lt;li&gt;코드숨 시큐리티 강의를 들었다.&lt;/li&gt;
&lt;li&gt;회사 세미나에서 스프링에 대한 주제로 세미나를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그 순간에는 뭐라고 한 소리 할까라고 생각을 했지만, 집에와서 다시 생각해보니까 안하길 잘한 것 같다.&lt;/li&gt;
&lt;li&gt;그리고 퇴근 하기전에 오해가 풀려서 다행이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 되고 싶은 개발자는 같이 일하고 싶은 개발자라는 것을 명심해야겠다.&lt;/li&gt;
&lt;li&gt;감정에 휩쓸리지 말자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110481786-479d4c80-812b-11eb-9297-6c700c1b528c.png&#34; alt=&#34;Screen Shot 2021-03-09 at 10 47 13 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중요한 결정을 나중으로 미룰 수 있는 것이 바로 실력이다.&lt;/li&gt;
&lt;li&gt;중요한 결정을 너무 빨리 내려서 중요한 부분을 먼저 만들어버리면, 망했구나&amp;hellip; 라고 고민을 하기 시작할 것이다.&lt;/li&gt;
&lt;li&gt;아예 처음부터 다시 만들 생각을 하고, 만드는 습관이 들면 중요한 결정을 나중에 내리는 연습도 할 수 있다.&lt;/li&gt;
&lt;li&gt;그렇게 하다보면, 내가 지금 하고 있는 작업을 다시 만드려면 얼마나 힘들까라는것이 예측이 되고, 그런 결정을 나중에 내릴 수 있도록 인터페이스 같은 것으로 추상화를 해둔다.&lt;/li&gt;
&lt;li&gt;이런 식으로 한번 결정하면 다시 바꾸기 어려운 것들을 추상화를 해두거나, 아예 안만들거나 하는 식으로 미뤄가면서 개발을 한다.&lt;/li&gt;
&lt;li&gt;이건 어려운 것이고, 이런식으로 계속 미루는 스킬이 대단하다면 개발 실력이 엄청난 것이라 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의사소통 능력 및 소통을 잘 할 수 있도록 더 노력을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;말이 조금 느리더라도, 또박또박 논리적으로 말하자. 횡설수설하지 말자.&lt;/li&gt;
&lt;li&gt;중요한 부분을 나중에 결정할 수 있게 미루는 방법에 대해서 고민을 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>mariadb 유니크 인덱스</title>
      <link>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link>
      <pubDate>Tue, 09 Mar 2021 09:20:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/09/mariadb-%EC%9C%A0%EB%8B%88%ED%81%AC-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid>
      <description>&lt;h2 id=&#34;유니크-인덱스&#34;&gt;유니크 인덱스&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110399859-ed17d800-80b9-11eb-933e-d71a182abcb7.png&#34; alt=&#34;unique&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유니크 키는 유일해야하지만, 널을 허용할 수 있다.&lt;/li&gt;
&lt;li&gt;테이블을 생성한 후 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 또는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 명령을 사용하여, 고유 키를 추가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE Employees ADD UNIQUE `EmpCode`(`Employee_Code`);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;CREATE UNIQUE INDEX HomePhone ON Employees(Home_Phone);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/kb/en/getting-started-with-indexes/#unique-index&#34;&gt;mariadb-unique-index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 08 Mar 2021 15:20:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/08/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 구현하다가 설계가 잘못되었다는 사실을 발견하고, 이를 고치기 위해서 다시 설계를 하고 여태까지 작업한 내용을 거의 다 버리게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오늘 회사에서 새로운 테이블 설계를 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 오늘 생각하고 배운 것들을 코드숨에서 의견을 나누어 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다시 설계를 할 때, 뭔가 시간을 많이 사용하지 못하는 것 같다. 어색하기도 하고 막상 동료랑 같이 이야기를 하다보니까 뽀죡한 수가 떠오르지 않았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동료들과 해결책을 생각할 때, 그냥 말로만 하고 흘러가니까 나중에 남는 것이 없었다. 따라서, 이야기만 할 것이 아니라 말했던 내용들을 글로 남기고 이를 기록하도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일을 할 때, 동료와 신뢰를 쌓는 것이 굉장히 중요하다는 것을 느끼게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일도 훨씬 잘되고, 내가 진행 한 것을 공유하는 것이 편했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;새로운 테이블을 설계할 때, 이름을 짓는 것이 굉장히 어려웠다. 따라서 일단 이 테이블을 만들게 된 이유 및 이 테이블의 역할이 무엇인지를 생각했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;결론적으로는 문제가 무엇인지 명확하게 이해하지 못해서 발생한 것들이 많다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;버스에서 그냥 시간을 보내는게 아까웠는데, 코딩 테스트 문제의 해결책을 생각하면서 가는 것이 좋을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;설계를 꼼꼼히 검증하고, 유연한 설계를 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;동료들에게 신뢰를 쌓으려면, 내가 노력해야한다.&lt;/li&gt;
&lt;li&gt;변수명, 함수명, 클래스 명을 짓을 때 어려운 이유는 역할과 필요한 목적을 잘 정의하지 못했기 때문이다. 따라서 어떤 클래스, 메서드의 역할에 대해서 정의를 해보고 이름을 짓는 방법을 사용하는 것이 어떨까 하고 생각을 해보았다.&lt;/li&gt;
&lt;li&gt;나의 문제는 문제를 제대로 이해하지 못하는 것에서 온다. 어떻게 하면 문제를 더 잘 이해할 수 있을지를 고민하자.&lt;/li&gt;
&lt;li&gt;출 퇴근 시간에 코딩 테스트 문제를 정하고 이를 구글 킵에 메모를 하는 것이다. 그렇게 한 후에 내가 생각한 문제 풀이를 적어두고 구현은 시간이 날 때하는 것이다.&lt;/li&gt;
&lt;li&gt;내가 정말로 어떤 것을 알고 있다면, 그것을 말로 누군가에게 설명할 수 있을 정도가 되어야겠다고 생각했다.&lt;/li&gt;
&lt;li&gt;오늘 주간 보고를 하는데, 내가 한주동안 진행한 일도 제대로 설명하지 못했다. 따라서 주간보고 때 내가 진행한 일들을 논리정연하게 설명할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110323001-4c90cc00-8057-11eb-9cc3-4642f328db50.png&#34; alt=&#34;Screen Shot 2021-03-08 at 9 34 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현실적으로 설계가 완벽하게 되기는 힘들다는 의견이 있었고, 미쳐 생각하지 못하는 부분은 필연적으로 나타나게 된다. 따라서 피드백 주기를 짧게 하고, 공유를 자주하는 문화가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;피드백 주기를 짧게 하고, 공유를 어떻게 하면 잘 할 수 있을지 고민을 해봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;따라서 실험을 자주하되, 실험은 비용을 동반하기에 유연한 설계를 통해서 변경이 쉽도록 만드는 것이 최선이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;잦은 공유, 회고를 통한 개선, 코드숨에서 실천하는 것을 팀에서 하나씩 실천해보도록 노력해봐야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제를 막는 것보다 최대한 빨리 문제를 발견해서 적은 비용으로 새로 만드려고 한다. 테스트를 먼저 작성하는 것도 구현 전에 문제점을 찾아내서 수정하려는 노력의 일환이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수정하기 좋은 코드는 작성하지 않은 코드이다. 그리고 변경은 피할 수 없는 숙명이라고 생각하면 좋은 설계 = 쉽게 변경할 수 있는 구조라는 접근이 가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불확실성이 높고 변화가 빠른 요즘은 적응할 수 있는 능력이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;후회&amp;quot;는 사람마다 조직마다 기준이 다르다. 따라서 &amp;ldquo;우리는 언제 후회할까?&amp;ldquo;를 놓고 함게 논의를 해보면 좋은 방법이 나올 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일하는 방법을 조직 내에서 찾아서 합의를 이루는 게 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;불분명한 &lt;code&gt;BEST&lt;/code&gt; 대신에 명확한 &lt;code&gt;Better&lt;/code&gt;을 추구하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한번에 답을 내지 말고 계속 개선하려고 하는 것이 방법이 될 수 있다. (일일신 우일신)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동료들에게 신뢰를 쌓기 위해서는 솔직해지고, 실수를 인정하자.&lt;/li&gt;
&lt;li&gt;동료들에게 신뢰를 쌓기 위해서는 동료에게 관심을 가지고 동료의 일을 남일 처럼 여기지 말고 내일처럼 여기자.&lt;/li&gt;
&lt;li&gt;문제를 명확하게 이해하고 내가 정확히 이해하고 있는지 스스로 검증하는 프로세스가 필요하다.&lt;/li&gt;
&lt;li&gt;코드가 복잡해 질때, 문제를 정의하지 못하는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동료들에게 신뢰를 쌓을 수 있도록 노력하자.&lt;/li&gt;
&lt;li&gt;클래스, 메서드, 변수의 역할에 대해서 글로 정리 해보자. 그렇다면 이름을 명확하게 작성할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;문제를 정확히 이해하고 있는지 스스로에게 물어보고 테스트를 해보자.&lt;/li&gt;
&lt;li&gt;출퇴근 시간에 코딩 테스트를 정하고 해결책을 생각해보자!&lt;/li&gt;
&lt;li&gt;내가 배운 것들을 남에게 말로 설명할 수 있는지 스스로 테스트해보자.&lt;/li&gt;
&lt;li&gt;나는 알고 있다고 스스로 착각하고 있는 일들이 많은 것 같다. 따라서 스스로를 테스트해보자. 또한 어떻게 테스트 할 수 있는지 생각해보자.&lt;/li&gt;
&lt;li&gt;문제 해결의 시작은 명확히 어떤점이 문제인지를 정의하는 것이다. 따라서 코딩을 하면서 부딪치는 문제들을 마주치면 어떤 점이 문제인지를 명확히 정의하고 이를 풀어가려고 노력해보자.&lt;/li&gt;
&lt;li&gt;한번에 좋은 방법을 선택하려고 하지 말고, 계속 개선하려는 마음을 가지고, 유연한 설계를 하려고 노력하는 것이 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Deprecated 된 MediaType.APPLICATION_JSON_UTF8</title>
      <link>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</link>
      <pubDate>Mon, 08 Mar 2021 07:20:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/08/deprecated-%EB%90%9C-mediatype.application_json_utf8/</guid>
      <description>&lt;h2 id=&#34;mediatypeapplication_json_utf8&#34;&gt;MediaType.APPLICATION_JSON_UTF8&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257472-75767a00-7fe1-11eb-82e2-0f1db1ca3886.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 39 39 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257431-38aa8300-7fe1-11eb-8389-34b865de421b.png&#34; alt=&#34;deprecated&#34;&gt;&lt;/p&gt;
&lt;p&gt;테스트 코드를 작성하다가, &lt;code&gt;MediaType.APPLICATION_JSON_UTF8&lt;/code&gt; 부분이 &lt;code&gt;Deprecated&lt;/code&gt; 된 것을 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;밑줄로 표시까지 해줬는데, 그냥 대수롭지 않게 생각했던 것 같다. 그리고 개발자로서 이러한 부분을 보고도 지나친게 조금은 부끄러웠다. 다음부터는 이러한 부분을 발견하면 지나치지 말고 왜 &lt;code&gt;Deprecated&lt;/code&gt; 되었는지 알아보고 &lt;code&gt;API&lt;/code&gt; 개발자가 의도한 방향으로 사용을 하도록 노력해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110257623-11a08100-7fe2-11eb-93fc-771900030db8.png&#34; alt=&#34;Screen Shot 2021-03-08 at 7 44 02 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt; 주석을 읽어보니 이유는 다음과 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;크롬 같은 주요 브라우저가 스펙을 준수하고, 이제 &lt;code&gt;UTF-8&lt;/code&gt; 같은 파라미터 값을 넣어주지 않아도 올바르게 해석 되기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 이제는 &lt;code&gt;APPLICATION_JSON_UTF8&lt;/code&gt;을 사용하는 것 보다는 그냥 &lt;code&gt;APPLICATION_JSON&lt;/code&gt; 을 사용하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258251-fe42e500-7fe4-11eb-8fb8-06b332bf7b95.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 04 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위의 링크에 나와있듯이, &lt;code&gt;Content-Type&lt;/code&gt;을 &lt;code&gt;application/json&lt;/code&gt;으로 명시를 해도 인코딩이 깨진다고 버그 리포팅을 하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;charset=utf-8&lt;/code&gt;로 명시했을 때는 동작하지만 &lt;code&gt;charset&lt;/code&gt; 은  &lt;code&gt;application/json&lt;/code&gt;에 명시되어있지 않고 무시 되어야 한다고 문제를 제기하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rfc4627&#34;&gt;RFC4627&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258583-a7d6a600-7fe6-11eb-8654-5aa39d132d55.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 16 46 AM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110258530-6b0aaf00-7fe6-11eb-969c-b32776e629cd.png&#34; alt=&#34;Screen Shot 2021-03-08 at 8 15 10 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인코딩 부분을 살펴보면, &lt;code&gt;JSON&lt;/code&gt; 타입은 유니코드로 인코딩 되어야 하며 디폴트로 &lt;code&gt;UTF-8&lt;/code&gt;이 적용된다는 부분을 살펴볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;느낀점&#34;&gt;느낀점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 나였으면 그냥 내가 잘못 한 거구나라고 하면서 &lt;code&gt;charset&lt;/code&gt; 옵션을 주고 스펙까지 확인해볼 생각을 하지 않을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이런 점은 나도 배워야겠다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4627&#34;&gt;RFC4627&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=438464&#34;&gt;discussion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>네이버 신입 공채 체크 포인트 및 준비해야할 것들</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4/</link>
      <pubDate>Sun, 07 Mar 2021 22:15:14 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%EC%B2%B4%ED%81%AC-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%B0%8F-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%83%EB%93%A4/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110241534-b7c59a00-7f94-11eb-8b8c-3038b005cff4.png&#34; alt=&#34;Screen Shot 2021-03-07 at 10 29 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;네이버에서 신입을 뽑을 때 고려하는 부분을 알 수 있을 것 같아서 읽어보았다. 물론 다른 기업들도 이러한 점을 고려해서 신입을 뽑을 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://campaign.naver.com/recruit2020/checkpoint/&#34;&gt;2020신입개발공채체크포인트!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네이버가-강조하는-세가지의-키워드&#34;&gt;네이버가 강조하는 세가지의 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;기본기!&lt;/li&gt;
&lt;li&gt;커뮤니케이션!&lt;/li&gt;
&lt;li&gt;성장가능성!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본기&#34;&gt;기본기&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;기술 생태계가 빠르기 때문에, 의욕만 앞서 모두 다 경험해보겠다는 태도는 그다지 효율적인 접근 방법이 아니다.
따라서 이럴 수록 기본기에 충실해야만 새로운 기술 흐름에 압도되지 않고, 스스로의 방향성과 페이스로 앞으로 나갈 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 기술을 배웠다거나, 사용할 수 있다고 어필을 하는 것 보다는 기본기가 탄탄하다는 인상을 주는 것이 유리할 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 자료구조, &lt;strong&gt;운영체제&lt;/strong&gt;, 알고리즘, &lt;strong&gt;네트워크&lt;/strong&gt;, &lt;strong&gt;데이터베이스&lt;/strong&gt; 관련된 블로그 포스팅을 하고 면접 때 이러한 기본기에 대한 답변을 잘 할 수 있도록 해야겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기초를 많이 깊게 공부하는 것이 네이버를 입사하는데 많은 도움이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 다음과 같은 부분도 함께 본다고 했다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 너비보다 깊이.
2. 끝까지 파본 경험 
3. 창업자형 개발
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;면접&#34;&gt;면접&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;틀린답이라도 왜 그러한 답을 냈는지 설명하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;문제를 해결하기 위한 자신의 노력을 어필하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;모르면 찾으면 되고, 질문하면 되지만 끝까지 파고들고자 하는 마음가짐이 없으면 확실한 결과물을 만들어내지 못한다!&lt;/li&gt;
&lt;li&gt;공부를 하려는 사람을 많이 뽑으려고 했다.&lt;/li&gt;
&lt;li&gt;문제를 접근하는 방식에 있어서 어떤 식으로 접근하려고 하는지를 많이 보았다.&lt;/li&gt;
&lt;li&gt;1차 면접이 끝났다고, 거기서 안주하지 말고 어떤 점들을 더 보강하면 되는지를 생각을 해라.&lt;/li&gt;
&lt;li&gt;전산 기초 과목에 대한 학습을 충분히 하는 것을 추천한다. &lt;strong&gt;단순히 외우지 말고 이해해야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&amp;lsquo;왜?&amp;lsquo;라고 스스로에게 질문하고 답을 찾아봐야한다. 왜 이런 개념이 나왔는지, 왜 이 개념이 더 좋은지, 한번 깊이 생각을 해보는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;잘 모르겠으면 솔직히 이야기를 하라! 그러면 면접관들이 힌트를 줄 것이다.&lt;/li&gt;
&lt;li&gt;정답을 맞추는 능력 이상으로 답을 유추해 가는 사고력 또한 굉장히 중요하기 때문이다.&lt;/li&gt;
&lt;li&gt;본인이 해결해왔던 문제를 어떤 식으로 대하고, 접근했고, 치열하게 고민하고, 솔루션을 도출했는지를 중점적으로 물어본다.&lt;/li&gt;
&lt;li&gt;성공했으면 성공한 대로, 실패했으면 실패한대로 의미가 있기 때문이다.&lt;/li&gt;
&lt;li&gt;개발을 정말 좋아하고 기저의 원리를 이해하는데, 많은 노력을 들였는지를 물어본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110243042-14788300-7f9c-11eb-80d1-a4f252ce7cda.png&#34; alt=&#34;Screen Shot 2021-03-07 at 11 22 52 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;최대한 구체적이고&amp;rdquo;, &amp;ldquo;솔직할 것이다.&amp;rdquo; 왜냐하면 개발자의 핵심 역량은 &lt;strong&gt;설계 역량&lt;/strong&gt;, &lt;strong&gt;논리적 사고&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;커뮤니케이션&#34;&gt;커뮤니케이션&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;문제를 잘 듣고 이해하며, 자신이 생각한 답을 명확하고 간결하게 커뮤니케이션 할 수 있는지를 본다.&lt;/li&gt;
&lt;li&gt;협업에 대한 것을 강조해서 질문을 한다.&lt;/li&gt;
&lt;li&gt;여러가지 해결책들이 존재하는 질문을 던지게 되고, 아래 항목정도를 살펴본다.
&lt;ul&gt;
&lt;li&gt;문제를 어떤 수준에서 이해하고, 본인의 전문성/인사이트를 보여주는지&lt;/li&gt;
&lt;li&gt;면접관이 면접자의 의견과 방향이 다른 해결책을 제시했을 때, 다른 해결책에 대해서 어떻게 반응하는지, 수렴하여 시너지가 나는 새로운 방향을 제시하는지&lt;/li&gt;
&lt;li&gt;면접관이 면접자의 해결책의 안되는 이유를 여러가지 나열 했을 때, 이것들을 어떻게 정리하고 일이 되게 만드는 방향에 집중하는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 부분은 어떻게 키워야 할지 조금 막막하다. 지금도 노력하고 있지만 가장 부족한 부분이 커뮤니케이션 부분이라고 생각하기 때문이다.&lt;/p&gt;
&lt;h2 id=&#34;지원서&#34;&gt;지원서&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;화려한 문체나 거창한 커리어보다는, 개발에 대한 나만의 열정과, 노력들을 보여주는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;개발을 정말로 좋아하는지를 많이 본다.&lt;/li&gt;
&lt;li&gt;이수한 컴퓨터공학 관련 과목, 기술적 문제를 해결한 경험, 에너지를 집중해 끝가지 파고 들었던 경험을 적는 것이 좋다.&lt;/li&gt;
&lt;li&gt;개발자로서 개선해보고 싶은 네이버 서비스등도 미리 생각하면 좋다.&lt;/li&gt;
&lt;li&gt;포기하지 않고 끝까지 몰입해본 경험, 세상의 불편을 개발로 풀고자 시도했던 경험 등 개발자로서 성장 의지를 보여줄 수 있는 본인만의 스토리가 있다면 잘 녹여서 적어라&lt;/li&gt;
&lt;li&gt;내가 무엇을 할 수 있는지가 명확히 드러나는 지원서를 선호한다.&lt;/li&gt;
&lt;li&gt;어떤 프로젝트를 했었고, 그 프로젝트에서 어떤 역할을 했고, 내가 만든 산출물이 어떤 것이고, 기술적으로 어떤 고민을 했었는지 등이 나와 있는 지원서의 경우 더 자세히 보게 된다.&lt;/li&gt;
&lt;li&gt;지원서에 개인 &lt;code&gt;GITHUB URL&lt;/code&gt;을 작성한 지원자의 경우, 꼭 들어가서 본다.&lt;/li&gt;
&lt;li&gt;소스코드를 통해서 지원자의 개발 역량을 파악할 수 있을 뿐더라, &lt;code&gt;GITHUB&lt;/code&gt;를 운영하고 공유할 정도라면 어느 정도 수준이 있는 개발자일 것이라는 기대를 하기 때문이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GITHUB&lt;/code&gt;는 생각보다 많은 정보를 준다. 소스 코드를 지속적으로 업로드 하고, 관리하고 공유하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;지원서에서는 &amp;lsquo;결과&amp;rsquo;보다는 &amp;lsquo;무엇을 했는지&amp;rsquo; 강조하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;학과 공부에서 배운 것 뿐만 아니라 새로 알게 된 경험에 관한 이야기도 좋다.&lt;/li&gt;
&lt;li&gt;협업에 대해서 이야기 하고 싶다면 갈등, 조정, 협의, 합의 등에 이르게 된 과정을 설명하는게 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;네이버가 왜 이러한 점을 면접때 보는지 생각하면 업무에 도움이 되고 성장할 수 있는 개발자를 뽑으려고 하기 때문이다. 따라서 앞으로 내 업무 능력을 키워가는데도 도움이 될 것이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그리고 일을 하면서 만나는 문제들을 끝까지 파보자라는 자세를 가지고 접근하며 이와 내가 문제를 어떤 식으로 대하고, 접근했고, 치열하게 고민했고, 파봤고, 솔루션을 도출한 과정을 적으려면 실제로 그러한 자세로 일을 해야한다.&lt;/p&gt;
&lt;p&gt;너무 많아서 다 정리하지는 못했다. 하지만 어떤 기업을 지원하더라도, 지원서를 작성하기 전에, 이 사이트에 들려서 내가 작성한 글이 적합한지에 대한 고민을 해봐야 할 것이다.&lt;/p&gt;
&lt;h2 id=&#34;코딩-테스트&#34;&gt;코딩 테스트&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110243118-5d303c00-7f9c-11eb-9bdd-c9aa327aa421.png&#34; alt=&#34;Screen Shot 2021-03-07 at 11 24 31 PM&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://campaign.naver.com/recruit2020/checkpoint/&#34;&gt;naver 2020 신입개발공채 체크포인트!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (4) - ComputableFuture</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</link>
      <pubDate>Sun, 07 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-4-computablefuture/</guid>
      <description>&lt;h2 id=&#34;computablefuture란&#34;&gt;ComputableFuture란&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;자바에서 비동기(Asynchronous)를 가능케 하는 인터페이스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바에서는 Future를 통해서 어느정도의 비동기 프로그래밍이 가능하기는 했지만, 하기 힘든 일들이 많았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Future를 외부에서 완료시킬 수 없다.&lt;/li&gt;
&lt;li&gt;작업을 취소하거나, &lt;code&gt;get()&lt;/code&gt;에 타임아웃을 설정할 수 없다.&lt;/li&gt;
&lt;li&gt;블럭킹 코드를 사용하지 않고서는 작업이 끝났을 때 콜백을 실행할 수 없다.&lt;/li&gt;
&lt;li&gt;예외처리용 &lt;code&gt;API&lt;/code&gt;를 제공하지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비동기로-작업-실행하기&#34;&gt;비동기로 작업 실행하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;비동기로 작업을 실행하는 방법은 두가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runAsync()&lt;/code&gt;: 리턴값이 없는 경우 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;supplyAsync()&lt;/code&gt;: 리턴 값이 있는 경우 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음은 &lt;code&gt;ComputableFuture&lt;/code&gt;를 사용한 예제이다. &lt;code&gt;get()&lt;/code&gt;을 호출 했을 때 실행되게 된다.
자바 &lt;code&gt;API&lt;/code&gt;를 살펴보면 &lt;code&gt;supplyAsync()&lt;/code&gt;메서드는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110235572-1e868b80-7f74-11eb-9235-e71a182b912b.png&#34; alt=&#34;runAsync&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환한다. &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;에서 실행중인 태스트에 의해서 비동기적으로 실행된다.&lt;/li&gt;
&lt;li&gt;역시 새로운 &lt;code&gt;ComputableFuture&lt;/code&gt;를 반환하지만 차이점은 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스크를 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;ForkJoinPool&lt;/code&gt;을 사용하지 않는다면 다음과 같이 &lt;code&gt;ExecutorService&lt;/code&gt;에서 태스트가 처리되도록 할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }, executorService).thenRunAsync(() -&amp;gt; {
            System.out.println(Thread.currentThread().getName());
        }, executorService);
        future.get();
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;콜백-제공하기&#34;&gt;콜백 제공하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenApply(Function)&lt;/code&gt;: 리턴값을 받아서 다른 값으로 바꾸는 콜백&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenAccept(Consumer)&lt;/code&gt;: 리턴값을 또 다른 작업으로 처리하는 콜백 (리턴 없이)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thenRun(Runnable)&lt;/code&gt;: 리턴 값을 받지 않고 다른 작업을 처리하는 콜백&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;조합하기&#34;&gt;조합하기&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCompose()&lt;/code&gt;: 두 작업이 서로 이어서 실행하도록 조합하기&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCompose(Main::getWorld);

        System.out.println(future.get());
    }

    private static CompletableFuture&amp;lt;String&amp;gt; getWorld(String message) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return message + &amp;quot; World&amp;quot;;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thenCombine()&lt;/code&gt;: 두 작업을 독립적으로 실행하고 둘다 종료했을 때, 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; world = CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(&amp;quot;World &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;World&amp;quot;;
        });

        CompletableFuture&amp;lt;String&amp;gt; future = hello.thenCombine(world, (h, w) -&amp;gt; h + &amp;quot; &amp;quot; + w);
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음과 같이 두 작업이 각각 실행하여, 둘다 종료되었을 때, 콜백이 실행되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allOf()&lt;/code&gt;: 여러 작업을 모두 실행하고 모든 작업 결과에 콜백 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anyOf&lt;/code&gt;: 여러 작업중에 가장 빨리 끝난 하나의 결과에 콜백 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;예외-처리&#34;&gt;예외 처리&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exceptionally(Funciton)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).exceptionally(ex -&amp;gt; {
            System.out.println(ex);
            return &amp;quot;Error&amp;quot;;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handle(BiFunction)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        boolean throwError = true;
        CompletableFuture&amp;lt;String&amp;gt; hello = CompletableFuture.supplyAsync(() -&amp;gt; {
            if (throwError) {
                throw new IllegalArgumentException();
            }

            System.out.println(&amp;quot;Hello &amp;quot; + Thread.currentThread().getName());
            return &amp;quot;Hello&amp;quot;;
        }).handle((result, ex) -&amp;gt; {
            if (ex != null) {
                System.out.println(ex);
                return &amp;quot;ERROR!&amp;quot;;
            }
            return result;
        });

        System.out.println(hello.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 07 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/07/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h2 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;한 주간에 있었던 일과 생각을 정리해보았습니다.&lt;/p&gt;
&lt;h2 id=&#34;jwt-토큰에-대해서-알게-되었다&#34;&gt;JWT 토큰에 대해서 알게 되었다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 과제를 하면서 JWT 토큰에 대해서 조사를 해보았다.&lt;/li&gt;
&lt;li&gt;JWT 토큰에 대해서 들어본적은 기억은 있었지만, 로그인을 할 때 사용한다 정도로만 알고 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110233686-e0d03580-7f68-11eb-8721-07699d334efc.png&#34; alt=&#34;Screen Shot 2021-03-07 at 5 16 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과제를 제출하기 전에, 내가 사용하는 라이브러리에 대해서 최소한의 조사를 하고 PR을 하자는 목표를 가지고 조사를 하게 되었다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RFC&lt;/code&gt; 문서까지 읽고 공부를 했으면 더 좋았을 것 같다. 따라서 투두 리스트에 넣어두고 시간이 되는대로 읽고 정리하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;커뮤니케이션&#34;&gt;커뮤니케이션&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;적극적으로 내가 어떤 일을 어디까지 진행했고, 어떤 일을 하려고 하는지 이야기 하였다. 일부러 조금 오버해서 &lt;code&gt;TMI&lt;/code&gt; 일정도로 동료들에게 내가 하고있는 일을 이야기했다.&lt;/li&gt;
&lt;li&gt;동료들이 알아주는 것 같아서 기뻣다.&lt;/li&gt;
&lt;li&gt;하지만, 말하다보니 생각이 완전히 정리되지 않을 때가 많다고 느꼈다.&lt;/li&gt;
&lt;li&gt;따라서 이야기를 하기 전에 미리 할 이야기를 정리하고 얘기를 하도록 해야겠다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 잘 하려면 소프트 스킬이 중요하다는 사실을 깨닫게 되었다.&lt;/li&gt;
&lt;li&gt;회사를 다니기 전에는 커뮤니케이션 능력의 중요성에 대해서 간과하고 있었다.&lt;/li&gt;
&lt;li&gt;따라서 소프트 스킬 능력을 키우기 위해서 많이 노력해야겠다.&lt;/li&gt;
&lt;li&gt;개발자 뿐만 아니라, 업무와 연관된 모든 사람들에게 내가 여태까지 어떤일을 진행하고 있고 현재 어떤 업무를 하고 있는지 적극적으로 알려야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;고쳐야-할점&#34;&gt;고쳐야 할점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;내가 발견한 사실 및 해결책이 나올 것 같을 때, 흥분해서 성급하게 짐작해서 말하는 습관이 있다. 이를 고치도록 해야겠다. 예를 들어서 비슷한 예외가 많이 발생하여 이번에도 이 예외가 발생하고 있다고 말했는데 다시 확인해보니 아니였다.&lt;/li&gt;
&lt;li&gt;이때의 부끄러운 기억을 간직하고 다시는 같은 실수를 반복하지말고 때로는 시간이 조금 걸리더라도 정확하게 확인하는 습관을 들이자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;잘한-점&#34;&gt;잘한 점&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이슈를 진행하면서 내가 모르는 옵션이나, 기능이 나올 때 공식문서를 찾아보고 있다.&lt;/li&gt;
&lt;li&gt;최근에는 &lt;code&gt;groupby&lt;/code&gt; 함수를 사용할 일이 있었는데, 공식 문서를 보지 않고 사용했으면 버그를 발생시킬 수 있는 일이 있었다. 왜냐하면 파이썬의 &lt;code&gt;groupby&lt;/code&gt; 함수는 SQL 문과 달리 사용하기전에 키로 한번 정렬을 해주어야 하기 때문이다. 아마도 문서를 읽어보지 않았더라면 버그가 발생했을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;라인-신입-개발자-채용이라는-글을-읽고-느낀점&#34;&gt;라인 신입 개발자 채용이라는 글을 읽고 느낀점&amp;hellip;&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;라인 신입 개발자 채용이라는 기술 블로그에 있는 글을 읽고 정리를 했다. &lt;a href=&#34;https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/&#34;&gt;라인 개발자 입사기를 읽고 느낀점&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;코딩 테스트를 준비는 꾸준히 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;이번 기회에 운영체제, 자료구조, 네트워크, 데이터베이스와 같은 컴퓨터공학 기초 지식들을 블로그에 틈틈히 정리를 해야겠다.&lt;/li&gt;
&lt;li&gt;포트폴리오에서는 내가 얼마만큼 알고 있는지보다는, 내가 얼마만큼 고민 했다는 것을 어필하라고 했다.&lt;/li&gt;
&lt;li&gt;프로젝트를 할 때, 문제 발생 - 문제 원인 파악 - 해결책 적용 - 결과 라는 절차를 두고 프로젝트 문제 과정을 서술했다고 했고 좋은 방법인것 같다.&lt;/li&gt;
&lt;li&gt;코드숨에서 이제 곧 프로젝트를 할 텐데, 이러한 점을 놓치지 않아야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;오랜만에-주고-받았던-메일을-보면서-많은-것을-느낄-수-있었다&#34;&gt;오랜만에 주고 받았던 메일을 보면서 많은 것을 느낄 수 있었다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/&#34;&gt;DBMS를 분석하는 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;회사 코드를 작성하면서 내가 코드 레벨부터 확인하려는 습관이 있는데 시간이 오래걸리고 놓친 부분이 많아서 코드를 수정하는 일이 많았는데, 이를 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;회사-코드에-클래스-주석-메서드-주석을-적고-있다&#34;&gt;회사 코드에, 클래스 주석, 메서드 주석을 적고 있다.&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 과제를 하면서 자신감이 생겨서 클래스 주석 및 메서드 주석을 회사 코드에 작성하였다.&lt;/li&gt;
&lt;li&gt;다만, DRY 원칙에 어긋나지 않고 제대로 작성을 하기 위해서 노력해야겠다.&lt;/li&gt;
&lt;li&gt;더 나아가서, 중복된 코드를 제거하고 테스트 코드까지 작성할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;코드숨&#34;&gt;코드숨&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;이번주에는 딴짓도 많이 하고(블로그에 쓰고 싶은 글이 많아 손이 근질근질 해서 블로그에 글을 많이 작성했다.) 시간도 부족해서 강의에 집중하지 못했다.&lt;/li&gt;
&lt;li&gt;게다가 회사 세미나 과제를 부랴부랴 하느라 시간이 부족했다.&lt;/li&gt;
&lt;li&gt;이번주에는 많이 부족했지만 리프레시 했다고 생각하고 다음주에는 열심히 과제를 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (3) - Callable과 Future</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</link>
      <pubDate>Sat, 06 Mar 2021 15:50:23 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-3-callable%EA%B3%BC-future/</guid>
      <description>&lt;h2 id=&#34;callable과-future&#34;&gt;Callable과 Future&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;과 &lt;code&gt;Runnable&lt;/code&gt;의 차이점은 작업의 결과를 받을 수 있다는 사실이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198342-24f20600-7e95-11eb-827d-e423468801e7.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;다음은 &lt;code&gt;Future&lt;/code&gt;에 대해 설명한 API 주석이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;는 비동기식 계산의 결과를 나타냅니다.&lt;/li&gt;
&lt;li&gt;계산이 완료되었는지 확인하고, 완료되기를 기다리며, 결과를 확인할 수 있는 방법이 제공됩니다.&lt;/li&gt;
&lt;li&gt;결과는 계산이 완료된 경우에만 메서드 &lt;code&gt;get&lt;/code&gt;을 사용하여 검색할 수 있으며, 작업이 완료될 때까지 블록킹 됩니다.&lt;/li&gt;
&lt;li&gt;또한 작업이 정상적으로 완료되었는지 또는 취소되었는지 확인할 수 있는 추가적인 방법이 제공된다.&lt;/li&gt;
&lt;li&gt;작업이 완료되면 이를 취소할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get---결과를-가져오기&#34;&gt;get() - 결과를 가져오기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198530-8d8db280-7e96-11eb-9b45-45b9bae25d57.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;은 오버로딩 된 두가지 메서드를 제공한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계산이 완료될 때까지 기다린 다음에 결과를 검색한다.&lt;/li&gt;
&lt;li&gt;최대 지정된 시간까지 기다렸다가 사용 가능한 경우 결과를 검색합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Future&amp;lt;String&amp;gt; helloFuture = executorService.submit(hello);
        System.out.println(&amp;quot;Started!&amp;quot;);

        helloFuture.get(); // blocking call

        System.out.println(&amp;quot;End!!&amp;quot;);
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다음과 같은 경우에는 터미널에 &lt;code&gt;Started!&lt;/code&gt; 라는 글씨가 적히고 나서, 2초간 대기를 한 후에 &lt;code&gt;End!!&lt;/code&gt; 라는 글씨가 찍히게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;타임아웃(최대로 기다릴 시간)을 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isdone-iscancelled---작업-상태-확인하기&#34;&gt;isDone(), isCancelled() - 작업 상태 확인하기&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110198688-a64a9800-7e97-11eb-8f77-8bd8a28d5757.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 56 51 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isDone&lt;/code&gt;은 작업이 완료되었으면 참을 반환하고 아닌 경우에는 거짓을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isCancelled&lt;/code&gt;는 작업이 완료된 경우 참을 반환한다. 작업이 정상적으로 종료되거나, 예외 또는, 취소된 경우도 역시 참으로 반환된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cancel---작업-취소하기&#34;&gt;cancel() - 작업 취소하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199234-d3e51080-7e9a-11eb-9fb7-1ff63519640f.png&#34; alt=&#34;작업 취소&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작업을 취소할 때 사용한다.&lt;/li&gt;
&lt;li&gt;작업이 이미 완료되었거나, 취소되었거나, 다른 이유로 취소할 수 없는 경우에는 실패한다.&lt;/li&gt;
&lt;li&gt;이 메서드가 실행된 후에 &lt;code&gt;isDone()&lt;/code&gt;는 항상 참을 반환한다.&lt;/li&gt;
&lt;li&gt;일반적으로 작업이 이미 정상적으로 완료되었기 때문에, 작업을 취소할 수 없는 경우에는 거짓을 반환하고 그렇지 않으면 참을 반환한다.&lt;/li&gt;
&lt;li&gt;성공적으로 취소했으면, 참 아니면 거짓을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;invokeall과-invokeany의-차이점&#34;&gt;invokeAll()과 invokeAny()의 차이점&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;invokeall&#34;&gt;invokeAll&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199536-2d017400-7e9c-11eb-8b43-33862e419425.png&#34; alt=&#34;invokeAll&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;태스크를 실행하고 모두 완료되거나 시간 초과가 만료될 때, 상태 및 결과를 저장하고 있는 &lt;code&gt;Future&lt;/code&gt; 목록을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future.isDone&lt;/code&gt;은 반환된 목록의 각 요소에 대해서 적용됩니다.&lt;/li&gt;
&lt;li&gt;반환시에 완료되지 않은 태스크는 취소됩니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정한 컬렉션이 수정되면 메서드의 결과가 정의되지 않습니다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 가장 오래걸리는 작업만큼 시간이 소요된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = executorService.invokeAll(Arrays.asList(hello, java, dongwook));

        for (Future&amp;lt;String&amp;gt; f : futures) {
            System.out.println(f.get()); // Hello, Java, Dong Wook 순서대로 출력된다.
        }
        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;invokeany&#34;&gt;invokeAny&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110199641-adc07000-7e9c-11eb-8c91-a79c559268e2.png&#34; alt=&#34;invokeAny&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성공적으로 완료된 태스크의 결과를 반환합니다.&lt;/li&gt;
&lt;li&gt;이 작업이 진행되는 동안 지정된 컬렉션이 수정되면 이 메서드의 결과가 정의되지 않는다.&lt;/li&gt;
&lt;li&gt;동시에 실행한 작업중에 제일 짧게 걸리는 작업만큼 시간이 걸린다.&lt;/li&gt;
&lt;li&gt;이 역시 또한 블록킹 콜이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        Callable&amp;lt;String&amp;gt; hello = () -&amp;gt; {
            Thread.sleep(2000L);
            return &amp;quot;Hello&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; java = () -&amp;gt; {
            Thread.sleep(4000L);
            return &amp;quot;Java&amp;quot;;
        };

        Callable&amp;lt;String&amp;gt; dongwook = () -&amp;gt; {
            Thread.sleep(100L);
            return &amp;quot;Dong Wook&amp;quot;;
        };

        String futures = executorService.invokeAny(Arrays.asList(hello, java, dongwook));

        System.out.println(futures); // Dong Wook
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 06 Mar 2021 15:14:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파이썬 AOP라는 글을 읽어보았다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;오늘 회사 세미나 과제를 했다. (자바 동시성 및 &lt;code&gt;ComputableFuture&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;인터셉터에 대해서 배우게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아직 스트림 연산에 대해서 완전히 이해를 하지 못한 것 같다.&lt;/li&gt;
&lt;li&gt;객체의 본질적인 역할과 관심사의 분리를 해주는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤한 기능을 도입할 때, 프로젝트에 정말로 필요한 기능인가를 생각해보고 프로젝트에 필요한 부분만 선택하는 능력이 필요하다는 것을 느꼈다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;항상 다양한 관점에서 생각을 해보고 이를 목록으로 정리하여 내가 선택한 이유를 정리하는 것을 보았다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트 코드를 설명할 때, 나는 주로 ~~ 했을 때 ~~ 한다라고 작성하였지만 ~~하면 ~~ 한다라는 패턴으로 작성하는 것이 좋을 것 같다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228193-9340d200-7f42-11eb-937a-900cce6a64af.png&#34; alt=&#34;Screen Shot 2021-03-07 at 12 42 09 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨트롤러나, 서비스 클래스를 설명하는 자바 독을 작성할 때는, ~~ 관련된 이라는 키워드를 사용하면 쉽게 설명할 수 있다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228587-a99c5d00-7f45-11eb-920e-50d322cc79d7.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 04 29 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서비스 클래스를 설명하는 자바 독은 ~~ 작업을 제공한다. 이렇게 적는 것이 더 바람직하다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228608-cb95df80-7f45-11eb-855e-7335dcafaed9.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 05 23 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나는 기존에 ~~를 얻는다. 이렇게 작성을 했는데, ~~를 리턴한다와 같이 행동에만 집중해서 자바 문서를 작성하는 것이 좋을 것이다.
&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110228567-807bcc80-7f45-11eb-8b1c-c2015bcededa.png&#34; alt=&#34;Screen Shot 2021-03-07 at 1 03 18 PM&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인증과 인가의 차이점에 대해서 배웠다. 그리고 서버와 클라이언트 사이의 인증과 인가에 대한 관점 차이를 알게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication -&amp;gt; 로그인 -&amp;gt; Token (인증)&lt;/li&gt;
&lt;li&gt;Authorization &amp;lt;- Token (인가)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication = 로그인 (인증)&lt;/li&gt;
&lt;li&gt;Token -&amp;gt; Authentication (인증)&lt;/li&gt;
&lt;li&gt;User -&amp;gt; Role -&amp;gt; Authentication (인가)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;중복과 테스트 코드에 대해서 고민을 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이번주에 코드숨 과정에 집중하지 못했다.&lt;/li&gt;
&lt;li&gt;작은 부분이라도 최선을 다해야겠다.&lt;/li&gt;
&lt;li&gt;일의 우선순위를 정하고 이를 꼭 지키도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다음주부터는 코드숨 과정에 완전히 집중할 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://labs.brandi.co.kr/2020/01/07/yangjh.html&#34;&gt;http://labs.brandi.co.kr/2020/01/07/yangjh.html&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>파이썬에 AOP 적용하기라는 글을 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Sat, 06 Mar 2021 14:50:40 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90-aop-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;내가 현재 맡고 있는 솔루션에는 일일이 데이터베이스를 열어주고 쿼리를 실행하고 데이터베이스를 닫아주는 과정을 거치고 있었다. 매우 비효율적이고 중복된 코드가 많아져 이를 수정하고자 하였다. 따라서, 어떻게 수정할까 고민하는 과정에서 스프링에 있는 &lt;code&gt;AOP&lt;/code&gt; 개념이 파이썬에도 있을 것이라고 확신하고 검색을 했다.  그러던 중에, 브랜디 개발 블로그에서 좋은 글을 발견하여 이를 읽고 느낀점을 적어보았다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197088-69c56f00-7e8c-11eb-8350-146a7c2cbed8.png&#34; alt=&#34;Screen Shot 2021-03-06 at 2 58 11 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 관점에서 고려해보는 모습이 인상 깊었다.&lt;/li&gt;
&lt;li&gt;나도 물론 최선의 방법을 생각해보려고 고민을 해보지만, 이렇게까지 다양한 과점을 고려해보지는 않은 것 같다. 따라서 이와 같은 점을 배우도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197130-cde83300-7e8c-11eb-98ca-f47d669044bd.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 01 03 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구현을 할 때, 요구사항을 명확히 정리해서 어떤 부분의 만족 시켜야하는지 조건을 상세하게 나열하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 회사에서 요구사항을 명확히 이해하지 못해서 자꾸 실수를 하는 일이 있었는데, 이와 같이 요구사항을 명확히 글로 작성하면 실수할 일이 적어지고 내가 빠뜨린 부분이 없나 쉽게 확인할 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110197183-2d464300-7e8d-11eb-827d-03141a27e467.png&#34; alt=&#34;Screen Shot 2021-03-06 at 3 03 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩을 할 때, 시간의 제약 때문에 때로는 완벽하게 구현을 하지 못할 수 도 있다. 그래도 앞으로 개선할 방향 및 고민을 해야하는 부분을 기록해두면 나중에 여유가 생기거나 문제가 생겼을 때, 어떤 부분을 고민하고 해결해야하는지 쉽게 알 수 있을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글쓴이가 생각하는 불변의 원칙은 &amp;lsquo;정확한 요구사항을 지키는 것&amp;rsquo; 이다. 좋은 개발 방법론이나, 라이브러리가 있지만 정말로 우리 프로젝트에 필요한 기능인가를 항상 염두해야한다고 했다. 정말 맞는 것 같고, 프로젝트에 좋은 기능이라고 생각하면 무조건 도입을 해야한다고 생각하던 때가 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하지만 정말로 우리 프로젝트에 필요한 기능인가를 고민하고 필요한 기능만 구현하는 안목이 필요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://labs.brandi.co.kr/2020/01/07/yangjh.html&#34;&gt;파이썬 프로젝트에 AOP 도입하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 itertools 모듈의 group by 함수</title>
      <link>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98/</link>
      <pubDate>Sat, 06 Mar 2021 13:15:35 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/06/%ED%8C%8C%EC%9D%B4%EC%8D%AC-itertools-%EB%AA%A8%EB%93%88%EC%9D%98-group-by-%ED%95%A8%EC%88%98/</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;회사에서 이슈를 처리 하다가, 키 값을 기준으로 하위 리스트를 처리할 일이 있었다.
자바였으면  &lt;code&gt;groupingBy()&lt;/code&gt;를 이용하여 쉽게 처리를 할 수 있다는 생각을 하고 있었던 참에 파이썬도 이와같은 함수를 지원하지 않을까라는 생각이 들어서 검색을 해보니 비슷한 함수가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/110194923-8d81b880-7e7e-11eb-818d-fc66c7f4a6a0.png&#34; alt=&#34;Screen Shot 2021-03-06 at 1 18 19 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;연속된 키와 그룹을 반환하는 이터레이터를 만든다.&lt;/li&gt;
&lt;li&gt;인자중에, 키는 각 요소의 키 값을 계산하는 함수이다.&lt;/li&gt;
&lt;li&gt;일반적으로 해당 항목은 동일한 키 함수에 대해서 이미 정렬되어야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;키 함수의 값이 변경될 때마다 중단하거나 새 그룹을 생성하기 때문에 동일한 키 함수를 이용하여 데이터를 정렬해줘야한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;그렇기 때문에 입력 순서에 관계없이 공통 요소를 집계하는 SQL의 GROUP BY와는 다르다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이터레이터가 진행될 때마다, 이전 그룹은 사라지므로 만약 필요하다면 리스트로 저장해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 &lt;code&gt;groupby&lt;/code&gt;를 사용한 예제이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import groupby

things = [(&amp;quot;animal&amp;quot;, &amp;quot;bear&amp;quot;), (&amp;quot;animal&amp;quot;, &amp;quot;duck&amp;quot;), (&amp;quot;plant&amp;quot;, &amp;quot;cactus&amp;quot;), (&amp;quot;vehicle&amp;quot;, &amp;quot;speed boat&amp;quot;), (&amp;quot;vehicle&amp;quot;, &amp;quot;school bus&amp;quot;)]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(&amp;quot;A %s is a %s.&amp;quot; % (thing[1], key))
    print(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;키 값으로 튜플의 첫 번째 값을 사용하여 정렬 하였고, 키 값에 따른 그룹이 생성될 때마다 이를 출력한 것이다.&lt;/p&gt;
&lt;h4 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 말했듯이 사용하기 전에, 키 값을 기준으로 정렬이 된 리스트인지, 그리고 보장을 하지 못한다면 정렬을 해줘야하는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# [k for k, g in groupby(&#39;AAAABBBCCDAABBB&#39;)] --&amp;gt; A B C D A B
# [list(g) for k, g in groupby(&#39;AAAABBBCCD&#39;)] --&amp;gt; AAAA BBB CC D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;정렬을 해주지 않으면 위와 같은 형태로 만들어 지게 된다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/itertools.html#itertools.groupby&#34;&gt;itertools - groupby 파이썬 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/773/how-do-i-use-itertools-groupby&#34;&gt;group by 예제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 05 Mar 2021 07:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/05/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기계인간님의 DRY 원칙에 대해서 쓴 글을 읽었다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;기계인간님의 디미터 법칙에 관한 글을 읽었다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DRY 원칙은 모든 곳에 적용할 수 있을 것이다. (코드, 테스트, 문서화) 그리고 내가 DRY 원칙을 잘 지키고 있는지 생각하면 그렇지 못한 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실용주의 프로그래머에서는 중복을 4가지로 분리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;강요된 중복 : 개발자들은 다른 선택이 없어 보인다. 환경이 중복을 요구하는 것 처럼 보인다.&lt;/li&gt;
&lt;li&gt;부주의한 중복 : 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.&lt;/li&gt;
&lt;li&gt;참을성 없는 중복 : 중복이 쉬워보이기 때문에, 개발자들이 게을러져서 중복을 하게 된다.&lt;/li&gt;
&lt;li&gt;개발자간의 중복 : 한 팀에 있는 (혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;또한 코드내의 주석이 너무 많거나 상세하더라도 DRY 원칙을 위반할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;코드에는 주석이 있어야하지만, 너무 많은 것은 너무 적은 것만큼이나 좋지 않다. &lt;strong&gt;일반적으로 주석은 왜 이렇게 되어 있는지 목적을 논해야한다.&lt;/strong&gt; 코드가 이미 어떻게 되어 있는지 보여주기 때문에 이에 대해 주석을 다는 것은 사족이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라. 이렇듯 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다. 다른 프로그래머들이 그만큼 어휘를 사용하기 쉬워진다. &lt;strong&gt;추상화 수준을 높였으므로, 구현이 빨라지고 오류가 적어진다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디미터 법칙이란 긴 객체 구조의 경로를 따라서 멀리 떨어져 있는 간접적인 (낯선) 객체에 메세지를 보내는 (또는 이야기하는) 설계는 피하라는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Don&#39;t talk to Strangers&lt;/code&gt; 패턴은 메서드 내에서 어떤 객체에 메시지를 보내야 하는가에 대한 제약을 가한다. 메서드 안에서는 다음의 객체들에게만 메시지를 보내야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;this(또는 self) 객체&lt;/li&gt;
&lt;li&gt;메서드의 매개변수&lt;/li&gt;
&lt;li&gt;this의 속성&lt;/li&gt;
&lt;li&gt;this 속성인 컬렉션의 요소&lt;/li&gt;
&lt;li&gt;메서드 내에서 생성된 객체&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;중복의-유형과-제거-방법&#34;&gt;중복의 유형과 제거 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 뻔한 유형은 똑같은 코드가 여러 차례 나오는 중복이다. 프로그래머가 미친듯이 마우스로 긁어다 여기저기로 복사한 듯이 보이는 코드이다. 이러한 중복은 간단한 함수로 교체한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 미묘한 유형은 여러 모듈에서 일련의 &lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;문으로 똑같은 조건을 거듭 확인하는 중복이다. 이러한 중복은 다형성으로 대체해야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더더욱 미묘한 유형은 알고리즘이 유사하나 코드가 서로 다른 중복이다. 중복은 중복이므로, &lt;code&gt;TEMPLATE METHOD&lt;/code&gt; 패턴이나, &lt;code&gt;STRATEGY&lt;/code&gt; 패턴으로 중복을 제거한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디자인 패턴은 대다수가 중복을 제거하는 잘 알려진 방법에 불과하다. &lt;code&gt;OOP&lt;/code&gt;, &lt;code&gt;BDNF&lt;/code&gt; 역시 마찬가지이고, 또한 구조적 프로그래밍도 마찬가지이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여태까지 주석을 코드의 목적을 위해서 적기 보다는 과정을 설명하기 위해서 적었던 것 같다.&lt;/li&gt;
&lt;li&gt;코드에서 중복된 부분이 많음에도 불구하고, 그냥 무심코 지나간 적이 많았던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;중복을 최대한 줄이도록 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;회사에서 일을 하면서 중복된 코드가 보인다면 제거하려고 시도하겠다.&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 중복을 줄이면 저절로 소프트웨어가 좋은 설계대로 구현이 될 것 같다. 나는 처음에는 좋은 설계로 소프트웨어를 작성해야지라고 생각을 했지만 사실, 좋은 설계를 한다는 것 자체가 추상적이다. 구체적인 방법은 코드에 중복을 줄여야지, 테스트 코드를 작성해야지 같은 구체적인 행동을 통해서 좋은 설계가 나온다는 생각을 했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/dry-principle/&#34;&gt;https://johngrib.github.io/wiki/dry-principle/&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/law-of-demeter/&#34;&gt;https://johngrib.github.io/wiki/law-of-demeter/&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>테크니컬 라이팅 4대 원칙이라는 글을 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Thu, 04 Mar 2021 18:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/04/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%9D%BC%EC%9D%B4%ED%8C%85-4%EB%8C%80-%EC%9B%90%EC%B9%99%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>&lt;h3 id=&#34;테스트-코드-및-메서드-주석에-대한-고민&#34;&gt;테스트 코드 및 메서드 주석에 대한 고민&lt;/h3&gt;
&lt;p&gt;코드를 작성하면서 테스트 코드에 어떤 테스트라는 것을 어떻게 명확하게 표현할까, 그리고 모듈 및 클래스, 메서드 주석을 달면서 어떻게 작성해야 좋은 문서가 될까? 라는 고민을 하고 작성하였지만 여전히 어렵기만 했다. 그런던 중에서 카카오 기술 블로그에서 도움이 될 만한 글을 발견하였다.&lt;/p&gt;
&lt;h4 id=&#34;테크닐컬-라이팅의-4대-원칙&#34;&gt;테크닐컬 라이팅의 4대 원칙&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109958056-21da0700-7d29-11eb-8f4f-779e11801b92.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;명확성&#34;&gt;명확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;테크니컬 라이팅의 첫 번째 원칙은 명확성이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;명확성이란 핵심어나 핵심 문장이 모호하게 사용되지 않고, 대상 독자가 기술 문서를 읽을 때, 내용의 모호함이나 혼란 없이 한번에 이해하도록 하는 글이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 문서를 읽을 때, 독자 입장에서 이해가 가지 않아 특정 부분을 몇 번이고 다시 읽게 된다면, 이는 명확성이 떨어지는 글이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성이 떨어지는 이유는 대부분의 경우 대상 독자를 제대로 파악하지 못해서 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자라면 모두 아는 내용인데 적어야할까?&amp;rdquo; 라는 의문이 생기더라도 모두 적어야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;개발자들이라면 다 안다&amp;quot;라는 생각은 굉장히 주관적일 수 있기 때문이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대학생들이나 외부의 초급 개발자들도 쉽게 따라 할 수 있을 정도의 상세한 문서여야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959088-6023f600-7d2a-11eb-9a7f-cfb1012115e6.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 44 05 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;간결성&#34;&gt;간결성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;간결성이란 특정 독자가 기술적인 내용을 신속하고 정확하게 이해할 수 있도록 미사여구나 감탄사 등을 사용하지 않고, 쉬운 단어와 간결한 문장을 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문장을 길고 복잡하게 복문으로 써야 더 있어보이고, 더 많은 정보를 담게 될 것이라는 생각은 금물이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기술 문서에서는 &amp;ldquo;~는 ~입니다.&amp;rdquo; 라는 형식의 단문을 사용할 때 더욱 명확하고 가독성이 높은 글을 작성할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959559-040da180-7d2b-11eb-8d7a-a0ad03e6e701.png&#34; alt=&#34;img1 daumcdn&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959668-2a334180-7d2b-11eb-924d-1945a49faf98.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 49 40 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;정확성&#34;&gt;정확성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;독자가 필요로 하는 정보를 기술적 오류 없이 정확하게 제공하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;명확성과, 간결성이 떨어지지만 정확성이 확보된 기술문서라면, 독자들은 시간이 많이 걸린다고 해도 해당 문서를 이해할 수 있지만 반대의 경우에는 잘못된 정보를 전달하게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109959933-7da58f80-7d2b-11eb-9144-7ca86c041707.png&#34; alt=&#34;Screen Shot 2021-03-04 at 8 51 58 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;일관성&#34;&gt;일관성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문서에 용어, 표현, 그리고 어조 등을 일관성 있게 사용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특히 한번 언급된 단어를 다른 방식으로 언급하는 것은 독자에게 큰 혼란을 줄 수 있고, 결과적으로 문서의 신뢰도와 가독성이 저하된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;정리&#34;&gt;정리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;짧게 써라&amp;quot;라고 시작하는 문장은 테크니컬 라이팅 대 원칙중 &amp;ldquo;간결성&amp;quot;을 &amp;ldquo;명료하게 써라&amp;quot;는 &amp;ldquo;명확성에 해당한다&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;그림처럼 써라&amp;quot;라는 문장은 독자가 어떤 시스템이나 기능의 아키텍처를 보다 쉽게 이해할 수 있도록 논리적으로 기술하거나 개발 시나리오나 개발 흐름 등의 시각 자료를 활용하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakaoenterprise.com/102&#34;&gt;테크니컬 라이팅 4대 원칙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 04 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/04/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 &lt;code&gt;PM&lt;/code&gt; 분이 맡은 일을 언제까지 끝낼 수 있는지 공유를 해주면 일정 조율을 하기 편할 것 같다는 말씀을 하셨다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하면서, 전체적인 기능을 보고 코드를 보면서 어떻게 구현할지 생각하지 않고, 코드부터 보면서 어떻게 구현할지 생각을 했다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하면서 메서드 주석 및 클래스 주석을 작성하려고 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여태까지 팀 안에서 개발자들과의 소통만 생각했었는데, &lt;code&gt;PM&lt;/code&gt; 분과의 소통 하는 방법에 대해서도 생각을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;우리 팀장님은 나이나 실력이 어리다고 무시하지 않고 모두 똑같이 존중을 해주시는 것 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DBMS&lt;/code&gt; 개발자분이 말씀하셨던 것 처럼, 모듈이 어떤 기능을 하는 지 먼저 파악하고 그 다음에, 코드를 보면서 어떻게 구현할지를 생각하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;하지만, 이 모듈 및 클래스 그리고 메서드가 어떤 역할을 하는지 몰라서 작성하지 못했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발자 뿐만 아니라, &lt;code&gt;PM&lt;/code&gt;, &lt;code&gt;QA&lt;/code&gt; 분들간에 내가 무엇을 하고있는지 그리고 언제까지 할 수 있을지를 공유하는것이 중요하다.&lt;/li&gt;
&lt;li&gt;나도 다른 사람들을 한결같이 존중해야겠고, 이러한 자세를 배우려고 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;나는 앞으로 코딩을 할 때, 뭐든지 여태까지 해왔던 것에서 반대로 진행을 해야겠다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;코드를 보기 전에 기능을 파악하기&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;설계를 하기전에 테스트를 작성하기&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;구현을 하기전에 어떻게 구현할지 단계별로 생각하기&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코드 레벨부터 보게 된다면 많은 시행착오를 거치게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;너무 스트레스 받지 않으면서 일을 하고 있다.&lt;/li&gt;
&lt;li&gt;코드에 문서화를 시도하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;개발자 뿐만 아니라, 모든 분들과 소통을 할 수 있도록 해야겠다.&lt;/li&gt;
&lt;li&gt;문서화를 어떻게 하면 잘 할 수 있는지 살펴보도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;앞으로 다른 모든 직군분들과 소통하려고 노력을 할 것이다.&lt;/li&gt;
&lt;li&gt;문서화를 어떻게 하면 더 잘할 수 있을지 고민하고 남들이 내가 작성할 코드를 보았을 때, 명확하게 이해할 수 있도록 할 것이다.&lt;/li&gt;
&lt;li&gt;개발을 하기전에, 전체적인 기능 및 구현이 어떻게 되어있는지 그리고 어떻게 돌아가는지를 먼저 파악할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>DBMS를 분석하는 방법</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Wed, 03 Mar 2021 23:32:24 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/dbms%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>&lt;h3 id=&#34;kcd-2020&#34;&gt;KCD 2020&lt;/h3&gt;
&lt;hr&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/CgxiNF6xigY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;막 오픈소스 컨트리뷰톤을 끝마치고, 오픈소스 개발에 재미를 붙였을 때, KDC 2020이라는 세미나가 열렸다. 오픈소스 데이터베이스 큐브리드에 기여하기라는 제목의 세션을 보았을 때, 오픈소스 DBMS를 개발한다는 부분이 신기했고, 궁금한 점이 있어서 메일을 보내게 되었는데, 친절하게도 아주 장문의 답장을 해주셨다.&lt;/p&gt;
&lt;h3 id=&#34;메일&#34;&gt;메일&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109822109-ffd57b80-7c79-11eb-878d-337a28318428.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 41 29 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;내가 보낸 메일을 다시 보니까, 많이 부끄럽다;;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109821623-82117000-7c79-11eb-9da5-7f9b3f2d2864.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 37 57 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;매우 유용한 조언을 해주셨고, 실제로 많은 도움이 되었다. 이를 요약하자면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코드 레벨에서부터 접근하면 분석하기 쉽지 않다. 특히 DBMS는 여러가지 큰 개념이 모두 함께 유기적으로 동작하기 때문에 (&lt;code&gt;SQL&lt;/code&gt;, &lt;code&gt;Query Rewrite/Optimization&lt;/code&gt;, &lt;code&gt;Index&lt;/code&gt;, &lt;code&gt;Transaction&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;앞에서 말한 각 모듈들은 코드상으로는 &lt;code&gt;DBMS&lt;/code&gt; 마다 모두 다르게 구현되어 있을 것이다. 따라서 추상적인 개념을 코드로 된 구현체로 최대한 맵핑해보려는 시도를 하는 것이 좋다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어, &amp;ldquo;SQL 파서 모듈은 SQL을 읽어서 파싱 트리라는 구조를 만든다&amp;quot;와 같은 개념들은 DBMS 마다 같지만 코드상으로는 다르게 구현되어 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQL 파서 모듈과 같이, 각 모듈을 처음부터 코드를 읽어가면서 맨땅부터 이해하는 것은 쉽지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시간이 충분하다면 한줄 한줄 분석하면서 파악할 수는 있겠지만 거의 불가능하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 그 모듈이 어떻게 돌아가는지에 대한 맥락을 먼저 잡아야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 현업에서 일을 할 때 도 마찬가지라는 것을 명심해야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;모듈을-분석하는-법&#34;&gt;모듈을 분석하는 법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;1. 개략적인 모듈의 모양을 파악하기 위해서, 모듈의 인터페이스 또는 API나 시작점을 먼저 찾아본다.
2. 모듈을 관통하는 주요 자료구조가 있다면 파악해둔다, (SQL 파서의 경우에는 `파싱트리`) 그 자료구조를 바탕으로 다른 엮여 있는 자료구조나 기능 구현을 파악해나간다.
3. 분석하고 있는 모듈과 관련해서 다른 사람이 이전에 개발했던 기능, 기능/개선, 버그 수정사항에 대한 기록이 있으면 좋다. 
  - 버그 트래킹 시스템이 있으면 먼저 찾아보고, 코드를 보다가 이해되지 않는 부분이 있으면 `git blame`기능으로 어떤 맥락으로 그 코드가 추가되었는지를 찾아보면 좋다.
  - 찾아보았던 기능 개발/개선 기록을 검토하면서 코드 분석을 하다보면 가끔 이전 개발자가 예외 사항들을 놓치는 경우가 있는데 분석한 부분을 잘 이해했다면 기여할 수 있다.
  - 개발자 메뉴얼이나 자료구조/모듈 간의 구조를 그려주는 문서들이 있으면 더 이해가 빠르다. (e.g. https://doxygen.postgresql.org/)
4. 1 ~ 3번을 반복하면서 모듈들을 하나씩 이해해 가다 보면 모듈간에 어떻게 엮여 있는지 개략적으로 알아갈 수 있다. 확실히 코드를 분석하려면 어떤 새로운 기능을 개발하거나 큰 버그를 고친다면 더 자세히 이해할 수 있는 것 같다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 알려주신 개발자 분이 위의 방법대로 한 단계씩 분석을 하면서 각 부분을 접근하고 계신다고 하셨다.
그리고 분석하는 도중에 어떤 버그가 보여서 이건 버그라고 확신할 때 커미터에게 자신이 궁금한 점을 물어보면서 토론을 해보는 것도 좋다고 생각한다고 하셨다.&lt;/p&gt;
&lt;h4 id=&#34;마무리&#34;&gt;마무리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;아쉽게도 현재는 오픈소스 활동을 재개하고 있지 않다. 사실 다시 오픈 소스 활동을 재개하고 싶지만, 현업에서 일을 하다보니 부족한 점이 너무 많아서 부족한 부분을 채우느라 다시 시작할 엄두를 못내고 있다.&lt;/p&gt;
&lt;p&gt;하지만 이번 글을 쓰면서 감사함을 느꼈고 이에 보답하기 위해서라도 오픈 소스 컨트리뷰션을 조만간 다시 재개할 수 있도록 노력을 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doxygen.postgresql.org/&#34;&gt;postgres doxygen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>우아한 테크 코드 지원 후기 및 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 03 Mar 2021 23:15:14 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EB%93%9C-%EC%A7%80%EC%9B%90-%ED%9B%84%EA%B8%B0-%EB%B0%8F-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109818546-707a9900-7c76-11eb-857b-2ee77f773bf0.png&#34; alt=&#34;Screen Shot 2021-03-03 at 11 15 58 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;이전에 우아한 테크코스에 지원을 하여 코딩 테스트를 본 적이 있었다. 비록 탈락했지만 다음에 더 잘할 수 있도록 피드백을 주셨다.&lt;/p&gt;
&lt;h3 id=&#34;코딩-테스트&#34;&gt;코딩 테스트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;코딩 테스트의 경우 알고리즘 역량이나 풀이 속도도 중요하지만, 문제를 명확하고 꼼꼼히 이해하는 능력이 가장 중요하다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그래머에게 속도가 빠름도 중요하지만, 그 보다는 요구사항을 명확히 이해해 버그없는 프로그래밍을 구현하는게 더 중요하다고 하셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;자기소개서&#34;&gt;자기소개서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자기소개서는 구체적으로 쓰는 것이 좋다. 어떤 내용을 학습했다는 결과 위주의 내용이 아니라, 어떤 내용을 학습하는데 어떤 어려움이 있었고, 어떻게 극복했다와 같이 구체적인 사례를 들어서 공감을 얻는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자기소개서에서 얻고 싶은 가장 큰 부분은 여러분이 생각에만 그치지 않고 행동으로 얼마나 실행했는지를 보고 싶은 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;누구나 생각을 할 수는 있지만 이를 실행으로 옮겨 일정 수준의 성취를 만들기란 쉬운 것이 아니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작은 성취라도 만들어가는 과정에서 깨달음들을 보여준다면, 합격률이 조금은 높아질 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>라인 개발자 입사기를 읽고 느낀점</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</link>
      <pubDate>Wed, 03 Mar 2021 21:49:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9E%85%EC%82%AC%EA%B8%B0%EB%A5%BC-%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80%EC%A0%90/</guid>
      <description>&lt;h1 id=&#34;지원서-작성할-때-참고할-부분&#34;&gt;지원서 작성할 때, 참고할 부분&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109811374-1a095c80-7c6e-11eb-9077-d4d5a18b0768.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 16 05 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;대외 활동을 했다는 사실 그 자체보다는 그 활동에서 배우고 얼마나 성장했는지를 위주로 적자&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무엇을 했는지가 중요한 것이 아니다, 무엇을 얻었고, 배웠는지를 위주로 작성하자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;어떤 활동을 하더라도, 자신의 성장을 연결하는 것이 중요하다, 자신의 성장을 감춰두고 혼자만 아는 것 보다는 어떠한 방식으로도 그것을 드러내서 어필하는 것이 중요하다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;신입-개발자가-아닌-경우&#34;&gt;신입 개발자가 아닌 경우&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109811905-bdf30800-7c6e-11eb-844c-0ec338e53c4f.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 20 14 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스스로 공부해 왔던 내용과, 더불어 내가 어떤 개발자가 되고 싶은지 목표를 설정&lt;/li&gt;
&lt;li&gt;지금 근무하는 곳에서 책임감을 가지고 근무하는 모습이 중요하다.&lt;/li&gt;
&lt;li&gt;이직을 준비하더라도 현재 다니고 있는 직장에 집중하고 최선을 다하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;코딩-테스트-준비&#34;&gt;코딩 테스트 준비&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;선택한 하나의 알고리즘을 난이도 별로 풀어보았다.&lt;/li&gt;
&lt;li&gt;특히 구현, 자료구조 부분은 다른 문제와 연계되는 경우가 많아서 더욱 집중적으로 풀어보았다.&lt;/li&gt;
&lt;li&gt;채용을 준비할 때는 취업을 준비하기전에 풀었던 문제의 절반정도를 풀면서 연습을 했다.&lt;/li&gt;
&lt;li&gt;코딩 테스트라는 과정은 단기간에 실력을 올릴 수 없기 때문에, 매일 또는 매주 꾸준히 코딩 테스트 문제를 풀어보는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;처음 준비를 할 때는 알고리즘 공부를 위한 영상을 찾고, 해당 영상을 들으면서 그날 배웠던 알고리즘과 관련된 문제를 2~3개 정도 풀면서 준비를 했다.&lt;/li&gt;
&lt;li&gt;꾸준히 흥미를 붙여가면서 하는것이 중요하다.&lt;/li&gt;
&lt;li&gt;단기간에 바짝 공부해서 관련 내용을 익히고 문제 풀이 능력을 성장시키는 것보다는, 꾸준하게 문제의 유형과 풀이의 방식을 익히면서 체득하는 것이 많은 도움이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;서류-제출과-관련된-팁&#34;&gt;서류 제출과 관련된 팁!&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;나 자신을 잘 아는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;나&amp;rsquo;를 알아야 어필할 수 있는 포인트도 보이고, 나에게 잘 맞는 직무도 찾을 수 있다.&lt;/li&gt;
&lt;li&gt;내가 지금까지 활동했던 것을 정리해보는 것을 추천한다.&lt;/li&gt;
&lt;li&gt;어떤 경험을 했고, 어떤 일이 일어났고, 어떤 것을 배우고 얻었는지를 중점으로 작성해보는 것이다.&lt;/li&gt;
&lt;li&gt;그리고 나서 지원할 직무와 연결지어서 어떤 경험들을 추려낼지 고민하면서 서류를 작성하면 조금 더 쉬워질 것이다.&lt;/li&gt;
&lt;li&gt;내가 흥미를 느끼는 분야와 기술, 그리고 쌓아온 역량을 직무와 연결지어서 생각해보면 좋을 것이다.&lt;/li&gt;
&lt;li&gt;포트폴리오의 경우에는 진행 했던 프로젝트의 전체 구조와 내가 맡았던 역할, 사용한 기술을 중점으로 만들었다. 그리고 각각의 프로젝트에 해당하는 &lt;code&gt;Git Repository&lt;/code&gt;를 추가하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109813328-8d13d280-7c70-11eb-9fc4-5fbb310702a4.png&#34; alt=&#34;Screen Shot 2021-03-03 at 10 33 50 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포트폴리오를 작성할 때는, &lt;code&gt;문제 발생 - 문제 원인 파악 - 해결책 적용 - 결과&lt;/code&gt; 와 같은 순서로 프로젝트 문제 해결 과정을 서술 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이 부분에 공감을 하는데, 포트폴리오에서 내가 보여줘야할 것은 내가 얼마만큼 알고 할 수 있는 능력이 있는지 보다는, 내가 어떤 분야를 얼마만큼 고민했다는 사실을 어필하는 것이 더 효과적일 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;포트폴리오에서는 자신의 개발 역량이나 팀으로 활동할 때의 자신의 모습을 보여줄 수 있는 것 등 자기소개서에서 드러내지 못한 부분을 보여주면 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;면접을-위해서-따로-준비한-것들&#34;&gt;면접을 위해서 따로 준비한 것들&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;CS(Computer Science) 지식과 프로젝트에서 사용한 기술들을 다시 한 번 정리하였다.&lt;/li&gt;
&lt;li&gt;운영체제, 데이터베이스, 자료구조/알고리즘, 네트워크에 대해서 정리를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;되도록 공식 개발 문서를 레퍼런스로 하여, CS 지식들을 틈틈히 정리하도록 해야겠다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트에서 사용한 기술은 왜 그 기술을 사용했고, 어떤 장/단점을 가지고 있으며, 어떤한 원리로 동작하는지를 중점으로 준비하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;나의 포트폴리오에서 보완해야할 점이다. 왜 그 기술을 사용했는지, 그리고 어떤 장/단점을 가지고 있는지, 어떠한 원리로 동작하는지 고민을 많이하지 않았다.따라서 이러한 부분을 개선하자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다른 사람들에게 자신의 포트폴리오를 보여주고 피드백을 얻는 것도 좋은 방법이 될 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접을 위해서는 자기소개서와 포트폴리오를 다시 확인하면서 예상 질문을 확인하였고, 또한 블로그에 포스팅한 내용들을 공부하며 범위를 넓혔다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접을 보기 전에, 친구들과 모의 면접을 보거나 휴대폰으로 답변하는 모습을 촬영하면서 준비하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;답변할 때는 스스로 어필하고 싶거나 강조하고 싶은 점에 대해서는 톤을 달리하고, 시선 처리는 한곳만 바라보거나 허공을 바라보지 않게 면접관들을 번갈아 볼 수 있게 준비하였다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;답변할 수 있는 것은 자신있게 답변하고, 모르는 것은 모른다고 답하되 보완할 방법이나 알고 있는 비슷한 개념을 엮어 답변을 할 수 있도록 준비해라&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자신이 제출한 자기소개서, 이력서, 포트폴리오를 2 ~ 3번 정독하고 면접관들이 어떤 부분에서 궁금할지를 예측하여 자문자답하면서 내용을 정리&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;면접은 &amp;lsquo;어떻게&amp;rsquo;보다 &amp;lsquo;왜&amp;rsquo;라는 질문을 받았을 때 제대로 답변할 수 있도록 준비를 하면 좋을 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대답을 못한다고 감점은 없다, 따라서 모르면 모른다고 답변을 하고 모든 것을 후회없이 보여줄 수 있도록 준비를 하자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 준비를 꾸준히 하자.&lt;/li&gt;
&lt;li&gt;컴퓨터 공학 관련 지식들을 꾸준히 리마인드 하고, 블로그에 잘 정리를 하자.&lt;/li&gt;
&lt;li&gt;포트폴리오는 왜 이러한 기술을 사용했고, 문제점, 및 문제를 해결한 과정이 잘 녹아들어 있어야 한다.&lt;/li&gt;
&lt;li&gt;면접은 &amp;lsquo;어떻게&amp;rsquo;보다는 &amp;lsquo;왜&amp;rsquo;라는 질문에 답을 할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;면접 질문 기반이 자기소개서 및 포트폴리오에서 나오므로 자기소개서 및 포트폴리오를 처음부터 잘 작성하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linecorp.com/ko/blog/2020-first-half-new-liners-interview/&#34;&gt;2020 상반기 LINE 신입 개발자 3인의 WOW한 입사기!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>데이터베이스 스키마를 관리하는 도구, Flyway</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway/</link>
      <pubDate>Wed, 03 Mar 2021 20:09:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-flyway/</guid>
      <description>&lt;h1 id=&#34;데이터베이스-스키마-관리의-필요성&#34;&gt;데이터베이스 스키마 관리의 필요성&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;최근에 회사에서 기존에 &lt;code&gt;AWS&lt;/code&gt;에서 서비스하던 서비스를 &lt;code&gt;ALI&lt;/code&gt; 클라우드에서 제공해야하는 일이 있었다. 따라서 데이터베이스 스키마와 마스터 데이터를 새로운 클라우드 환경으로 이전을 시켜줘야 했다.&lt;/p&gt;
&lt;p&gt;비교적 규모가 큰 서비스는 아니여서, 덤프를 이용해서 간단하게 이전하였고, 데이터베이스 스키마 및 마스터 데이터를 쿼리문 형태로 만들어서 GIT으로 형상관리를 하였다.&lt;/p&gt;
&lt;p&gt;이 정도로 모든 일이 마무리 되기는 하였지만, 어딘가 부족한 느낌이 들었다. 왜냐하면 개발을 하면서 DB 스키마가 변경할 일이 있는데 그럴 때마다 쿼리문으로 테이블 스키마를 변경하고, 스키마 파일을 업데이트 해야했기 때문이다. 문제는 변경해줘야 할 환경이 &lt;code&gt;AWS&lt;/code&gt;, &lt;code&gt;ALI&lt;/code&gt; 각각 &lt;code&gt;DEV&lt;/code&gt;, &lt;code&gt;EDU&lt;/code&gt;, &lt;code&gt;STG&lt;/code&gt;, &lt;code&gt;PROD&lt;/code&gt;이 존재하므로 8 개의 환경을 업데이트 해주어야 했습니다. 그리고 메일 서버가 바라보는 테이블까지 생각하면 서비스가 조금만 더 확장된다면 엄청나게 힘들어 질 것이다.&lt;/p&gt;
&lt;p&gt;게다가 단순한 컬럼 값 추가, 삭제가 아니라 컬럼이 어떤 연산을 통해서 새로운 값을 가져야 하거나, 새로운 테이블을 만들어 기존 데이터를 옮기거나 하는 좀 더 복잡한 작업이 되면 엄청나게 복잡해 질 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 현대적인 애플리케이션 개발 환경에서는 단일 DB 스키마가 아니라, 변화를 다루는 마이그레이션 스크립트를 만들어서 사용한다. 소스 코드 저장소에 함께 포함을 시키고, 모든 환경에서 서버를 구동하기 전에 적용시키는 방법을 사용한다.&lt;/p&gt;
&lt;h1 id=&#34;flyway&#34;&gt;Flyway&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109799728-b5470580-7c5f-11eb-9f0a-6ca5e87ae745.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 32 58 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flyway&lt;/code&gt;는 오픈소스 데이터베이스 마이그레이션 도구이다.&lt;/li&gt;
&lt;li&gt;마이그레이션은 &lt;code&gt;SQL&lt;/code&gt; 또는 &lt;code&gt;Java&lt;/code&gt;로 작성할 수 있다.&lt;/li&gt;
&lt;li&gt;일곱 가지의 간단한 명령어로 구성되어 있다. (&lt;code&gt;Migrate&lt;/code&gt;, &lt;code&gt;Clean&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Validate&lt;/code&gt;, &lt;code&gt;Undo&lt;/code&gt;, &lt;code&gt;Baseline&lt;/code&gt;, &lt;code&gt;Repair&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;다양한 패키지 및 빌드 도구에서 지원하며 플러그인 형태로도 이용할 수 있다.&lt;/li&gt;
&lt;li&gt;많은 DBMS를 지원한다. (&lt;code&gt;MySQL&lt;/code&gt;, &lt;code&gt;Postgres&lt;/code&gt;, &lt;code&gt;H2&lt;/code&gt;, &amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마이그레이션이-필요한-이유&#34;&gt;마이그레이션이 필요한 이유&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109800868-16bba400-7c61-11eb-9b83-9dff2469cf53.png&#34; alt=&#34;Environments&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션의 경우, &lt;code&gt;GIT&lt;/code&gt;과 같은 형상 관리 툴로, 재현 가능한 구조와 CI 환경을 구성할 수 있다.&lt;/li&gt;
&lt;li&gt;릴리즈 및 배포 프로세스를 잘 정의함으로써, 이를 관리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801147-6ef2a600-7c61-11eb-8058-c5086b4a1522.png&#34; alt=&#34;DbRed&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;불행하게도 애플리케이션과 데이터베이스 간의 불일치가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 여전히 많은 프로젝트가 수동으로 적용된 &lt;code&gt;SQL&lt;/code&gt; 스크립트에 의존하고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스 마이그레이션은 이러한 혼란을 제어할 수 있는 좋은 방법이다. 마이그레이션은 위와 같은 문제에 대해서 다음과 같은 이점을 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 데이터베이스 다시 만들기&lt;/li&gt;
&lt;li&gt;데이터베이스가 어떤 상태인지 확인&lt;/li&gt;
&lt;li&gt;현재 버전의 데이터베이스에서 새로운 데이터베이스로 마이그레이션&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flyway-작동-원리&#34;&gt;Flyway 작동 원리&lt;/h3&gt;
&lt;p&gt;가장 간단한 경우는 &lt;code&gt;Flyway&lt;/code&gt;가 비어있는 데이터베이스를 가리킬 때입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801736-3bfce200-7c62-11eb-81eb-a3ea67e714dd.png&#34; alt=&#34;EmptyDb&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;데이터베이스가 비어있으므로, &lt;code&gt;Flyway&lt;/code&gt;는 데이터베이스를 찾지 못하고 대신 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그리고 &lt;code&gt;Flyway&lt;/code&gt;는 마이그레이션을 위해서 파일 시스템 및 응용 프로그램의 클래스 경로를 탐색하기 시작한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그런 다음에 마이그레이션은 버전 번호를 기준으로 정렬되고 순서대로 적용될 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109801958-87af8b80-7c62-11eb-9c7d-0f55a59c44b5.png&#34; alt=&#34;Migration-1-2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 마이그레이션이 적용될 때마다 스키마 기록 테이블이 업데이트 되며 이러한 이력 데이터로 특정 버전으로 쉽게 마이그레이션을 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109802186-d9581600-7c62-11eb-958a-c9726222a374.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 55 48 PM&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론&lt;/h1&gt;
&lt;p&gt;현재 진행하는 프로젝트에 도입을 해도 괜찮을 것 같고, 마치 깃을 사용하는 것 같이 특정 버전의 스키마로 쉽게 돌아갈 수 있다는 것이 편리할 것 같다. 기존에는 특정 버전의 스키마를 보려면 깃으로 특정 버전의 스키마를 조회한 다음에 도커 가상 환경에서 마이그레이션을 하고 나서 테스트를 했다. 이렇게 진행하니까 테스트를 하기 위해서 준비해야할 것도 많고 번거로웠다. 지금 당장은 괜찮을지 몰라도 나중을 위해서 우선 시험삼아서 사용해보고 좋다면 팀원에게 소개를 해야겠다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://flywaydb.org/documentation/getstarted/why&#34;&gt;Flyway, documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>파이썬 @classmethod와 @staticmethod 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Wed, 03 Mar 2021 08:45:13 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%ED%8C%8C%EC%9D%B4%EC%8D%AC-classmethod%EC%99%80-staticmethod-%EC%B0%A8%EC%9D%B4/</guid>
      <description>&lt;p&gt;파이썬을 코딩을 하다가 &lt;code&gt;@classmethod&lt;/code&gt; 데코레이터가 붙어 있는 메서드를 볼 수 있었다. 정확히 어떤 역할을 하는지 몰라서 문서에서 찾아보았다.&lt;/p&gt;
&lt;h4 id=&#34;classmethod&#34;&gt;@classmethod&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109730703-420ca780-7bfd-11eb-9a41-47561874c29e.png&#34; alt=&#34;Screen Shot 2021-03-03 at 8 48 29 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드를 클래스 메서드로 변환합니다.&lt;/li&gt;
&lt;li&gt;클래스 메서드는 인스턴스 메서드가 인스턴스를 받는 것 처럼 클래스를 암시적인 첫 번째 인수로 수신한다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클래스 메서드는 다음과 같이 사용한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;클래스 메서드는 다음과 같이 호출 될 수 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C.f()&lt;/code&gt;, &lt;code&gt;C().f()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;앞의 경우에는 클래스에서 호출 된 것이고, 뒤의 경우에는 인스턴스에서 호출 된 것이다.&lt;/li&gt;
&lt;li&gt;클래스 메서드가 상속 받은 클래스에서 호출되면 상속 받은 클래스가 첫 번째 인수로 전달된다.&lt;/li&gt;
&lt;li&gt;클래스 메서드는 &lt;code&gt;C++&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt;의 스태틱 메서드와는 다르다, 만약 앞의 경우로 스태틱 메서드를 사용하고 싶다면, &lt;code&gt;@staticmethod&lt;/code&gt; 를 사용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기까지만 봐서는 정적 메서드랑 무슨 차이인지 알기 힘들었다. 따라서 정적 메서드 관련된 문서를 확인해봤다.&lt;/p&gt;
&lt;h4 id=&#34;staticmethod&#34;&gt;@staticmethod&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109732266-3a9acd80-7c00-11eb-98b4-bd34b94a81fb.png&#34; alt=&#34;Screen Shot 2021-03-03 at 9 09 51 AM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드를 정적 메서드로 변환시켜 줍니다.&lt;/li&gt;
&lt;li&gt;정적 메서드는 암시적으로 첫 번째 인수를 받지 않습니다.&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용하는 방법은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class C:
    @staticmethod
    def f(arg1, arg2, ...): ...
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;정적 메서드는 다음과 같이 호출 될 수 있습니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C.f()&lt;/code&gt;, &lt;code&gt;C().f()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데코레이터와 마찬가지로, 정적 메서드를 &lt;code&gt;regular&lt;/code&gt; 함수 처럼 호출 할 수 있다.&lt;/li&gt;
&lt;li&gt;클래스 바디에 함수에 대한 참조가 필요하고 인스턴스 메서드로 자동 변환하지 않으려는 경우에 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class C:
    builtin_open = staticmethod(open)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;차이점&#34;&gt;차이점&lt;/h4&gt;
&lt;p&gt;얼핏봐서는 차이점을 크게 못느껴서 인터넷을 찾아본 결과 좋은 글을 볼 수 있었다. &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@classmethod&lt;/code&gt;와 &lt;code&gt;@staticmethod&lt;/code&gt;는 상속에서 차이가 난다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person:
    default= &amp;quot;아빠&amp;quot;

     def __init__(self):
        self.data = self.default

    @classmethod
    def class_person(cls):
        return cls()

    @staticmethod
    def static_person():
        return Person()

class WhatPerson(Person):
    default = &amp;quot;엄마&amp;quot;
person1 = WhatPerson.class_person()    # return 엄마
person2 = WhatPerson.static_person()   # return 아빠
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같이 &lt;code&gt;@staticmethod&lt;/code&gt;인 경우에는 부모 클래스의 속성 값을 가져오지만, &lt;code&gt;@classmethod&lt;/code&gt;의 경우 cls 인자를 활용하여 클래스의 클래스 속성을 가져온다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://julien.danjou.info/guide-python-static-class-abstract-methods/&#34;&gt;The definitive guide on how to use static, class or abstract methods in Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#classmethod&#34;&gt;https://docs.python.org/3/library/functions.html#classmethod&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#staticmethod&#34;&gt;https://docs.python.org/3/library/functions.html#staticmethod&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@hckcksrl/python-%EC%A0%95%EC%A0%81%EB%A9%94%EC%86%8C%EB%93%9C-staticmethod-%EC%99%80-classmethod-6721b0977372&#34;&gt;https://medium.com/@hckcksrl/python-%EC%A0%95%EC%A0%81%EB%A9%94%EC%86%8C%EB%93%9C-staticmethod-%EC%99%80-classmethod-6721b0977372&lt;/a&gt; &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 03 Mar 2021 08:00:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/03/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 WSGI에 대해서 정리를 해보았다.&lt;/li&gt;
&lt;li&gt;오늘 &lt;code&gt;@staticmethod&lt;/code&gt;, &lt;code&gt;@classmethod&lt;/code&gt;에 대해서 조사 및 정리를 하였다.&lt;/li&gt;
&lt;li&gt;이슈를 진행하던 도중에 &lt;code&gt;@classmethod&lt;/code&gt;를 사용하는 코드를 보았고, 무슨 역할을 하는지 몰라서 찾아보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;그냥 모르고 관성적으로 쓰는 것보다 이게 왜 사용되었는지 알고 생각하면서 사용하니까 훨씬 많이 배우는 느낌이고 자신감이 생긴것 같다.&lt;/li&gt;
&lt;li&gt;오늘 이슈를 진행하다가 비슷한 예외가 많이 발생하여, 이러한 예외가 발생하고 있다고 말했는데 실제로는 그러한 예외가 호출되지 않고 다른 예외가 호출되었다.&lt;/li&gt;
&lt;li&gt;요즘 공식 문서를 읽고 정리하는 것에 재미를 붙였다. 글을 읽고 요약하는 것도 좋지만, 실제 개발을 하면서 이를 생각하는지 또는 내가 진정으로 문제에 대해서 고민을 하는 것이 더 중요할 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것이 있으면 그냥 넘어가지말고 고민해야할 것이 있으면 충분히 고민하자.&lt;/li&gt;
&lt;li&gt;모르는 것이 있으면 추측을 해서 말하지 말고 확실히 눈으로 확인하고 말하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소통을 하려고, 내가 진행한 내용을 공유하려고 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;버그나 문제점을 발견할 때, 확인을 제대로 하지 않고 말하는 경향이 있다. 이러한 점을 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;내가 발견한 사실 및 곧 해결책이 나올 것 같으면 흥분해서 상대방에게 성급하게 말하는 경향이 있다. 이를 고치도록 해야겠다.&lt;/li&gt;
&lt;li&gt;공유를 할 때 내용이 정리가 되지 않은 상태에서 말을 하려고 하니 횡설수설 한다.&lt;/li&gt;
&lt;li&gt;내가 한 작업을 공유 하려는 행동이지만 상대방에게는 집중을 방해하는 것일 수도 있을 것 같다. 따라서 사내 채팅으로 내가 진행한 내용을 간단하게 공유하고 필요하다면 화면 녹화로 내가 무엇을 했는지 알려주는 방식도 고려해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것이 있으면 끝까지 알아볼 것이고, 내가 작성한 코드에 당위성을 부여할 것이다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때, 흥분하지 말고 그럴 때 위험한 신호라고 생각하고 한번 더 생각하고 한번 더 검토하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>WSGI</title>
      <link>https://dongwooklee96.github.io/post/2021/03/02/wsgi/</link>
      <pubDate>Tue, 02 Mar 2021 14:39:13 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/02/wsgi/</guid>
      <description>&lt;h1 id=&#34;플라스크와-wsgi&#34;&gt;플라스크와 WSGI&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109603667-7896e380-7b65-11eb-8e62-961951e0c969.png&#34; alt=&#34;Screen Shot 2021-03-02 at 2 42 04 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;플라스크 문서를 살펴보다가 다음과 같은 문장을 보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플라스크는 &lt;code&gt;Jinja&lt;/code&gt; 템플릿 엔진과 &lt;code&gt;Werkzeug WSGI&lt;/code&gt; 툴킷에 의존하고 있다. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109604060-37530380-7b66-11eb-8217-e8c8a95ae4ec.png&#34; alt=&#34;Screen Shot 2021-03-02 at 2 47 21 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;가 무엇을 하는 툴인지 몰라서 검색을 해본 결과 다음과 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Werkzeug&lt;/code&gt;는 포괄적인 &lt;code&gt;WSGI&lt;/code&gt; 웹 애플리케이션 라이브러리이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt; 응용 프로그램을 위한 단순한 유틸리티에서 시작하였지만, 현재는 가장 진보한 &lt;code&gt;WSGI&lt;/code&gt; 유틸리티 라이브러가 되었다.&lt;/li&gt;
&lt;li&gt;플라스크는 &lt;code&gt;Werkzeug&lt;/code&gt;를 감싸 &lt;code&gt;WSGI&lt;/code&gt;의 세부사항을 처리하는 동시에 강력한 애플리케이션을 위한 더 많은 구조와 패턴을 제공한다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Werkzeug&lt;/code&gt;는 다음을 포함하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저에 있는 스택 트레이스와 코드를 검사할 수 있는 디버거를 포함한다.&lt;/li&gt;
&lt;li&gt;헤더, 쿼리 인자, 폼 데이터, 파일 및 쿠키와 상호 작용할 수 있는 요청 객체이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;플라스크는 내부적으로 &lt;code&gt;Werkzeug&lt;/code&gt;로 구현되어 있고, &lt;code&gt;Werkzeug&lt;/code&gt;는 &lt;code&gt;WSGI&lt;/code&gt;를 구현하는 라이브러리이다.
그렇다면 자연스럽게 &lt;code&gt;WSGI&lt;/code&gt;가 무엇인지 궁금하였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109774010-38a62e00-7c43-11eb-9a90-3e95c3090c30.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 09 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt;는 웹 서버 게이트웨이 인터페이스이다.&lt;/li&gt;
&lt;li&gt;웹 서버가 웹 애플리케이션과 통신하는 방법과 웹 애플리케이션을 연결하여 하나의 요청을 처리하는 방법을 설명하는 규격 입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WSGI&lt;/code&gt;는 &lt;a href=&#34;https://www.python.org/dev/peps/pep-3333/&#34;&gt;PEP 3333&lt;/a&gt;에 설명되어 있는 파이썬 표준이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문서의 양이 방대하므로 지금 모두 설명하는 것보다는 따로 나중에 관련된 페이지를 만들어서 공부를 해야겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109775165-81aab200-7c44-11eb-8455-d5db0d39f127.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 18 38 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;파이썬은 다양한 웹 애플리케이션 프레임워크가 있고 웹 프레임 워크의 선택이 사용가능한 웹 서버 선택을 제한할 수 있고 그 반대의 경우도 마찬가지이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이와 대조적으로, 자바의 서블릿 API를 지원하는 웹 서버에서 자바 웹 애플리케이션 프레임워크로 작성된 애플리케이션을 실행할 수 있게 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프레임워크 선택과 웹 서버 선택을 분리함으로써, 사용자는 자신에게 맞는 조합을 선택할 수 있고, 프레임워크와 서버 개발자는 원하는 분야에 집중할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;따라서 이 &lt;code&gt;PEP&lt;/code&gt; 문서는 웹 서버와 웹 애플리케이션 또는 프레임워크 사이의 단순하고 보편적인 인터페이스인 파이썬 웹 서버 게이트웨이 인터페이스를 제안하는 문서이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WSGI&lt;/code&gt;의 목표는 새로운 웹 프레임워크를 만드는 것이 아니라 기존 서버, 애플리케이션 또는 프레임워크의 쉬운 상호 연결을 촉진하는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;wsgi-개요&#34;&gt;WSGI 개요&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109776796-52954000-7c46-11eb-93eb-f622fd14dccf.png&#34; alt=&#34;Screen Shot 2021-03-03 at 5 31 36 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WSGI 인터페이스는 서버, 게이트웨이 측면과 애플리케이션, 프레임워크 측면이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버 측에서 응용 프로그램이 제공하는 &lt;code&gt;Callable&lt;/code&gt; 객체를 호출한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 객체의 제공 방법은 서버 또는 게이트웨이에 따라서 다르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;순수한 서버/게이트웨이 및 애플리케이션/프레임워크 외에도, 이 규격 양쪽을 모두 구현하는 &amp;ldquo;중간 소프트웨어&amp;rdquo; 컴포넌트를 만들 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 규격에서 &lt;code&gt;Callable&lt;/code&gt; 이라는 용어는 &lt;code&gt;__call__&lt;/code&gt; 메서드를 가지는 함수, 메서드, 클래스, 그리고 인스턴스를 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;필요에 따라 적절한 구현 기술을 선택하는 것은 &lt;code&gt;Callable&lt;/code&gt;을 구현하는 서버, 게이트웨이 또는 애플리케이션에 달려 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반대로 &lt;code&gt;Callable&lt;/code&gt;을 호출하는 서버, 게이트웨이 또는 응용 프로그램은 &lt;code&gt;Callable&lt;/code&gt; 타입에 종속되지 않아야 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 서버와 프레임워크를 분리하기 위해서 생겨났다.&lt;/li&gt;
&lt;li&gt;WSGI는 웹 서버와 애플리케이션이 통신하는 방법과 요청을 처리하는 방법을 설명한 규약이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://flask.palletsprojects.com/en/1.1.x/&#34;&gt;https://flask.palletsprojects.com/en/1.1.x/&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://palletsprojects.com/p/werkzeug/&#34;&gt;https://palletsprojects.com/p/werkzeug/&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 02 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/02/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드숨 강의를 들엇다. (JWT 토큰에 대해서 알게 되었다.)&lt;/li&gt;
&lt;li&gt;오늘 회사에서 일을 할 때, 적극적으로 의사소통을 하려고 노력하였다.&lt;/li&gt;
&lt;li&gt;플라스크 관련된 문서를 정리해보았다.&lt;/li&gt;
&lt;li&gt;퇴근하는 길에, 라인 개발자 채용 관련 QnA 영상을 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;적극적으로 의사소통을 하니, 동료들과 소통이 더 잘되는 느낌이였다.&lt;/li&gt;
&lt;li&gt;라인 채용 유튜브 영상을 보니, 컴퓨터공학 기반 지식과 알고리즘 그리고 코딩테스트를 중요하게 여기는 것 같았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소통하려는 의지만 있어도 동료들이 알아차리고 좋게 봐주는 것 같다.&lt;/li&gt;
&lt;li&gt;소트프 스킬 또한 하드 스킬 못지 않게 중요하다는 것을 알게되었다.&lt;/li&gt;
&lt;li&gt;회사를 다니기 전에는 회사에서 소통하는 능력이 얼마나 중요한지를 모르고 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;코딩 테스트를 잘 보기 위해서는 자료 구조 및 알고리즘이 중요하고, 면접을 잘 보기 위해서는 운영체제, 자료구조, 데이터베이스 등 컴퓨터공학 기반 지식이 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;업무에 있어서는 TMI형 인간이 되는 것이 좋다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 했던 일을 상대방에게 전달을 하려고 노력하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 공부를 하다가 매번 흐지부지 되는데, 꾸준히 노력하는것이 중요할 것 같고 TDD를 접목하여 두마리 토끼를 잡을 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;꾸준하게 블로그 글을 작성하면서 컴퓨터 공학 기반 지식 및 웹 개발을 하는데 기반 지식들을 갈고 닦아야겠다.&lt;/li&gt;
&lt;li&gt;코딩 테스트 공부를 꾸준하게 하여, 필요할 때 능력 발휘를 못하는 일이 없도록 해야겠다.&lt;/li&gt;
&lt;li&gt;어학 능력을 키워서 개발자로서 성장하는데 제약이 없도록 하겠다.&lt;/li&gt;
&lt;li&gt;업무에 있어서는 TMI형 인간이 되자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (2) - Executor Interfaces</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</link>
      <pubDate>Mon, 01 Mar 2021 14:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-2-executor-interfaces/</guid>
      <description>&lt;h1 id=&#34;executor-interfaces&#34;&gt;Executor Interfaces&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;, 태스크를 관리하는 인터페이스 입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExecutorService&lt;/code&gt;는 &lt;code&gt;Executor&lt;/code&gt;의 하위 인터페이스이며 태스트와 &lt;code&gt;Exector&lt;/code&gt;의 라이프 사이클을 관리하는 기능을 포함하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt;는 &lt;code&gt;ExecutorService&lt;/code&gt;의 하위 인터페이스이며 미래의 태스트에 대한 주기적인 실행을 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executor-인터페이스&#34;&gt;Executor 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109464198-a159a300-7aa9-11eb-87f8-85c69935a454.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 16 49 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465577-bf280780-7aab-11eb-98d3-3fd65c0177ec.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 32 36 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt; 인터페이스는 저수준의 스레드 생성문을 대체할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;/code&gt;는 저수준의 스레드 생성문과 동일한 작업을 수행할 수 있지만 차이점은 워크 스레드가 사용 가능해질때까지 큐에 배치할 가능성이 더 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;executorservice-인터페이스&#34;&gt;ExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465963-542b0080-7aac-11eb-929c-517e84df5f5c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 36 24 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.submit(() -&amp;gt; {
            System.out.println(&amp;quot;Thread &amp;quot; + Thread.currentThread().getName());
        });

        executorService.shutdown();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다음작업이 들어올 때가지 계속 대기를 하기 때문에 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;code&gt;showdown()&lt;/code&gt; 메서드를 사용하여 명시적으로 종료를 시켜줘야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shutdown-과-shutdownnow의-차이점&#34;&gt;shutdown() 과 shutdownNow()의 차이점&lt;/h4&gt;
&lt;p&gt;메서드 주석을 읽어본 결과 다음과 같은 차이가 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109467219-35c60480-7aae-11eb-920c-201a60fb2a75.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt; 메서드는 이전에 제출된 태스트가 실행이 되고 더 이상 새로운 태스크는 수락하지 않으며 작업을 종료하기 시작한다. 하지만 &lt;code&gt;shutdownNow()&lt;/code&gt; 메서드는 실행 중인 작업이 종료될 때까지 기다리지 않고 실행중인 작업 처리를 중단 하려는 보장을 할 수 없다고 되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scheduledexecutorservice-인터페이스&#34;&gt;ScheduledExecutorService 인터페이스&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109465999-61e08600-7aac-11eb-892d-ee3b46714715.png&#34; alt=&#34;Screen Shot 2021-03-01 at 4 37 15 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ScheduledExecutorService&lt;/code&gt; 인터페이스는 지정한 지연시간 후에 실행 또는 호출 가능한 태스크를 실행하는 기능을 지원한다.&lt;/li&gt;
&lt;li&gt;지정된 태스크를 정의된 간격으로 반복적으로 실행하는 &lt;code&gt;scheduledWithFixedDelay&lt;/code&gt; 및 &lt;code&gt;ScheduledAtFixedRate&lt;/code&gt;를 정의합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰레드-풀&#34;&gt;쓰레드 풀&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109468299-bcc7ac80-7aaf-11eb-8e93-2e15be786920.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 패키지의 Executor 구현은 대부분은 워커 쓰레드로 구성된 쓰레드 풀을 사용한다. 이러한 종류의 스레드는 &lt;code&gt;Runnable&lt;/code&gt; 및 &lt;code&gt;Callable&lt;/code&gt;로 각각 존재하며 여러가지 태스크를 실행하는데 종종 사용된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;워커 쓰레드를 사용하면 스레드 생성으로 인한 오버헤드가 최소화 된다. 스레드 개체는 상당한 양의 메모리를 사용하며, 대규모 애플리케이션에서는 많은 스레드 개체를 할당 및 할당 해제하면 상당한 메모리 관리 오버헤드가 발생한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적인 유형의 쓰레드 풀은 쓰레드의 개수가 고정되어 있고 이 유형의 풀에서는 항상 지정된 수의 스레드가 실행되며, 스레드가 동작할 때 갑자기 종료되면 새로운 스레드로 교체되어 실행된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;태스크는 큐를 통해서 풀에 제출되며 풀에 있는 스레드보다 많은 태스크가 있을 때는 잠시 큐에서 대기한다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;runnable-과-callable의-차이&#34;&gt;Runnable 과 Callable의 차이&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469393-4d52bc80-7ab1-11eb-89d4-24e040a2161c.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 스레드에 의해서 실행되도록 설계된 모든 클래스에 의해 구현되어야 한다.&lt;/li&gt;
&lt;li&gt;클래스는 &lt;code&gt;Run()&lt;/code&gt; 메서드를 정의해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109469486-6fe4d580-7ab1-11eb-886c-bdddc2d8fa90.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 01 08 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;결과를 반환하고 예외를 발생시킬 수 있는 작업이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 인터페이스는 다른 스레드에 의해서 잠재적으로 실행될 수 있다는 점에서 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스와 유사하지만 &lt;code&gt;Runnable&lt;/code&gt; 인터페이스는 결과를 반환하지 않으며 선택한 예외를 발생시킬 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;forkjoin-프레임워크&#34;&gt;Fork/Join 프레임워크&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109471877-c1429400-7ab4-11eb-91fa-723f310cf9b9.png&#34; alt=&#34;Screen Shot 2021-03-01 at 5 37 04 PM&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포크/조인 프레임워크는 여러 프로세서를 활용할 수 있도록 지원하는 &lt;code&gt;ExecutorService&lt;/code&gt; 인터페이스의 구현이다.&lt;/li&gt;
&lt;li&gt;반복적으로 작은 조각으로 쪼개 질 수 있는 작업을 위해서 고안이 되었다.&lt;/li&gt;
&lt;li&gt;다른 &lt;code&gt;ExecutorService&lt;/code&gt; 구현과 마찬가지로 포크/조인 프레임워크도 쓰레드 풀에 있는 워커 쓰레드에게 작업을 할당한다.&lt;/li&gt;
&lt;li&gt;포크/조인 프레임워크는 워크 스틸링 알고리즘을 사용하는 점에서 차이가 있고 할 일이 부족한 워커 쓰레드는 작동중인 다른 쓰레드에서 작업을 가져올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>동시성 프로그래밍 및 자바 (1) - 프로세스와 쓰레드의 차이</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</link>
      <pubDate>Mon, 01 Mar 2021 12:40:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%8F-%EC%9E%90%EB%B0%94-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/</guid>
      <description>&lt;h1 id=&#34;동시성이란-concurrency&#34;&gt;동시성이란? (Concurrency)&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동시성-프로그래밍이란&#34;&gt;동시성 프로그래밍이란?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109454793-6438e500-7a98-11eb-9454-cc8af1cbfb76.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 13 30 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성에 대해서 자바 문서에서는 이렇게 설명하고 있다.
유저는 컴퓨터를 사용하면서 한 번에 한 가지 이상의 작업을 수행할 수 있다는 사실을 당연하게 여긴다. 그들은 워드 프로세서 작업을 하면서 파일을 다운로드 받거나, 프린트 인쇄 대기열을 관리하거나, 오디오 스트리밍을 할 수 있는다고 생각한다. 심지어 단일 응용 어플리케이션의 경우에도 한 번에 둘 이상의 작업을 해야할 때가 많다. 예를 들어서 스트리밍 오디오 애플리케이션은 네트워크에서 디지털 오디오를 동시에 읽고 압축을 풀고, 재생을 관리하고 디스플레이를 업데이트 해야합니다. 워드 프로세서 조차도 텍스트 서식을 변경하거나 디스플레이를 업데이트 하는 작업이 아무리 바쁘더라도 키보드 및 마우스 이벤트에 항상 응답을 할 준비가 되어있어야 합니다. 이러한 작업을 수행할 수 있는 소프트웨어를 동시성 소프트웨어라고 합니다.
자바 플랫폼은 동시성 프로그래밍을 지원하도록 처음부터 설계되었습니다. 자바 버전 5.0부터 자바는 높은 수준의 동시성 API를 포함하고 있습니다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&#34;프로세스와-쓰레드&#34;&gt;프로세스와 쓰레드&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109455687-7d429580-7a9a-11eb-9d1f-8155d55cbbf2.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 29 04 PM&#34;&gt;&lt;/p&gt;
&lt;p&gt;동시성 프로그래밍에서는 두가지의 기본 실행 단위가 있다. 자바에서는 동시성 프로그래밍은 주로 쓰레드와 관련이 있지만, 프로세스 역시 중요하다. 컴퓨터 시스템에서 일반적으로 많은 프로세스와 스레드가 있다. 이는 단일 코어 시스템에서도 마찬가지이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109456633-99dfcd00-7a9c-11eb-886e-52f965f26b10.png&#34; alt=&#34;Screen Shot 2021-03-01 at 2 44 12 PM&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;프로세스&#34;&gt;프로세스&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 자체적으로 포함된 실행 환경이 있다. 일반적으로 프로세스에서는 개인적인 리소스 공간이 존재하고 특히 각각의 프로세스에는 자체적인 메모리 공간을 가집니다.&lt;/li&gt;
&lt;li&gt;대부분의 자바 가상 머신 구현은 단일 프로세스로 실행된다. &lt;code&gt;Java&lt;/code&gt;는 &lt;code&gt;ProcessBuilder&lt;/code&gt; 를 이용하여 추가적인 프로세스를 생성할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;쓰레드&#34;&gt;쓰레드&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 때때로 경량 프로세스라고 불리우며, 프로세스와 쓰레드 모두 실행 환경을 제공하지만 새로운 쓰레드를 만드는데 필요한 리소스가 새 프로세를 만드는 것보다 적은 비용이 든다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쓰레드는 프로세스 내에 존재하며 모든 프로세스에는 최소한 한 개의 쓰레드가 있다. 쓰레드는 프로세스의 메모리, 열린 파일 및 자원을 공유합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이러한 자원 공유는 쓰레드 간의 소통에 효율적이지만 잠재적으로 문제를 일으킬 수 있습니다. &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;자바에서-쓰레드를-사용하는-방법&#34;&gt;자바에서 쓰레드를 사용하는 방법&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;자바에서 쓰레드를 사용할 수 있는 방법에는 크게 3가지가 있다.&lt;/p&gt;
&lt;h4 id=&#34;1-thread를-상속-받는-방법&#34;&gt;1. Thread를 상속 받는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();

        System.out.println(&amp;quot;Hello&amp;quot;);
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2-runnable을-구현하는-방법&#34;&gt;2. Runnable을 구현하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3-람다를-사용하는-방법&#34;&gt;3. 람다를 사용하는 방법&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;쓰레드의-주요-기능&#34;&gt;쓰레드의 주요 기능&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&#34;sleep&#34;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460950-d0b9e100-7aa4-11eb-86c8-29276cda855f.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 59 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep&lt;/code&gt; 은 스레드가 지정된 기간 동안 실행을 일시 중단 하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InterruptedException&lt;/code&gt;은 스레드가 슬립된 상태에서 다른 스레드가 현재 스레드를 인터럽트 시킬 떄 발생된다.&lt;/li&gt;
&lt;li&gt;위의 예제에서는 쓰레드가 1초동안 슬립 되었다가 다시 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;interrupt&#34;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460917-ba138a00-7aa4-11eb-85d3-0ad70e163bdf.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 42 22 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            while (true) {
                System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    System.out.println(&amp;quot;interrupt!&amp;quot;);
                    return;
                }
            }
        });
        thread.start();
        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        Thread.sleep(3000L);
        thread.interrupt();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;interrupt()&lt;/code&gt; 메서드를 호출 했을 때 &lt;code&gt;InterruptedException&lt;/code&gt; 예외가 발생하고 예외 처리 구문이 실행된다.&lt;/li&gt;
&lt;li&gt;스레드가 인터럽트 되었을 때, 처리하는 방식은 프로그래머가 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109460851-a10ad900-7aa4-11eb-8f02-8d5812cd1f80.png&#34; alt=&#34;Screen Shot 2021-03-01 at 3 41 37 PM&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;Thread: &amp;quot; + Thread.currentThread().getName());
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
        });
        thread.start();

        System.out.println(&amp;quot;Hello: &amp;quot; + Thread.currentThread().getName());
        thread.join();
        System.out.println(thread + &amp;quot; is finished&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt;을 사용하면 스레드가 다른 스레드가 끝날 때까지 기다려준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;과 마찬가지로 &lt;code&gt;join()&lt;/code&gt;은 인터럽트가 되면  &lt;code&gt;InterruptedException&lt;/code&gt;을 호출하면서 종료 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=200069290&#34;&gt;모던 자바 인 액션, 책, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-java8/dashboard&#34;&gt;더 자바, Java8, 프로그래밍 강의, 백기선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&#34;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 01 Mar 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/03/01/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;til-양식&#34;&gt;TIL 양식&lt;/h1&gt;
&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 공부를 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정답을 맞추는 것 뿐만 아니라, 더 좋은 방법은 없는지 생각을 해보는 것이 중요하다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;더 좋은 방법이 없는지 생각해보는 것은 실제로 코딩을 할 때, 지금보다 나은 방법이 없는지 꾸준히 고민하게 해주는 습관을 기를 수 있게 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트 문제를 풀 때, 입력 값을 받는 코드를 넣으면 테스트 하기 불편해진다. 따라서 입력 값은 모두 매개변수로 따로 빼면 테스트 하기 편해진다. 그리고 가장 나중에 입력 값을 넣어주면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩을 할 때, 내가 작성한 코드보다 더 나은 방법은 없는지 끊임없이 고민을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 회사에서 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.2. Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>그리디 알고리즘</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</guid>
      <description>&lt;h1 id=&#34;그리디-알고리즘&#34;&gt;그리디 알고리즘&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;현재 상황에서 좋아 보이는 것만을 선택하는 알고리즘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 문제가 있을 때 단순 무식하게 탐욕적으로 푸는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;여기서 탐욕적이라는 말은 &amp;lsquo;현재 상황에서 지금 당장 좋은 것을 고르는 방법&amp;rsquo;을 의미한다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 유형&amp;rsquo; 이라는 특징이 있다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘 유형의 문제는 매우 다양하기 때문에, 암기한다고 해서 항상 잘 풀수 있는 것은 아니다.&lt;/li&gt;
&lt;li&gt;많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.&lt;/li&gt;
&lt;li&gt;코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;문제-1-거스름돈&#34;&gt;문제 1: 거스름돈&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한이 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야할 돈 N은 항상 10의 배수이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def solve(money):
    ret = 0
    if money &amp;gt;= 500:
        ret += money // 500
        money %= 500

    if money &amp;gt;= 100:
        ret += money // 100
        money %= 100

    if money &amp;gt;= 50:
        ret += money // 50
        money %= 50

    if money &amp;gt;= 10:
        ret += money // 10
        money %= 10

    return ret
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;from problem import solve


def test_solve1():
    assertMoney(1300, 5)
    assertMoney(1260, 6)
    assertMoney(500, 1)
    assertMoney(260, 4)
    assertMoney(200, 2)
    assertMoney(150, 2)
    assertMoney(110, 2)
    assertMoney(100, 1)
    assertMoney(90, 4)
    assertMoney(80, 4)
    assertMoney(60, 2)
    assertMoney(50, 1)
    assertMoney(40, 4)
    assertMoney(10, 1)
    assertMoney(0, 0)


def assertMoney(money, count):
    assert (solve(money), count)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;코드를 보면 화폐의 종류 만큼 반복을 수행해야하는 것을 알 수 있다. 따라서 화폐의 종류가 &lt;code&gt;K&lt;/code&gt;개라고 할 때, 위 소스 코드의 시간 복잡도는 &lt;code&gt;O(K)&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.&lt;/li&gt;
&lt;li&gt;그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토를 해야한다.&lt;/li&gt;
&lt;li&gt;어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고 문제를 해결할 수 있는 탐욕적인 해결책이 있는지 고민을 해보자.&lt;/li&gt;
&lt;li&gt;만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 그때는 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결 할 수 있는지를 재차 고민해보는 것도 한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>주간 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 28 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/28/%EC%A3%BC%EA%B0%84-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h1 id=&#34;주간-회고&#34;&gt;주간 회고&lt;/h1&gt;
&lt;p&gt;이번주에 있던 일들을 종합해서 회고를 해보고 정리를 해보았습니다.&lt;/p&gt;
&lt;h4 id=&#34;출근-방식의-변화&#34;&gt;출근 방식의 변화&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;이번주에는 새벽까지 할 일을 하고 아침에 늦게 출근하느 방식에서 벗어나 차라리 일찍 일어나서 일찍 출근하고 일찍 취침하는 방식을 택했다. 무엇보다 마음에 드는 것은 활용할 수 있는 시간이 훨씬 많아진 것이다. 새벽에 출근을 하니까 교통이 막히자 않아서 전에는 버스를 타고 1시간 20분 걸리던 거리가 40분 만에 도착할 수 있었다. 그리고 남는 시간에 개인적인 공부를 하니 시간 확보를 하는데 많은 도움이 되었다.
또한 회사에서 회식을 하더라도, 끝까지 가지 말고 아홉시나 열시쯤에는 헤어져서 집에 가야지 생활 패턴을 유지할 수 있을 것이다.&lt;/p&gt;
&lt;h4 id=&#34;테스트-코드&#34;&gt;테스트 코드&lt;/h4&gt;
&lt;hr&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/anH8Y8vAz2Q&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;빌 에반스가 성공한 사람들은 놀랍게도 어떤일을 잘하기 위해서 현실적인 관점을 가지고 접근한다고 했는데, 나 역시 추상적으로 코딩을 잘해야지 보다는 테스트 코드를 작성하면서 코드의 구조를 깔끔하게 만든다던지, 객체간의 의존성을 줄여야지 같은 현실적은 방법을 생각하기로 하였고, 현재 우선적으로 실력을 늘리기 위해서 생각한 방법은 테스트 코드를 먼저 작성하면서 내가 어떻게 코드를 만들어갈지를 생각하는 것이다.&lt;/p&gt;
&lt;h4 id=&#34;코드-숨&#34;&gt;코드 숨&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;코드 숨 강의를 들으면서, 도메인 객체를 외부와 소통하는 용도로 사용하는 것이 아니라, 외부랑 소통하는 용도의 새로운 객체를 만들어서 이를 이용해서 통신을 하는 것을 배울 수 있었다.
또한 이를 더욱 편리하게 하기 위해서, 맵퍼를 사용하는데 &lt;code&gt;DozerMapper&lt;/code&gt;라는 것을 사용해서 객체간의 변환을 쉽게 하는 방법에 대해서 배울 수 있었다.
그리고 예외 처리를 어디서 해야 좋을지에 대한 이야기를 해주셨는데, 꼭 컨트롤러에서 해주어야한다는 고정 관념을 가질 필요가 없고, 핵심은 서비스/컨트롤러 입장에서 외부에 공개되어야 하는 예외 상황이란 무엇이며 외부에 알리지 않고 조용히 처리할 예외는 무엇인지를 적절하게 구분하고 사용하는 것이 중요하다라는 사실을 알게 되었다.&lt;/p&gt;
&lt;h4 id=&#34;경력-관리&#34;&gt;경력 관리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109415964-f1c7f680-79fe-11eb-870e-53947fa7dfc8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;저번주에, 네이버 채용공고를 작성해보면서 내가 어떤 부분이 부족한지 생각을 해보는 시간을 가지고 실제로 제출까지 해봤다. 서류 합격을 기대하지는 않았지만 놀랍게도 합격을 해서 코딩 테스트를 보라고 메일이 왔다. 하지만 평소에 코딩 테스트를 준비한 적이 없어서 코딩 테스트를 보기 조금은 막막 했다. 이를 통해서 준비를 평소에 해야지 기회를 잡는 다는 사실을 다시 한번 깨닫게 되었다. 따라서 현재 이직할 마음이 별로 없더라도, 코딩 테스트 및 이직 준비는 꾸준하게 해두어야겠다는 생각이 들었다. 그리고 지금부터라도 공부한 내용들을 모두 기술 블로그에 정리를 해야겠다는 생각을 했고 여태까지 공부한 내용들도 깃허브 및 블로그로 옮겨야겠다.&lt;/p&gt;
&lt;h4 id=&#34;pr을-날릴-때는-코드에-대한-명확한-이유와-설명&#34;&gt;PR을 날릴 때는 코드에 대한 명확한 이유와 설명&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/14002238/109415477-4e75e200-79fc-11eb-8ec8-9b5e5f496d4c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드숨에서 PR을 날릴 때, 잘 짜여진 연극이라고 생각할지는 모르겠지만, 현재 사용하고 있는 라이브러나 코드를 사용한 이슈를 남에게 설득 시키려는 것 처럼 글을 작성하라고 하셨는데, 곰곰히 생각해보니 회사에서 내가 새롭게 추가하려는 라이브러리에 대한 정확한 설명없이 내가 도입을 하려고 했던 적이 많은 것 같다. 따라서 앞으로 코드를 작성하고 PR을 날릴 일이 있으면 내가 코드를 이렇게 작성한 이유 및 만약 라이브러리를 도입하려고 한다면 도입하려는 이유 및 도입했을 때 장점 같은 것을 상세하게 적어 동료들을 설득 시킬 수 있어야 된다는 것을 알게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트레스-관리&#34;&gt;스트레스 관리&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;이번주에 팀장님이랑 매월마다 진행하는 면담을 실시 했는데, 팀원 분들이 나를 많이 걱정 해주신다는 사실을 알게 되었다. 최근에 팀원분들이 내가 많이 스트레스를 받아하는 것 같다고 하셨는데, 실제로 이번주에 스트레스를 많이 받기는 했지만 그게 다른 사람들이 눈치를 챌 정도인건 정말로 몰랐다. 따라서 스트레스를 해소할 수 있는 취미나 운동을 해보는게 어떻겠냐고 물어보셨다. 나도 그 부분에 어느정도 동의를 하였고 따라서 회사에서 받은 스트레스를 해소할 수 있는 취미나 운동을 알아봐야겠다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>개발자 채용 프로세스</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</link>
      <pubDate>Sat, 27 Feb 2021 22:56:33 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/</guid>
      <description>&lt;h1 id=&#34;개발자-채용-프로세스&#34;&gt;개발자 채용 프로세스&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;개발자 채용 프로세스는 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;서류 검토&lt;/li&gt;
&lt;li&gt;코딩 테스트&lt;/li&gt;
&lt;li&gt;기술 면접&lt;/li&gt;
&lt;li&gt;인성 면접&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트는 주로 알고리즘 문제를 출제하므로, 알고리즘을 열심히 공부하고 연습했다면 합격할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 기술 면접에서는 알고리즘 외에도 컴퓨터구조, 운영체제 등 컴퓨터공학 전반에 대한 다양한 지식에 관해서 질문하므로 공부해야할 범위가 상당히 넓다.&lt;/li&gt;
&lt;li&gt;또한 아무리 실력이 좋더라도 성실성과 팀원으로서 잘 어울릴 수 있는지 그리고 커뮤니케이션 능력 또한 무시할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접의-대표-유형&#34;&gt;기술 면접의 대표 유형&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;알고리즘-문제-풀이와-질의-응답-형식&#34;&gt;알고리즘 문제 풀이와 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코딩 테스트를 치른 내용을 토대로 면접을 진행하며 알고리즘 역량이 제대로 갖추었는지를 평가한다.&lt;/li&gt;
&lt;li&gt;알고리즘의 원리를 완전히 자기것으로 만들 수 있어야한다.&lt;/li&gt;
&lt;li&gt;자료구조와 알고리즘에 대한 이해가 바탕이 되어야한다.&lt;/li&gt;
&lt;li&gt;단순히 알고리즘의 시간 복잡도를 평가하는 것만으로는 부족하고, 실제로 서로 다른 알고리즘을 비교하여 &amp;lsquo;특정한 상황&amp;rsquo;에서 무엇이 더 좋을지를 설명할 수 있어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;포트폴리오-질의-응답-형식&#34;&gt;포트폴리오 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;투입될 개발 프로젝트에 필요한 지식을 가지고 있는지 물어볼 때 주로 이용되는 유형이다.&lt;/li&gt;
&lt;li&gt;개발 경험에 가중치를 부여하는 회사는 포트폴리오를 상당히 중요하게 본다.&lt;/li&gt;
&lt;li&gt;이를 대비해 공부하면서 만든 토이 프로젝트를 정리하여 포트폴리오로 만들어두면 좋다.&lt;/li&gt;
&lt;li&gt;다른 사람들이 보기 편하게 문서화를 하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;만약 팀 프로젝트라면 본이이 맡은 역할 및 이슈를 해결하면서 배운 내용 등을 문서에 담도록 하자.&lt;/li&gt;
&lt;li&gt;또한 전체 소스코드를 깃 허브에 올리고 이력서에 깃허브 주소를 첨부하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;AWS, GCP에 배포하는 형식으로 포트폴리오를 제출해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;컴퓨터-공학-질의-응답-형식&#34;&gt;컴퓨터 공학 질의 응답 형식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기술 면접 때 컴퓨터공학에 대한 전반적인 지식을 질문하기도 한다.&lt;/li&gt;
&lt;li&gt;운영체제, 컴퓨터아키텍처, 개발 방법론 등에 대한 이해가 있어야 개발할 수 있는 분야도 있기 때문이다.&lt;/li&gt;
&lt;li&gt;예를 들어서 서버 개발을 할 때는 멀티 스레딩, 메모리 관리 등을 알아야한다.&lt;/li&gt;
&lt;li&gt;또한 어느 분야든 네트워크에 대한 지식이 필요하다. 예를 들어서 웹 개발 직군에 지원한다면 (GET, POST 방식의 차이나) TCP, UDP, HTTP, HTTPS의 개념과 원리에 대해서 알고 있어야 한다.&lt;/li&gt;
&lt;li&gt;데이터베이스 관련 직군이라면 데이터베이스의 정규화, 인덱스, NoSQL 등 다양한 데이터베이스 관련 내용에 대해서 물어볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접-준비&#34;&gt;기술 면접 준비&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 잘 풀었다고 해서, 기술 면접을 쉽게 통과할 수 있다고 생각을 하면 안된다.&lt;/li&gt;
&lt;li&gt;기업에서 원하는 직원은 문제를 풀어 &amp;lsquo;정답 판정&amp;rsquo;을 받는 지원자가 아니라, 어떤 방법으로 문제에 접근하여 어떠한 알고리즘을 사용했는지를 논리 정연하게 설명할 수 있는 지원자를 원한다.&lt;/li&gt;
&lt;li&gt;회사에서 같이 일할 사람을 뽑는 과정이므로 논리적으로 말로 정리하는 능력도 매우 중요하다.&lt;/li&gt;
&lt;li&gt;이러한 능력은 하루 아침에 생기는 것이 아니므로, 평소에 기술 블로그나 깃허브 저장소를 운영하며 능력을 키워갈 수 있다. 또한 글로도 논리적인 풀이 능력을 확인할 수 있으므로 채용시에 장점이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;기술-면접의-어려움&#34;&gt;기술 면접의 어려움&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;면접관마다 중요하게 생각하는 개발자의 자질이 다들 수 있어서, 기술 면접을 &amp;lsquo;완벽&amp;rsquo;하게 대비하는 일은 불가능하다.&lt;/li&gt;
&lt;li&gt;어떤 면접관은 (개발자) 수학과 알고리즘의 원리를 중요하게 생각해서 업무에서 필요한 알고리즘 원리에 초점을 맞추어 질문을 할 수 있는 반면에, 다른 면접관은 프레임워크나 라이브러리를 다룬 경험을 중요하게 생각하여 관련 경험을 주로 물어볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;인성-면접-질문-리스트&#34;&gt;인성 면접 질문 리스트&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;다음은 대표적인 인성 면접 질문 리스트이다. 아무것도 모르는 것보다는 이러한 유형으로 질문을 받을 수 있다는 것을 알고 미리 자신만의 대답을 질문하는 것이 좋을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;개발하면서 가장 행복했던 일은 무엇인가요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 질문은 개발자로서의 열정을 느낀 경험을 물어보는 질문이다. 개발하면서 행복감을 느꼈던 순간이나, 보람을 느꼈던 경험을 이야기하면 좋다. 채용자는 같이 일할 만한 사람인지를 확인하고자 이러한 질문을 한다. 따라서 자신이 개발하면서 얼마나 행복감을 느끼는지, 어떨 때 기쁜지 등을 설명하면서 개발을 좋아한다는 점을 알리면 좋다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자신이 가장 열정적으로 참여했던 프로젝트가 있다면 이야기해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 질문에는 자신이 열정적으로 참여했던 프로젝트를 소개하고, 누구와 함께 했는지, 자신이 맡은 역할이 무엇이었는지를 답하면 된다. 특히 프로젝트에서 자신이 기여한 파트를 구체적으로 언급하고 그 과정에서 겪었던 어려운 점을 어떻게 해결하여 실력 향상을 이룰 수 있었는지에 대해서 설명할 수 있을 정도로 준비를 하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;회사에 대해 궁금한 점이 있다면 말해주세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;면접은 단순히 회사에 채용되는 과정이 아니라, 여러분 또한 회사를 선택하는 입장이라는 점을 기억하자. 따라서 회사에 대하여 궁금한 점이 있다면 질문할 수 있도록 사전에 회사에 대해 알아보고 면접에 임하자.&lt;/p&gt;
&lt;p&gt;1차원적으로 궁금한 것을 물어보는 것보다는 자신의 개발자로서의 성향 중에서 &amp;lsquo;긍정적인 성향&amp;rsquo;을 드러낼 만한 질문을 하는 것이 좋다.&lt;/p&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>코딩 테스트 출제 경향 및 준비 방향</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5/</link>
      <pubDate>Sat, 27 Feb 2021 22:28:35 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EC%A0%9C-%EA%B2%BD%ED%96%A5-%EB%B0%8F-%EC%A4%80%EB%B9%84-%EB%B0%A9%ED%96%A5/</guid>
      <description>&lt;h1 id=&#34;최신-출제-경향과-준비-방향&#34;&gt;최신 출제 경향과 준비 방향&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;정확한 알고리즘을 사용하여 얼마나 빠르게 많은 문제를 풀었는지를 토대로 순위를 매긴다.&lt;/li&gt;
&lt;li&gt;기업은 코딩 테스트를 통해서 취업 준비생들에게 뛰어난 프로그래밍 실력을 원하는 것이 아니라, 기초 알고리즘에 기반하는 문제들이 출제된다.&lt;/li&gt;
&lt;li&gt;가장 출제 빈도가 높은 문제는 그리디, 구현(implementation), DFS/BFS를 활용한 탐색 문제이다.&lt;/li&gt;
&lt;li&gt;또한 상대적으로 높은 사고력을 요구하는 다이나믹 프로그래밍이나, 그래프 이론 문제도 출제된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 카카오 기술 블로그에 언급된 코딩 테스트 문제 난이도에 대한 내용이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ACM-ICPC 같은 어려운 알고리즘 설계 능력을 겨루는 문제가 아닌, 업무에서 있을만한 상황을 가정하여 독창적이고 다양한 분야의 문제를 출제했고 난이도 또한 비교적 쉬운 수준으로 조정하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;다양한 케이스를 고려해야 안정적으로 만점을 받을 수 있는 문제들이 주로 출제 된다.&lt;/li&gt;
&lt;li&gt;위와 같은 경우 테스트 코드를 활용하면 안정적으로 구현을 할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;시간이 촉박하기 때문에, 평상시 프로그램을 개발하거나 학교 과제용 문제 풀이에 비하면 심리적으로 부담이 되는 편이다.&lt;/li&gt;
&lt;li&gt;따라서 연습해두지 않으면 평소의 문제 해결 기량에 비하여 좋은 성과가 나오지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;알고리즘 역량을 벗어나 REST API, JSON 등의 원리를 이해하고 있어야 풀 수 있는 문제들도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>이것이 코딩 테스트다</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/</guid>
      <description>&lt;h1 id=&#34;내가-코딩-테스트를-준비하는-이유&#34;&gt;내가 코딩 테스트를 준비하는 이유&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;당장 구직하지 않더라도, 이러한 준비를 미리 해두어야 좋은 기회를 잡을 수 있다.&lt;/li&gt;
&lt;li&gt;대기업이나, 누구나 가고 싶은 기업에는 코딩 테스트가 존재한다.&lt;/li&gt;
&lt;li&gt;항상 서류에서 통과가 되더라도, 코딩 테스트에서 떨어지곤 했는데 이번에는 떨어지지 않고 면접까지 가는 것이 목표이다.&lt;/li&gt;
&lt;li&gt;대기업 면접을 통해서 합격하지 못하더라도 내가 미쳐 생각하지 못했던 부분과, 부족한 부분을 배울 수 있는 기회로 삼고 싶은데 코딩 테스트때문에 면접까지 갈 수가 없기 때문에 배울 기회가 없다.&lt;/li&gt;
&lt;li&gt;물론 코딩 테스트를 통해서 테스트 코드를 작성하는 법과 사고력을 키울 수 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;코딩-테스트를-공부하는-팁&#34;&gt;코딩 테스트를 공부하는 팁&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;문제를 많이 풀고, 복기하는 방법이 실력향상에 많은 도움이 되었다.&lt;/li&gt;
&lt;li&gt;복기한 내용을 깃허브에 기록으로 꼭 남기자, 이 기록은 코딩 테스트 직전에 훌륭한 요약집이 된다.&lt;/li&gt;
&lt;li&gt;상대적으로 어려운 알고리즘을 만나면, 한번에 완벽하게 이해하려 하지 말고 여러 번 읽어 체화시키려고 해야한다.&lt;/li&gt;
&lt;li&gt;총 3번에 걸쳐 읽고, 각 시간을 30, 20, 10 시간으로 쪼개서 점점 더 속도를 올리는 방법을 권한다.&lt;/li&gt;
&lt;li&gt;나는 추가적으로 테스트 코드를 작성하면서 문제를 풀려고 한다, 테스트 코드를 작성하는 실력도 높히고 놓치는 부분이 없는지 확인할 수 있어 TDD를 적용하면서 코딩 테스트를 준비하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;시간 복잡도 분석은 문제 풀이의 핵심이다.&lt;/li&gt;
&lt;li&gt;알고리즘 문제 풀이에 능숙한 숙련자들은 문제를 해석하기 전에 먼저 조건을 보기도 하는데 문제의 조건부터 확인하면 문제를 풀기 위해 얼마나 효율적인 알고리즘을 작성해야하는지 눈치챌 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;시간과-메모리-측정&#34;&gt;시간과 메모리 측정&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;파이썬에서는 쉽게 프로그램 수행 시간과 메모리 사용량을 측정할 수 있다.&lt;/li&gt;
&lt;li&gt;알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다.&lt;/li&gt;
&lt;li&gt;실질적으로 알고리즘의 소요 시간을 확인해야 자신이 제대로 알고리즘을 작성하고 있는지 체크할 수 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
start_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#75715e&#34;&gt;# 측정 시작&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# 프로그램 소스 코드...&lt;/span&gt;

end_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#75715e&#34;&gt;# 측정 종료&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time:{end_time - start_time}&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 수행 시간 출력&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;자신이 설계한 알고리즘의 성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247882118&#34;&gt;이것이 취업을 위한 코딩테스트다, 나동빈, 한빛미디어&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;facts (사실, 객관)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;오늘 개발 블로그를 만들었다.&lt;/li&gt;
&lt;li&gt;오늘 회사에 일찍 일어나서, 출근을 하였다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 3장까지 읽었다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;feelings (느낌, 주관)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;블로그 서비스를 이용하는 것보다는 많은 시간이 들었다.&lt;/li&gt;
&lt;li&gt;아직 많은 기능이 필요하지만, 실제로 그 기능이 필요할 때 까지는 최대한 늦추도록 해야겠다.&lt;/li&gt;
&lt;li&gt;일찍자고, 일찍 일어나는 것이 늦게까지 개발을 하다가 늦게 일어나는 것 보다 효율이 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;하지만, 회사에 출근을 했을 때, 무엇을 해야할지 계획을 세우지 않아서 조금 헤메였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;findings (배운 점)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;직접 개발 블로그를 만드니까, 조금 더 애정이 가는 것 같다.&lt;/li&gt;
&lt;li&gt;일찍자고 일찍일어나니까 활용할 수 있는 시간이 훨씬 늘어난 기분이다.&lt;/li&gt;
&lt;li&gt;테스트 코드에도 순서가 있다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;테스트 코드의 중복을 제거할 때, 가독성을 해치지 않는지를 고려하고 조심스럽게 중복된 부분을 제거해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 앞으로, 일찍 자고 일찍 일어나는 생활 패턴을 지킬 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는&amp;gt;다.&lt;/li&gt;
&lt;li&gt;affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지
하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>테스트 코드를 작성하는 순서</title>
      <link>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C/</link>
      <pubDate>Sat, 27 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/27/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C/</guid>
      <description>&lt;h3 id=&#34;테스트-코드를-작성하는-순서&#34;&gt;테스트 코드를 작성하는 순서&lt;/h3&gt;
&lt;p&gt;테스트 코드를 작성하는 것도 무작성 작성하는 것보다는 순서를 지켜가면서 작성하는 것이 훨씬 좋다.&lt;/p&gt;
&lt;h4 id=&#34;테스트는-다음과-같은-순서를-따르면서-작성-해야한다&#34;&gt;테스트는 다음과 같은 순서를 따르면서 작성 해야한다.&lt;/h4&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;쉬운 경우에서, 어려운 경우로 진행&lt;/li&gt;
&lt;li&gt;예외적인 경우에서, 정상적인 경우로 진행&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;한번에 완벽한 코드를 만들면 좋겠지만, 모두가 슈퍼 개발자인 것은 아니다. 보통의 개발자는 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고
나중에 버그를 잡기 위해 많은 시간을 허비하게 된다. 당연히 테스트 통과 시간도 길어진다.&lt;br&gt;
그 뿐만 아니라, 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름도 자주 끊기게 된다.&lt;br&gt;
중간에 화장실도 다녀오고 커피도 마시게 된다. 자리에 돌아오면 이전까지 했던 흐름을 이어가 기 위한 시간도 필요하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;따라서 테스트를 코드를 작성할 때, 순서에 유의해서 작성 해야 한다 가장 구현하기 쉬운 경우부터 시작하고, 보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다. 그래야만 점진적으로 구현을 완성해갈 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한번에 구현하는 시간이 짧아지면 디버깅 할 때에 유리하다.&lt;/li&gt;
&lt;li&gt;작성한 코드가 많지 않고 작성 시간도 짧으면 머리속에 코드에 대한 내용이 생생하게 남아있기 때문에, 디버깅할 때 문제의 원인을 쉽게 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 문장을 읽고 나서 &amp;ldquo;내가 지금 작성하고 있는 코드를 어떻게 하면 가장 빨리 실행할 수 있을까&amp;rdquo; 라는 생각이 들었고
가장 빠르게 실행 시킬 수 있는 방법은 테스트 코드를 작성하는 것이라는 결론을 내릴 수 있었다.&lt;/p&gt;
&lt;h4 id=&#34;예외-상황을-먼저-테스트해야-하는-이유&#34;&gt;예외 상황을 먼저 테스트해야 하는 이유&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;다양한 예외 상황은 복잡한 &lt;code&gt;if-else&lt;/code&gt; 블록을 동반하기 때문에 예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면, 코드의 구조를 뒤집거나 코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다.&lt;/li&gt;
&lt;li&gt;TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;완급-조절&#34;&gt;완급 조절&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;처음에 테스트 코드를 작성할 때, 어려운 것 중 하나는 한 번에 얼마만큼의 코드를 작성할 것인가이다.&lt;/li&gt;
&lt;li&gt;다음의 순서를 시키면서 TDD를 진행하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;값 비교를 이용해서 정해진 값을 리턴&lt;/li&gt;
&lt;li&gt;다양한 테스트를 추가하면서 구현을 일반화 시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;뻔한 구현이라도 위 단계를 거쳐서 연습하는 것과 바로 구현하는 것과는 차이가 있다.&lt;/li&gt;
&lt;li&gt;테스트를 만들고 통과시키는 과정에서 구현이 막힐 때가 있다. 이럴 때 위 단계를 이용해서 TDD를 연습한 개발자는 조금씩 기능을 구현해 나갈 수 있는 반면에 그렇지 못한 개발자는 구현에 실패하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;지속적인-리팩토링&#34;&gt;지속적인 리팩토링&lt;/h4&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;테스트를 통과한 후에는 리펙토링을 진행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 중복은 대표적인 리팩토링 대상이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드가 길어지면 메서드 추출과 같은 기법을 사용해서, 메서드 이름으로 코드의 의미를 표현할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDD를 진행하는 과정에서 지속적으로 리펙토링을 진행하면 코드 가독성이 높아진다. 코드 가독성이 높아지면 개발자는 빠르게 코드를 분석할 수 있어 변경할 코드를 빠르게 찾을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 변경의 어려움을 줄여주어 향후 유지보수에 도움이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  테스트 대상 코드에서 상수를 변수로 바꾸거나 변수 이름을 추출하는 것과 같은 작은 
  리펙토링은 발견하면 바로 실시하는데 반해서 메서드 추출과 같이 메서드의 구조에
  영향을 주는 리펙토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 후에 진행한다.
    
  구현 초기에는 아직 구현의 전반적인 흐름을 모르기 때문에, 메서드 추출과 같은 
  리펙토링을 진행하면 코드 구조를 잘못 잡을 가능성이 있기 때문이다. 코드 구조를 잘못 잡으면
  테스트를 통과 시키는 과정에서 코드가 복잡해지거나 구현을 더는 진행하지 못하고 막힐 수 있다.
  이런 상황이 오면 구현을 멈추고 메서드 추출 리팩토링을 되돌려야 한다. 
  리팩토링을  취소해서 코드를 원상 복구한 뒤에 다음 테스트를 진행하고
   코드의 의미나 구조가 더 명확해지면 그때 다시 리펙토링을 실시한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고-문헌&#34;&gt;참고 문헌&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=233614629&#34;&gt;테스트 주도 개발 시작하기, (최범균, 가메출판사)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 26 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/26/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들의 PR을 참고해보았다. (&lt;a href=&#34;https://github.com/CodeSoom/spring-week5-assignment-1/pull/10&#34;&gt;https://github.com/CodeSoom/spring-week5-assignment-1/pull/10&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들의 PR에서 내가 경험해보지 못한 많은 것을 배울 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예외처리에 어떤 정보를 추가하는 것은, 디버깅하는 사람과 모니터링을 하는 사람들을 위한 서비스 정보라는 것을 알게 되었고, 이러한 사람들을 위해서 적절한 예외와 정보를 알려줘야겠다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;예외를 반드시 컨트롤러에서 처리를 하지 않아도 된다는 것을 배울 수 있었다. 어떤 예외는 레이어를 넘나들고, 어떤 예외는 다른 레이어에 공개되지 않도록 조용이 처리해야한다.&lt;/li&gt;
&lt;li&gt;다른 사람들은 PR을 굉장히 정성스럽게 적고, 다른 사람들이 보기 좋게 적는 것을 확인하였다. 따라서 나도 이러한 점을 본받을 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;li&gt;핵심은 서비스/컨트롤러 입장에서 외부에 공개되어야 하는 예외 상황이란 무엇이며 외부에 알리지 않고 조용히 처리할 예외는 무엇인지를 적절하게 구분해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 25 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/25/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 일찍 출근하였다.&lt;/li&gt;
&lt;li&gt;버스로 출퇴근하면서 경제 유튜브를 시청하였다.&lt;/li&gt;
&lt;li&gt;어제 퇴근하면서 버클리에서 하는 데이터베이스 강의를 들었다.&lt;/li&gt;
&lt;li&gt;기계인간님이 코드숨 과정을 진행할 때, 자신의 PR에 dozer-mapper를 소개하고, 자신이 생각하는 장점을 같이 기입하면 좋을 것 같다고 하셨다.&lt;/li&gt;
&lt;li&gt;오늘 목표를 정했다. 1. LMS에서 함수 하나를 정해서 작게라도 테스트 코드를 작성하기&lt;/li&gt;
&lt;li&gt;슬랙에 요청만 하고 확인하지 않았다.&lt;/li&gt;
&lt;li&gt;최근에 스트레스 관리를 못해서 회사에서 감정 컨트롤을 하지 못해 회사에서 하루종
일 우울한 모습을 보였다.&lt;/li&gt;
&lt;li&gt;무언가를 물어볼 때, 말을 조리있게 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다행히도 버스를 놓치지는 않았지만 이전보다 여유를 부리는 느낌이다.&lt;/li&gt;
&lt;li&gt;강의는 영어로 진행되었지만, 생각보다 해석하는데 어려움이 없었다. 계속 퇴근할 때 틈틈히 공부를 하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;회사에서 PR을 할 때, 왜 이렇게 사용했는지, 왜 이런 라이브러리를 사용했는지 물어보는 경우가 많은데 이러한 방식을 미리 연습하면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;오늘 우리팀분들과 회사 사람들을 만난것을 행운이라고 생각을 한다.&lt;/li&gt;
&lt;li&gt;팀원 분들 및 솔루션 사람들이 걱정을 많이 해주는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;물어보기 전에, 물어볼 내용을 정리하는 것이 중요할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;부자가 되려면 G, R을 높여야하는데, G는 자신의 몸값이고, R은 재테크이다. 나는 아직은 몸값을 높이고, 능력을 높이는데 많은 노력을 해야겠다.&lt;/li&gt;
&lt;li&gt;앞으로 PR을 날릴 때, 자신의 코드에 대해서 이렇게 만든 이유와 만약 라이브러리를 도입했다면, 이 라이브러리를 도입한 이유에 대해서 논리적으로 설득시키는 형식으로 PR을 작성해야겠다.&lt;/li&gt;
&lt;li&gt;슬랙에 요청드렸더라도 주도적으로 확인을 해야한다!&lt;/li&gt;
&lt;li&gt;회사에서 일을 잘하는 것도 중요하지만, 감정 관리 및 스트레스 관리 같은 기본적인 예의를 지켜야겠다.&lt;/li&gt;
&lt;li&gt;모르는 것이 있을 때, 글로 한번 정리를 한 다음에 상대방에게 물어보는게 좋을 것  같다. 상대방이 시간을 내주는것이 당연하게 아니기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;good-잘한점&#34;&gt;Good (잘한점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;회고를 빠지지 않고 작성했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bad-개선할-점&#34;&gt;Bad (개선할 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들에게 더 친절하게 하고, 분위기를 띄우려고 노력해야겠다.&lt;/li&gt;
&lt;li&gt;최소한 우울한 모습 및 다른 사람들을 처지지 않게 해야겠다.&lt;/li&gt;
&lt;li&gt;웃으면서 다른 사람들에게 다가가는 연습을 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람의 시간도 귀하다는 것을 알고, 물어볼 것을 미리 적고 정리를 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 24 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/24/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 이력서를 간단하게 작성을 시도해보았다.&lt;/li&gt;
&lt;li&gt;아침에 과제를 바로 하거나, 이력서 관련 분석을 해야겠다.&lt;/li&gt;
&lt;li&gt;더 많은 일을 하면서 더 빠르게 하기(&lt;a href=&#34;http://agile.egloos.com/1762301&#34;&gt;http://agile.egloos.com/1762301&lt;/a&gt;) 라는 글을 읽었다.&lt;/li&gt;
&lt;li&gt;간단한 쿼리문을 작성해보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;경력 기술서를 간단하게 적고 있는데, 회사에서 했던일이 무엇인지 잘 생각이 나지 않는다.&lt;/li&gt;
&lt;li&gt;어떤 일을 할 때, 작은 규모의 일을 하고 그 다음에 같은일을 좀 더 큰 규모로 하면 더 쉽다는 것이다.&lt;/li&gt;
&lt;li&gt;조인에 대해서 내가 잘 이해하지 못하고 있는 것 같다. 따라서 부족한 부분을 채우고 공부를 할 필요성을 느끼고 있다.&lt;/li&gt;
&lt;li&gt;어떤 변경 사항이 있을 때, 데이터의 변경 사항을 보고나서 어떤 영향을 주는지 확인을 해야겠다.&lt;/li&gt;
&lt;li&gt;조금 더 꼼꼼하게 일을 처리해야겠다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OKR을 보면서 경력 기술서에 적을 내용을 생각해보고, 추가적으로 대외 활동을 많이 참여하거나, 오픈소스 컨트리뷰션을 많이 해야겠다.&lt;/li&gt;
&lt;li&gt;링크그인을 꾸준히 관리해야겠다.&lt;/li&gt;
&lt;li&gt;알고리즘 문제를 풀거나, 이력서를 작성하거나, 테스트 코드를 작성할 때, 작은 것을 만들고 큰 것을 이어서 만드는 연습을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;데이터를 조인할 때, 방향 선정을 잘 해야하는 필요성을 느끼게 되었다. 그리고 INNER, OUTER JOIN에 대하여 대략적으로 알게 되었다.&lt;/li&gt;
&lt;li&gt;오라클 문법이 아닌, 다른 ANSI가 아닌 방법으로 조인을 하는 법을 보았다.&lt;/li&gt;
&lt;li&gt;버그같은 기능이라도 URS를 먼저 확인해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;조인에 대해서 확실하게 공부를 하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Tue, 23 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/23/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘도 일찍 출근해서, 아침에 과제를 하였다.&lt;/li&gt;
&lt;li&gt;테스트를 먼저 작성하다보니, 미완성인 클래스들을 우선 만들어주어야하는 경우가 있었다.&lt;/li&gt;
&lt;li&gt;오늘 퍼블리싱 세미나에 참석했다.&lt;/li&gt;
&lt;li&gt;스마트한 시간관리, 인생관리 습관이라는 책을 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내가 자본주의를 살면서 느낀 것은 하이 리턴을 바랄 려면 하이 리스크를 감당할 줄 알아야하는 것과, 시간은 곧 돈이고 모든 서비스는 어떻게 보면 다른 사람들의 시간을 아껴주는데서 발생한다는 것이다. 따라서 다른 사람들이 어떤 일에 시간이라는 자원을 많이 들이는지 그리고 내가 어떻게 하면 그 시간을 줄여줄 수 있는지에 대해서 고민을 하자.&lt;/li&gt;
&lt;li&gt;한번에 한 가지 일만 하는 것이 중요한 것 같다. 예를 들면 어떤 테스트 코드를 작성하지라고 고민하다가 테스트 함수 이름을 어떻게 짓는것이 바람직한가?와 같은 문제들 말이다. 따라서 한 번에 한 가지 일만 할 수 있게 다른 것들을 미뤄두다가 한 번에 비슷한 일들을 처리하는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;테스트주도 개발 시작하기라는 책에서 배웠던 것 처럼, 우선 미완성된 클래스들을 테스트 코드 패키지 않에 넣어두었다가 어느정도의 테스트가 완성되고 기능이 완성되었다고 생각하면 이를 실제 소스코드 경로에 올리는 선택이 좋은 것 같다.&lt;/li&gt;
&lt;li&gt;항상 개발을 하면서 웹 프론트 레이아웃 잡는 것을 어려워 했는데, 이번 기회에 배울 수 있었던 것 같다.&lt;/li&gt;
&lt;li&gt;일찍 출근을 하니, 하루를 더 길게 사용하는 느낌이 들었고, 시간을 소중히 여기는 마음도 생기게 되었다.&lt;/li&gt;
&lt;li&gt;오늘 회사 팀원이랑 같이 식사를 할 떄, 이직준비를 어떻게 했나고 물어보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;도메인 객체를 외부와 소통하는 용도로 사용하면 안되고, 외부랑 소통하는 용도의 객체를 만들어주어야한다는 것을 배우게 되었다.&lt;/li&gt;
&lt;li&gt;DTO 같은 경우에는 직접 도메인 모델을 알면 안된다.&lt;/li&gt;
&lt;li&gt;원래 메서드 체이닝을 함부로 사용하면 안된다는 사실을 알게 되었고, 패턴 같은 경우에는 목적에 맞게 사용하는 것이 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;이직 준비는 꾸준히 해야하는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;개발 블로그를 꾸준하게 작성하고 배운것을 기록해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;내가 회사에서 했던 일들을 프로젝트 단위로, 기록을 해야겠다.&lt;/li&gt;
&lt;li&gt;우선 저녁에 할 일을 미리 정하고 실제로 하는 연습부터 하라고 했다. 따라서 오늘 부터 이를 연습할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이직 준비를 날마다 하면서, 내가 어떤 것을 공부해야하는지 어떤 부분을 채워야하는지 생각할 것이다.&lt;/li&gt;
&lt;li&gt;시간을 아껴서 사용할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Mon, 22 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/22/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어제 일찍 자고, 일찍 출근하여 개발 공부를 하였다.&lt;/li&gt;
&lt;li&gt;오늘 퇴근하는 길에, 라인 개발자 공고를 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;출근 시간이 훨씬 빨라진 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;하루가 길게 느껴졌고, 코드숨 강의를 여유롭게 들을 수 있었다.&lt;/li&gt;
&lt;li&gt;나도 저런곳에서 한번 일해보고 싶은 마음이 있었다.&lt;/li&gt;
&lt;li&gt;요즘 배우고 있는 TDD를 코딩 테스트를 풀면 일석이조의 효과를 누릴 수 있겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;빌 에반스가 성공한 사람들은 놀랍게도 현실적인 관점을 가지고 있다는 말을 했다. 그리고 대다수의 사람들은 대가의 피아노 연주를 보고 자신이 무엇을 하는지도 모르고 따라하려고만 노력한다고 했다. 이 이야기를 나의 관점에서 대입해서 본다면, 나는 잘 작성된 코드만 보고 어떻게 이렇게 좋은 구조로 코드를 작성했을까? 어쩜 저렇게 깔끔하게 코드를 작성했을까라고만 생각을 했다. 하지만 현실적으로 나도 저렇게 작성하려고 노력한다고 해도 그저 내가 뭘하는지 모르는 채로 흉내만 낼 뿐이다. 따라서 나도 현실적인 관점으로 대가처럼 코딩하는 방법중에 하나는 어떻게 테스트를 할 수 있을까? 라는 의문을 가지는 것이다. 나도 저렇게 의존성을 줄이고, 분기문을 줄이고, 관심사를 분리해서 짜야지라는 것 보다는 하나씩 테스트 코드를 작성하고, 그리고 레거시 코드를 테스트 하면서 접근해야지가 현실적이라는 말이다. 조금 생각이 정리가 안되서 정확한 의미를 글로 전달하지 못한 것일 수도 있지만 실제 현업에서 시간이 날때마다 기존의 소스를 어떻게 테스트 할까? 어떻게 문서화를 다른 사람들을 고려해서 만들까? 하는 현실적인 관점에서 노력을 한다면 저절로 좋은 소프트웨어 및 좋은 코드를 작성할 수도 있겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;이전에는 책을 보면 끝까지 다 읽어야지, 진정으로 책을 읽은 것이라고 생각 했다 그렇기 때문에, 책의 분량에 집착을 하게 되었고 따라서 제대로 지식을 습득하지 못했음에도 그냥 넘어간적도 많았다. 그렇게 되자 후반에는 이해가 되지 않아서 읽어도 읽지 않은 상태로 시간만 낭비를 많이 한 것 같다. 따라서 이제는 내가배우고 싶은 기술이 있으면 그 기술 스택을 사용해서 간단한 토이프로젝트를 만들어보는 식으로 공부를 할 것이다. 따라서 책에서 필요한 부분만 취하고 심화적인 내용이 나오기 전까지는 다시 책을 볼 일이 없고 차라리 테스트 코드와 코딩을 할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;채용 공고를 보니, 개발도 잘해야 하지만, 외국어로 의사소통이 가능한 사람을 구하고 있었다.&lt;/li&gt;
&lt;li&gt;링크드인에서 바로 지원을 할 수 있었다.&lt;/li&gt;
&lt;li&gt;일찍 자고, 일찍 일어나는게 코드숨 강의를 하는데 많은 도움이 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;원하는 포지션에 채용 공고가 올라왔을 때, 기회를 잡을 수 있게 꾸준하게 준비를 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;나는 개발 블로그에 글을 꾸준히 작성하여, 나중에 이직할 때 특별히 어필을 하지 않고, 나의 능력을 보여줄 것이다.&lt;/li&gt;
&lt;li&gt;쓸데없는 약속을 잡지 않고, 만약 회식을 하게 된다고 하더라도 무조건 아홉 시 이전에는 나오자.&lt;/li&gt;
&lt;li&gt;내가 맡고 있는 솔루션들을 보면서, 어떻게 테스트를 해야할지 그리고 남는 시간에 테스트코드를 작성해보자. 무조건!!!!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sun, 21 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/21/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;백기선님의 유튜브 영상을 보았다. (&lt;a href=&#34;https://www.youtube.com/watch?v=iua0nrfh4_Q&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=iua0nrfh4_Q&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;이직관련해서 좋은 영상들을 많이 보았다.
&lt;ul&gt;
&lt;li&gt;개발자가 이직하는 방법 (전략) (&lt;a href=&#34;https://www.youtube.com/watch?v=W5Nx4Bq7Y-4&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=W5Nx4Bq7Y-4&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;개발자 취업의 비밀 (역시사지)(&lt;a href=&#34;https://www.youtube.com/watch?v=PWl9dmwnzoo&amp;amp;feature=share&#34;&gt;https://www.youtube.com/watch?v=PWl9dmwnzoo&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;네이버 FINANCIAL에 지원을 해보았다.(&lt;a href=&#34;https://recruit.navercorp.com/naver/job/detail/developer?annoId=20005127&amp;amp;classId=&amp;amp;jobId=&amp;amp;entTypeCd=&amp;amp;searchTxt=&amp;amp;searchSysComCd=&#34;&gt;https://recruit.navercorp.com/naver/job/detail/developer?annoId=20005127&amp;amp;classId=&amp;amp;jobId=&amp;amp;entTypeCd=&amp;amp;searchTxt=&amp;amp;searchSysComCd=&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;자기 회고를 했던 일과 느낀점을 나열하고 있었다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때 세심하게 주의를 기울이지 않는 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단지 회고를 할 때 내가 했던일, 느낀점, 자기 선언을 나열하는 형식보다는 알아보기 쉽게 하는 능력이 부러웠다.&lt;/li&gt;
&lt;li&gt;이력서를 다시 작성하고 보니, 나의 부족한 점이 무엇인지 알 수 있었다.&lt;/li&gt;
&lt;li&gt;이번에 내가 작성한 코드를 다른 사람이 고치는 것을 확인하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;백기선님이 프레임워크를 분석하는 방법은 프레임워크가 흘러가는 로그 메시지를 볼 수 있게 만들도 분석을 해본다고 했다.&lt;/li&gt;
&lt;li&gt;가고 싶은 기업이 있으면 매달 한 두군데에 실제로 지원을 해보면서, 부족한 점을 채워나간다. 그리고 많이 자극을 받을 수 있다고 했다.&lt;/li&gt;
&lt;li&gt;구글에서 일하고 있는 어떤 개발자는 구글에서 일하기 전에 4, 5년을 계속 지원한 끝에 일을 할 수 있다는 사실을 알게 되었고, 누구나 가고 싶은 한번에 되지 않는다는 당연한 사실을 알게 되었고, 꾸준하게 자신을 갈고 닦아야한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;오히려 꾸준하게 이직 준비를 하는 것이 자기 일을 보다 열심히 할 수 있다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;취업 준비를 할 때, 역시사지로 내가 회사의 팀장이라고 생각을 해보고 어떤 사람이 필요한지를 생각하면서 이력서를 작성하면 많은 도움이 될 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;코딩을 할 때, 조금만 주의를 기울이면 이러한 부끄러운일이 발생하지 않을 것 같다. 따라서 나중에 부끄럽지 않으려면 계속 고민을 해야할 것 같다. 내가 작성하는 이 코드가 최선인지에 대해서 말이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 매달 나중에 가보고  싶은 회사에 지원을 해볼 것이다. 그리고, 회고를 통해서 내가 어떤 부분이 부족한지, 알고 이를 채워나갈 수 있을 것이다!&lt;/li&gt;
&lt;li&gt;내가 작성하는 코드가 최선인지 항상 주의를 기울이며, 최대한 많은 고민을 하고 작성할 것이다.&lt;/li&gt;
&lt;li&gt;나중에 겪을 창피함에 비하면 지금 최선의 방법을 고민하는 것은 아무것도 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Sat, 20 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/20/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 TDD로 과제를 하기 위해서 회사에 나왔다.&lt;/li&gt;
&lt;li&gt;오류 메시지가 나왔을 때, 아샬님은 어떤 오류 메시지가 발생하였는지 꼼꼼하게 읽어 보고 개선을 하지만, 나는 그냥 대충 읽어본다는 사실을 발견하였다.&lt;/li&gt;
&lt;li&gt;매일 회고를 작성하니까, 주간 회고를 더 상세하고 의미 있게 작성할 수 있었다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 2장까지 읽어보았다.&lt;/li&gt;
&lt;li&gt;회고를 작성하는 것도 좋지만, 내가 지난 회고를 보고 다시 리마인드 할 수 있게 만드는 것도 생각을 해봐야겠다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서 과제를 하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커뮤니케이션 부분에서 좋은 동료가 되어야겠다는 생각을 했다. 기술적으로 많이 아는 것도 중요하지만, 커뮤니케이션이 잘되는 그리고 같이 일하고 싶은 개발자가 되기 위해서 노력을 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;에러 메시지를 읽는 것이 때로는 힘들더라도, 무조건 읽는 연습을 해야겠다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서, 테스트를 먼저 작성하기 때문에, IDE 에러를 마주할 때가 굉장히 많았다. 처음에는 이러한 에러가 상당히 불편하고, 당장 에러를 없애고 싶었다.&lt;/li&gt;
&lt;li&gt;TDD를 진행하면서, 놀랍게도 테스트를 작성함과 동시에 내가 어떤 것을 만들지에 대한 설계도 같이 진행하고 있었다.&lt;/li&gt;
&lt;li&gt;IDE 에러를 하나씩 지워가면서 코딩을 하는 것이 상당히 재미있었다.&lt;/li&gt;
&lt;li&gt;테스트 주도 개발 시작하기라는 책을 읽으면서 느낀 점인데, 한가지 방법 뿐만이 아니라, 항상 여러가지의 대안을 생각해두고 그 중에서 고르고 있었다. 이를 보면서 나도 앞으로 개발을 하면서, 한가지 방법 뿐만이 아니라 다른 방법도 생각해보면서 그 중에서 고르도록 해야겠다.&lt;/li&gt;
&lt;li&gt;책을 읽을 때 욕심을 내서 제대로 이해하지도 못했는데 무조건 읽기만 하는 경우가 많았다. 따라서 내가 이해할 수 있는 범위까지 읽고나서, 충분히 이해를 했다고 생각되면 그때 계속 읽는 것이 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD는 테스트를 작성하는 것 뿐만 아니라, 코드를 작성하기 전에 어떤 것을 개발하고, 어떤 매개변수를 주어야하고 결과가 어떻게 나와야하는지에 대한 요구사항을 설계하는 느낌을 받았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Fri, 19 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/19/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오늘 친구랑 같이 졸업 사진을 찍었다.&lt;/li&gt;
&lt;li&gt;졸업 사진을 찍으면서 많은 이야기를 할 수 있었다.&lt;/li&gt;
&lt;li&gt;개발 관련된 이야기를 하면서 많은 것을 생각해 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;개발자 이종립님이 코드에 작성한 주석을 바탕으로 문서화를 할 수 있다는 것을 알려주었다.&lt;/li&gt;
&lt;li&gt;성공의 단계에 이르는 빌 에반스의 연습 방법이라는 영상을 보았다. (&lt;a href=&#34;https://youtube.com/watch?v=anH8Y8vAz2Q&amp;amp;feature=share&#34;&gt;https://youtube.com/watch?v=anH8Y8vAz2Q&amp;amp;feature=share&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;나 혼자 독단적으로 판단해서 과제를 진행하던 것을, 초기화 시켰다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;교수님이 추천한 곳으로 취직한 얘들은 별로 좋은 조건에 취업을 하지 못했다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;교수님이 추천한 곳의 조건이 압도적으로 좋지 않다면 다른 곳을 알아보는 것이 훨씬 낫다는 생각을 했다. 엄청 좋다고 해도 자기 힘으로 포트폴리오도 만들고, 채용 사이트에 지원을 해보고 실제 면접을 보는것이 좋을 것이다. 단기적으로는 교수님이 추천을 해주었을 때 취직을 쉽게 할 수 있을지는 모르겠지만, 스스로 취업을 하기 위해서 노력해본 적이 없다면 나중에 이직을 할 때 어려움을 겪을 수 있다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;파이썬에도 주석을 다는 것을 추천하지만, 이렇게까지 해야하나라는 생각을 가지고 있었다. 하지만, 문서를 코드에 작성하는 것이 관리하기도 쉽고 문서를 자동으로 만들어주는 도구까지 있다면 사용하지 않을 이유가 없다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;사람은 자신이 속해있는 집단에 영향을 많이 받는 다는 생각을 하였다. 따라서 좋은 영향력을 가진 사람들과 같이 일을 할 수 있도록 이직을 해야겠다는 생각을 했다. 또한 나도 다른 사람들에게 좋은 영향을 줄 수 있는 좋은 개발자가 되어야겠다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;빌 에반스 영상을 보면서 나도 배워야할게 있다고 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람의 도움에 의존하지 말고, 쉽고 편한 길이 무조건 좋은면만 있지는 않다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;자신이 어느 단계에 있는지 정확히 알고, 진실되고 현실적이며 정확하게 수행해야하는것이 실력 향상에 실질적인 도움이 된다고 생각을 했다.&lt;/li&gt;
&lt;li&gt;나는 큰 문제를 하나로 뭉뚱그려서 커다란 문제로 생각하는 경향이 있다. 이러한 큰 문제들을 작게 쪼개고 해결해나가려는 생각을 해야한다.&lt;/li&gt;
&lt;li&gt;실력이 부족한데 한 번에 모든 것을 해야한다. 따라서 하나의 덩어리 같은 문제점을 작게 쪼개고 이를 해결하려는 자세가 중요하다는 것을 배웠다.&lt;/li&gt;
&lt;li&gt;성공한 사람들은 모두 현실적인 관점을 가지고 있다고 했다. 이는 하나의 큰 문제점을 이렇게 하면 언젠가는 해결되겠지라는 마음을 가지고 있기 보다는 실제로 잘게 쪼개고 어떻게 하면 내가 이를 해결할 수 있을까라는 마음을 가지는 것이다.&lt;/li&gt;
&lt;li&gt;대가들이 작성한 코드를 보고 이를 바로 흉내내력는 시도를 하는 것 보다는 어떻게하면 저렇게 실력을 높일 수 있는지를 현실적으로 생각해보는 것이 나에게 도움이 될 것이다.&lt;/li&gt;
&lt;li&gt;기계 인간님이, 코드숨에서 과제를 하는 것은 혼자만의 작업이 아니고, 회사에서 리뷰 받는 것을 연습하는 것도 있지만, 회사 동료들과 함께 코드에 대해서 의견을 나누고, 함께 완성하는 과정을 연습하는 것이라고도 하셨다. 이러한 피드백을 받고 조금 뜨끔했던 것이, 회사에서 그냥 나 혼자 생각하고 진행하는 것들이 너무 많았던 적이 많다. 안좋은 습관이라서 빨리 고치도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 문제점을 어떻게하면 작게 쪼갤 수 있을까 고민을 하며, 이를 하나씩 정확하게 해결해 나갈 것이다.&lt;/li&gt;
&lt;li&gt;쉬운 방법이 아니라, 어렵더라도 올바른 길을 선택할 것이다.&lt;/li&gt;
&lt;li&gt;함수, 메서드, 클래스, 모듈 및 테스트에도 문서화를 위한 코드를 작성할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Thu, 18 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/18/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;요즘 출퇴근 하면서 30대 방구석 이야기라는 유튜브 채널을 시청하고 있다.&lt;/li&gt;
&lt;li&gt;개발 이야기 및 삶에 대한 좋은 자세를 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;이슈를 볼 때 현상에 집중하는 것 보다 빠르게 본질을 파악하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드에 대해서 근거와 논리가 있어야한다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;오늘 내가 작성한 코드에 대해서 왜 이렇게 작성하였는지, 질문이 들어왔다. 우연하게 내가 작성한 코드가 올바른 이유를 가지고는 있었지만 의도했다고는 말을 하지 못하겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나도 이러한 자세를 가지고 일을 하고 살아가고 싶다는 느낌을 받았다.&lt;/li&gt;
&lt;li&gt;최근에 회의를 할 때, 대충 이야기를 들은게 찔린다. 사소한 일에도 최선을 다하면서 몰입하는 자세를 배워야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;항상 느끼는 것은 있는데 이를 실천하는 빈도는 많이 떨어지는 것 같다. 따라서 이를 강제할 수 있는 프로세스를 세우는 것이 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드 그리고 옵션값을 제대로 알고 사용했을 때 참 기분이 좋은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;면접을 볼 때 내가 얼마만큼 알고 있는지를 어필하는 것 보다는 얼마만큼 생각을 해보았는지를 알려주는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;포트폴리오를 작성할 때도 내가 어떤 고민을 했는지 포트폴리오에 녹여내면 나를  어필할 수 있는 좋은 무기가 될 것이다.&lt;/li&gt;
&lt;li&gt;자기소개서를 작성할 때, 한문장 한문장 고쳐가면서 최선을 다하는 것은 후회를 하지 않기 위한 좋은 자세이다. 더 이상 미련을 갖지 않게 해준다.&lt;/li&gt;
&lt;li&gt;면접을 볼 때 내가 잘났다를 어필하는 것 보다는 내가 과연 같이 일하기 좋은 사람인가를 생각을 해보고, 역시사지로 생각을 해보면 좋을 것 같다.&lt;/li&gt;
&lt;li&gt;이슈를 해결할 때, 이슈 내용이 잘 이해되지 않으면 PM과 논의를 하여 문제를 이해하고 본질을 빠르게 파악하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;자신이 어떤 것을 알거나 배웠다고 어필하는 것보다 학습하는데 어떤 어려움이  있었는데, 극복을 한 내용을 적는 것이 더 공감을 받을 수 있다.&lt;/li&gt;
&lt;li&gt;자기소개서에서 얻고 싶은 가장 큰 부분은, 생각에만 그치지 않고 얼마나 행동으로 이를 실천했는지, 또 얼마만큼의 성취를 만들었는지 어필하는 것이 더 중요한 것 같다.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;나는 사소한 일에도 집중 및 최선을 다하면서 모든 일에 몰입을 할 것이다.&lt;/li&gt;
&lt;li&gt;일을 하면서 배울 수 있는 것을 최대한 끌어내면서 내가 어떤 것을 배울 수 있는지, 고민을 해봐야하는지 생각을 하며 고민을 하는 내용을 기록할 것이다.&lt;/li&gt;
&lt;li&gt;내가 작성한 코드, 그리고 옵션값 하나하나 이유를 가지고 코딩을 할 것이다. 따라서 내가 작성한 코드를 커밋할 때는 이렇게 작성한 이유, 그리고 이렇게 옵션을 준 이유를 무조건 적기로 하자!&lt;/li&gt;
&lt;li&gt;가장 빠르게 실행할 수 있는 코드를 작성할 것이다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>일일 회고</title>
      <link>https://dongwooklee96.github.io/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</link>
      <pubDate>Wed, 17 Feb 2021 12:29:39 +0900</pubDate>
      
      <guid>https://dongwooklee96.github.io/post/2021/02/17/%EC%9D%BC%EC%9D%BC-%ED%9A%8C%EA%B3%A0/</guid>
      <description>&lt;h3 id=&#34;facts-사실-객관&#34;&gt;Facts (사실, 객관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;좋은 유튜브 채널을 찾았다. (&lt;a href=&#34;https://www.youtube.com/channel/UCyCFnxi_hBaLvL6pV_zVILQ&#34;&gt;https://www.youtube.com/channel/UCyCFnxi_hBaLvL6pV_zVILQ&lt;/a&gt;) 면접을 보면서 공부한 내용을 정리하면 좋을 것 같다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최근에 네트워크 관련한 문제로 골머리를 앓고 있는데, 네트워크 패킷 분석에 대해서 조금 알아둔다면 이러한 상황에 잘 대처를 할 수 있을 것 같다는 생각을 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아샬님의 강의를 보다가 느꼈는데, 실제 인터페이스와 서비스, 그리고 인터페이스를 상속받는 클래스와의 의존성을 간단히 확인하고 계셨다. 그 방법은 메서드를 변경해보는 것이다. 그러자 인텔리제이에서 에러를 알아서 표시를 해주었고, 자연스럽게 의존하고 있는 부분이 들어났다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아샬님은 프로그래밍을 구현할 때, 어떤 것 부터 구현하는 편인지 질문이 있었다. 그러자 딱히 구분을 두는 편은 아니고, 프로그램이 가능한 실행될 수 있는 상태로 빠르게 만든다고 했다. 나도 이를 배워야겠다.
구체적인 방법은 다음과 같다. 1-5분 내에 무조건 실행 가능한 상태를 만들고, 1-3분 내에 여러 번 확인하며 개선하는 작업을 지속하려면 어떻게 해야하는지를 고민해보라고 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트의 목적이 의존 관계를 들어내는데 사용할 수도 있다. 예를 들어서, 스프링의 경우 서비스 코드에서, verify()를 사용하여 repository에서 어떤 메서드가 호출되는지 명시할 수 있는데, 이와같은 경우가 의존관계를 명시하는 좋은 예시이다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feelings-느낌-주관&#34;&gt;Feelings (느낌, 주관)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;findings-배운-점&#34;&gt;Findings (배운 점)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;affimation-자기-선언&#34;&gt;Affimation (자기 선언)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;회고-작성법&#34;&gt;회고 작성법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Facts(사실, 객관) 실제로 내가 했던 일이나 겪었던 일의 사실을 적는다.&lt;/li&gt;
&lt;li&gt;Feelings(느낌, 주관) 내가 했던 일을 하면서 느꼈던 감정이나 느낌을 적는다.&lt;/li&gt;
&lt;li&gt;Findings(배운 점) 내가 했던 일을 통해서 새롭게 배운 점이나 알게 된 점을 적는다.&lt;/li&gt;
&lt;li&gt;Affirmation (자기 선언) 내가 했던 일을 통해 배운 점과 아쉬운 점을 어떻게 유지하고 개선할지를 적는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Facts: 한 주 동안 회사에서 일하면서 정신이 없었다. 일정이 생겼다가 사라짐을 반복하여 시간을 관리하는데 어려움을 겪었고 내가 지금 무엇을 해야하는지 결정하기 힘들었다. 그리고 솔루션에 대한 기능을 자세하게 알고 있기 못했기 때문에 버그를 재현하는데도 시간이 많이 걸렸다.&lt;/li&gt;
&lt;li&gt;Feelings: 굉장히 마음이 불안했다, 내가 뭔가를 놓치고 있는지 계속해서 생각을 했기 때문에 일에 온전히 집중하기 힘들었다.&lt;/li&gt;
&lt;li&gt;Findings: 코드도 중요하지만, 솔루션에 대한 이해가 없으면 내가 지금 하고 있는 것이 맞는지 틀리는지 판단하기 어렵다. 그리고 평소에 시간이 날 때마다 솔루션에 대한 공부를 해야겠다.&lt;/li&gt;
&lt;li&gt;Affirmation : 앞으로 솔루션을 많이 사용해보면서 존재하는 기능들을 따로 정리를 해두고, 활자로써의 지식이 아니라, 경험적인 지식으로 이를 발전시켜서 생산성을 증가시켜야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
